{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/hexo-material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/uc.css","path":"css/uc.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/bg.png","path":"img/bg.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/mathjax.js","path":"js/mathjax.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/nprogress.js","path":"js/nprogress.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/queue.js","path":"js/queue.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/material.min.css","path":"css/material.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/js.js","path":"js/js.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/js.min.js","path":"js/js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/css/material.css","path":"css/material.css","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/img/icon.png","path":"img/icon.png","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"524be1324f4b0a6f6fdf88d90464585c150e3a02","modified":1498387880000},{"_id":"source/CNAME","hash":"021dfe8deafedc694ee2b5ea0c414cea400c3f09","modified":1495810615000},{"_id":"themes/hexo-material/.DS_Store","hash":"61d4653525ee800306d888d998f91174144e6d64","modified":1498557834000},{"_id":"themes/hexo-material/.eslintrc.json","hash":"83ddc0cdc18f28b967795b8dac0421a52cdf7ece","modified":1495546114000},{"_id":"themes/hexo-material/.npmignore","hash":"0e2700b8bcca0c252b8bcac0aea92a806a009986","modified":1495546114000},{"_id":"themes/hexo-material/.travis.yml","hash":"93eb4648349274ffda0c146bbc019d1d2cd57ca3","modified":1495546114000},{"_id":"themes/hexo-material/CONTRIBUTING.md","hash":"148f555e47d4725fe1faac775107a4d7b03f7136","modified":1495546114000},{"_id":"themes/hexo-material/README.md","hash":"fc8798c290e97352cb62bf4005aa8625245ec7e8","modified":1495546114000},{"_id":"themes/hexo-material/CONTRIBUTING.zh-cn.md","hash":"ef3ccef0451d6ac616b3a35fbfedb6abd35e6b41","modified":1495546114000},{"_id":"themes/hexo-material/contributing.json","hash":"1bc0871b1c7822b82533b614090ac0ab7c55282c","modified":1495546114000},{"_id":"themes/hexo-material/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1495546114000},{"_id":"themes/hexo-material/_config.yml","hash":"f36d2de424e2a322643e4388493349523ea2e8ff","modified":1498559652000},{"_id":"themes/hexo-material/lint.sh","hash":"49c3a65f8ca65754ec7fefcd2dcb6adc187f3856","modified":1495546114000},{"_id":"themes/hexo-material/package.json","hash":"9dcce730ce012285c86551b105bb35991cbdce2c","modified":1495546114000},{"_id":"source/about/index.md","hash":"e87d5677bfa4aab18e54d48bafbf3226f77c82eb","modified":1499253228000},{"_id":"source/_data/gallery.yml","hash":"d102502ac18b89c6713bf9dcf7d44ff1f63ca907","modified":1498559653000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1495547419000},{"_id":"source/_posts/2017-WWDC.md","hash":"ea3be1edc8692af45d4a3f82e2b257b7db93f037","modified":1497711575000},{"_id":"source/_posts/AVAudioFoundation-2-：音视频播放.md","hash":"1cc2d270e5e3a8355183f60dd99eb2023abc27e5","modified":1498661941000},{"_id":"source/_posts/AVAudioFoundation-1-：使用-AVAsset.md","hash":"abf40fab1608b0447814e778a4b8c671b2b6f2ab","modified":1498387138000},{"_id":"source/_posts/AVAudioFoundation-4-：音视频录制.md","hash":"82e3ec41b184b2b6e4573f518f78fb124f75f005","modified":1499253228000},{"_id":"source/_posts/AVAudioFoundation-3-：音视频编辑.md","hash":"517aff066fade1f98cf9c822c37eef0da15eff2e","modified":1499070651000},{"_id":"source/_posts/AVAudioFoundation-5-：音视频导出.md","hash":"eb55c069a0d7546278a541c9d6741b45425bed4f","modified":1499426148000},{"_id":"source/_posts/AVAudioFoundation-6-：时间和媒体表示.md","hash":"4d6127d66e695aedf56507ab1993ddf9ab11f47f","modified":1499426148000},{"_id":"source/_posts/GIF的秘密.md","hash":"19e41465312a7f89d27678e227d0821ee83b1b58","modified":1497711575000},{"_id":"source/_posts/GCD小结.md","hash":"505a442a610ca5f2476590bdbdb4766645ef4b92","modified":1497711575000},{"_id":"source/_posts/Github上的代码添加Cocoapods支持.md","hash":"170d4efd72f54bc983502b7538d16763384bb95d","modified":1499253228000},{"_id":"source/_posts/NSPredicate-使用小结.md","hash":"7ba4cc1ce1ff6e8a21f6fdd4b1c4921de12cb001","modified":1497711575000},{"_id":"source/_posts/HTTPS小解析.md","hash":"a1e931e62bf31916e90261fc748a6490ab8a232e","modified":1497711645000},{"_id":"source/_posts/OC中的load和initialize方法.md","hash":"7208c075d0971c30f9dabd9d3506af6e449ae5af","modified":1497711575000},{"_id":"source/_posts/iOS小经验（三）.md","hash":"93f278d13909ca49c30f5b2db30d348769d220c6","modified":1500216569000},{"_id":"source/_posts/iOS小经验（二）.md","hash":"7e3622b47a7cb950761f0576726a8f2db6d207b4","modified":1500216569000},{"_id":"source/_posts/iOS小经验（五）.md","hash":"6705799d5d2f3e39dfea7c9f59e6b2464423a5ad","modified":1500216569000},{"_id":"source/_posts/iOS小经验（六）.md","hash":"929e683805fc54074ef6904074a0b66b9490a310","modified":1500216609000},{"_id":"source/_posts/iOS小经验（四）.md","hash":"4e8f1ec135f8bda55a5ae6f01e8c576551d6604c","modified":1500216569000},{"_id":"source/_posts/RSA加密小结.md","hash":"b562e69f816f5e133852df240bce5138a290c170","modified":1497711575000},{"_id":"source/_posts/iOS小经验（一）.md","hash":"3b7d55f59d12b535555cdbc41060905c44f748a5","modified":1499682153000},{"_id":"source/_posts/iOS消息转发机制-动态方法解析.md","hash":"ddb1fb3059a57efb83fbd1c969cb1845098c3957","modified":1499002413000},{"_id":"source/_posts/iOS常用工具方法.md","hash":"2b6084b1fb1d2bc38acac4da7eeb6ef5f73da25c","modified":1497711575000},{"_id":"source/_posts/我是不懂浪漫.md","hash":"6c925d565546d47346ae20a6d0afdba7665bb2d8","modified":1497711575000},{"_id":"source/_posts/《招聘一个靠谱的iOS》面试题参考答案（下）.md","hash":"54e94326d12edad693779f5951480df1a8f47022","modified":1497711575000},{"_id":"source/_posts/指针与数组.md","hash":"e512c7ac4b5aa6cbaaf388056dcf090de357dc37","modified":1498227426000},{"_id":"source/_posts/排序算法.md","hash":"ca9e51a30df57630913acc6cd6cf09b9a0eda05a","modified":1497711575000},{"_id":"source/_posts/深浅拷贝.md","hash":"ebf472bec4d9ef1edb5e1f9be9422ed0138ef889","modified":1499253228000},{"_id":"source/gallery/index.md","hash":"99c5d001024576461267ed097890d451401b5825","modified":1498387832000},{"_id":"source/_posts/玩转iOS中UITextField的placeholder颜色.md","hash":"26326bdb4131e3ac3d8e046ecee3512d6f9861d8","modified":1497711575000},{"_id":"source/_posts/给你.md","hash":"6bdf9414f1a3558caa5902f1faba8af08aee77f1","modified":1498142140000},{"_id":"themes/hexo-material/.github/ISSUE_TEMPLATE.md","hash":"52a733a4d2e21a9c4d719495a0353c6719484f9f","modified":1495546114000},{"_id":"themes/hexo-material/.github/PULL_REQUEST_TEMPLATE.md","hash":"f2a3a0b929c0909ab99c96fb82853c2c2d67961a","modified":1495546114000},{"_id":"themes/hexo-material/languages/ar.yml","hash":"6df33c661d97cb096a2b8a338fd42c6b7cf72e19","modified":1495546114000},{"_id":"themes/hexo-material/languages/en.yml","hash":"518822aada4fbe8f5af85243d5e0b73b79a288d3","modified":1495546114000},{"_id":"themes/hexo-material/languages/de.yml","hash":"d7483dc78b2477de3f1d5b4675ff12f2bd47b937","modified":1495546114000},{"_id":"themes/hexo-material/languages/es.yml","hash":"e24ab8de3d9cd71548adefa11b179ab0c6e3dd2c","modified":1495546114000},{"_id":"themes/hexo-material/languages/ja.yml","hash":"062cfff0e32bdb64f27f6f18e552d118eabdf95a","modified":1495546114000},{"_id":"themes/hexo-material/languages/ms.yml","hash":"c78fd5335e9008e1195c5784b597b68c1d39429a","modified":1495546114000},{"_id":"themes/hexo-material/languages/fr.yml","hash":"dd8c477e656c50e9dced6b7f439d284392213d2b","modified":1495546114000},{"_id":"themes/hexo-material/languages/pt-BR.yml","hash":"ce712c6d79c3d3243b5ae189d2fa7c0adfcb8a25","modified":1495546114000},{"_id":"themes/hexo-material/languages/zh-TW.yml","hash":"cbd420929699cf6be1d05b211a151e17e87dfc87","modified":1495546114000},{"_id":"themes/hexo-material/layout/.DS_Store","hash":"c65c9d1aa3e98324aaca09da74ae56a88212485c","modified":1498557840000},{"_id":"themes/hexo-material/languages/zh-CN.yml","hash":"7e1acb427a8f24753d2583368db05355837b8e2d","modified":1495546114000},{"_id":"themes/hexo-material/layout/layout.ejs","hash":"0a5926ca361e8ce1bb4aadab112ba3b486f21716","modified":1495546114000},{"_id":"themes/hexo-material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1495546114000},{"_id":"themes/hexo-material/layout/post.ejs","hash":"3d4f506e8def5b776a904dcfefe9ac1eca3fae76","modified":1495546114000},{"_id":"themes/hexo-material/source/.DS_Store","hash":"0e341f8cfecd101247e9946629ccb6b346a107e7","modified":1498557859000},{"_id":"source/_posts/《招聘一个靠谱的iOS》面试题参考答案（上）.md","hash":"35e7baaf8dc0e61c7024b593e0de2a88a3b95583","modified":1497711575000},{"_id":"themes/hexo-material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"27acecc8a603a5dc7ccd9e08bd7084439b15f6ec","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Paradox-post-info.ejs","hash":"b5d558738b27ba16fef80399cc56a50e26c49f26","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Isolation-post_entry.ejs","hash":"45eb5dc723d36e32553038422061cba6828957a1","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"5c46780e439d6ae86e602ad41fe178b288cab9c0","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/comment.ejs","hash":"82a5f8dc6855d0d25ddfafd1a7ecce46da8208f2","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Paradox-post_entry.ejs","hash":"36d3798224bf7dff7c0659876c5ad8a4785198e2","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/blog_info.ejs","hash":"c4aaeebf103dc5131ca2fe5039ae92e40fe86a29","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/footer-option.ejs","hash":"5214273ce0a7888a3c1330ca2a9bc8622ece132d","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/config_css.ejs","hash":"e1e9ae721a0f513848dcadfcd351fefbad524bee","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/daily_pic.ejs","hash":"22f377c0ba70d930a66dfcc775f216a560746996","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/footer-left.ejs","hash":"be73b6e10da780defc535ad4503129be8eb2befc","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/footer.ejs","hash":"a794e79790594be252d6528631f378c063025d8d","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/footer_top.ejs","hash":"dfcb4d7fc0ee401613f7fa2ef22614e3e4ba3305","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/head.ejs","hash":"f540b2f83c5d6a9120fdd4e86b6bb03a92c04913","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/import_js.ejs","hash":"f9dd945a09febf6c1b0c0decb4f256f00796dbde","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/isolate_info.ejs","hash":"89cf453c7b0efc4665f73e3670cca54b2381a0a2","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/post-content.ejs","hash":"02374b20989c81031e29257d872624d5195ddcbd","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/post-header.ejs","hash":"e5c1271b94d66597812cdf88057c8690bfe72d55","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/post-info-share.ejs","hash":"2f9d670b17e7763ae595593e9881284dc6c1bada","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/post-nav.ejs","hash":"7b291719414408a9ec0b9167a2c6c834f90905b3","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/sidebar-footer_image.ejs","hash":"ea7ff13f099ebd9a0caad26621f4a23b26b72309","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/sidebar-header.ejs","hash":"d18344f05712f66e0385839e4d83d5a3a515c140","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/sidebar-navigation.ejs","hash":"eaedc9861342f9f4c85bf86aed7b9b9627887bac","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1495546114000},{"_id":"themes/hexo-material/layout/_partial/toc_button.ejs","hash":"38bbf3c7b3606845905b854a1649a481a1239ddd","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/changyan.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/disqus.ejs","hash":"64be5e0ac74b012b91f70bbfbaec42fa663d4c13","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/duoshuo.ejs","hash":"ae09d002bf5d3517ccde7f580dde20e0d47f627f","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/disqus_click.ejs","hash":"ff0fd6dfd4fe38b08c031373bee0fa0b76a41385","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/leancloud-like.ejs","hash":"f0cd9956fde4437fecb01e322ff025ad307c240a","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/leancloud-views.ejs","hash":"630796a1377a3a0fc378baa377b05926f6e0b8f4","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/mathjax.ejs","hash":"4cd6f3bc8278a6f1010f485d52e1f0ba7bf00fb4","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/nprogress.ejs","hash":"7d4131dbecb4168f9b0ab536278b7e7bcafba4f2","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/page-gallery.ejs","hash":"99b5fe45a1130f961a299ed4bf35e2c4a38a0d21","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/page-tagcloud.ejs","hash":"e184ca7f8519936903248b7797d281fad35b9521","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/page-links.ejs","hash":"75ce946ba9717ede360035853f5de873f00b57cb","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/search-local-js.ejs","hash":"475c507773be23c87e63e22d8474ead06a5ebd49","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/page-timeline.ejs","hash":"9040f18f96dcc0ac44cb2b4d3b53bc6630207279","modified":1495546114000},{"_id":"themes/hexo-material/layout/_widget/search-swiftype-js.ejs","hash":"c363e3c208eae18e7c440160790fafba110fa9c9","modified":1495546114000},{"_id":"themes/hexo-material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1495546114000},{"_id":"themes/hexo-material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1495546114000},{"_id":"themes/hexo-material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1495546114000},{"_id":"themes/hexo-material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1495546114000},{"_id":"themes/hexo-material/source/css/uc.css","hash":"7609828f93973d1a6d3ba4b38d94688a92a6a6c5","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1495546114000},{"_id":"themes/hexo-material/source/img/.DS_Store","hash":"5cc3c92a2b696a66f3a2b04d27f0714416168a6d","modified":1498557776000},{"_id":"themes/hexo-material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1495546114000},{"_id":"themes/hexo-material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1495546114000},{"_id":"themes/hexo-material/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1495546114000},{"_id":"themes/hexo-material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1495546114000},{"_id":"themes/hexo-material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1495546114000},{"_id":"themes/hexo-material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1495546114000},{"_id":"themes/hexo-material/source/js/.DS_Store","hash":"938a4d398c8d892724330dca2bec974a20c8d5b7","modified":1498557845000},{"_id":"themes/hexo-material/source/js/mathjax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1495546114000},{"_id":"themes/hexo-material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1495546114000},{"_id":"themes/hexo-material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1495546114000},{"_id":"themes/hexo-material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1495546114000},{"_id":"themes/hexo-material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1495546114000},{"_id":"themes/hexo-material/source/css/style.min.css","hash":"25874013ac8a604058ddbe58cb33a2e3fa5b9b3c","modified":1495546114000},{"_id":"themes/hexo-material/source/css/material.min.css","hash":"f3c8e6a9d94e6cad30c6628e1d732e6ee00d5fce","modified":1495546114000},{"_id":"themes/hexo-material/source/css/style.css","hash":"b423b687cfa2723554b7b42eab799a69ababa978","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1495546114000},{"_id":"themes/hexo-material/source/img/avatar.png","hash":"c30250810c3ec54ced20a73183cf15ad21f1509e","modified":1495548495000},{"_id":"themes/hexo-material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1495546114000},{"_id":"themes/hexo-material/source/img/sidebar_header.png","hash":"b663eb0be63536641b7f1b655fa95fb8ba64d19b","modified":1498055075000},{"_id":"themes/hexo-material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1495546114000},{"_id":"themes/hexo-material/source/js/js.js","hash":"4634558bdb27ca5a2f728d6ff57590fbd91af6f1","modified":1495546114000},{"_id":"themes/hexo-material/source/js/js.min.js","hash":"a06e88ba0f594bc67be1618f9d0c203369d53700","modified":1495546114000},{"_id":"themes/hexo-material/source/css/material.css","hash":"19818d637ecb3bae73d16ee90444c42fe4458b54","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1495546114000},{"_id":"themes/hexo-material/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1495546114000},{"_id":"themes/hexo-material/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1495546114000},{"_id":"themes/hexo-material/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1495546114000},{"_id":"themes/hexo-material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1495546114000},{"_id":"themes/hexo-material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1495546114000},{"_id":"themes/hexo-material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1495546114000},{"_id":"themes/hexo-material/source/img/icon.png","hash":"753b59adc9686900c8a2653077d04f74737ab786","modified":1497711575000},{"_id":"themes/hexo-material/source/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1495546114000},{"_id":"themes/hexo-material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1495546114000},{"_id":"public/gallery/index.html","hash":"b1eac57aff6224f62f61901f18d13e94529ec7a9","modified":1500216628729},{"_id":"public/about/index.html","hash":"8d94f0fd8605c3a809a5ba747dfecc1ab279aa6b","modified":1500216628729},{"_id":"public/2017/07/07/AVAudioFoundation-6-：时间和媒体表示/index.html","hash":"f83b117c6db237d1705918dfc5232e957b83424d","modified":1500216628730},{"_id":"public/2017/07/05/AVAudioFoundation-5-：音视频导出/index.html","hash":"57da6c0a1450767aa9de65b81b2b003c7befee8c","modified":1500216628730},{"_id":"public/2017/07/04/AVAudioFoundation-4-：音视频录制/index.html","hash":"a930fa97a8092b4f31d32973e0b961c184a223a7","modified":1500216628730},{"_id":"public/2017/07/03/AVAudioFoundation-3-：音视频编辑/index.html","hash":"b129e8678c4b487a493dbb8d7d241a7e103c00a8","modified":1500216628730},{"_id":"public/2017/06/28/AVAudioFoundation-2-：音视频播放/index.html","hash":"6ce8dbb74aee842cae84bfd9f69e010023251835","modified":1500216628730},{"_id":"public/2017/06/25/AVAudioFoundation-1-：使用-AVAsset/index.html","hash":"fae4ef6e3bc56e9d311d5eeea8ff6344ac8932a7","modified":1500216628730},{"_id":"public/2017/06/23/指针与数组/index.html","hash":"96496e4e34f264e41d6093b15861899db0778b86","modified":1500216628730},{"_id":"public/2017/06/22/给你/index.html","hash":"68b4c83078fc7de1c136f1cfac288b8a0ed7c823","modified":1500216628730},{"_id":"public/2017/06/17/HTTPS小解析/index.html","hash":"4d42e799a79ba3861e7321240685e17ab5feadd4","modified":1500216628730},{"_id":"public/2017/06/15/排序算法/index.html","hash":"3a516ac90189d02daf8a23c4602908908288f38c","modified":1500216628730},{"_id":"public/2017/06/14/2017-WWDC/index.html","hash":"158e59a397ca5e4d491e6ef1254aebcc2a1fbcdf","modified":1500216628730},{"_id":"public/2017/06/13/GIF的秘密/index.html","hash":"e9f99eca43111a24b825e6c2acfd21596970096c","modified":1500216628730},{"_id":"public/2017/06/05/我是不懂浪漫/index.html","hash":"dad4b4b92b5bc310343f6dca671b921688d70116","modified":1500216628730},{"_id":"public/2017/06/05/NSPredicate-使用小结/index.html","hash":"612e913053e7385f8f7e28b26b83e5d6371a8e54","modified":1500216628730},{"_id":"public/2017/06/03/iOS常用工具方法/index.html","hash":"aa79dd14e80447a29d28c7f0d4d5fef840b718df","modified":1500216628730},{"_id":"public/2017/06/01/OC中的load和initialize方法/index.html","hash":"99e648e982527b02beabc76d81b77b2fa4aa6457","modified":1500216628730},{"_id":"public/2017/05/31/GCD小结/index.html","hash":"b27ae41503c9e62d71ec86aa38e1e11e8e55c730","modified":1500216628731},{"_id":"public/2017/05/26/RSA加密小结/index.html","hash":"781072ec310e330d79fbd22c1729c6113da6c547","modified":1500216628731},{"_id":"public/2017/05/24/《招聘一个靠谱的iOS》面试题参考答案（下）/index.html","hash":"6dd5ea33c1a5b51b965615360dd99642efecb047","modified":1500216628731},{"_id":"public/2017/05/24/《招聘一个靠谱的iOS》面试题参考答案（上）/index.html","hash":"cec09e6459339e9daba2d09c511e2dbde7091ecb","modified":1500216628731},{"_id":"public/2017/05/23/玩转iOS中UITextField的placeholder颜色/index.html","hash":"c18a4ae9c9538c30db39b066ee831b5dc64c5d47","modified":1500216628731},{"_id":"public/2017/04/01/深浅拷贝/index.html","hash":"328449130b9d43a7e9c3ec4e6c9061a577ada960","modified":1500216628731},{"_id":"public/2017/03/10/Github上的代码添加Cocoapods支持/index.html","hash":"fa274b86d4334b4978ed956068744c11d87b42d0","modified":1500216628731},{"_id":"public/2017/02/02/iOS消息转发机制-动态方法解析/index.html","hash":"7b1a3cc99b1d6675973aa6acba0473167884372d","modified":1500216628731},{"_id":"public/2016/03/17/iOS小经验（六）/index.html","hash":"e07414e7113ce5c7b1118f0e3a8a778801eeaca6","modified":1500216628731},{"_id":"public/2016/03/14/iOS小经验（五）/index.html","hash":"ba58651a3f7da217ab71e5a3660b63820e227b23","modified":1500216628731},{"_id":"public/2016/02/26/iOS小经验（四）/index.html","hash":"25d7ee846646a0407a1dfa625a0f3f1aec792365","modified":1500216628731},{"_id":"public/2016/02/18/iOS小经验（三）/index.html","hash":"da773ebab8498ed89cdf5737b6e29e37dd41da39","modified":1500216628731},{"_id":"public/2016/02/14/iOS小经验（二）/index.html","hash":"e1898acbfbc00945eedc2f9135d052637bb5903e","modified":1500216628731},{"_id":"public/2016/02/10/iOS小经验（一）/index.html","hash":"b26a0587de4aefcdec74d4ac290346ac5727d9ca","modified":1500216628731},{"_id":"public/archives/index.html","hash":"67bbd62fa879a93540377dae35af982202b8c2f4","modified":1500216628731},{"_id":"public/archives/page/2/index.html","hash":"95c573e4456390b1abcfecd2d3bfc5552126e256","modified":1500216628731},{"_id":"public/archives/page/3/index.html","hash":"743f8fcbdb56c067f06abc4440dacc260c2a7551","modified":1500216628731},{"_id":"public/archives/2016/index.html","hash":"912d47fa49e8eee764074f544aec8eb7b6550d9a","modified":1500216628731},{"_id":"public/archives/2016/02/index.html","hash":"3e15229e1101b3c750d30fcb67357d4ea95289e2","modified":1500216628731},{"_id":"public/archives/2016/03/index.html","hash":"abdc62a71e6c5ce57dbbf9b7b329779b470609c1","modified":1500216628731},{"_id":"public/archives/2017/index.html","hash":"0ef873b2ee06c67942881d3a7f2abe885a6fe894","modified":1500216628731},{"_id":"public/archives/2017/page/2/index.html","hash":"c146c5e0235927bb3736bed52f702bba4281f0e0","modified":1500216628731},{"_id":"public/archives/2017/page/3/index.html","hash":"72327b05b1453c89bc35bd111e63e67179471d30","modified":1500216628732},{"_id":"public/archives/2017/02/index.html","hash":"9df5627f4f7718aa018143e2b06ed343f208b0ca","modified":1500216628732},{"_id":"public/archives/2017/03/index.html","hash":"386a29906a895958324b2eca9f0d94d150340740","modified":1500216628732},{"_id":"public/archives/2017/04/index.html","hash":"27bb92090a7d1cbaa9855e2d1687b2c007fd315a","modified":1500216628732},{"_id":"public/archives/2017/05/index.html","hash":"7e3ff3c85c6e5baf6a658814da8e57d229aefdf1","modified":1500216628732},{"_id":"public/archives/2017/06/index.html","hash":"ada2c74fc65780afb4c0143dff6e5440474ad31d","modified":1500216628732},{"_id":"public/archives/2017/06/page/2/index.html","hash":"b1a22492b2dd4e15144eadb837e35296dd05b8e5","modified":1500216628732},{"_id":"public/archives/2017/07/index.html","hash":"16cf3f8e2c0eae1bea3dbe7fe1243df4fd746ec1","modified":1500216628732},{"_id":"public/categories/技术向/index.html","hash":"e2b99e2e78721665f2e3e55b1601d8a9836415fe","modified":1500216628732},{"_id":"public/categories/iOS合集/index.html","hash":"6d8e66e42fcd0703ddcea480efa541a6e14060d2","modified":1500216628732},{"_id":"public/categories/iOS合集/page/2/index.html","hash":"746be9f328ba37979304c02f5df0d2a8494e36fd","modified":1500216628732},{"_id":"public/categories/知识簿/index.html","hash":"4084f830812cbf9d4ffc46e67a4f9beaa839f9e8","modified":1500216628732},{"_id":"public/categories/iOS小经验/index.html","hash":"58326a9aa5b8a9097fc4074bbf44a07b46166dcc","modified":1500216628732},{"_id":"public/categories/自言语/index.html","hash":"df6b2c3dc0aa12807f7e19313387a8f2e95030eb","modified":1500216628732},{"_id":"public/categories/面试经/index.html","hash":"612ad760de263bf4a8f5d88e23d6cc3f43607e1d","modified":1500216628732},{"_id":"public/index.html","hash":"da86e66944306baec2078378407e4d6ad74d81f2","modified":1500216628732},{"_id":"public/page/2/index.html","hash":"33b41d5eae4f5481467522e70ea2110631fbc8e9","modified":1500216628732},{"_id":"public/page/3/index.html","hash":"6e892cb3beee61340f7172c5345b6d421346b2cc","modified":1500216628732},{"_id":"public/CNAME","hash":"021dfe8deafedc694ee2b5ea0c414cea400c3f09","modified":1500216628743},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1500216628743},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1500216628743},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1500216628743},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1500216628743},{"_id":"public/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1500216628743},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1500216628743},{"_id":"public/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1500216628743},{"_id":"public/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1500216628743},{"_id":"public/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1500216628743},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1500216628743},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1500216628743},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1500216628743},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1500216628743},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1500216628743},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1500216628743},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1500216628743},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1500216628743},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1500216628743},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1500216628743},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1500216628743},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1500216628744},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1500216628744},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1500216628744},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1500216628744},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1500216628744},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1500216628744},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1500216628744},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1500216628744},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1500216628744},{"_id":"public/css/prism.css","hash":"bed3a85b4fb53bc89e65e42ec62b9ce3e907fc80","modified":1500216628744},{"_id":"public/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1500216628752},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1500216628759},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1500216628761},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1500216628762},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1500216628762},{"_id":"public/img/avatar.png","hash":"c30250810c3ec54ced20a73183cf15ad21f1509e","modified":1500216628762},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1500216628762},{"_id":"public/img/sidebar_header.png","hash":"b663eb0be63536641b7f1b655fa95fb8ba64d19b","modified":1500216628763},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1500216628763},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1500216628764},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1500216628764},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1500216628765},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1500216628765},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1500216628765},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1500216628765},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1500216628765},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1500216628765},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1500216628765},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1500216628773},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1500216628773},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1500216628773},{"_id":"public/css/uc.css","hash":"7609828f93973d1a6d3ba4b38d94688a92a6a6c5","modified":1500216628773},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1500216628773},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1500216628773},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1500216628773},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1500216628773},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1500216628773},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1500216628773},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1500216628773},{"_id":"public/js/mathjax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1500216628773},{"_id":"public/css/style.min.css","hash":"25874013ac8a604058ddbe58cb33a2e3fa5b9b3c","modified":1500216628773},{"_id":"public/css/material.min.css","hash":"f3c8e6a9d94e6cad30c6628e1d732e6ee00d5fce","modified":1500216628773},{"_id":"public/css/style.css","hash":"b423b687cfa2723554b7b42eab799a69ababa978","modified":1500216628773},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1500216628774},{"_id":"public/css/material.css","hash":"19818d637ecb3bae73d16ee90444c42fe4458b54","modified":1500216628774},{"_id":"public/js/js.js","hash":"4634558bdb27ca5a2f728d6ff57590fbd91af6f1","modified":1500216628774},{"_id":"public/js/js.min.js","hash":"a06e88ba0f594bc67be1618f9d0c203369d53700","modified":1500216628774},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1500216628774},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1500216628774},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1500216628774},{"_id":"public/img/icon.png","hash":"753b59adc9686900c8a2653077d04f74737ab786","modified":1500216628786},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1500216628790},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1500216628794},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1500216628801},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1500216628801},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1500216628801},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1500216628802},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1500216628803}],"Category":[{"name":"技术向","_id":"cj56u8tuw0004znuzv1sfz7gz"},{"name":"iOS合集","_id":"cj56u8tv60008znuzqn82igzd"},{"name":"知识簿","_id":"cj56u8tvp000qznuz75tcg98z"},{"name":"iOS小经验","_id":"cj56u8tvu000vznuz4d0555wn"},{"name":"自言语","_id":"cj56u8twb001cznuzv6j627we"},{"name":"面试经","_id":"cj56u8twp001sznuzyy1vhqdv"}],"Data":[{"_id":"gallery","data":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}],"Page":[{"title":"About Me","date":"2017-06-06T01:11:31.000Z","_content":"\n## 关于我\n----\n\nAben，\n93年生人，\n\n向往自由主义，\n可一直过着不太自由的生活\n\n人已奔三，焦虑渐重\n\n\n","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2017-06-06 09:11:31\n---\n\n## 关于我\n----\n\nAben，\n93年生人，\n\n向往自由主义，\n可一直过着不太自由的生活\n\n人已奔三，焦虑渐重\n\n\n","updated":"2017-07-05T11:13:48.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj56u8tul0000znuzzrsxetfu","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><hr>\n<p>Aben，<br>93年生人，</p>\n<p>向往自由主义，<br>可一直过着不太自由的生活</p>\n<p>人已奔三，焦虑渐重</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><hr>\n<p>Aben，<br>93年生人，</p>\n<p>向往自由主义，<br>可一直过着不太自由的生活</p>\n<p>人已奔三，焦虑渐重</p>\n"},{"title":"gallery","date":"2017-06-25T10:50:32.000Z","layout":"gallery","_content":"\n\n","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate:\nlayout: gallery\n---\n\n\n","updated":"2017-06-25T10:50:32.000Z","path":"gallery/index.html","comments":1,"_id":"cj56u8tur0002znuz79258p2v","content":"","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":""}],"Post":[{"title":"2017 WWDC","date":"2017-06-14T12:09:38.000Z","_content":"![](http://oqepgj2jp.bkt.clouddn.com/wwdc.jpg)\n\n#### 前言\n\n每年的 WWDC 都是 iOS 开发者集体高潮的时刻。第一天的 WWDC 带来了全新的 iOS 11、MacOS、tvOS 和 watchOS，革命性的 AR 和 ML 应用，以及更强的 iPad、“硬件神兽” iMac Pro 和智能音箱 HomePod。我想从开发者的角度，聊聊这次大会给我的印象和感受。欢迎大家在评论中谈谈自己的看法。\n\n#### 机器学习\n\n恐怕没有哪个词的频率高过 Machine Learning，它也是贯穿各个平台的关键词汇：watchOS 的表盘，macOS 上照片流的分类，Siri 的上下文理解、翻译、预测，手写笔记的直接识别和搜索支持，甚至 Mac 系列芯片和 Metal 的更新都表示支持机器学习。iPhone 上人脸识别甚至比 Google Pixel 快出6倍。可以看出机器学习已经完完全全得融入到了 Apple 的全平台、全应用、全硬件。\n\n而作为开发者，最令我激动的是 MLKit 的发布。苹果带来了自己的模型，你只要不停的运用数据喂养它即可。这意味着我们今后的 App 将变得更加动态化 -- 随着用户使用的增多，App 将越来越智能和强大。\n\n原来的路线是 App 发布 -> 用户反馈 -> 线下产品经理分析 -> 程序员优化 -> App 更新；今后的路线可能是 App 发布 -> 用户反馈 -> 机器学习 -> App 更新。这次 Apple 还推出了急速审核（40分钟过审，摩拜单车团队已验证）和灰度发布的两大功能，也许就是为了给机器学习能自主的更新 App 铺路。目前苹果公布的 API 主要支持视觉识别、自然语言以及游戏 AI。\n\n#### 相关链接：\n- [Build more intelligent apps with machine learning](https://developer.apple.com/machine-learning/)\n- [Machine Learning API (Core ML)](https://developer.apple.com/documentation/coreml)\n- [Introducing Core ML](https://developer.apple.com/videos/play/wwdc2017/703/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc1.png)\n\n#### 虚拟现实和增强现实\n\n这些年虚拟现实遭遇了过山车式的变化。先是遭到资本疯狂追逐，大厂如三星、HTC 重金投入，索尼也趁势推出了 PlayStation VR；然后是 Pokemon Go 的大火，仿佛虚拟现实和增强现实的元年已经到来；突然，Facebook 的 Oculus 线下200家体验店关门；乐视的虚拟现实部门倒闭走人；直到上个月的 Google IO，Day Dream 的更新也表现平平。大家都认为，VR/AR 只是个概念炒作，充其量在游戏上起到锦上添花的效果。\n直到今天。如同当年普鲁士一统德意志，苹果姗姗来迟，却在一出场就技惊四座。\nMetal 2 十倍于当前性能的图像处理技术，芯片的升级和“硬件神兽” iMac Pro 的出现，让苹果在 AR/VR 上的雄心彰显无遗。现场的星球大战 VR 以及 iOS 11 即时战场 AR 展示完全颠覆了我对 AR 的认知 -- 要知道，这可是无需沉重的头套、专用的手机，直接用 iPad 即可完成的事情。\n同样， 推出了全新的 ARKit 来供开发者使用。配合 iPhone 和 iPad 上强大的传感器以及全新的 GPU、CPU，我们开发者可以使用 ARSession 这个共享单例来在摄像头上实现 2D 和 3D 的宏大场景构建。\n\n#### 相关链接：\n\n- [Metal 2](https://developer.apple.com/metal/)\n- [Introducing ARKit](https://developer.apple.com/arkit/)\n- [Augmented Reality API (ARKit)](https://developer.apple.com/documentation/arkit)\n- [VR with Metal 2](https://developer.apple.com/videos/play/wwdc2017/603/)\n- [Introducing ARKit: Augmented Reality for iOS](https://developer.apple.com/videos/play/wwdc2017/602/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc2.png)\n\n#### Swift 和 Xcode 9\n\nSwift 毫无疑问是开发者关心的头等大事。作为苹果的野心，Swift 引入了很多非常先进的思路。然而令我有点失望的是，这次 Keynote 却对 Swift 和 Xcode 9 只字未提。\n不过从现场看来，Swift 这次的更新主要是 API 的优化上，对现有的标准库进行了11项更新和1处新增，主要集中在基本数据类型和文件系统上。\nXcode 上，目前发现的更新主要是多个模拟器同时运行（鸡肋，估计会卡），本地化，runtime debug 工具，持续集成，和源码管理。\n我们只能期待秋季的苹果发布会上 Swift 4 进一步的更新了。有意思的是，之前 Swift 之父 Christ Lattner 写了篇总结文：[Chris Lattner 对 Swift 3 的总结与对 Swift 4 的展望](https://segmentfault.com/a/1190000006909760)。另外大家如果关心 [swift-evolution](https://github.com/apple/swift-evolution) 这个开源库，Swift 4 的新功能应该可见一斑。\n\n#### 相关链接\n\n- [Introducing Swift 4](https://developer.apple.com/swift/)\n- [Localizing with Xcode 9](https://developer.apple.com/videos/play/wwdc2017/401/)\n- [What's New in Signing for Xcode and Xcode Server](https://developer.apple.com/wwdc17/403)\n- [Debugging with Xcode 9](https://developer.apple.com/videos/play/wwdc2017/404/)\n- [Finding Bugs Using Xcode Runtime Tools](https://developer.apple.com/videos/play/wwdc2017/406/)\n\n\n#### iOS 11\n\n这次 iOS 11 更新可以说是全面彻底。从基本的功能升级到 App 新功能添加，再到 iPad 平台 UI 重构。主要集中在这几个方面。\niPad\n为 iPad 全新打造的 iOS 系统，多任务、分屏 UI，Docker 工具栏。虚拟现实和增强现实的引入，以及对机器学习的支持。总体来说，消费者很开心，开发者又有新的东西可玩了。同时我觉得 iPad 越来越向 Macbook 看齐了。\n#### App\nApp Store 全新设计\nFiles 文件管理软件放出\n开放  Music\n Pay 新的转账功能，注意 NFC API 接口开放，是不是为了  Pay 更方便接入其它 App？\n 地图继续追赶 Google 地图\niMessage 花里胡哨扩展中\nHomeKit 追加音响（HomePod）支持\n\n#### 新功能\nDrag and Drop (梦想成真！)\n拍照和截屏（扫描文件这个功能真是又重创了一大波 App）\n中国特殊加成：二维码和上海话识别\n\n#### 相关 Session\n- [Updating Your App for iOS 11](https://developer.apple.com/videos/play/wwdc2017/204/)\n- [Building Great Document-based Apps in iOS 11](https://developer.apple.com/videos/play/wwdc2017/229/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc3.png)\n\n#### tvOS, watchOS 4, MacOS\n这三个平台的更新可以说是泛善可陈（除了 Machine Learning 和 AR）。基本上就是，更多的内容（Amazon 的加入）、更炫更方便的 UI（运动界面和音乐界面）、以及更拽的名字（对，新 MacOS 叫 High）。\n值得一提的是  File System。其实这个文件系统去年就宣布了，不过并不在 Keynote 之中。今年苹果用它全面替代了古老的 HFS+，取而代之的是更高的性能、更好的安全性、更多的空间。这主要是 copy-on-write 和空间共享技术的运用。\n 同时开放了 [FileProvider API](https://developer.apple.com/documentation/fileprovider)，开发者可以用它在新的  File System 基础上实现对文件各种基本操作，还能通过它对应的 extension 实现诸如 drag and drop 这样跨 App 的功能。\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc4.png)\n\n#### 相关链接\n- [What's new in  File System](https://developer.apple.com/videos/play/wwdc2017/715/)\n- [File Provider Enhancements](https://developer.apple.com/videos/play/wwdc2017/243/)\n\n#### 总结\n\n这次的 WWDC，苹果可以说是打了一个漂亮的翻身仗：在人工智能方面挑战 Google，在虚拟、增强现实方面加入战局震慑 Facebook，并重夺工业界顶峰的宝座。 watchOS 和 tvOS 的丰富，虽然进步并不明显，但好歹补足了短板。iOS 11 让 iPad 这个日趋边缘的产品逐渐焕发出了生机。后面的几天，应该会有更多精彩的 Session，给开发上带来更多的启示。\n\n","source":"_posts/2017-WWDC.md","raw":"---\ntitle: 2017 WWDC\ndate: 2017-06-14 20:09:38\ncategories: \n\t- 技术向\n---\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc.jpg)\n\n#### 前言\n\n每年的 WWDC 都是 iOS 开发者集体高潮的时刻。第一天的 WWDC 带来了全新的 iOS 11、MacOS、tvOS 和 watchOS，革命性的 AR 和 ML 应用，以及更强的 iPad、“硬件神兽” iMac Pro 和智能音箱 HomePod。我想从开发者的角度，聊聊这次大会给我的印象和感受。欢迎大家在评论中谈谈自己的看法。\n\n#### 机器学习\n\n恐怕没有哪个词的频率高过 Machine Learning，它也是贯穿各个平台的关键词汇：watchOS 的表盘，macOS 上照片流的分类，Siri 的上下文理解、翻译、预测，手写笔记的直接识别和搜索支持，甚至 Mac 系列芯片和 Metal 的更新都表示支持机器学习。iPhone 上人脸识别甚至比 Google Pixel 快出6倍。可以看出机器学习已经完完全全得融入到了 Apple 的全平台、全应用、全硬件。\n\n而作为开发者，最令我激动的是 MLKit 的发布。苹果带来了自己的模型，你只要不停的运用数据喂养它即可。这意味着我们今后的 App 将变得更加动态化 -- 随着用户使用的增多，App 将越来越智能和强大。\n\n原来的路线是 App 发布 -> 用户反馈 -> 线下产品经理分析 -> 程序员优化 -> App 更新；今后的路线可能是 App 发布 -> 用户反馈 -> 机器学习 -> App 更新。这次 Apple 还推出了急速审核（40分钟过审，摩拜单车团队已验证）和灰度发布的两大功能，也许就是为了给机器学习能自主的更新 App 铺路。目前苹果公布的 API 主要支持视觉识别、自然语言以及游戏 AI。\n\n#### 相关链接：\n- [Build more intelligent apps with machine learning](https://developer.apple.com/machine-learning/)\n- [Machine Learning API (Core ML)](https://developer.apple.com/documentation/coreml)\n- [Introducing Core ML](https://developer.apple.com/videos/play/wwdc2017/703/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc1.png)\n\n#### 虚拟现实和增强现实\n\n这些年虚拟现实遭遇了过山车式的变化。先是遭到资本疯狂追逐，大厂如三星、HTC 重金投入，索尼也趁势推出了 PlayStation VR；然后是 Pokemon Go 的大火，仿佛虚拟现实和增强现实的元年已经到来；突然，Facebook 的 Oculus 线下200家体验店关门；乐视的虚拟现实部门倒闭走人；直到上个月的 Google IO，Day Dream 的更新也表现平平。大家都认为，VR/AR 只是个概念炒作，充其量在游戏上起到锦上添花的效果。\n直到今天。如同当年普鲁士一统德意志，苹果姗姗来迟，却在一出场就技惊四座。\nMetal 2 十倍于当前性能的图像处理技术，芯片的升级和“硬件神兽” iMac Pro 的出现，让苹果在 AR/VR 上的雄心彰显无遗。现场的星球大战 VR 以及 iOS 11 即时战场 AR 展示完全颠覆了我对 AR 的认知 -- 要知道，这可是无需沉重的头套、专用的手机，直接用 iPad 即可完成的事情。\n同样， 推出了全新的 ARKit 来供开发者使用。配合 iPhone 和 iPad 上强大的传感器以及全新的 GPU、CPU，我们开发者可以使用 ARSession 这个共享单例来在摄像头上实现 2D 和 3D 的宏大场景构建。\n\n#### 相关链接：\n\n- [Metal 2](https://developer.apple.com/metal/)\n- [Introducing ARKit](https://developer.apple.com/arkit/)\n- [Augmented Reality API (ARKit)](https://developer.apple.com/documentation/arkit)\n- [VR with Metal 2](https://developer.apple.com/videos/play/wwdc2017/603/)\n- [Introducing ARKit: Augmented Reality for iOS](https://developer.apple.com/videos/play/wwdc2017/602/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc2.png)\n\n#### Swift 和 Xcode 9\n\nSwift 毫无疑问是开发者关心的头等大事。作为苹果的野心，Swift 引入了很多非常先进的思路。然而令我有点失望的是，这次 Keynote 却对 Swift 和 Xcode 9 只字未提。\n不过从现场看来，Swift 这次的更新主要是 API 的优化上，对现有的标准库进行了11项更新和1处新增，主要集中在基本数据类型和文件系统上。\nXcode 上，目前发现的更新主要是多个模拟器同时运行（鸡肋，估计会卡），本地化，runtime debug 工具，持续集成，和源码管理。\n我们只能期待秋季的苹果发布会上 Swift 4 进一步的更新了。有意思的是，之前 Swift 之父 Christ Lattner 写了篇总结文：[Chris Lattner 对 Swift 3 的总结与对 Swift 4 的展望](https://segmentfault.com/a/1190000006909760)。另外大家如果关心 [swift-evolution](https://github.com/apple/swift-evolution) 这个开源库，Swift 4 的新功能应该可见一斑。\n\n#### 相关链接\n\n- [Introducing Swift 4](https://developer.apple.com/swift/)\n- [Localizing with Xcode 9](https://developer.apple.com/videos/play/wwdc2017/401/)\n- [What's New in Signing for Xcode and Xcode Server](https://developer.apple.com/wwdc17/403)\n- [Debugging with Xcode 9](https://developer.apple.com/videos/play/wwdc2017/404/)\n- [Finding Bugs Using Xcode Runtime Tools](https://developer.apple.com/videos/play/wwdc2017/406/)\n\n\n#### iOS 11\n\n这次 iOS 11 更新可以说是全面彻底。从基本的功能升级到 App 新功能添加，再到 iPad 平台 UI 重构。主要集中在这几个方面。\niPad\n为 iPad 全新打造的 iOS 系统，多任务、分屏 UI，Docker 工具栏。虚拟现实和增强现实的引入，以及对机器学习的支持。总体来说，消费者很开心，开发者又有新的东西可玩了。同时我觉得 iPad 越来越向 Macbook 看齐了。\n#### App\nApp Store 全新设计\nFiles 文件管理软件放出\n开放  Music\n Pay 新的转账功能，注意 NFC API 接口开放，是不是为了  Pay 更方便接入其它 App？\n 地图继续追赶 Google 地图\niMessage 花里胡哨扩展中\nHomeKit 追加音响（HomePod）支持\n\n#### 新功能\nDrag and Drop (梦想成真！)\n拍照和截屏（扫描文件这个功能真是又重创了一大波 App）\n中国特殊加成：二维码和上海话识别\n\n#### 相关 Session\n- [Updating Your App for iOS 11](https://developer.apple.com/videos/play/wwdc2017/204/)\n- [Building Great Document-based Apps in iOS 11](https://developer.apple.com/videos/play/wwdc2017/229/)\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc3.png)\n\n#### tvOS, watchOS 4, MacOS\n这三个平台的更新可以说是泛善可陈（除了 Machine Learning 和 AR）。基本上就是，更多的内容（Amazon 的加入）、更炫更方便的 UI（运动界面和音乐界面）、以及更拽的名字（对，新 MacOS 叫 High）。\n值得一提的是  File System。其实这个文件系统去年就宣布了，不过并不在 Keynote 之中。今年苹果用它全面替代了古老的 HFS+，取而代之的是更高的性能、更好的安全性、更多的空间。这主要是 copy-on-write 和空间共享技术的运用。\n 同时开放了 [FileProvider API](https://developer.apple.com/documentation/fileprovider)，开发者可以用它在新的  File System 基础上实现对文件各种基本操作，还能通过它对应的 extension 实现诸如 drag and drop 这样跨 App 的功能。\n\n![](http://oqepgj2jp.bkt.clouddn.com/wwdc4.png)\n\n#### 相关链接\n- [What's new in  File System](https://developer.apple.com/videos/play/wwdc2017/715/)\n- [File Provider Enhancements](https://developer.apple.com/videos/play/wwdc2017/243/)\n\n#### 总结\n\n这次的 WWDC，苹果可以说是打了一个漂亮的翻身仗：在人工智能方面挑战 Google，在虚拟、增强现实方面加入战局震慑 Facebook，并重夺工业界顶峰的宝座。 watchOS 和 tvOS 的丰富，虽然进步并不明显，但好歹补足了短板。iOS 11 让 iPad 这个日趋边缘的产品逐渐焕发出了生机。后面的几天，应该会有更多精彩的 Session，给开发上带来更多的启示。\n\n","slug":"2017-WWDC","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tun0001znuzx49a9jur","content":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc.jpg\" alt=\"\"></p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>每年的 WWDC 都是 iOS 开发者集体高潮的时刻。第一天的 WWDC 带来了全新的 iOS 11、MacOS、tvOS 和 watchOS，革命性的 AR 和 ML 应用，以及更强的 iPad、“硬件神兽” iMac Pro 和智能音箱 HomePod。我想从开发者的角度，聊聊这次大会给我的印象和感受。欢迎大家在评论中谈谈自己的看法。</p>\n<h4 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h4><p>恐怕没有哪个词的频率高过 Machine Learning，它也是贯穿各个平台的关键词汇：watchOS 的表盘，macOS 上照片流的分类，Siri 的上下文理解、翻译、预测，手写笔记的直接识别和搜索支持，甚至 Mac 系列芯片和 Metal 的更新都表示支持机器学习。iPhone 上人脸识别甚至比 Google Pixel 快出6倍。可以看出机器学习已经完完全全得融入到了 Apple 的全平台、全应用、全硬件。</p>\n<p>而作为开发者，最令我激动的是 MLKit 的发布。苹果带来了自己的模型，你只要不停的运用数据喂养它即可。这意味着我们今后的 App 将变得更加动态化 – 随着用户使用的增多，App 将越来越智能和强大。</p>\n<p>原来的路线是 App 发布 -&gt; 用户反馈 -&gt; 线下产品经理分析 -&gt; 程序员优化 -&gt; App 更新；今后的路线可能是 App 发布 -&gt; 用户反馈 -&gt; 机器学习 -&gt; App 更新。这次 Apple 还推出了急速审核（40分钟过审，摩拜单车团队已验证）和灰度发布的两大功能，也许就是为了给机器学习能自主的更新 App 铺路。目前苹果公布的 API 主要支持视觉识别、自然语言以及游戏 AI。</p>\n<h4 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h4><ul>\n<li><a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"external\">Build more intelligent apps with machine learning</a></li>\n<li><a href=\"https://developer.apple.com/documentation/coreml\" target=\"_blank\" rel=\"external\">Machine Learning API (Core ML)</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/703/\" target=\"_blank\" rel=\"external\">Introducing Core ML</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc1.png\" alt=\"\"></p>\n<h4 id=\"虚拟现实和增强现实\"><a href=\"#虚拟现实和增强现实\" class=\"headerlink\" title=\"虚拟现实和增强现实\"></a>虚拟现实和增强现实</h4><p>这些年虚拟现实遭遇了过山车式的变化。先是遭到资本疯狂追逐，大厂如三星、HTC 重金投入，索尼也趁势推出了 PlayStation VR；然后是 Pokemon Go 的大火，仿佛虚拟现实和增强现实的元年已经到来；突然，Facebook 的 Oculus 线下200家体验店关门；乐视的虚拟现实部门倒闭走人；直到上个月的 Google IO，Day Dream 的更新也表现平平。大家都认为，VR/AR 只是个概念炒作，充其量在游戏上起到锦上添花的效果。<br>直到今天。如同当年普鲁士一统德意志，苹果姗姗来迟，却在一出场就技惊四座。<br>Metal 2 十倍于当前性能的图像处理技术，芯片的升级和“硬件神兽” iMac Pro 的出现，让苹果在 AR/VR 上的雄心彰显无遗。现场的星球大战 VR 以及 iOS 11 即时战场 AR 展示完全颠覆了我对 AR 的认知 – 要知道，这可是无需沉重的头套、专用的手机，直接用 iPad 即可完成的事情。<br>同样， 推出了全新的 ARKit 来供开发者使用。配合 iPhone 和 iPad 上强大的传感器以及全新的 GPU、CPU，我们开发者可以使用 ARSession 这个共享单例来在摄像头上实现 2D 和 3D 的宏大场景构建。</p>\n<h4 id=\"相关链接：-1\"><a href=\"#相关链接：-1\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h4><ul>\n<li><a href=\"https://developer.apple.com/metal/\" target=\"_blank\" rel=\"external\">Metal 2</a></li>\n<li><a href=\"https://developer.apple.com/arkit/\" target=\"_blank\" rel=\"external\">Introducing ARKit</a></li>\n<li><a href=\"https://developer.apple.com/documentation/arkit\" target=\"_blank\" rel=\"external\">Augmented Reality API (ARKit)</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/603/\" target=\"_blank\" rel=\"external\">VR with Metal 2</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/602/\" target=\"_blank\" rel=\"external\">Introducing ARKit: Augmented Reality for iOS</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc2.png\" alt=\"\"></p>\n<h4 id=\"Swift-和-Xcode-9\"><a href=\"#Swift-和-Xcode-9\" class=\"headerlink\" title=\"Swift 和 Xcode 9\"></a>Swift 和 Xcode 9</h4><p>Swift 毫无疑问是开发者关心的头等大事。作为苹果的野心，Swift 引入了很多非常先进的思路。然而令我有点失望的是，这次 Keynote 却对 Swift 和 Xcode 9 只字未提。<br>不过从现场看来，Swift 这次的更新主要是 API 的优化上，对现有的标准库进行了11项更新和1处新增，主要集中在基本数据类型和文件系统上。<br>Xcode 上，目前发现的更新主要是多个模拟器同时运行（鸡肋，估计会卡），本地化，runtime debug 工具，持续集成，和源码管理。<br>我们只能期待秋季的苹果发布会上 Swift 4 进一步的更新了。有意思的是，之前 Swift 之父 Christ Lattner 写了篇总结文：<a href=\"https://segmentfault.com/a/1190000006909760\" target=\"_blank\" rel=\"external\">Chris Lattner 对 Swift 3 的总结与对 Swift 4 的展望</a>。另外大家如果关心 <a href=\"https://github.com/apple/swift-evolution\" target=\"_blank\" rel=\"external\">swift-evolution</a> 这个开源库，Swift 4 的新功能应该可见一斑。</p>\n<h4 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h4><ul>\n<li><a href=\"https://developer.apple.com/swift/\" target=\"_blank\" rel=\"external\">Introducing Swift 4</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/401/\" target=\"_blank\" rel=\"external\">Localizing with Xcode 9</a></li>\n<li><a href=\"https://developer.apple.com/wwdc17/403\" target=\"_blank\" rel=\"external\">What’s New in Signing for Xcode and Xcode Server</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/404/\" target=\"_blank\" rel=\"external\">Debugging with Xcode 9</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/406/\" target=\"_blank\" rel=\"external\">Finding Bugs Using Xcode Runtime Tools</a></li>\n</ul>\n<h4 id=\"iOS-11\"><a href=\"#iOS-11\" class=\"headerlink\" title=\"iOS 11\"></a>iOS 11</h4><p>这次 iOS 11 更新可以说是全面彻底。从基本的功能升级到 App 新功能添加，再到 iPad 平台 UI 重构。主要集中在这几个方面。<br>iPad<br>为 iPad 全新打造的 iOS 系统，多任务、分屏 UI，Docker 工具栏。虚拟现实和增强现实的引入，以及对机器学习的支持。总体来说，消费者很开心，开发者又有新的东西可玩了。同时我觉得 iPad 越来越向 Macbook 看齐了。</p>\n<h4 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h4><p>App Store 全新设计<br>Files 文件管理软件放出<br>开放  Music<br> Pay 新的转账功能，注意 NFC API 接口开放，是不是为了  Pay 更方便接入其它 App？<br> 地图继续追赶 Google 地图<br>iMessage 花里胡哨扩展中<br>HomeKit 追加音响（HomePod）支持</p>\n<h4 id=\"新功能\"><a href=\"#新功能\" class=\"headerlink\" title=\"新功能\"></a>新功能</h4><p>Drag and Drop (梦想成真！)<br>拍照和截屏（扫描文件这个功能真是又重创了一大波 App）<br>中国特殊加成：二维码和上海话识别</p>\n<h4 id=\"相关-Session\"><a href=\"#相关-Session\" class=\"headerlink\" title=\"相关 Session\"></a>相关 Session</h4><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/204/\" target=\"_blank\" rel=\"external\">Updating Your App for iOS 11</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/229/\" target=\"_blank\" rel=\"external\">Building Great Document-based Apps in iOS 11</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc3.png\" alt=\"\"></p>\n<h4 id=\"tvOS-watchOS-4-MacOS\"><a href=\"#tvOS-watchOS-4-MacOS\" class=\"headerlink\" title=\"tvOS, watchOS 4, MacOS\"></a>tvOS, watchOS 4, MacOS</h4><p>这三个平台的更新可以说是泛善可陈（除了 Machine Learning 和 AR）。基本上就是，更多的内容（Amazon 的加入）、更炫更方便的 UI（运动界面和音乐界面）、以及更拽的名字（对，新 MacOS 叫 High）。<br>值得一提的是  File System。其实这个文件系统去年就宣布了，不过并不在 Keynote 之中。今年苹果用它全面替代了古老的 HFS+，取而代之的是更高的性能、更好的安全性、更多的空间。这主要是 copy-on-write 和空间共享技术的运用。<br> 同时开放了 <a href=\"https://developer.apple.com/documentation/fileprovider\" target=\"_blank\" rel=\"external\">FileProvider API</a>，开发者可以用它在新的  File System 基础上实现对文件各种基本操作，还能通过它对应的 extension 实现诸如 drag and drop 这样跨 App 的功能。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc4.png\" alt=\"\"></p>\n<h4 id=\"相关链接-1\"><a href=\"#相关链接-1\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h4><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/715/\" target=\"_blank\" rel=\"external\">What’s new in  File System</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/243/\" target=\"_blank\" rel=\"external\">File Provider Enhancements</a></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这次的 WWDC，苹果可以说是打了一个漂亮的翻身仗：在人工智能方面挑战 Google，在虚拟、增强现实方面加入战局震慑 Facebook，并重夺工业界顶峰的宝座。 watchOS 和 tvOS 的丰富，虽然进步并不明显，但好歹补足了短板。iOS 11 让 iPad 这个日趋边缘的产品逐渐焕发出了生机。后面的几天，应该会有更多精彩的 Session，给开发上带来更多的启示。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc.jpg\" alt=\"\"></p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>每年的 WWDC 都是 iOS 开发者集体高潮的时刻。第一天的 WWDC 带来了全新的 iOS 11、MacOS、tvOS 和 watchOS，革命性的 AR 和 ML 应用，以及更强的 iPad、“硬件神兽” iMac Pro 和智能音箱 HomePod。我想从开发者的角度，聊聊这次大会给我的印象和感受。欢迎大家在评论中谈谈自己的看法。</p>\n<h4 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h4><p>恐怕没有哪个词的频率高过 Machine Learning，它也是贯穿各个平台的关键词汇：watchOS 的表盘，macOS 上照片流的分类，Siri 的上下文理解、翻译、预测，手写笔记的直接识别和搜索支持，甚至 Mac 系列芯片和 Metal 的更新都表示支持机器学习。iPhone 上人脸识别甚至比 Google Pixel 快出6倍。可以看出机器学习已经完完全全得融入到了 Apple 的全平台、全应用、全硬件。</p>\n<p>而作为开发者，最令我激动的是 MLKit 的发布。苹果带来了自己的模型，你只要不停的运用数据喂养它即可。这意味着我们今后的 App 将变得更加动态化 – 随着用户使用的增多，App 将越来越智能和强大。</p>\n<p>原来的路线是 App 发布 -&gt; 用户反馈 -&gt; 线下产品经理分析 -&gt; 程序员优化 -&gt; App 更新；今后的路线可能是 App 发布 -&gt; 用户反馈 -&gt; 机器学习 -&gt; App 更新。这次 Apple 还推出了急速审核（40分钟过审，摩拜单车团队已验证）和灰度发布的两大功能，也许就是为了给机器学习能自主的更新 App 铺路。目前苹果公布的 API 主要支持视觉识别、自然语言以及游戏 AI。</p>\n<h4 id=\"相关链接：\"><a href=\"#相关链接：\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h4><ul>\n<li><a href=\"https://developer.apple.com/machine-learning/\" target=\"_blank\" rel=\"external\">Build more intelligent apps with machine learning</a></li>\n<li><a href=\"https://developer.apple.com/documentation/coreml\" target=\"_blank\" rel=\"external\">Machine Learning API (Core ML)</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/703/\" target=\"_blank\" rel=\"external\">Introducing Core ML</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc1.png\" alt=\"\"></p>\n<h4 id=\"虚拟现实和增强现实\"><a href=\"#虚拟现实和增强现实\" class=\"headerlink\" title=\"虚拟现实和增强现实\"></a>虚拟现实和增强现实</h4><p>这些年虚拟现实遭遇了过山车式的变化。先是遭到资本疯狂追逐，大厂如三星、HTC 重金投入，索尼也趁势推出了 PlayStation VR；然后是 Pokemon Go 的大火，仿佛虚拟现实和增强现实的元年已经到来；突然，Facebook 的 Oculus 线下200家体验店关门；乐视的虚拟现实部门倒闭走人；直到上个月的 Google IO，Day Dream 的更新也表现平平。大家都认为，VR/AR 只是个概念炒作，充其量在游戏上起到锦上添花的效果。<br>直到今天。如同当年普鲁士一统德意志，苹果姗姗来迟，却在一出场就技惊四座。<br>Metal 2 十倍于当前性能的图像处理技术，芯片的升级和“硬件神兽” iMac Pro 的出现，让苹果在 AR/VR 上的雄心彰显无遗。现场的星球大战 VR 以及 iOS 11 即时战场 AR 展示完全颠覆了我对 AR 的认知 – 要知道，这可是无需沉重的头套、专用的手机，直接用 iPad 即可完成的事情。<br>同样， 推出了全新的 ARKit 来供开发者使用。配合 iPhone 和 iPad 上强大的传感器以及全新的 GPU、CPU，我们开发者可以使用 ARSession 这个共享单例来在摄像头上实现 2D 和 3D 的宏大场景构建。</p>\n<h4 id=\"相关链接：-1\"><a href=\"#相关链接：-1\" class=\"headerlink\" title=\"相关链接：\"></a>相关链接：</h4><ul>\n<li><a href=\"https://developer.apple.com/metal/\" target=\"_blank\" rel=\"external\">Metal 2</a></li>\n<li><a href=\"https://developer.apple.com/arkit/\" target=\"_blank\" rel=\"external\">Introducing ARKit</a></li>\n<li><a href=\"https://developer.apple.com/documentation/arkit\" target=\"_blank\" rel=\"external\">Augmented Reality API (ARKit)</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/603/\" target=\"_blank\" rel=\"external\">VR with Metal 2</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/602/\" target=\"_blank\" rel=\"external\">Introducing ARKit: Augmented Reality for iOS</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc2.png\" alt=\"\"></p>\n<h4 id=\"Swift-和-Xcode-9\"><a href=\"#Swift-和-Xcode-9\" class=\"headerlink\" title=\"Swift 和 Xcode 9\"></a>Swift 和 Xcode 9</h4><p>Swift 毫无疑问是开发者关心的头等大事。作为苹果的野心，Swift 引入了很多非常先进的思路。然而令我有点失望的是，这次 Keynote 却对 Swift 和 Xcode 9 只字未提。<br>不过从现场看来，Swift 这次的更新主要是 API 的优化上，对现有的标准库进行了11项更新和1处新增，主要集中在基本数据类型和文件系统上。<br>Xcode 上，目前发现的更新主要是多个模拟器同时运行（鸡肋，估计会卡），本地化，runtime debug 工具，持续集成，和源码管理。<br>我们只能期待秋季的苹果发布会上 Swift 4 进一步的更新了。有意思的是，之前 Swift 之父 Christ Lattner 写了篇总结文：<a href=\"https://segmentfault.com/a/1190000006909760\" target=\"_blank\" rel=\"external\">Chris Lattner 对 Swift 3 的总结与对 Swift 4 的展望</a>。另外大家如果关心 <a href=\"https://github.com/apple/swift-evolution\" target=\"_blank\" rel=\"external\">swift-evolution</a> 这个开源库，Swift 4 的新功能应该可见一斑。</p>\n<h4 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h4><ul>\n<li><a href=\"https://developer.apple.com/swift/\" target=\"_blank\" rel=\"external\">Introducing Swift 4</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/401/\" target=\"_blank\" rel=\"external\">Localizing with Xcode 9</a></li>\n<li><a href=\"https://developer.apple.com/wwdc17/403\" target=\"_blank\" rel=\"external\">What’s New in Signing for Xcode and Xcode Server</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/404/\" target=\"_blank\" rel=\"external\">Debugging with Xcode 9</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/406/\" target=\"_blank\" rel=\"external\">Finding Bugs Using Xcode Runtime Tools</a></li>\n</ul>\n<h4 id=\"iOS-11\"><a href=\"#iOS-11\" class=\"headerlink\" title=\"iOS 11\"></a>iOS 11</h4><p>这次 iOS 11 更新可以说是全面彻底。从基本的功能升级到 App 新功能添加，再到 iPad 平台 UI 重构。主要集中在这几个方面。<br>iPad<br>为 iPad 全新打造的 iOS 系统，多任务、分屏 UI，Docker 工具栏。虚拟现实和增强现实的引入，以及对机器学习的支持。总体来说，消费者很开心，开发者又有新的东西可玩了。同时我觉得 iPad 越来越向 Macbook 看齐了。</p>\n<h4 id=\"App\"><a href=\"#App\" class=\"headerlink\" title=\"App\"></a>App</h4><p>App Store 全新设计<br>Files 文件管理软件放出<br>开放  Music<br> Pay 新的转账功能，注意 NFC API 接口开放，是不是为了  Pay 更方便接入其它 App？<br> 地图继续追赶 Google 地图<br>iMessage 花里胡哨扩展中<br>HomeKit 追加音响（HomePod）支持</p>\n<h4 id=\"新功能\"><a href=\"#新功能\" class=\"headerlink\" title=\"新功能\"></a>新功能</h4><p>Drag and Drop (梦想成真！)<br>拍照和截屏（扫描文件这个功能真是又重创了一大波 App）<br>中国特殊加成：二维码和上海话识别</p>\n<h4 id=\"相关-Session\"><a href=\"#相关-Session\" class=\"headerlink\" title=\"相关 Session\"></a>相关 Session</h4><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/204/\" target=\"_blank\" rel=\"external\">Updating Your App for iOS 11</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/229/\" target=\"_blank\" rel=\"external\">Building Great Document-based Apps in iOS 11</a></li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc3.png\" alt=\"\"></p>\n<h4 id=\"tvOS-watchOS-4-MacOS\"><a href=\"#tvOS-watchOS-4-MacOS\" class=\"headerlink\" title=\"tvOS, watchOS 4, MacOS\"></a>tvOS, watchOS 4, MacOS</h4><p>这三个平台的更新可以说是泛善可陈（除了 Machine Learning 和 AR）。基本上就是，更多的内容（Amazon 的加入）、更炫更方便的 UI（运动界面和音乐界面）、以及更拽的名字（对，新 MacOS 叫 High）。<br>值得一提的是  File System。其实这个文件系统去年就宣布了，不过并不在 Keynote 之中。今年苹果用它全面替代了古老的 HFS+，取而代之的是更高的性能、更好的安全性、更多的空间。这主要是 copy-on-write 和空间共享技术的运用。<br> 同时开放了 <a href=\"https://developer.apple.com/documentation/fileprovider\" target=\"_blank\" rel=\"external\">FileProvider API</a>，开发者可以用它在新的  File System 基础上实现对文件各种基本操作，还能通过它对应的 extension 实现诸如 drag and drop 这样跨 App 的功能。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wwdc4.png\" alt=\"\"></p>\n<h4 id=\"相关链接-1\"><a href=\"#相关链接-1\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h4><ul>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/715/\" target=\"_blank\" rel=\"external\">What’s new in  File System</a></li>\n<li><a href=\"https://developer.apple.com/videos/play/wwdc2017/243/\" target=\"_blank\" rel=\"external\">File Provider Enhancements</a></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这次的 WWDC，苹果可以说是打了一个漂亮的翻身仗：在人工智能方面挑战 Google，在虚拟、增强现实方面加入战局震慑 Facebook，并重夺工业界顶峰的宝座。 watchOS 和 tvOS 的丰富，虽然进步并不明显，但好歹补足了短板。iOS 11 让 iPad 这个日趋边缘的产品逐渐焕发出了生机。后面的几天，应该会有更多精彩的 Session，给开发上带来更多的启示。</p>\n"},{"title":"AVAudioFoundation(1)：使用 AVAsset","date":"2017-06-25T10:38:11.000Z","_content":"要了解 iOS 上的音视频相关的内容，首先需要了解的就是 `AVFoundation` 这个框架。\n\n下图是 `AVFoundation` 框架大的层级结构：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/AVF1.png)\n\n在 `AVFoundation` 框架中，最主要的表示媒体的类就是 `AVAsset`，甚至可以认为 `AVFoundation` 框架的大部分能力都是围绕着 `AVAsset` 展开的。\n\n一个 `AVAsset` 实例表示的是一份或多份音视频数据（audio and video tracks）的集合，它描述的是这个集合作为一个整体对象的一些属性，比如：标题、时长、大小等，而不与具体的数据格式绑定。通常，在实际使用时我们可能会基于某个 URL 创建对应的媒体资源对象（AVURLAsset），或者直接创建 compositions（AVComposition），这些类都是 `AVAsset` 的子类。\n\n一个 `AVAsset` 中的每一份音频或视频数据都称为一个**轨道（track）**。在最简单的情况下，一个媒体文件中可能只有两个轨道，一个音频轨道，一个视频轨道。而复杂的组合中，可能包含多个重叠的音频轨道和视频轨道。此外  `AVAsset` 也可能包含元数据**（metadata）**。\n\n在 `AVFoundation` 中另一个非常重要的概念是，初始化一个 `AVAsset` 或者一个 `AVAssetTrack` 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。\n\n我们可以从一个文件或者用户的相册中来创建 asset。获得一个视频 asset 时，我们可以从中提出静态图，对其进行转码，裁剪器内容。\n\n#### 创建 Asset\n\n当使用一个 URL 来创建 asset 时，可以用 `AVURLAsset`：\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\n```\n\n#### 设置 Asset 选项\n\n可以看到当我们创建一个 `AVURLAsset` 时，是可以设置一个对象的 options 的，这里可选的设置项包括：\n\n`AVURLAssetPreferPreciseDurationAndTimingKey`，这个选项对应的值是布尔值，默认为 `@(NO)`，当设为 `@(YES)` 时表示 asset 应该提供精确的时长，并能根据时间准确地随机访问，提供这样的能力是需要开销更大的计算的。当你只是想播放视频时，你可以不设置这个选项，但是如果你想把这个 asset 添加到一个 composition（AVMutableComposition）中去做进一步编辑，你通常需要精确的随机访问，这时你最好设置这个选项为 YES。\n`AVURLAssetReferenceRestrictionsKey`，这个选项对应的值是 AVAssetReferenceRestrictions enum。有一些 asset 可以保护一些指向外部数据的引用，这个选项用来表示对外部数据访问的限制。具体含义参见 AVAssetReferenceRestrictions。\n`AVURLAssetHTTPCookiesKey`，这个选项用来设置 asset 通过 HTTP 请求发送的 HTTP cookies，当然 cookies 只能发给同站。具体参见文档。\n`AVURLAssetAllowsCellularAccessKey`，这个选项对应的值是布尔值，默认为 @(YES)。表示 asset 是否能使用移动网络资源。\n不过要注意这几个选项适用的 iOS 版本。\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nNSDictionary *options = @{ AVURLAssetPreferPreciseDurationAndTimingKey : @YES };\nAVURLAsset *anAssetToUseInAComposition = [[AVURLAsset alloc] initWithURL:url options:options];\n```\n\n#### 访问用户的 Asset\n\n获取用户相册的资源时，你需要借用 `ALAssetsLibrary` 的相关接口：\n\n```objectivec\nALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];\n\n// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.\n[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n\n// Within the group enumeration block, filter to enumerate just videos.\n[group setAssetsFilter:[ALAssetsFilter allVideos]];\n\n// For this example, we're only interested in the first item.\n[group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0]\n                        options:0\n                     usingBlock:^(ALAsset *alAsset, NSUInteger index, BOOL *innerStop) {\n\n                         // The end of the enumeration is signaled by asset == nil.\n                         if (alAsset) {\n                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];\n                             NSURL *url = [representation url];\n                             AVAsset *avAsset = [AVURLAsset URLAssetWithURL:url options:nil];\n                             // Do something interesting with the AV asset.\n                         }\n                     }];\n                 }\n                 failureBlock: ^(NSError *error) {\n                     // Typically you should handle an error more gracefully than this.\n                     NSLog(@\"No groups\");\n                 }];\n\n```\n\n\n#### 加载 Asset 来使用\n\n初始化一个 `AVAsset` 或者一个 `AVAssetTrack` 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。\n\n这时你可以使用 `AVAsynchronousKeyValueLoading` protocol 来获取加载 asset 的状态，并在对应的 completion handler 中做对应的处理。`AVAsset` 和 `AVAssetTrack` 都是遵循 `AVAsynchronousKeyValueLoading` protocol 的。下面是一个示例：\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\nNSArray *keys = @[@\"duration\"];\n\n[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() {\n\n    NSError *error = nil;\n    AVKeyValueStatus tracksStatus = [asset statusOfValueForKey:@\"duration\" error:&error];\n    switch (tracksStatus) {\n        case AVKeyValueStatusLoaded:\n            [self updateUserInterfaceForDuration];\n            break;\n        case AVKeyValueStatusFailed:\n            [self reportError:error forAsset:asset];\n            break;\n        case AVKeyValueStatusCancelled:\n            // Do whatever is appropriate for cancelation.\n            break;\n   }\n}];\n```\n\n需要注意的是：当你需要加载一个 asset 来点播，你应该加载它的 `tracks` 属性。\n\n#### 获取一张图片\n\n我们可以用 `copyCGImageAtTime:actualTime:error:` 来获得指定时间的截图。`AVFoundation` 也许无法精确地获得你指定时间的截图，所以你需要传入一个 actualTime 参数来获得截图所对应的实际时间。\n\n```objectivec\nAVAsset *myAsset = <#An asset#>];\nAVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime midpoint = CMTimeMakeWithSeconds(durationSeconds/2.0, 600);\nNSError *error;\nCMTime actualTime;\n\nCGImageRef halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&actualTime error:&error];\n\nif (halfWayImage != NULL) {\n\n    NSString *actualTimeString = (NSString *)CMTimeCopyDescription(NULL, actualTime);\n    NSString *requestedTimeString = (NSString *)CMTimeCopyDescription(NULL, midpoint);\n    NSLog(@\"Got halfWayImage: Asked for %@, got %@\", requestedTimeString, actualTimeString);\n\n    // Do something interesting with the image.\n    CGImageRelease(halfWayImage);\n}\n```\n#### 获取一组截图\n\n我们可以用 `generateCGImagesAsynchronouslyForTimes:completionHandler:` 接口来传入一组时间来获取相应的一组截图。同样的，必须保证在生成图片时对 `AVAssetImageGenerator` 实例的强引用。示例代码如下：\n\n```objectivec\nAVAsset *myAsset = <#An asset#>];\n// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;\nself.imageGenerator = [AVAssetImageGenerator assetImageGeneratorWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 600);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 600);\nCMTime end = CMTimeMakeWithSeconds(durationSeconds, 600);\nNSArray *times = @[NSValue valueWithCMTime:kCMTimeZero],\n                  [NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird],\n                  [NSValue valueWithCMTime:end]];\n\n[imageGenerator generateCGImagesAsynchronouslyForTimes:times\n                completionHandler:^(CMTime requestedTime, CGImageRef image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError *error) {\n\n                NSString *requestedTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, requestedTime));\n                NSString *actualTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, actualTime));\n                NSLog(@\"Requested: %@; actual %@\", requestedTimeString, actualTimeString);\n\n                if (result == AVAssetImageGeneratorSucceeded) {\n                    // Do something interesting with the image.\n                }\n\n                if (result == AVAssetImageGeneratorFailed) {\n                    NSLog(@\"Failed with error: %@\", [error localizedDescription]);\n                }\n                if (result == AVAssetImageGeneratorCancelled) {\n                    NSLog(@\"Canceled\");\n                }\n}];\n```\n我们还能使用 `cancelAllCGImageGeneration` 接口来中断截图。\n\n#### 对视频进行裁剪和转码\n\n我们可以使用一个 `AVAssetExportSession` 实例来对视频进行裁剪或格式转换。流程如下图所示：\n![图二](http://oqepgj2jp.bkt.clouddn.com/AVF2.png)\n\n`AVAssetExportSession` 实例用来控制异步的导出 asset。使用 export session 时，首先我们需要传入要导出的 asset 和对应的 preset 配置，我们可以用 `allExportPresets` 接口来查看所有可用的 preset 配置。接着，你需要设置导出的 URL 和文件类型。此外，我们还能设置导出视频文件的 metadata 以及导出的是否应该针对网络访问优化。\n\n在下面的示例代码中，我们用 `exportPresetsCompatibleWithAsset:` 接口检查可用的 preset，用 `outputURL` 和 `outputFileType` 接口设置导出 URL 和导出文件类型，通过 timeRange 设置导出时间段。此外，我们还能用 `shouldOptimizeForNetworkUse` 接口设置是否针对网络使用优化以方便秒开，用 `maxDuration`、`fileLengthLimit` 设置导入限制等等。\n\n我们用 `exportAsynchronouslyWithCompletionHandler:` 接口来开始导出。\n\n```objectivec\nAVAsset *anAsset = <#Get an asset#>;\nNSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:anAsset];\nif ([compatiblePresets containsObject:AVAssetExportPresetLowQuality]) {\n    AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:anAsset presetName:AVAssetExportPresetLowQuality];\n\n    exportSession.outputURL = <#A file URL#>;\n    exportSession.outputFileType = AVFileTypeQuickTimeMovie;\n\n    CMTime start = CMTimeMakeWithSeconds(1.0, 600);\n    CMTime duration = CMTimeMakeWithSeconds(3.0, 600);\n    CMTimeRange range = CMTimeRangeMake(start, duration);\n    exportSession.timeRange = range;\n\n    [exportSession exportAsynchronouslyWithCompletionHandler:^{\n\n        switch ([exportSession status]) {\n            case AVAssetExportSessionStatusFailed:\n                NSLog(@\"Export failed: %@\", [[exportSession error] localizedDescription]);\n                break;\n            case AVAssetExportSessionStatusCancelled:\n                NSLog(@\"Export canceled\");\n                break;\n            default:\n                break;\n        }\n    }];\n}\n```\n此外，我们还可以用 `cancelExport` 接口来取消导出。\n\n当我们想要覆盖已有的文件，或者向应用沙盒外写文件时，导出会失败。此外，在导出时突然来了电话、导出时应用在后台状态并且其他应用开始播放时导出也可能会失败。在这些情况下，你需要提示用户导出失败，并允许用户重新导出。\n\n参考： [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n\n","source":"_posts/AVAudioFoundation-1-：使用-AVAsset.md","raw":"---\ntitle: AVAudioFoundation(1)：使用 AVAsset\ndate: 2017-06-25 18:38:11\ncategories: \n\t- iOS合集\n---\n要了解 iOS 上的音视频相关的内容，首先需要了解的就是 `AVFoundation` 这个框架。\n\n下图是 `AVFoundation` 框架大的层级结构：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/AVF1.png)\n\n在 `AVFoundation` 框架中，最主要的表示媒体的类就是 `AVAsset`，甚至可以认为 `AVFoundation` 框架的大部分能力都是围绕着 `AVAsset` 展开的。\n\n一个 `AVAsset` 实例表示的是一份或多份音视频数据（audio and video tracks）的集合，它描述的是这个集合作为一个整体对象的一些属性，比如：标题、时长、大小等，而不与具体的数据格式绑定。通常，在实际使用时我们可能会基于某个 URL 创建对应的媒体资源对象（AVURLAsset），或者直接创建 compositions（AVComposition），这些类都是 `AVAsset` 的子类。\n\n一个 `AVAsset` 中的每一份音频或视频数据都称为一个**轨道（track）**。在最简单的情况下，一个媒体文件中可能只有两个轨道，一个音频轨道，一个视频轨道。而复杂的组合中，可能包含多个重叠的音频轨道和视频轨道。此外  `AVAsset` 也可能包含元数据**（metadata）**。\n\n在 `AVFoundation` 中另一个非常重要的概念是，初始化一个 `AVAsset` 或者一个 `AVAssetTrack` 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。\n\n我们可以从一个文件或者用户的相册中来创建 asset。获得一个视频 asset 时，我们可以从中提出静态图，对其进行转码，裁剪器内容。\n\n#### 创建 Asset\n\n当使用一个 URL 来创建 asset 时，可以用 `AVURLAsset`：\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\n```\n\n#### 设置 Asset 选项\n\n可以看到当我们创建一个 `AVURLAsset` 时，是可以设置一个对象的 options 的，这里可选的设置项包括：\n\n`AVURLAssetPreferPreciseDurationAndTimingKey`，这个选项对应的值是布尔值，默认为 `@(NO)`，当设为 `@(YES)` 时表示 asset 应该提供精确的时长，并能根据时间准确地随机访问，提供这样的能力是需要开销更大的计算的。当你只是想播放视频时，你可以不设置这个选项，但是如果你想把这个 asset 添加到一个 composition（AVMutableComposition）中去做进一步编辑，你通常需要精确的随机访问，这时你最好设置这个选项为 YES。\n`AVURLAssetReferenceRestrictionsKey`，这个选项对应的值是 AVAssetReferenceRestrictions enum。有一些 asset 可以保护一些指向外部数据的引用，这个选项用来表示对外部数据访问的限制。具体含义参见 AVAssetReferenceRestrictions。\n`AVURLAssetHTTPCookiesKey`，这个选项用来设置 asset 通过 HTTP 请求发送的 HTTP cookies，当然 cookies 只能发给同站。具体参见文档。\n`AVURLAssetAllowsCellularAccessKey`，这个选项对应的值是布尔值，默认为 @(YES)。表示 asset 是否能使用移动网络资源。\n不过要注意这几个选项适用的 iOS 版本。\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nNSDictionary *options = @{ AVURLAssetPreferPreciseDurationAndTimingKey : @YES };\nAVURLAsset *anAssetToUseInAComposition = [[AVURLAsset alloc] initWithURL:url options:options];\n```\n\n#### 访问用户的 Asset\n\n获取用户相册的资源时，你需要借用 `ALAssetsLibrary` 的相关接口：\n\n```objectivec\nALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];\n\n// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.\n[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n\n// Within the group enumeration block, filter to enumerate just videos.\n[group setAssetsFilter:[ALAssetsFilter allVideos]];\n\n// For this example, we're only interested in the first item.\n[group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0]\n                        options:0\n                     usingBlock:^(ALAsset *alAsset, NSUInteger index, BOOL *innerStop) {\n\n                         // The end of the enumeration is signaled by asset == nil.\n                         if (alAsset) {\n                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];\n                             NSURL *url = [representation url];\n                             AVAsset *avAsset = [AVURLAsset URLAssetWithURL:url options:nil];\n                             // Do something interesting with the AV asset.\n                         }\n                     }];\n                 }\n                 failureBlock: ^(NSError *error) {\n                     // Typically you should handle an error more gracefully than this.\n                     NSLog(@\"No groups\");\n                 }];\n\n```\n\n\n#### 加载 Asset 来使用\n\n初始化一个 `AVAsset` 或者一个 `AVAssetTrack` 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。\n\n这时你可以使用 `AVAsynchronousKeyValueLoading` protocol 来获取加载 asset 的状态，并在对应的 completion handler 中做对应的处理。`AVAsset` 和 `AVAssetTrack` 都是遵循 `AVAsynchronousKeyValueLoading` protocol 的。下面是一个示例：\n\n```objectivec\nNSURL *url = <#A URL that identifies an audiovisual asset such as a movie file#>;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\nNSArray *keys = @[@\"duration\"];\n\n[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() {\n\n    NSError *error = nil;\n    AVKeyValueStatus tracksStatus = [asset statusOfValueForKey:@\"duration\" error:&error];\n    switch (tracksStatus) {\n        case AVKeyValueStatusLoaded:\n            [self updateUserInterfaceForDuration];\n            break;\n        case AVKeyValueStatusFailed:\n            [self reportError:error forAsset:asset];\n            break;\n        case AVKeyValueStatusCancelled:\n            // Do whatever is appropriate for cancelation.\n            break;\n   }\n}];\n```\n\n需要注意的是：当你需要加载一个 asset 来点播，你应该加载它的 `tracks` 属性。\n\n#### 获取一张图片\n\n我们可以用 `copyCGImageAtTime:actualTime:error:` 来获得指定时间的截图。`AVFoundation` 也许无法精确地获得你指定时间的截图，所以你需要传入一个 actualTime 参数来获得截图所对应的实际时间。\n\n```objectivec\nAVAsset *myAsset = <#An asset#>];\nAVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime midpoint = CMTimeMakeWithSeconds(durationSeconds/2.0, 600);\nNSError *error;\nCMTime actualTime;\n\nCGImageRef halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&actualTime error:&error];\n\nif (halfWayImage != NULL) {\n\n    NSString *actualTimeString = (NSString *)CMTimeCopyDescription(NULL, actualTime);\n    NSString *requestedTimeString = (NSString *)CMTimeCopyDescription(NULL, midpoint);\n    NSLog(@\"Got halfWayImage: Asked for %@, got %@\", requestedTimeString, actualTimeString);\n\n    // Do something interesting with the image.\n    CGImageRelease(halfWayImage);\n}\n```\n#### 获取一组截图\n\n我们可以用 `generateCGImagesAsynchronouslyForTimes:completionHandler:` 接口来传入一组时间来获取相应的一组截图。同样的，必须保证在生成图片时对 `AVAssetImageGenerator` 实例的强引用。示例代码如下：\n\n```objectivec\nAVAsset *myAsset = <#An asset#>];\n// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;\nself.imageGenerator = [AVAssetImageGenerator assetImageGeneratorWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 600);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 600);\nCMTime end = CMTimeMakeWithSeconds(durationSeconds, 600);\nNSArray *times = @[NSValue valueWithCMTime:kCMTimeZero],\n                  [NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird],\n                  [NSValue valueWithCMTime:end]];\n\n[imageGenerator generateCGImagesAsynchronouslyForTimes:times\n                completionHandler:^(CMTime requestedTime, CGImageRef image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError *error) {\n\n                NSString *requestedTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, requestedTime));\n                NSString *actualTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, actualTime));\n                NSLog(@\"Requested: %@; actual %@\", requestedTimeString, actualTimeString);\n\n                if (result == AVAssetImageGeneratorSucceeded) {\n                    // Do something interesting with the image.\n                }\n\n                if (result == AVAssetImageGeneratorFailed) {\n                    NSLog(@\"Failed with error: %@\", [error localizedDescription]);\n                }\n                if (result == AVAssetImageGeneratorCancelled) {\n                    NSLog(@\"Canceled\");\n                }\n}];\n```\n我们还能使用 `cancelAllCGImageGeneration` 接口来中断截图。\n\n#### 对视频进行裁剪和转码\n\n我们可以使用一个 `AVAssetExportSession` 实例来对视频进行裁剪或格式转换。流程如下图所示：\n![图二](http://oqepgj2jp.bkt.clouddn.com/AVF2.png)\n\n`AVAssetExportSession` 实例用来控制异步的导出 asset。使用 export session 时，首先我们需要传入要导出的 asset 和对应的 preset 配置，我们可以用 `allExportPresets` 接口来查看所有可用的 preset 配置。接着，你需要设置导出的 URL 和文件类型。此外，我们还能设置导出视频文件的 metadata 以及导出的是否应该针对网络访问优化。\n\n在下面的示例代码中，我们用 `exportPresetsCompatibleWithAsset:` 接口检查可用的 preset，用 `outputURL` 和 `outputFileType` 接口设置导出 URL 和导出文件类型，通过 timeRange 设置导出时间段。此外，我们还能用 `shouldOptimizeForNetworkUse` 接口设置是否针对网络使用优化以方便秒开，用 `maxDuration`、`fileLengthLimit` 设置导入限制等等。\n\n我们用 `exportAsynchronouslyWithCompletionHandler:` 接口来开始导出。\n\n```objectivec\nAVAsset *anAsset = <#Get an asset#>;\nNSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:anAsset];\nif ([compatiblePresets containsObject:AVAssetExportPresetLowQuality]) {\n    AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:anAsset presetName:AVAssetExportPresetLowQuality];\n\n    exportSession.outputURL = <#A file URL#>;\n    exportSession.outputFileType = AVFileTypeQuickTimeMovie;\n\n    CMTime start = CMTimeMakeWithSeconds(1.0, 600);\n    CMTime duration = CMTimeMakeWithSeconds(3.0, 600);\n    CMTimeRange range = CMTimeRangeMake(start, duration);\n    exportSession.timeRange = range;\n\n    [exportSession exportAsynchronouslyWithCompletionHandler:^{\n\n        switch ([exportSession status]) {\n            case AVAssetExportSessionStatusFailed:\n                NSLog(@\"Export failed: %@\", [[exportSession error] localizedDescription]);\n                break;\n            case AVAssetExportSessionStatusCancelled:\n                NSLog(@\"Export canceled\");\n                break;\n            default:\n                break;\n        }\n    }];\n}\n```\n此外，我们还可以用 `cancelExport` 接口来取消导出。\n\n当我们想要覆盖已有的文件，或者向应用沙盒外写文件时，导出会失败。此外，在导出时突然来了电话、导出时应用在后台状态并且其他应用开始播放时导出也可能会失败。在这些情况下，你需要提示用户导出失败，并允许用户重新导出。\n\n参考： [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n\n","slug":"AVAudioFoundation-1-：使用-AVAsset","published":1,"updated":"2017-06-25T10:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tut0003znuz7hkt7h5s","content":"<p>要了解 iOS 上的音视频相关的内容，首先需要了解的就是 <code>AVFoundation</code> 这个框架。</p>\n<p>下图是 <code>AVFoundation</code> 框架大的层级结构：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/AVF1.png\" alt=\"图一\"></p>\n<p>在 <code>AVFoundation</code> 框架中，最主要的表示媒体的类就是 <code>AVAsset</code>，甚至可以认为 <code>AVFoundation</code> 框架的大部分能力都是围绕着 <code>AVAsset</code> 展开的。</p>\n<p>一个 <code>AVAsset</code> 实例表示的是一份或多份音视频数据（audio and video tracks）的集合，它描述的是这个集合作为一个整体对象的一些属性，比如：标题、时长、大小等，而不与具体的数据格式绑定。通常，在实际使用时我们可能会基于某个 URL 创建对应的媒体资源对象（AVURLAsset），或者直接创建 compositions（AVComposition），这些类都是 <code>AVAsset</code> 的子类。</p>\n<p>一个 <code>AVAsset</code> 中的每一份音频或视频数据都称为一个<strong>轨道（track）</strong>。在最简单的情况下，一个媒体文件中可能只有两个轨道，一个音频轨道，一个视频轨道。而复杂的组合中，可能包含多个重叠的音频轨道和视频轨道。此外  <code>AVAsset</code> 也可能包含元数据<strong>（metadata）</strong>。</p>\n<p>在 <code>AVFoundation</code> 中另一个非常重要的概念是，初始化一个 <code>AVAsset</code> 或者一个 <code>AVAssetTrack</code> 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。</p>\n<p>我们可以从一个文件或者用户的相册中来创建 asset。获得一个视频 asset 时，我们可以从中提出静态图，对其进行转码，裁剪器内容。</p>\n<h4 id=\"创建-Asset\"><a href=\"#创建-Asset\" class=\"headerlink\" title=\"创建 Asset\"></a>创建 Asset</h4><p>当使用一个 URL 来创建 asset 时，可以用 <code>AVURLAsset</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A URL that identifies an audiovisual asset such as a movie file#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVURLAsset <span class=\"token operator\">*</span>anAsset <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVURLAsset alloc<span class=\"token punctuation\">]</span> initWithURL<span class=\"token punctuation\">:</span>url options<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"设置-Asset-选项\"><a href=\"#设置-Asset-选项\" class=\"headerlink\" title=\"设置 Asset 选项\"></a>设置 Asset 选项</h4><p>可以看到当我们创建一个 <code>AVURLAsset</code> 时，是可以设置一个对象的 options 的，这里可选的设置项包括：</p>\n<p><code>AVURLAssetPreferPreciseDurationAndTimingKey</code>，这个选项对应的值是布尔值，默认为 <code>@(NO)</code>，当设为 <code>@(YES)</code> 时表示 asset 应该提供精确的时长，并能根据时间准确地随机访问，提供这样的能力是需要开销更大的计算的。当你只是想播放视频时，你可以不设置这个选项，但是如果你想把这个 asset 添加到一个 composition（AVMutableComposition）中去做进一步编辑，你通常需要精确的随机访问，这时你最好设置这个选项为 YES。<br><code>AVURLAssetReferenceRestrictionsKey</code>，这个选项对应的值是 AVAssetReferenceRestrictions enum。有一些 asset 可以保护一些指向外部数据的引用，这个选项用来表示对外部数据访问的限制。具体含义参见 AVAssetReferenceRestrictions。<br><code>AVURLAssetHTTPCookiesKey</code>，这个选项用来设置 asset 通过 HTTP 请求发送的 HTTP cookies，当然 cookies 只能发给同站。具体参见文档。<br><code>AVURLAssetAllowsCellularAccessKey</code>，这个选项对应的值是布尔值，默认为 @(YES)。表示 asset 是否能使用移动网络资源。<br>不过要注意这几个选项适用的 iOS 版本。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A URL that identifies an audiovisual asset such as a movie file#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nNSDictionary <span class=\"token operator\">*</span>options <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span> AVURLAssetPreferPreciseDurationAndTimingKey <span class=\"token punctuation\">:</span> <span class=\"token operator\">@</span>YES <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nAVURLAsset <span class=\"token operator\">*</span>anAssetToUseInAComposition <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVURLAsset alloc<span class=\"token punctuation\">]</span> initWithURL<span class=\"token punctuation\">:</span>url options<span class=\"token punctuation\">:</span>options<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"访问用户的-Asset\"><a href=\"#访问用户的-Asset\" class=\"headerlink\" title=\"访问用户的 Asset\"></a>访问用户的 Asset</h4><p>获取用户相册的资源时，你需要借用 <code>ALAssetsLibrary</code> 的相关接口：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">ALAssetsLibrary <span class=\"token operator\">*</span>library <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>ALAssetsLibrary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span>\n<span class=\"token punctuation\">[</span>library enumerateGroupsWithTypes<span class=\"token punctuation\">:</span>ALAssetsGroupSavedPhotos usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>ALAssetsGroup <span class=\"token operator\">*</span>group<span class=\"token punctuation\">,</span> BOOL <span class=\"token operator\">*</span>stop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Within the group enumeration block, filter to enumerate just videos.</span>\n<span class=\"token punctuation\">[</span>group setAssetsFilter<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>ALAssetsFilter allVideos<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// For this example, we're only interested in the first item.</span>\n<span class=\"token punctuation\">[</span>group enumerateAssetsAtIndexes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSIndexSet indexSetWithIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n                        options<span class=\"token punctuation\">:</span><span class=\"token number\">0</span>\n                     usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>ALAsset <span class=\"token operator\">*</span>alAsset<span class=\"token punctuation\">,</span> NSUInteger index<span class=\"token punctuation\">,</span> BOOL <span class=\"token operator\">*</span>innerStop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                         <span class=\"token comment\" spellcheck=\"true\">// The end of the enumeration is signaled by asset == nil.</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>alAsset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                             ALAssetRepresentation <span class=\"token operator\">*</span>representation <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>alAsset defaultRepresentation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                             NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>representation url<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                             AVAsset <span class=\"token operator\">*</span>avAsset <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVURLAsset URLAssetWithURL<span class=\"token punctuation\">:</span>url options<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                             <span class=\"token comment\" spellcheck=\"true\">// Do something interesting with the AV asset.</span>\n                         <span class=\"token punctuation\">}</span>\n                     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span>\n                 failureBlock<span class=\"token punctuation\">:</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                     <span class=\"token comment\" spellcheck=\"true\">// Typically you should handle an error more gracefully than this.</span>\n                     <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"No groups\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"加载-Asset-来使用\"><a href=\"#加载-Asset-来使用\" class=\"headerlink\" title=\"加载 Asset 来使用\"></a>加载 Asset 来使用</h4><p>初始化一个 <code>AVAsset</code> 或者一个 <code>AVAssetTrack</code> 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。</p>\n<p>这时你可以使用 <code>AVAsynchronousKeyValueLoading</code> protocol 来获取加载 asset 的状态，并在对应的 completion handler 中做对应的处理。<code>AVAsset</code> 和 <code>AVAssetTrack</code> 都是遵循 <code>AVAsynchronousKeyValueLoading</code> protocol 的。下面是一个示例：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A URL that identifies an audiovisual asset such as a movie file#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVURLAsset <span class=\"token operator\">*</span>anAsset <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVURLAsset alloc<span class=\"token punctuation\">]</span> initWithURL<span class=\"token punctuation\">:</span>url options<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>keys <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"duration\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>asset loadValuesAsynchronouslyForKeys<span class=\"token punctuation\">:</span>keys completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    NSError <span class=\"token operator\">*</span>error <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    AVKeyValueStatus tracksStatus <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>asset statusOfValueForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"duration\"</span> error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>tracksStatus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> AVKeyValueStatusLoaded<span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> updateUserInterfaceForDuration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> AVKeyValueStatusFailed<span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> reportError<span class=\"token punctuation\">:</span>error forAsset<span class=\"token punctuation\">:</span>asset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> AVKeyValueStatusCancelled<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Do whatever is appropriate for cancelation.</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>需要注意的是：当你需要加载一个 asset 来点播，你应该加载它的 <code>tracks</code> 属性。</p>\n<h4 id=\"获取一张图片\"><a href=\"#获取一张图片\" class=\"headerlink\" title=\"获取一张图片\"></a>获取一张图片</h4><p>我们可以用 <code>copyCGImageAtTime:actualTime:error:</code> 来获得指定时间的截图。<code>AVFoundation</code> 也许无法精确地获得你指定时间的截图，所以你需要传入一个 actualTime 参数来获得截图所对应的实际时间。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAsset <span class=\"token operator\">*</span>myAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An asset#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetImageGenerator <span class=\"token operator\">*</span>imageGenerator <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetImageGenerator alloc<span class=\"token punctuation\">]</span> initWithAsset<span class=\"token punctuation\">:</span>myAsset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nFloat64 durationSeconds <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeGetSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>myAsset duration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime midpoint <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token operator\">/</span><span class=\"token number\">2.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\nCMTime actualTime<span class=\"token punctuation\">;</span>\n\nCGImageRef halfWayImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>imageGenerator copyCGImageAtTime<span class=\"token punctuation\">:</span>midpoint actualTime<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>actualTime error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>halfWayImage <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    NSString <span class=\"token operator\">*</span>actualTimeString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">CMTimeCopyDescription</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> actualTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>requestedTimeString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">CMTimeCopyDescription</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> midpoint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Got halfWayImage: Asked for %@, got %@\"</span><span class=\"token punctuation\">,</span> requestedTimeString<span class=\"token punctuation\">,</span> actualTimeString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Do something interesting with the image.</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>halfWayImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"获取一组截图\"><a href=\"#获取一组截图\" class=\"headerlink\" title=\"获取一组截图\"></a>获取一组截图</h4><p>我们可以用 <code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code> 接口来传入一组时间来获取相应的一组截图。同样的，必须保证在生成图片时对 <code>AVAssetImageGenerator</code> 实例的强引用。示例代码如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAsset <span class=\"token operator\">*</span>myAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An asset#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>imageGenerator <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetImageGenerator assetImageGeneratorWithAsset<span class=\"token punctuation\">:</span>myAsset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nFloat64 durationSeconds <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeGetSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>myAsset duration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime firstThird <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token operator\">/</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime secondThird <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token operator\">*</span><span class=\"token number\">2.0</span><span class=\"token operator\">/</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime end <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>times <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>firstThird<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>secondThird<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>imageGenerator generateCGImagesAsynchronouslyForTimes<span class=\"token punctuation\">:</span>times\n                completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>CMTime requestedTime<span class=\"token punctuation\">,</span> CGImageRef image<span class=\"token punctuation\">,</span> CMTime actualTime<span class=\"token punctuation\">,</span> AVAssetImageGeneratorResult result<span class=\"token punctuation\">,</span> NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                NSString <span class=\"token operator\">*</span>requestedTimeString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">CFBridgingRelease</span><span class=\"token punctuation\">(</span><span class=\"token function\">CMTimeCopyDescription</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> requestedTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                NSString <span class=\"token operator\">*</span>actualTimeString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">CFBridgingRelease</span><span class=\"token punctuation\">(</span><span class=\"token function\">CMTimeCopyDescription</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> actualTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Requested: %@; actual %@\"</span><span class=\"token punctuation\">,</span> requestedTimeString<span class=\"token punctuation\">,</span> actualTimeString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> AVAssetImageGeneratorSucceeded<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Do something interesting with the image.</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> AVAssetImageGeneratorFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Failed with error: %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>error localizedDescription<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> AVAssetImageGeneratorCancelled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Canceled\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们还能使用 <code>cancelAllCGImageGeneration</code> 接口来中断截图。</p>\n<h4 id=\"对视频进行裁剪和转码\"><a href=\"#对视频进行裁剪和转码\" class=\"headerlink\" title=\"对视频进行裁剪和转码\"></a>对视频进行裁剪和转码</h4><p>我们可以使用一个 <code>AVAssetExportSession</code> 实例来对视频进行裁剪或格式转换。流程如下图所示：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/AVF2.png\" alt=\"图二\"></p>\n<p><code>AVAssetExportSession</code> 实例用来控制异步的导出 asset。使用 export session 时，首先我们需要传入要导出的 asset 和对应的 preset 配置，我们可以用 <code>allExportPresets</code> 接口来查看所有可用的 preset 配置。接着，你需要设置导出的 URL 和文件类型。此外，我们还能设置导出视频文件的 metadata 以及导出的是否应该针对网络访问优化。</p>\n<p>在下面的示例代码中，我们用 <code>exportPresetsCompatibleWithAsset:</code> 接口检查可用的 preset，用 <code>outputURL</code> 和 <code>outputFileType</code> 接口设置导出 URL 和导出文件类型，通过 timeRange 设置导出时间段。此外，我们还能用 <code>shouldOptimizeForNetworkUse</code> 接口设置是否针对网络使用优化以方便秒开，用 <code>maxDuration</code>、<code>fileLengthLimit</code> 设置导入限制等等。</p>\n<p>我们用 <code>exportAsynchronouslyWithCompletionHandler:</code> 接口来开始导出。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAsset <span class=\"token operator\">*</span>anAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get an asset#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>compatiblePresets <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetExportSession exportPresetsCompatibleWithAsset<span class=\"token punctuation\">:</span>anAsset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>compatiblePresets containsObject<span class=\"token punctuation\">:</span>AVAssetExportPresetLowQuality<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    AVAssetExportSession <span class=\"token operator\">*</span>exportSession <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetExportSession alloc<span class=\"token punctuation\">]</span> initWithAsset<span class=\"token punctuation\">:</span>anAsset presetName<span class=\"token punctuation\">:</span>AVAssetExportPresetLowQuality<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    exportSession<span class=\"token punctuation\">.</span>outputURL <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A file URL#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    exportSession<span class=\"token punctuation\">.</span>outputFileType <span class=\"token operator\">=</span> AVFileTypeQuickTimeMovie<span class=\"token punctuation\">;</span>\n\n    CMTime start <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CMTime duration <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CMTimeRange range <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    exportSession<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> range<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">[</span>exportSession exportAsynchronouslyWithCompletionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>exportSession status<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> AVAssetExportSessionStatusFailed<span class=\"token punctuation\">:</span>\n                <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Export failed: %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>exportSession error<span class=\"token punctuation\">]</span> localizedDescription<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> AVAssetExportSessionStatusCancelled<span class=\"token punctuation\">:</span>\n                <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Export canceled\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>此外，我们还可以用 <code>cancelExport</code> 接口来取消导出。</p>\n<p>当我们想要覆盖已有的文件，或者向应用沙盒外写文件时，导出会失败。此外，在导出时突然来了电话、导出时应用在后台状态并且其他应用开始播放时导出也可能会失败。在这些情况下，你需要提示用户导出失败，并允许用户重新导出。</p>\n<p>参考： <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>要了解 iOS 上的音视频相关的内容，首先需要了解的就是 <code>AVFoundation</code> 这个框架。</p>\n<p>下图是 <code>AVFoundation</code> 框架大的层级结构：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/AVF1.png\" alt=\"图一\"></p>\n<p>在 <code>AVFoundation</code> 框架中，最主要的表示媒体的类就是 <code>AVAsset</code>，甚至可以认为 <code>AVFoundation</code> 框架的大部分能力都是围绕着 <code>AVAsset</code> 展开的。</p>\n<p>一个 <code>AVAsset</code> 实例表示的是一份或多份音视频数据（audio and video tracks）的集合，它描述的是这个集合作为一个整体对象的一些属性，比如：标题、时长、大小等，而不与具体的数据格式绑定。通常，在实际使用时我们可能会基于某个 URL 创建对应的媒体资源对象（AVURLAsset），或者直接创建 compositions（AVComposition），这些类都是 <code>AVAsset</code> 的子类。</p>\n<p>一个 <code>AVAsset</code> 中的每一份音频或视频数据都称为一个<strong>轨道（track）</strong>。在最简单的情况下，一个媒体文件中可能只有两个轨道，一个音频轨道，一个视频轨道。而复杂的组合中，可能包含多个重叠的音频轨道和视频轨道。此外  <code>AVAsset</code> 也可能包含元数据<strong>（metadata）</strong>。</p>\n<p>在 <code>AVFoundation</code> 中另一个非常重要的概念是，初始化一个 <code>AVAsset</code> 或者一个 <code>AVAssetTrack</code> 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。</p>\n<p>我们可以从一个文件或者用户的相册中来创建 asset。获得一个视频 asset 时，我们可以从中提出静态图，对其进行转码，裁剪器内容。</p>\n<h4 id=\"创建-Asset\"><a href=\"#创建-Asset\" class=\"headerlink\" title=\"创建 Asset\"></a>创建 Asset</h4><p>当使用一个 URL 来创建 asset 时，可以用 <code>AVURLAsset</code>：</p>\n<pre><code class=\"objectivec\">NSURL *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\n</code></pre>\n<h4 id=\"设置-Asset-选项\"><a href=\"#设置-Asset-选项\" class=\"headerlink\" title=\"设置 Asset 选项\"></a>设置 Asset 选项</h4><p>可以看到当我们创建一个 <code>AVURLAsset</code> 时，是可以设置一个对象的 options 的，这里可选的设置项包括：</p>\n<p><code>AVURLAssetPreferPreciseDurationAndTimingKey</code>，这个选项对应的值是布尔值，默认为 <code>@(NO)</code>，当设为 <code>@(YES)</code> 时表示 asset 应该提供精确的时长，并能根据时间准确地随机访问，提供这样的能力是需要开销更大的计算的。当你只是想播放视频时，你可以不设置这个选项，但是如果你想把这个 asset 添加到一个 composition（AVMutableComposition）中去做进一步编辑，你通常需要精确的随机访问，这时你最好设置这个选项为 YES。<br><code>AVURLAssetReferenceRestrictionsKey</code>，这个选项对应的值是 AVAssetReferenceRestrictions enum。有一些 asset 可以保护一些指向外部数据的引用，这个选项用来表示对外部数据访问的限制。具体含义参见 AVAssetReferenceRestrictions。<br><code>AVURLAssetHTTPCookiesKey</code>，这个选项用来设置 asset 通过 HTTP 请求发送的 HTTP cookies，当然 cookies 只能发给同站。具体参见文档。<br><code>AVURLAssetAllowsCellularAccessKey</code>，这个选项对应的值是布尔值，默认为 @(YES)。表示 asset 是否能使用移动网络资源。<br>不过要注意这几个选项适用的 iOS 版本。</p>\n<pre><code class=\"objectivec\">NSURL *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;\nNSDictionary *options = @{ AVURLAssetPreferPreciseDurationAndTimingKey : @YES };\nAVURLAsset *anAssetToUseInAComposition = [[AVURLAsset alloc] initWithURL:url options:options];\n</code></pre>\n<h4 id=\"访问用户的-Asset\"><a href=\"#访问用户的-Asset\" class=\"headerlink\" title=\"访问用户的 Asset\"></a>访问用户的 Asset</h4><p>获取用户相册的资源时，你需要借用 <code>ALAssetsLibrary</code> 的相关接口：</p>\n<pre><code class=\"objectivec\">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];\n\n// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.\n[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, BOOL *stop) {\n\n// Within the group enumeration block, filter to enumerate just videos.\n[group setAssetsFilter:[ALAssetsFilter allVideos]];\n\n// For this example, we&#39;re only interested in the first item.\n[group enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:0]\n                        options:0\n                     usingBlock:^(ALAsset *alAsset, NSUInteger index, BOOL *innerStop) {\n\n                         // The end of the enumeration is signaled by asset == nil.\n                         if (alAsset) {\n                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];\n                             NSURL *url = [representation url];\n                             AVAsset *avAsset = [AVURLAsset URLAssetWithURL:url options:nil];\n                             // Do something interesting with the AV asset.\n                         }\n                     }];\n                 }\n                 failureBlock: ^(NSError *error) {\n                     // Typically you should handle an error more gracefully than this.\n                     NSLog(@&quot;No groups&quot;);\n                 }];\n</code></pre>\n<h4 id=\"加载-Asset-来使用\"><a href=\"#加载-Asset-来使用\" class=\"headerlink\" title=\"加载 Asset 来使用\"></a>加载 Asset 来使用</h4><p>初始化一个 <code>AVAsset</code> 或者一个 <code>AVAssetTrack</code> 时并不一定意味着它已经可以立即使用，因为这需要一段时间来做计算，而这个计算可能会阻塞当前线程，所以通常你可以选用异步的方式来初始化，并通过回调来得到异步返回。</p>\n<p>这时你可以使用 <code>AVAsynchronousKeyValueLoading</code> protocol 来获取加载 asset 的状态，并在对应的 completion handler 中做对应的处理。<code>AVAsset</code> 和 <code>AVAssetTrack</code> 都是遵循 <code>AVAsynchronousKeyValueLoading</code> protocol 的。下面是一个示例：</p>\n<pre><code class=\"objectivec\">NSURL *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;\nAVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];\nNSArray *keys = @[@&quot;duration&quot;];\n\n[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() {\n\n    NSError *error = nil;\n    AVKeyValueStatus tracksStatus = [asset statusOfValueForKey:@&quot;duration&quot; error:&amp;error];\n    switch (tracksStatus) {\n        case AVKeyValueStatusLoaded:\n            [self updateUserInterfaceForDuration];\n            break;\n        case AVKeyValueStatusFailed:\n            [self reportError:error forAsset:asset];\n            break;\n        case AVKeyValueStatusCancelled:\n            // Do whatever is appropriate for cancelation.\n            break;\n   }\n}];\n</code></pre>\n<p>需要注意的是：当你需要加载一个 asset 来点播，你应该加载它的 <code>tracks</code> 属性。</p>\n<h4 id=\"获取一张图片\"><a href=\"#获取一张图片\" class=\"headerlink\" title=\"获取一张图片\"></a>获取一张图片</h4><p>我们可以用 <code>copyCGImageAtTime:actualTime:error:</code> 来获得指定时间的截图。<code>AVFoundation</code> 也许无法精确地获得你指定时间的截图，所以你需要传入一个 actualTime 参数来获得截图所对应的实际时间。</p>\n<pre><code class=\"objectivec\">AVAsset *myAsset = &lt;#An asset#&gt;];\nAVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime midpoint = CMTimeMakeWithSeconds(durationSeconds/2.0, 600);\nNSError *error;\nCMTime actualTime;\n\nCGImageRef halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&amp;actualTime error:&amp;error];\n\nif (halfWayImage != NULL) {\n\n    NSString *actualTimeString = (NSString *)CMTimeCopyDescription(NULL, actualTime);\n    NSString *requestedTimeString = (NSString *)CMTimeCopyDescription(NULL, midpoint);\n    NSLog(@&quot;Got halfWayImage: Asked for %@, got %@&quot;, requestedTimeString, actualTimeString);\n\n    // Do something interesting with the image.\n    CGImageRelease(halfWayImage);\n}\n</code></pre>\n<h4 id=\"获取一组截图\"><a href=\"#获取一组截图\" class=\"headerlink\" title=\"获取一组截图\"></a>获取一组截图</h4><p>我们可以用 <code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code> 接口来传入一组时间来获取相应的一组截图。同样的，必须保证在生成图片时对 <code>AVAssetImageGenerator</code> 实例的强引用。示例代码如下：</p>\n<pre><code class=\"objectivec\">AVAsset *myAsset = &lt;#An asset#&gt;];\n// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;\nself.imageGenerator = [AVAssetImageGenerator assetImageGeneratorWithAsset:myAsset];\n\nFloat64 durationSeconds = CMTimeGetSeconds([myAsset duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 600);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 600);\nCMTime end = CMTimeMakeWithSeconds(durationSeconds, 600);\nNSArray *times = @[NSValue valueWithCMTime:kCMTimeZero],\n                  [NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird],\n                  [NSValue valueWithCMTime:end]];\n\n[imageGenerator generateCGImagesAsynchronouslyForTimes:times\n                completionHandler:^(CMTime requestedTime, CGImageRef image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError *error) {\n\n                NSString *requestedTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, requestedTime));\n                NSString *actualTimeString = (NSString *)\n                    CFBridgingRelease(CMTimeCopyDescription(NULL, actualTime));\n                NSLog(@&quot;Requested: %@; actual %@&quot;, requestedTimeString, actualTimeString);\n\n                if (result == AVAssetImageGeneratorSucceeded) {\n                    // Do something interesting with the image.\n                }\n\n                if (result == AVAssetImageGeneratorFailed) {\n                    NSLog(@&quot;Failed with error: %@&quot;, [error localizedDescription]);\n                }\n                if (result == AVAssetImageGeneratorCancelled) {\n                    NSLog(@&quot;Canceled&quot;);\n                }\n}];\n</code></pre>\n<p>我们还能使用 <code>cancelAllCGImageGeneration</code> 接口来中断截图。</p>\n<h4 id=\"对视频进行裁剪和转码\"><a href=\"#对视频进行裁剪和转码\" class=\"headerlink\" title=\"对视频进行裁剪和转码\"></a>对视频进行裁剪和转码</h4><p>我们可以使用一个 <code>AVAssetExportSession</code> 实例来对视频进行裁剪或格式转换。流程如下图所示：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/AVF2.png\" alt=\"图二\"></p>\n<p><code>AVAssetExportSession</code> 实例用来控制异步的导出 asset。使用 export session 时，首先我们需要传入要导出的 asset 和对应的 preset 配置，我们可以用 <code>allExportPresets</code> 接口来查看所有可用的 preset 配置。接着，你需要设置导出的 URL 和文件类型。此外，我们还能设置导出视频文件的 metadata 以及导出的是否应该针对网络访问优化。</p>\n<p>在下面的示例代码中，我们用 <code>exportPresetsCompatibleWithAsset:</code> 接口检查可用的 preset，用 <code>outputURL</code> 和 <code>outputFileType</code> 接口设置导出 URL 和导出文件类型，通过 timeRange 设置导出时间段。此外，我们还能用 <code>shouldOptimizeForNetworkUse</code> 接口设置是否针对网络使用优化以方便秒开，用 <code>maxDuration</code>、<code>fileLengthLimit</code> 设置导入限制等等。</p>\n<p>我们用 <code>exportAsynchronouslyWithCompletionHandler:</code> 接口来开始导出。</p>\n<pre><code class=\"objectivec\">AVAsset *anAsset = &lt;#Get an asset#&gt;;\nNSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:anAsset];\nif ([compatiblePresets containsObject:AVAssetExportPresetLowQuality]) {\n    AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:anAsset presetName:AVAssetExportPresetLowQuality];\n\n    exportSession.outputURL = &lt;#A file URL#&gt;;\n    exportSession.outputFileType = AVFileTypeQuickTimeMovie;\n\n    CMTime start = CMTimeMakeWithSeconds(1.0, 600);\n    CMTime duration = CMTimeMakeWithSeconds(3.0, 600);\n    CMTimeRange range = CMTimeRangeMake(start, duration);\n    exportSession.timeRange = range;\n\n    [exportSession exportAsynchronouslyWithCompletionHandler:^{\n\n        switch ([exportSession status]) {\n            case AVAssetExportSessionStatusFailed:\n                NSLog(@&quot;Export failed: %@&quot;, [[exportSession error] localizedDescription]);\n                break;\n            case AVAssetExportSessionStatusCancelled:\n                NSLog(@&quot;Export canceled&quot;);\n                break;\n            default:\n                break;\n        }\n    }];\n}\n</code></pre>\n<p>此外，我们还可以用 <code>cancelExport</code> 接口来取消导出。</p>\n<p>当我们想要覆盖已有的文件，或者向应用沙盒外写文件时，导出会失败。此外，在导出时突然来了电话、导出时应用在后台状态并且其他应用开始播放时导出也可能会失败。在这些情况下，你需要提示用户导出失败，并允许用户重新导出。</p>\n<p>参考： <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n"},{"title":"AVAudioFoundation(4)：音视频录制","date":"2017-07-04T00:51:56.000Z","_content":"\n本文转自：[AVAudioFoundation(4)：音视频录制 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n采集设备的音视频时，我们需要组装各路数据，这时可以使用 AVCaptureSession 对象来协调。\n\n- 一个 `AVCaptureDevice` 对象表示输入设备，比如摄像头或者麦克风。\n- 一个 `AVCaptureInput` 具体子类的实例可以用来配置输出设备的端口。\n- 一个 `AVCaptureOutput` 具体子类的实例可以用来将音视频数据输出到一个视频文件或静态图片。\n- 一个 `AVCaptureSession` 实例用来协调输入输出的数据流。\n在录制视频时，为了让用户看到预览效果，我们可以使用 `AVCaptureVideoPreviewLayer`。\n\n下图展示了通过一个 `capture session` 实例来协调多路输入输出数据：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B61.png)\n\n对于大多数应用场景，这些细节已经足够我们用了。但是对于有些操作，比如当我们想要监测一个音频通道的强度，我们需要了解不同的输入设备的端口对应的对象，以及这些端口和输出是如何连接起来的。\n\n在音视频录制时，输入和输出之间的连接是用 `AVCaptureConnection` 来表示的。输入方(`AVCaptureInput`)包含一个或多个输入端口(`AVCaptureInputPort`)，输出端(`AVCaptureOutput`)可以从一个或多个数据源接收数据，比如一个 `AVCaptureMovieFileOutput` 就可以同时接收视频和音频数据。\n\n当你往一次录制 `session` 中添加一个输入或输出时，这个 `session` 会生成所有兼容的输入和输出端口间的连接，由 `AVCaptureConnection` 对象表示。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B62.png)\n\n\nYou can use a capture connection to enable or disable the flow of data from a given input or to a given output. You can also use a connection to monitor the average and peak power levels in an audio channel.\n\n我们可以用 `connetion` 对象来控制输入输出端之间的数据流的断开或连接，我们还能用它来监控 `audio` 通道的平均值和峰值。\n\n## 使用 Capture Session 来协调数据流\n\n`AVCaptureSession` 是我们用来管理数据捕获的核心协调者，我们用它来协调音视频输入和输出端的数据流。我们可以将我们需要的捕获设备添加到 `session` 中，然后用 `startRunning` 接口启动数据流，用 `stopRunning` 停止数据流。\n\n```objectivec\nAVCaptureSession *session = [[AVCaptureSession alloc] init];\n// Add inputs and outputs.\n[session startRunning];\n```\n\n#### 配置 Session\n\n我们可以给 `session` 设置我们需要的图像质量和分辨率。以下是其中的几个配置选项：\n\n- AVCaptureSessionPresetHigh，高分辨率，具体值取决于设备能提供的最高分辨率。\n- AVCaptureSessionPresetMedium，中等分辨率，具体值取决于设备。\n- AVCaptureSessionPresetLow，低分辨率，具体指取决于设备。\n- AVCaptureSessionPreset640x480，分辨率为 640x480，常称为 480P。\n- AVCaptureSessionPreset1280x720，分辨率为 1280x720，常称为 720P。\n- AVCaptureSessionPresetPhoto，全尺寸相片的分辨率，这个选项不支持输出视频。\n如果要使用某种分辨率选项，我们需要先测试一下设备是否支持：\n\n```objectivec\nif ([session canSetSessionPreset:AVCaptureSessionPreset1280x720]) {\n    session.sessionPreset = AVCaptureSessionPreset1280x720;\n}\nelse {\n    // Handle the failure.\n}\n```\n如果想对 `session` 的配置参数做更细粒度的控制，或者想修改已经在运行状态的 `session` 的配置参数，我们需要在 `beginConfiguration` 和 `commitConfiguration` 方法直接做修改。这两个方法的配合，可以使得我们队设备的修改是以一个 `group` 的方式提交，从而尽量避免视觉或者状态上的不一致性。在调用了 `beginConfiguration` 之后，我们可以增加或删除输出端，修改 `sessionPreset` 值，单独配置视频捕获的输入或输出参数。知道我们调用了 `commitConfiguration`，这些修改采用被提交并一起应用。\n\n```objectivec\n[session beginConfiguration];\n// Remove an existing capture device.\n// Add a new capture device.\n// Reset the preset.\n[session commitConfiguration];\n```\n\n#### 监控 Session 状态\n\n录制过程中 `session` 会发出通知来告知其对应的状态，比如 `session` 开始、结束、被打断。我们可以从 `AVCaptureSessionRuntimeErrorNotification` 来接收 `session` 运行时的错误。我们也可以差选 `session` 的运行时属性来获取其状态是在运行中还是被打断。此外，这些属性都是支持 `KVO` 监测的，并且通知会被发送到主线程。\n\n## 使用 AVCaptureDevice 来表示输入设备\n\n`AVCaptureDevice` 是由我们现实中物理的提供输入数据（比如音频或视频输入）的设备抽象而来，每个 `AVCaptureDevice` 对象都对应着一个输入设备，比如我们常见的前置摄像头、后置摄像头、麦克风。它们采集的数据将会输出给 `AVCaptureSession` 实例。\n\n我们可以使用 `AVCaptureDevice` 的 `devices` 和 `devicesWithMediaType:` 类方法来检查哪些是当前可用的设备。如果需要，我们还可以获取设备支持哪些功能。当前可用的设备列表是会动态变化的，有些设备会因为被别的应用使用而变得不可用，有的设备也有可能突然就可用了，所以我们需要注册 `AVCaptureDeviceWasConnectedNotification` 和 `AVCaptureDeviceWasDisconnectedNotification` 通知来感知当前可用设备的变化情况。\n\n我们可以使用 `capture input` 来想向一个 `AVCaptureSession` 中添加输入设备。\n\n\n#### 设备特性\n\n我们可以查询采集设备的不同特性。比如，我们可以使用 hasMediaType: 接口来判断采集设备是否支持某种媒体类型，也可以使用 supportsAVCaptureSessionPreset: 接口来判断采集设备是否支持预设的 session preset。我们还能获取设备的位置、本地化命名等信息以便于展示给用户。\n\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B63.png)\n\n\n下面的示例代码展示了如何遍历设备，并打印设备名：\n\n```objectivec\nNSArray *devices = [AVCaptureDevice devices];\nfor (AVCaptureDevice *device in devices) {\n\n    NSLog(@\"Device name: %@\", [device localizedName]);\n    if ([device hasMediaType:AVMediaTypeVideo]) {\n        if ([device position] == AVCaptureDevicePositionBack) {\n            NSLog(@\"Device position : back\");\n        }\n        else {\n            NSLog(@\"Device position : front\");\n        }\n    }\n}\n```\n\n此外，你还能查出设备的 model ID 和 unique ID。\n\n## 设备录制设置\n\n不同的设备有不同的能力，比如有些设备支持不同的对焦或刷新模式。下面的代码展示了如何找到一个支持手电筒以及预设的 `preset` 的设备。\n\n```objectivec\nNSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];\nNSMutableArray *torchDevices = [[NSMutableArray alloc] init];\n\nfor (AVCaptureDevice *device in devices) {\n    [if ([device hasTorch] &&\n         [device supportsAVCaptureSessionPreset:AVCaptureSessionPreset640x480]) {\n        [torchDevices addObject:device];\n    }\n}\n```\n\n如果你找到多个设备，你可以向用户展示设备的 `localizedName` 来让用户选择他们需要的设备。在使用对应的设备时，我们可以设置设备的各种工作模式，但是有一点需要注意的是在设置前需要对设备加锁。\n\n#### 聚焦模式\n\n目前支持的聚焦模式有以下几种：\n\n- AVCaptureFocusModeLocked：聚焦点固定。通常以拍摄场景的中点作为焦点。\n- AVCaptureFocusModeAutoFocus：自动聚焦。这种模式可以让用户选择一件事物来进行对焦，即使对于的位置不是拍摄场景的中点。\n- AVCaptureFocusModeContinuousAutoFocus：相机将持续自动对焦。\n我们可以使用 isFocusModeSupported: 接口来检查设备是否支持相应的聚焦模式，然后设置对应的 focusMode 属性。\n\n我们还能用 `focusPointOfInterestSupported` 来检查设备是否支持指定焦点，如果支持，我们就可以设置对应的 `focusPointOfInterest`属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。\n\n我们可以访问 `adjustingFocus` 属性来获知相机是否正在对焦，这个属性是支持 KVO 的，所以我们可以监测它来获知对焦状态的变化。\n\n如果你修改过了相机的对焦模式相关的设置，你可以用下面的代码将其恢复到默认状态：\n\n```objectivec\nif ([currentDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {\n    CGPoint autofocusPoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setFocusPointOfInterest:autofocusPoint];\n    [currentDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus];\n}\n```\n\n#### 曝光模式\n\n目前支持的曝光模式有以下几种：\n\n- AVCaptureExposureModeLocked，曝光等级锁定。\n- AVCaptureExposureModeAutoExpose，相机自动根据情况调整一次曝光等级，然后将曝光模式切换到 AVCaptureExposureModeLocked。\n- AVCaptureExposureModeContinuousAutoExposure，相机随时根据情况调整曝光等级。\n- AVCaptureExposureModeCustom，用户自定义曝光等级。\n我们可以通过 isExposureModeSupported: 来检查设备是否支持对应的模式，然后设置对应的 exposureMode 属性。\n\n我们还能用 `exposurePointOfInterestSupported` 来检查设备是否支持指定曝光点，如果支持，我们就可以设置对应的 `exposurePointOfInterest` 属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。\n\n我们可以访问 `adjustingExposure` 属性来获知相机是否正在改变曝光设置，这个属性是支持 KVO 的，所以我们可以监测它来获知曝光状态的变化。\n\n如果你修改过了相机的曝光模式相关的设置，你可以用下面的代码将其恢复到默认状态：\n\n```objectivec\nif ([currentDevice isExposureModeSupported:AVCaptureExposureModeContinuousAutoExposure]) {\n    CGPoint exposurePoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setExposurePointOfInterest:exposurePoint];\n    [currentDevice setExposureMode:AVCaptureExposureModeContinuousAutoExposure];\n}\n```\n\n\n#### 闪光灯模式\n\n目前支持的闪光灯模式有如下几种：\n\n- AVCaptureFlashModeOff，不会闪光。\n- AVCaptureFlashModeOn，会闪光。\n- AVCaptureFlashModeAuto，根据具体情况决定是否闪光。\n我们可以通过 `hasFlash` 检查设备是否有闪光灯，可以通过 `isFlashModeSupported:` 检查设备是否支持对应的模式，通过 `flashMode` 设置对应的模式。\n\n#### 手电筒模式\n\n在手电筒模式下，闪光灯会以低耗电量模式持续打开来为图像录制来照明。目前支持的模式有以下几种：\n\n- AVCaptureTorchModeOff，关闭。\n- AVCaptureTorchModeOn，开启。\n- AVCaptureTorchModeAuto，自动。\n我们可以通过 `hasTorch` 检查设备是否有闪光灯，可以通过 `isTorchModeSupported:` 检查设备是否支持对应的手电筒模式，通过 `torchMode` 设置对应的模式。\n\n\n#### 视频防抖\n\n视频防抖主要依赖于硬件，虽然如此，也不是所有的视频格式和分辨率都能支持。此外，开启防抖也会带来为视频录制带来一定的延迟。我们可以通过 `videoStabilizationEnabled` 来检查是否启动了防抖，通过 `enablesVideoStabilizationWhenAvailable` 来允许应用在条件支持的情况下自动开启防抖。\n\n#### 白平衡\n\n目前支持面几种白平衡模式：\n\n- AVCaptureWhiteBalanceModeLocked，固定模式。\n- AVCaptureWhiteBalanceModeAutoWhiteBalance，自动模式。相机根据情况调整一次白平衡，然后切换至 AVCaptureWhiteBalanceModeLocked 模式。\n- AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance，相机随时根据情况调整白平衡。\n我们可以通过 `isWhiteBalanceModeSupported:` 检查是否支持给定的模式，然后通过 `whiteBalanceMode` 设置对应模式。\n\n我们可以访问 `adjustingWhiteBalance` 属性来获知相机是否正在改变白平衡设置，这个属性是支持 KVO 的，所以我们可以监测它来获知白平衡状态的变化。\n\n#### 设置方向\n\n我们可以通过 `AVCaptureConnection` 实例来设置想要在 AVCaptureOutput(AVCaptureMovieFileOutput, AVCaptureStillImageOutput, AVCaptureVideoDataOutput) 获得的图像方向。\n\n我们通过 `isVideoOrientationSupported` 检查是否支持改变视频方向，通过 `videoOrientation` 设置方向。\n\n下面是示例代码：\n\n```objectivec\nAVCaptureConnection *captureConnection = <#A capture connection#>;\nif ([captureConnection isVideoOrientationSupported]) {\n    AVCaptureVideoOrientation orientation = AVCaptureVideoOrientationLandscapeLeft;\n    [captureConnection setVideoOrientation:orientation];\n}\n```\n\n#### 配置设备\n\n在设置设备的相关属性前，我们需要使用 lockForConfiguration: 来获取一个对设备操作的锁，这样可以避免你在使用设备时被别的应用更改了设置而导致不兼容等问题。\n\n```objectivec\nif ([device isFocusModeSupported:AVCaptureFocusModeLocked]) {\n    NSError *error = nil;\n    if ([device lockForConfiguration:&error]) {\n        device.focusMode = AVCaptureFocusModeLocked;\n        [device unlockForConfiguration];\n    }\n    else {\n        // Respond to the failure as appropriate.\n            }\n```\n\n你应该只在希望设备的设置不能被修改时保持设备锁，不正确的持有设备锁可能会影响其他程序的录制质量。\n\n#### 设备切换\n\n有时候你可能需要在使用时切换设备，比如切换前后摄像头。这时为了避免卡顿或者闪屏，我们可以重新配置一个正在执行的 `session`，但是我们在修改前后需要分别使用 `beginConfiguration` 和 `commitConfiguration:`\n\n```objectivec\nAVCaptureSession *session = <#A capture session#>;\n[session beginConfiguration];\n\n[session removeInput:frontFacingCameraDeviceInput];\n[session addInput:backFacingCameraDeviceInput];\n\n[session commitConfiguration];\n```\n\n当最外的 `commitConfiguration` 被调用时，所有的配置修改会被一起提交，这样可以保证平滑的切换。\n\n## 使用 Capture Inputs 来给一个 Session 添加设备\n\n我们可以用 `AVCaptureDeviceInput` 来给一个 `session` 添加设备。`AVCaptureDeviceInput` 是用来管理设备的端口。\n\n```objectivec\nNSError *error;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];\nif (!input) {\n    // Handle the error appropriately.\n}\n```\n\n我们用 `addInput:` 来添加设备。我们还可以在添加前用 `canAddInput:` 来检查一下。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nAVCaptureDeviceInput *captureDeviceInput = <#Get a capture device input#>;\nif ([captureSession canAddInput:captureDeviceInput]) {\n    [captureSession addInput:captureDeviceInput];\n}\nelse {\n    // Handle the failure.\n}\n```\n\n`AVCaptureInput` 声明一个或者多个媒体数据流。例如，输入设备可以同时提供音频和视频数据。输入提供的每个媒体流都被一个 `AVCaptureInputPort` 所表示。一个会话使用 `AVCaptureConnection` 对象来定义一组 `AVCaptureInputPort` 对象和一个 `AVCaptureOutput` 之间的映射。\n\n## 使用 Capture Outputs 来从一个 Session 获取输出\n\n要从一个 `capture session` 中获取输出，我们需要给它添加一个或多个输出实例，输出实例都是 `AVCaptureOutput` 的子类。比如：\n\n- AVCaptureMovieFileOutput，输出电影文件。\n- AVCaptureVideoDataOutput，当我们需要处理录制得到的视频帧时（比如创建自定义的渲染层），可以用这个。\n- AVCaptureAudioDataOutput，当我们需要处理录制到的音频数据时，可以用这个。\n- AVCaptureStillImageOutput，当我们需要获取静态图片以及对应的 metadata 时，可以用这个。\n我们可以使用 `addOutput:` 向 `session` 中添加输出实例，我们也可以在加之前，通过 `canAddOutput:` 来检测要添加的输出实例是否是兼容的。我们可以往一个正在运行状态的 `session` 中添加输出实例。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nAVCaptureMovieFileOutput *movieOutput = <#Create and configure a movie output#>;\nif ([captureSession canAddOutput:movieOutput]) {\n    [captureSession addOutput:movieOutput];\n} else {\n    // Handle the failure.\n}\n```\n\n## 保存电影文件\n\n使用 `AVCaptureMovieFileOutput` 将音视频数据保存到文件中时，我们可以做一些输出设置，比如最大录制时长、最大文件尺寸等等。我们还能够在硬盘空间不够时停止录制。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = [[AVCaptureMovieFileOutput alloc] init];\nCMTime maxDuration = <#Create a CMTime to represent the maximum duration#>;\naMovieFileOutput.maxRecordedDuration = maxDuration;\naMovieFileOutput.minFreeDiskSpaceLimit = <#An appropriate minimum given the quality of the movie format and the duration#>;\n```\n\n录制时输出的分辨率和码率是根据 capture session 的 sessionPreset 属性而定的。其中视频的编码类型是 H.264，音频的编码类型是 AAC，这个也是由不同的设备类型决定的。\n\n#### 开始录制\n\n我们通过 `startRecordingToOutputFileURL:recordingDelegate:` 来开始录制，这时你需要提供一个文件 `URL` 和一个 `delegate`。这个 `URL` 不能指向已存在的文件，因为这里的音视频输出不会去覆盖已有的资源。同时我们也必须要有对这个 `URL` 指向位置的写权限。这里的 `delegate` 必须遵循 `AVCaptureFileOutputRecordingDelegate` 协议，而且必须实现 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = <#Get a movie file output#>;\nNSURL *fileURL = <#A file URL that identifies the output location#>;\n[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:<#The delegate#>];\n```\n\n在 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法中，`delegate` 可以将最终输出的文件写入相册，同时也需要检查和处理各种可能出现的错误。\n\n#### 确保文件写入成功\n\n要确保文件是否成功，我们可以在 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法中检查 `AVErrorRecordingSuccessfullyFinishedKey`。\n\n```objectivec\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error {\n\n    BOOL recordedSuccessfully = YES;\n    if ([error code] != noErr) {\n        // A problem occurred: Find out if the recording was successful.\n        id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey];\n        if (value) {\n            recordedSuccessfully = [value boolValue];\n        }\n    }\n    // Continue as appropriate...\n```\n我们需要检查 `error` 的 `userInfo` 的 `AVErrorRecordingSuccessfullyFinishedKey` 对应的值，因为有时候即使我们收到了错误，文件也可能是保存成功的，这时候，有可能是触及了我们设置的某些限制，比如 `AVErrorMaximumDurationReached` 或者 `AVErrorMaximumFileSizeReached`，其他的原因还有：\n\n- AVErrorDiskFull，磁盘空间不够。\n- AVErrorDeviceWasDisconnected，录制设备断开连接。\n- AVErrorSessionWasInterrupted，录制 `session` 被打断了，比如来电话了。\n\n#### 给文件添加 Metadata\n\n我们可以在任何时候给录制的文件设置 `metadata`，即使是在录制过程中。文件的 `metadata` 是由一系列的 `AVMetadataItem` 对象表示，我们可以用 `AVMutableMetadataItem` 来创建我们自己的 `metadata`。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = <#Get a movie file output#>;\nNSArray *existingMetadataArray = aMovieFileOutput.metadata;\nNSMutableArray *newMetadataArray = nil;\nif (existingMetadataArray) {\n    newMetadataArray = [existingMetadataArray mutableCopy];\n} else {\n    newMetadataArray = [[NSMutableArray alloc] init];\n}\n\nAVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];\nitem.keySpace = AVMetadataKeySpaceCommon;\nitem.key = AVMetadataCommonKeyLocation;\n\nCLLocation *location - <#The location to set#>;\nitem.value = [NSString stringWithFormat:@\"%+08.4lf%+09.4lf/\" location.coordinate.latitude, location.coordinate.longitude];\n\n[newMetadataArray addObject:item];\n\naMovieFileOutput.metadata = newMetadataArray;\n```\n\n#### 处理视频帧\n`AVCaptureVideoDataOutput`\n 对象使用代理来对外暴露视频帧，我们通过 `setSampleBufferDelegate:queue:`\n 来设置代理。除了设置代理以外，还需要设置一个 `serial queue` 来供代理调用，这里必须使用 `serial queue` 来保证传给 `delegate` 的帧数据的顺序正确。我们可以使用这个 queue 来分发和处理视频帧，这里可以参考一下例子 [SquareCam](https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190)。\n`captureOutput:didOutputSampleBuffer:fromConnection:`\n 中输出的视频帧数据是用 `CMSampleBufferRef`\n 来表示的。默认情况下，这个 `buffer` 的数据格式来自于相机能最高效处理的格式。我们可以通过 `videoSettings`\n 来设置一个自定义的输出格式，这个值是一个字典，现在支持的键包括 `kCVPixelBufferPixelFormatTypeKey`\n。推荐的 `pixel formats` 可以通过 `availableVideoCVPixelFormatTypes`\n 属性获得，此外还能通过 `availableVideoCodecTypes`\n 获得支持编码类型。`Core Graphics` 和 `OpenGL` 都能很好地处理 `BGRA`\n 格式。\n\n```objectivec\nAVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];NSDictionary *newSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};videoDataOutput.videoSettings = newSettings; // discard if the data output queue is blocked (as we process the still image[videoDataOutput setAlwaysDiscardsLateVideoFrames:YES];)// create a serial dispatch queue used for the sample buffer delegate as well as when a still image is captured// a serial dispatch queue must be used to guarantee that video frames will be delivered in order// see the header doc for setSampleBufferDelegate:queue: for more informationvideoDataOutputQueue = dispatch_queue_create(\"VideoDataOutputQueue\", DISPATCH_QUEUE_SERIAL);[videoDataOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];AVCaptureSession *captureSession = <#The Capture Session#>;if ([captureSession canAddOutput:videoDataOutput]) { [captureSession addOutput:videoDataOutput];}\n```\n\n\n#### 处理视频的性能问题\n\n对于我们的应用，设置够用的分辨率就好了，不要太高，那样性能会降低。\n\n我们需要确保，在 `captureOutput:didOutputSampleBuffer:fromConnection:` 中处理视频帧的时间开销不要超过分配给一帧的处理时长。如果这里处理的太长，那么 `AV Foundation` 将会停止发送视频帧给代理，也会停止发给其他输出端，比如 `preview layer`。\n\n你可以使用 `AVCaptureVideoDataOutput` 的 `minFrameDuration` 属性来确保你有足够的时间来处理一帧。同时，我们还可以设置 `alwaysDiscardsLateVideoFrames` 为 YES 来确保晚到的帧会被丢掉来避免延迟。如果你不介意延迟，而更想要处理更多的帧，那就设置这个值为 NO，但是这并不意味着不会丢帧，只是不会被那么早或那么高效的丢掉。\n\n## 截取静态图片\n\n当我们想要截取带着 `metadata` 的静态图片时，我们可以用 `AVCaptureStillImageOutput`。截出的图的分辨率依赖于 `session` 的 `preset` 和具体的设备。\n\n#### 像素和编码类型\n\n不同的类型支持不同的图片格式。我们可以用 `availableImageDataCVPixelFormatTypes` 和 `availableImageDataCodecTypes` 来检查当前的设备支持的像素类型和编码类型。然后，我们可以通过设置 `outputSettings` 属性指定图片的格式。\n\n```objectivec\nAVCaptureStillImageOutput *stillImageOutput = [[AVCaptureStillImageOutput alloc] init];\nNSDictionary *outputSettings = @{AVVideoCodecKey: AVVideoCodecJPEG};\n[stillImageOutput setOutputSettings:outputSettings];\n````\n\n如果我们要截取一张 JPEG 图片，你最好不要指定你自己的压缩格式，相反，你需要做的是让 `AVCaptureStillImageOutput` 帮你做压缩，因为它使用硬件加速来压缩。如果这时你需要图像的数据，可以用 `jpegStillImageNSDataRepresentation:` 来获取对应的 `NSData` 对象，这个数据是未经压缩的，甚至你都可以修改它。\n\n#### 捕获图像\n\n当截图时，我们使用 `captureStillImageAsynchronouslyFromConnection:completionHandler:`方法，其中的第一个参数是对应的 `connection`，这是你需要查找一下哪个 `connection` 的输出端口是在手机视频：\n\n```objectivec\nAVCaptureConnection *videoConnection = nil;\nfor (AVCaptureConnection *connection in stillImageOutput.connections) {\n    for (AVCaptureInputPort *port in [connection inputPorts]) {\n        if ([[port mediaType] isEqual:AVMediaTypeVideo] ) {\n            videoConnection = connection;\n            break;\n        }\n    }\n    if (videoConnection) { break; }\n}\n```\n\n第二个参数是一个 `block` 回调，其中带回两个参数：一个包含图像数据的 `CMSampleBuffer`，一个 `NSError`。这个 `sample buffer` 中可能包含着 `metadata`，比如一个 EXIF 字典作为附属信息。我们可以去修改附属信息，但是需要注意针对 JPEG 图像的像素和编码上的优化。\n\n```objectivec\n[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageSampleBuffer, NSError *error) {\n    CFDictionaryRef exifAttachments =\n        CMGetAttachment(imageSampleBuffer, kCGImagePropertyExifDictionary, NULL);\n    if (exifAttachments) {\n        // Do something with the attachments.\n    }\n    // Continue as appropriate.\n}];\n```\n\n## 预览\n\n#### 视频预览\n\n我们可以用 `AVCaptureVideoPreviewLayer` 来给用户提供预览，我们不需要任何 `output` 对象来展示预览。此外，我们可以使用 `AVCaptureVideoDataOutput` 来在给用户预览之前获取到图像像素级别的数据。\n\nUnlike a capture output, a video preview layer maintains a strong reference to the session with which it is associated. This is to ensure that the session is not deallocated while the layer is attempting to display video. This is reflected in the way you initialize a preview layer:\n\n不像 `capture output`，一个 `video preview layer` 会持有一个关联 `session` 的强引用。这样来防止 `layer` 在展示预览时而 `session` 被释放引起问题。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nCALayer *viewLayer = <#Get a layer from the view in which you want to present the preview#>;\n\nAVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:captureSession];\n[viewLayer addSublayer:captureVideoPreviewLayer];\n```\n\n一般来说，`preview layer` 和其他 `CALayer` 对象一样，我们可以缩放它的图像，执行变换，旋转。一个不同的地方是，我们需要设置 `layer` 的 `orientation` 属性来指定它改如何旋转从相机获得的图像。此外，我们可以用 `supportsVideoMirroring` 来测试设备是否支持视频镜面效果(左右翻转)，我们可以设置 `videoMirrored` 来配置是否开启镜面效果，即使 `automaticallyAdjustsVideoMirroring` 被设置为默认的 YES 也没问题(这个值是在配置 `session` 时被自动设置的)。\n\n#### 视频重力模式\n\n我们可以通过 `videoGravity`\n 属性设置视频重力模式，比如：\n- AVLayerVideoGravityResizeAspect\n，保持视频的宽高比；不一定完全填充，可能留黑边；不裁剪视频，。\n- AVLayerVideoGravityResizeAspectFill\n，保持视频的宽高比；完全填充，不留黑边；可能裁剪视频。\n- AVLayerVideoGravityResize\n，不保持视频宽高比，可能扭曲画面；完全填充；不裁剪视频。\n\n#### 使用预览时的点击聚焦\n\n需要注意的是，在实现点击聚焦时必须考虑到该层的预览方向和重力，并考虑预览变为镜像显示的可能性。可以参考实例项目：[AVCam-iOS: Using AVFoundation to Capture Images and Movies](https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112)。\n\n## 显示音频等级\n\nTo monitor the average and peak power levels in an audio channel in a capture connection, you use an AVCaptureAudioChannel object. Audio levels are not key-value observable, so you must poll for updated levels as often as you want to update your user interface (for example, 10 times a second).\n\n要监测 capture connection 中音频通道的平均强度和峰值强度，我们可以用 `AVCaptureAudioChannel`。音频等级是不支持 KVO 监测的，所以当我们想更新用户界面时，我们需要去查询。\n\n```objectivec\nAVCaptureAudioDataOutput *audioDataOutput = <#Get the audio data output#>;\nNSArray *connections = audioDataOutput.connections;\nif ([connections count] > 0) {\n    // There should be only one connection to an AVCaptureAudioDataOutput.\n    AVCaptureConnection *connection = [connections objectAtIndex:0];\n\n    NSArray *audioChannels = connection.audioChannels;\n\n    for (AVCaptureAudioChannel *channel in audioChannels) {\n        float avg = channel.averagePowerLevel;\n        float peak = channel.peakHoldLevel;\n        // Update the level meter user interface.\n    }\n}\n```\n## 一个完整示例\n\n这里的示例代码将展示如何获取视频并转化为 UIImage。大概包括下面几步：\n\n- 创建一个 AVCaptureSession 对象来协调输入设备到输出的数据流。\n- 找到我们想要的 AVCaptureDevice。\n- 为 device 创建一个 AVCaptureDeviceInput 对象。\n- 创建 AVCaptureVideoDataOutput 来输出视频帧。\n- 实现 AVCaptureVideoDataOutput 的 delegate 方法来处理视频帧。\n- 在实现的代理方法中将 CMSampleBuffer 转为 UIImage。\n代码如下：\n\n```objectivec\n// 创建并配置 Capture Session：\nAVCaptureSession *session = [[AVCaptureSession alloc] init];\nsession.sessionPreset = AVCaptureSessionPresetMedium;\n\n// 创建和配置 Device 和 Device Input：\nAVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n\nNSError *error = nil;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];\nif (!input) {\n    // Handle the error appropriately.\n}\n[session addInput:input];\n\n// 创建和配置 Video Data Output：\nAVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];\n[session addOutput:output];\noutput.videoSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};\noutput.minFrameDuration = CMTimeMake(1, 15);\n// 设置 Video Data Output 的 delegate 和处理队列：\ndispatch_queue_t queue = dispatch_queue_create(\"MyQueue\", NULL);\n[output setSampleBufferDelegate:self queue:queue];\n```\n\n代理方法实现：\n\n```objectivec\n- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {\n\n    UIImage *image = imageFromSampleBuffer(sampleBuffer);\n    // Add your code here that uses the image.\n}\n```\n\n开始录制：\n\n录制前，还需要注意申请相机权限：\n\n```objectivec\n// 申请权限：\nNSString *mediaType = AVMediaTypeVideo;\n\n[AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {\n    if (granted) {\n        //Granted access to mediaType\n        [self setDeviceAuthorized:YES];\n    } else {\n        //Not granted access to mediaType\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[[UIAlertView alloc] initWithTitle:@\"AVCam!\"\n                                    message:@\"AVCam doesn't have permission to use Camera, please change privacy settings\"\n                                   delegate:self\n                          cancelButtonTitle:@\"OK\"\n                          otherButtonTitles:nil] show];\n            [self setDeviceAuthorized:NO];\n        });\n    }\n}];\n```\n\n开始录制方法：\n\n```objectivec\n[session startRunning];\n```\n\n停止录制方法：\n```objectivec\n[session stopRunning];\n```\n\n#### 高帧率视频获取\n\niOS 7 以后在一些设备中引入了高帧率视频捕获的支持。我们可以通过 `AVCaptureDeviceFormat` 来查询设备支持的媒体类型、帧率、缩放比、视频防抖等。在 AVFoundation 中：\n\n- 支持捕获分辨率 720p 及以上、帧率 60 fps、视频防抖、P 帧丢帧。\n- 播放方面增强了对音频加速和慢速播放的支持。\n- 编辑方面提供了全面的编辑能力支持。\n- 输出方面支持两种方式输出帧率达 60 fps 的影视文件。一种是输出为可变帧率，支持慢速或快速播放。另一种是输出为任意指定帧率，比如 30 fps。\n需要注意的是，现在最新的 iOS 版本支持的能力会比以上这些更多更强大。\n\n#### 播放\n\n播放时，可以通过 `AVPlayer` 设置 `rate` 属性来设置播放速率。\n\n`AVPlayerItem` 可以支持通过 `audioTimePitchAlgorithm` 属性来设置当你用不同的速率播放视频时，该如何播放音频。以下是相关选项：\n\n- AVAudioTimePitchAlgorithmLowQualityZeroLatency，较低音质，适应多种播放速率。适宜的速率：0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0.\n- AVAudioTimePitchAlgorithmTimeDomain，普通音质。适宜的速率：0.5–2x。\n- AVAudioTimePitchAlgorithmSpectral，最高音质，性能消耗较大。适宜的速率：1/32–32。\n- AVAudioTimePitchAlgorithmVarispeed，高音质。适宜的速率：1/32–32。\n\n\n#### 编辑\n\n通常使用 `AVMutableComposition` 来做音视频编辑：\n\n使用 `composition` 类方法类创建 `AVMutableComposition` 对象。\n使用 `insertTimeRange:ofAsset:atTime:error:` 来插入音视频数据。\n使用 `scaleTimeRange:toDuration:` 来设置音视频数据的时间区间。\n导出\n\n可以使用 `AVAssetExportSession` 来导出 60 fps 的视频，可以用以下两种方式：\n\n使用 `AVAssetExportPresetPassthrough preset` 来编码重新编码视频。它会重新处理那些标记为 60 fps、降速、加速区域的时间。\n使用一个固定帧率来保证导出视频的最大兼容性。比如设置 `video composition` 的 `frameDuration` 为 30 fps。比如设置 `export session` 的 `audioTimePitchAlgorithm` 来配置音频播放选项。\n录制\n\n我们用 `AVCaptureMovieFileOutput` 来录制高帧率的视频，它会默认支持高帧率的视频录制，会默认选择正确的 H264 pitch level 和比特率。\n\n如果想要做一些自定义录制，我们必须使用 `AVAssetWriter`，这个则需要一些额外的创建过程。\n\n通常我们需要设置一下：\n\n```objectivec\netWriterInput.expectsMediaDataInRealTime = YES;\n```\n来保证视频捕获能跟得上传入的数据。\n\n\n","source":"_posts/AVAudioFoundation-4-：音视频录制.md","raw":"---\ntitle: AVAudioFoundation(4)：音视频录制\ndate: 2017-07-04 08:51:56\ncategories: \n\t- iOS合集\n---\n\n本文转自：[AVAudioFoundation(4)：音视频录制 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n采集设备的音视频时，我们需要组装各路数据，这时可以使用 AVCaptureSession 对象来协调。\n\n- 一个 `AVCaptureDevice` 对象表示输入设备，比如摄像头或者麦克风。\n- 一个 `AVCaptureInput` 具体子类的实例可以用来配置输出设备的端口。\n- 一个 `AVCaptureOutput` 具体子类的实例可以用来将音视频数据输出到一个视频文件或静态图片。\n- 一个 `AVCaptureSession` 实例用来协调输入输出的数据流。\n在录制视频时，为了让用户看到预览效果，我们可以使用 `AVCaptureVideoPreviewLayer`。\n\n下图展示了通过一个 `capture session` 实例来协调多路输入输出数据：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B61.png)\n\n对于大多数应用场景，这些细节已经足够我们用了。但是对于有些操作，比如当我们想要监测一个音频通道的强度，我们需要了解不同的输入设备的端口对应的对象，以及这些端口和输出是如何连接起来的。\n\n在音视频录制时，输入和输出之间的连接是用 `AVCaptureConnection` 来表示的。输入方(`AVCaptureInput`)包含一个或多个输入端口(`AVCaptureInputPort`)，输出端(`AVCaptureOutput`)可以从一个或多个数据源接收数据，比如一个 `AVCaptureMovieFileOutput` 就可以同时接收视频和音频数据。\n\n当你往一次录制 `session` 中添加一个输入或输出时，这个 `session` 会生成所有兼容的输入和输出端口间的连接，由 `AVCaptureConnection` 对象表示。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B62.png)\n\n\nYou can use a capture connection to enable or disable the flow of data from a given input or to a given output. You can also use a connection to monitor the average and peak power levels in an audio channel.\n\n我们可以用 `connetion` 对象来控制输入输出端之间的数据流的断开或连接，我们还能用它来监控 `audio` 通道的平均值和峰值。\n\n## 使用 Capture Session 来协调数据流\n\n`AVCaptureSession` 是我们用来管理数据捕获的核心协调者，我们用它来协调音视频输入和输出端的数据流。我们可以将我们需要的捕获设备添加到 `session` 中，然后用 `startRunning` 接口启动数据流，用 `stopRunning` 停止数据流。\n\n```objectivec\nAVCaptureSession *session = [[AVCaptureSession alloc] init];\n// Add inputs and outputs.\n[session startRunning];\n```\n\n#### 配置 Session\n\n我们可以给 `session` 设置我们需要的图像质量和分辨率。以下是其中的几个配置选项：\n\n- AVCaptureSessionPresetHigh，高分辨率，具体值取决于设备能提供的最高分辨率。\n- AVCaptureSessionPresetMedium，中等分辨率，具体值取决于设备。\n- AVCaptureSessionPresetLow，低分辨率，具体指取决于设备。\n- AVCaptureSessionPreset640x480，分辨率为 640x480，常称为 480P。\n- AVCaptureSessionPreset1280x720，分辨率为 1280x720，常称为 720P。\n- AVCaptureSessionPresetPhoto，全尺寸相片的分辨率，这个选项不支持输出视频。\n如果要使用某种分辨率选项，我们需要先测试一下设备是否支持：\n\n```objectivec\nif ([session canSetSessionPreset:AVCaptureSessionPreset1280x720]) {\n    session.sessionPreset = AVCaptureSessionPreset1280x720;\n}\nelse {\n    // Handle the failure.\n}\n```\n如果想对 `session` 的配置参数做更细粒度的控制，或者想修改已经在运行状态的 `session` 的配置参数，我们需要在 `beginConfiguration` 和 `commitConfiguration` 方法直接做修改。这两个方法的配合，可以使得我们队设备的修改是以一个 `group` 的方式提交，从而尽量避免视觉或者状态上的不一致性。在调用了 `beginConfiguration` 之后，我们可以增加或删除输出端，修改 `sessionPreset` 值，单独配置视频捕获的输入或输出参数。知道我们调用了 `commitConfiguration`，这些修改采用被提交并一起应用。\n\n```objectivec\n[session beginConfiguration];\n// Remove an existing capture device.\n// Add a new capture device.\n// Reset the preset.\n[session commitConfiguration];\n```\n\n#### 监控 Session 状态\n\n录制过程中 `session` 会发出通知来告知其对应的状态，比如 `session` 开始、结束、被打断。我们可以从 `AVCaptureSessionRuntimeErrorNotification` 来接收 `session` 运行时的错误。我们也可以差选 `session` 的运行时属性来获取其状态是在运行中还是被打断。此外，这些属性都是支持 `KVO` 监测的，并且通知会被发送到主线程。\n\n## 使用 AVCaptureDevice 来表示输入设备\n\n`AVCaptureDevice` 是由我们现实中物理的提供输入数据（比如音频或视频输入）的设备抽象而来，每个 `AVCaptureDevice` 对象都对应着一个输入设备，比如我们常见的前置摄像头、后置摄像头、麦克风。它们采集的数据将会输出给 `AVCaptureSession` 实例。\n\n我们可以使用 `AVCaptureDevice` 的 `devices` 和 `devicesWithMediaType:` 类方法来检查哪些是当前可用的设备。如果需要，我们还可以获取设备支持哪些功能。当前可用的设备列表是会动态变化的，有些设备会因为被别的应用使用而变得不可用，有的设备也有可能突然就可用了，所以我们需要注册 `AVCaptureDeviceWasConnectedNotification` 和 `AVCaptureDeviceWasDisconnectedNotification` 通知来感知当前可用设备的变化情况。\n\n我们可以使用 `capture input` 来想向一个 `AVCaptureSession` 中添加输入设备。\n\n\n#### 设备特性\n\n我们可以查询采集设备的不同特性。比如，我们可以使用 hasMediaType: 接口来判断采集设备是否支持某种媒体类型，也可以使用 supportsAVCaptureSessionPreset: 接口来判断采集设备是否支持预设的 session preset。我们还能获取设备的位置、本地化命名等信息以便于展示给用户。\n\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B63.png)\n\n\n下面的示例代码展示了如何遍历设备，并打印设备名：\n\n```objectivec\nNSArray *devices = [AVCaptureDevice devices];\nfor (AVCaptureDevice *device in devices) {\n\n    NSLog(@\"Device name: %@\", [device localizedName]);\n    if ([device hasMediaType:AVMediaTypeVideo]) {\n        if ([device position] == AVCaptureDevicePositionBack) {\n            NSLog(@\"Device position : back\");\n        }\n        else {\n            NSLog(@\"Device position : front\");\n        }\n    }\n}\n```\n\n此外，你还能查出设备的 model ID 和 unique ID。\n\n## 设备录制设置\n\n不同的设备有不同的能力，比如有些设备支持不同的对焦或刷新模式。下面的代码展示了如何找到一个支持手电筒以及预设的 `preset` 的设备。\n\n```objectivec\nNSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];\nNSMutableArray *torchDevices = [[NSMutableArray alloc] init];\n\nfor (AVCaptureDevice *device in devices) {\n    [if ([device hasTorch] &&\n         [device supportsAVCaptureSessionPreset:AVCaptureSessionPreset640x480]) {\n        [torchDevices addObject:device];\n    }\n}\n```\n\n如果你找到多个设备，你可以向用户展示设备的 `localizedName` 来让用户选择他们需要的设备。在使用对应的设备时，我们可以设置设备的各种工作模式，但是有一点需要注意的是在设置前需要对设备加锁。\n\n#### 聚焦模式\n\n目前支持的聚焦模式有以下几种：\n\n- AVCaptureFocusModeLocked：聚焦点固定。通常以拍摄场景的中点作为焦点。\n- AVCaptureFocusModeAutoFocus：自动聚焦。这种模式可以让用户选择一件事物来进行对焦，即使对于的位置不是拍摄场景的中点。\n- AVCaptureFocusModeContinuousAutoFocus：相机将持续自动对焦。\n我们可以使用 isFocusModeSupported: 接口来检查设备是否支持相应的聚焦模式，然后设置对应的 focusMode 属性。\n\n我们还能用 `focusPointOfInterestSupported` 来检查设备是否支持指定焦点，如果支持，我们就可以设置对应的 `focusPointOfInterest`属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。\n\n我们可以访问 `adjustingFocus` 属性来获知相机是否正在对焦，这个属性是支持 KVO 的，所以我们可以监测它来获知对焦状态的变化。\n\n如果你修改过了相机的对焦模式相关的设置，你可以用下面的代码将其恢复到默认状态：\n\n```objectivec\nif ([currentDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {\n    CGPoint autofocusPoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setFocusPointOfInterest:autofocusPoint];\n    [currentDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus];\n}\n```\n\n#### 曝光模式\n\n目前支持的曝光模式有以下几种：\n\n- AVCaptureExposureModeLocked，曝光等级锁定。\n- AVCaptureExposureModeAutoExpose，相机自动根据情况调整一次曝光等级，然后将曝光模式切换到 AVCaptureExposureModeLocked。\n- AVCaptureExposureModeContinuousAutoExposure，相机随时根据情况调整曝光等级。\n- AVCaptureExposureModeCustom，用户自定义曝光等级。\n我们可以通过 isExposureModeSupported: 来检查设备是否支持对应的模式，然后设置对应的 exposureMode 属性。\n\n我们还能用 `exposurePointOfInterestSupported` 来检查设备是否支持指定曝光点，如果支持，我们就可以设置对应的 `exposurePointOfInterest` 属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。\n\n我们可以访问 `adjustingExposure` 属性来获知相机是否正在改变曝光设置，这个属性是支持 KVO 的，所以我们可以监测它来获知曝光状态的变化。\n\n如果你修改过了相机的曝光模式相关的设置，你可以用下面的代码将其恢复到默认状态：\n\n```objectivec\nif ([currentDevice isExposureModeSupported:AVCaptureExposureModeContinuousAutoExposure]) {\n    CGPoint exposurePoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setExposurePointOfInterest:exposurePoint];\n    [currentDevice setExposureMode:AVCaptureExposureModeContinuousAutoExposure];\n}\n```\n\n\n#### 闪光灯模式\n\n目前支持的闪光灯模式有如下几种：\n\n- AVCaptureFlashModeOff，不会闪光。\n- AVCaptureFlashModeOn，会闪光。\n- AVCaptureFlashModeAuto，根据具体情况决定是否闪光。\n我们可以通过 `hasFlash` 检查设备是否有闪光灯，可以通过 `isFlashModeSupported:` 检查设备是否支持对应的模式，通过 `flashMode` 设置对应的模式。\n\n#### 手电筒模式\n\n在手电筒模式下，闪光灯会以低耗电量模式持续打开来为图像录制来照明。目前支持的模式有以下几种：\n\n- AVCaptureTorchModeOff，关闭。\n- AVCaptureTorchModeOn，开启。\n- AVCaptureTorchModeAuto，自动。\n我们可以通过 `hasTorch` 检查设备是否有闪光灯，可以通过 `isTorchModeSupported:` 检查设备是否支持对应的手电筒模式，通过 `torchMode` 设置对应的模式。\n\n\n#### 视频防抖\n\n视频防抖主要依赖于硬件，虽然如此，也不是所有的视频格式和分辨率都能支持。此外，开启防抖也会带来为视频录制带来一定的延迟。我们可以通过 `videoStabilizationEnabled` 来检查是否启动了防抖，通过 `enablesVideoStabilizationWhenAvailable` 来允许应用在条件支持的情况下自动开启防抖。\n\n#### 白平衡\n\n目前支持面几种白平衡模式：\n\n- AVCaptureWhiteBalanceModeLocked，固定模式。\n- AVCaptureWhiteBalanceModeAutoWhiteBalance，自动模式。相机根据情况调整一次白平衡，然后切换至 AVCaptureWhiteBalanceModeLocked 模式。\n- AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance，相机随时根据情况调整白平衡。\n我们可以通过 `isWhiteBalanceModeSupported:` 检查是否支持给定的模式，然后通过 `whiteBalanceMode` 设置对应模式。\n\n我们可以访问 `adjustingWhiteBalance` 属性来获知相机是否正在改变白平衡设置，这个属性是支持 KVO 的，所以我们可以监测它来获知白平衡状态的变化。\n\n#### 设置方向\n\n我们可以通过 `AVCaptureConnection` 实例来设置想要在 AVCaptureOutput(AVCaptureMovieFileOutput, AVCaptureStillImageOutput, AVCaptureVideoDataOutput) 获得的图像方向。\n\n我们通过 `isVideoOrientationSupported` 检查是否支持改变视频方向，通过 `videoOrientation` 设置方向。\n\n下面是示例代码：\n\n```objectivec\nAVCaptureConnection *captureConnection = <#A capture connection#>;\nif ([captureConnection isVideoOrientationSupported]) {\n    AVCaptureVideoOrientation orientation = AVCaptureVideoOrientationLandscapeLeft;\n    [captureConnection setVideoOrientation:orientation];\n}\n```\n\n#### 配置设备\n\n在设置设备的相关属性前，我们需要使用 lockForConfiguration: 来获取一个对设备操作的锁，这样可以避免你在使用设备时被别的应用更改了设置而导致不兼容等问题。\n\n```objectivec\nif ([device isFocusModeSupported:AVCaptureFocusModeLocked]) {\n    NSError *error = nil;\n    if ([device lockForConfiguration:&error]) {\n        device.focusMode = AVCaptureFocusModeLocked;\n        [device unlockForConfiguration];\n    }\n    else {\n        // Respond to the failure as appropriate.\n            }\n```\n\n你应该只在希望设备的设置不能被修改时保持设备锁，不正确的持有设备锁可能会影响其他程序的录制质量。\n\n#### 设备切换\n\n有时候你可能需要在使用时切换设备，比如切换前后摄像头。这时为了避免卡顿或者闪屏，我们可以重新配置一个正在执行的 `session`，但是我们在修改前后需要分别使用 `beginConfiguration` 和 `commitConfiguration:`\n\n```objectivec\nAVCaptureSession *session = <#A capture session#>;\n[session beginConfiguration];\n\n[session removeInput:frontFacingCameraDeviceInput];\n[session addInput:backFacingCameraDeviceInput];\n\n[session commitConfiguration];\n```\n\n当最外的 `commitConfiguration` 被调用时，所有的配置修改会被一起提交，这样可以保证平滑的切换。\n\n## 使用 Capture Inputs 来给一个 Session 添加设备\n\n我们可以用 `AVCaptureDeviceInput` 来给一个 `session` 添加设备。`AVCaptureDeviceInput` 是用来管理设备的端口。\n\n```objectivec\nNSError *error;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];\nif (!input) {\n    // Handle the error appropriately.\n}\n```\n\n我们用 `addInput:` 来添加设备。我们还可以在添加前用 `canAddInput:` 来检查一下。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nAVCaptureDeviceInput *captureDeviceInput = <#Get a capture device input#>;\nif ([captureSession canAddInput:captureDeviceInput]) {\n    [captureSession addInput:captureDeviceInput];\n}\nelse {\n    // Handle the failure.\n}\n```\n\n`AVCaptureInput` 声明一个或者多个媒体数据流。例如，输入设备可以同时提供音频和视频数据。输入提供的每个媒体流都被一个 `AVCaptureInputPort` 所表示。一个会话使用 `AVCaptureConnection` 对象来定义一组 `AVCaptureInputPort` 对象和一个 `AVCaptureOutput` 之间的映射。\n\n## 使用 Capture Outputs 来从一个 Session 获取输出\n\n要从一个 `capture session` 中获取输出，我们需要给它添加一个或多个输出实例，输出实例都是 `AVCaptureOutput` 的子类。比如：\n\n- AVCaptureMovieFileOutput，输出电影文件。\n- AVCaptureVideoDataOutput，当我们需要处理录制得到的视频帧时（比如创建自定义的渲染层），可以用这个。\n- AVCaptureAudioDataOutput，当我们需要处理录制到的音频数据时，可以用这个。\n- AVCaptureStillImageOutput，当我们需要获取静态图片以及对应的 metadata 时，可以用这个。\n我们可以使用 `addOutput:` 向 `session` 中添加输出实例，我们也可以在加之前，通过 `canAddOutput:` 来检测要添加的输出实例是否是兼容的。我们可以往一个正在运行状态的 `session` 中添加输出实例。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nAVCaptureMovieFileOutput *movieOutput = <#Create and configure a movie output#>;\nif ([captureSession canAddOutput:movieOutput]) {\n    [captureSession addOutput:movieOutput];\n} else {\n    // Handle the failure.\n}\n```\n\n## 保存电影文件\n\n使用 `AVCaptureMovieFileOutput` 将音视频数据保存到文件中时，我们可以做一些输出设置，比如最大录制时长、最大文件尺寸等等。我们还能够在硬盘空间不够时停止录制。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = [[AVCaptureMovieFileOutput alloc] init];\nCMTime maxDuration = <#Create a CMTime to represent the maximum duration#>;\naMovieFileOutput.maxRecordedDuration = maxDuration;\naMovieFileOutput.minFreeDiskSpaceLimit = <#An appropriate minimum given the quality of the movie format and the duration#>;\n```\n\n录制时输出的分辨率和码率是根据 capture session 的 sessionPreset 属性而定的。其中视频的编码类型是 H.264，音频的编码类型是 AAC，这个也是由不同的设备类型决定的。\n\n#### 开始录制\n\n我们通过 `startRecordingToOutputFileURL:recordingDelegate:` 来开始录制，这时你需要提供一个文件 `URL` 和一个 `delegate`。这个 `URL` 不能指向已存在的文件，因为这里的音视频输出不会去覆盖已有的资源。同时我们也必须要有对这个 `URL` 指向位置的写权限。这里的 `delegate` 必须遵循 `AVCaptureFileOutputRecordingDelegate` 协议，而且必须实现 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = <#Get a movie file output#>;\nNSURL *fileURL = <#A file URL that identifies the output location#>;\n[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:<#The delegate#>];\n```\n\n在 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法中，`delegate` 可以将最终输出的文件写入相册，同时也需要检查和处理各种可能出现的错误。\n\n#### 确保文件写入成功\n\n要确保文件是否成功，我们可以在 `captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:` 方法中检查 `AVErrorRecordingSuccessfullyFinishedKey`。\n\n```objectivec\n- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error {\n\n    BOOL recordedSuccessfully = YES;\n    if ([error code] != noErr) {\n        // A problem occurred: Find out if the recording was successful.\n        id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey];\n        if (value) {\n            recordedSuccessfully = [value boolValue];\n        }\n    }\n    // Continue as appropriate...\n```\n我们需要检查 `error` 的 `userInfo` 的 `AVErrorRecordingSuccessfullyFinishedKey` 对应的值，因为有时候即使我们收到了错误，文件也可能是保存成功的，这时候，有可能是触及了我们设置的某些限制，比如 `AVErrorMaximumDurationReached` 或者 `AVErrorMaximumFileSizeReached`，其他的原因还有：\n\n- AVErrorDiskFull，磁盘空间不够。\n- AVErrorDeviceWasDisconnected，录制设备断开连接。\n- AVErrorSessionWasInterrupted，录制 `session` 被打断了，比如来电话了。\n\n#### 给文件添加 Metadata\n\n我们可以在任何时候给录制的文件设置 `metadata`，即使是在录制过程中。文件的 `metadata` 是由一系列的 `AVMetadataItem` 对象表示，我们可以用 `AVMutableMetadataItem` 来创建我们自己的 `metadata`。\n\n```objectivec\nAVCaptureMovieFileOutput *aMovieFileOutput = <#Get a movie file output#>;\nNSArray *existingMetadataArray = aMovieFileOutput.metadata;\nNSMutableArray *newMetadataArray = nil;\nif (existingMetadataArray) {\n    newMetadataArray = [existingMetadataArray mutableCopy];\n} else {\n    newMetadataArray = [[NSMutableArray alloc] init];\n}\n\nAVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];\nitem.keySpace = AVMetadataKeySpaceCommon;\nitem.key = AVMetadataCommonKeyLocation;\n\nCLLocation *location - <#The location to set#>;\nitem.value = [NSString stringWithFormat:@\"%+08.4lf%+09.4lf/\" location.coordinate.latitude, location.coordinate.longitude];\n\n[newMetadataArray addObject:item];\n\naMovieFileOutput.metadata = newMetadataArray;\n```\n\n#### 处理视频帧\n`AVCaptureVideoDataOutput`\n 对象使用代理来对外暴露视频帧，我们通过 `setSampleBufferDelegate:queue:`\n 来设置代理。除了设置代理以外，还需要设置一个 `serial queue` 来供代理调用，这里必须使用 `serial queue` 来保证传给 `delegate` 的帧数据的顺序正确。我们可以使用这个 queue 来分发和处理视频帧，这里可以参考一下例子 [SquareCam](https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190)。\n`captureOutput:didOutputSampleBuffer:fromConnection:`\n 中输出的视频帧数据是用 `CMSampleBufferRef`\n 来表示的。默认情况下，这个 `buffer` 的数据格式来自于相机能最高效处理的格式。我们可以通过 `videoSettings`\n 来设置一个自定义的输出格式，这个值是一个字典，现在支持的键包括 `kCVPixelBufferPixelFormatTypeKey`\n。推荐的 `pixel formats` 可以通过 `availableVideoCVPixelFormatTypes`\n 属性获得，此外还能通过 `availableVideoCodecTypes`\n 获得支持编码类型。`Core Graphics` 和 `OpenGL` 都能很好地处理 `BGRA`\n 格式。\n\n```objectivec\nAVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];NSDictionary *newSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};videoDataOutput.videoSettings = newSettings; // discard if the data output queue is blocked (as we process the still image[videoDataOutput setAlwaysDiscardsLateVideoFrames:YES];)// create a serial dispatch queue used for the sample buffer delegate as well as when a still image is captured// a serial dispatch queue must be used to guarantee that video frames will be delivered in order// see the header doc for setSampleBufferDelegate:queue: for more informationvideoDataOutputQueue = dispatch_queue_create(\"VideoDataOutputQueue\", DISPATCH_QUEUE_SERIAL);[videoDataOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];AVCaptureSession *captureSession = <#The Capture Session#>;if ([captureSession canAddOutput:videoDataOutput]) { [captureSession addOutput:videoDataOutput];}\n```\n\n\n#### 处理视频的性能问题\n\n对于我们的应用，设置够用的分辨率就好了，不要太高，那样性能会降低。\n\n我们需要确保，在 `captureOutput:didOutputSampleBuffer:fromConnection:` 中处理视频帧的时间开销不要超过分配给一帧的处理时长。如果这里处理的太长，那么 `AV Foundation` 将会停止发送视频帧给代理，也会停止发给其他输出端，比如 `preview layer`。\n\n你可以使用 `AVCaptureVideoDataOutput` 的 `minFrameDuration` 属性来确保你有足够的时间来处理一帧。同时，我们还可以设置 `alwaysDiscardsLateVideoFrames` 为 YES 来确保晚到的帧会被丢掉来避免延迟。如果你不介意延迟，而更想要处理更多的帧，那就设置这个值为 NO，但是这并不意味着不会丢帧，只是不会被那么早或那么高效的丢掉。\n\n## 截取静态图片\n\n当我们想要截取带着 `metadata` 的静态图片时，我们可以用 `AVCaptureStillImageOutput`。截出的图的分辨率依赖于 `session` 的 `preset` 和具体的设备。\n\n#### 像素和编码类型\n\n不同的类型支持不同的图片格式。我们可以用 `availableImageDataCVPixelFormatTypes` 和 `availableImageDataCodecTypes` 来检查当前的设备支持的像素类型和编码类型。然后，我们可以通过设置 `outputSettings` 属性指定图片的格式。\n\n```objectivec\nAVCaptureStillImageOutput *stillImageOutput = [[AVCaptureStillImageOutput alloc] init];\nNSDictionary *outputSettings = @{AVVideoCodecKey: AVVideoCodecJPEG};\n[stillImageOutput setOutputSettings:outputSettings];\n````\n\n如果我们要截取一张 JPEG 图片，你最好不要指定你自己的压缩格式，相反，你需要做的是让 `AVCaptureStillImageOutput` 帮你做压缩，因为它使用硬件加速来压缩。如果这时你需要图像的数据，可以用 `jpegStillImageNSDataRepresentation:` 来获取对应的 `NSData` 对象，这个数据是未经压缩的，甚至你都可以修改它。\n\n#### 捕获图像\n\n当截图时，我们使用 `captureStillImageAsynchronouslyFromConnection:completionHandler:`方法，其中的第一个参数是对应的 `connection`，这是你需要查找一下哪个 `connection` 的输出端口是在手机视频：\n\n```objectivec\nAVCaptureConnection *videoConnection = nil;\nfor (AVCaptureConnection *connection in stillImageOutput.connections) {\n    for (AVCaptureInputPort *port in [connection inputPorts]) {\n        if ([[port mediaType] isEqual:AVMediaTypeVideo] ) {\n            videoConnection = connection;\n            break;\n        }\n    }\n    if (videoConnection) { break; }\n}\n```\n\n第二个参数是一个 `block` 回调，其中带回两个参数：一个包含图像数据的 `CMSampleBuffer`，一个 `NSError`。这个 `sample buffer` 中可能包含着 `metadata`，比如一个 EXIF 字典作为附属信息。我们可以去修改附属信息，但是需要注意针对 JPEG 图像的像素和编码上的优化。\n\n```objectivec\n[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageSampleBuffer, NSError *error) {\n    CFDictionaryRef exifAttachments =\n        CMGetAttachment(imageSampleBuffer, kCGImagePropertyExifDictionary, NULL);\n    if (exifAttachments) {\n        // Do something with the attachments.\n    }\n    // Continue as appropriate.\n}];\n```\n\n## 预览\n\n#### 视频预览\n\n我们可以用 `AVCaptureVideoPreviewLayer` 来给用户提供预览，我们不需要任何 `output` 对象来展示预览。此外，我们可以使用 `AVCaptureVideoDataOutput` 来在给用户预览之前获取到图像像素级别的数据。\n\nUnlike a capture output, a video preview layer maintains a strong reference to the session with which it is associated. This is to ensure that the session is not deallocated while the layer is attempting to display video. This is reflected in the way you initialize a preview layer:\n\n不像 `capture output`，一个 `video preview layer` 会持有一个关联 `session` 的强引用。这样来防止 `layer` 在展示预览时而 `session` 被释放引起问题。\n\n```objectivec\nAVCaptureSession *captureSession = <#Get a capture session#>;\nCALayer *viewLayer = <#Get a layer from the view in which you want to present the preview#>;\n\nAVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:captureSession];\n[viewLayer addSublayer:captureVideoPreviewLayer];\n```\n\n一般来说，`preview layer` 和其他 `CALayer` 对象一样，我们可以缩放它的图像，执行变换，旋转。一个不同的地方是，我们需要设置 `layer` 的 `orientation` 属性来指定它改如何旋转从相机获得的图像。此外，我们可以用 `supportsVideoMirroring` 来测试设备是否支持视频镜面效果(左右翻转)，我们可以设置 `videoMirrored` 来配置是否开启镜面效果，即使 `automaticallyAdjustsVideoMirroring` 被设置为默认的 YES 也没问题(这个值是在配置 `session` 时被自动设置的)。\n\n#### 视频重力模式\n\n我们可以通过 `videoGravity`\n 属性设置视频重力模式，比如：\n- AVLayerVideoGravityResizeAspect\n，保持视频的宽高比；不一定完全填充，可能留黑边；不裁剪视频，。\n- AVLayerVideoGravityResizeAspectFill\n，保持视频的宽高比；完全填充，不留黑边；可能裁剪视频。\n- AVLayerVideoGravityResize\n，不保持视频宽高比，可能扭曲画面；完全填充；不裁剪视频。\n\n#### 使用预览时的点击聚焦\n\n需要注意的是，在实现点击聚焦时必须考虑到该层的预览方向和重力，并考虑预览变为镜像显示的可能性。可以参考实例项目：[AVCam-iOS: Using AVFoundation to Capture Images and Movies](https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112)。\n\n## 显示音频等级\n\nTo monitor the average and peak power levels in an audio channel in a capture connection, you use an AVCaptureAudioChannel object. Audio levels are not key-value observable, so you must poll for updated levels as often as you want to update your user interface (for example, 10 times a second).\n\n要监测 capture connection 中音频通道的平均强度和峰值强度，我们可以用 `AVCaptureAudioChannel`。音频等级是不支持 KVO 监测的，所以当我们想更新用户界面时，我们需要去查询。\n\n```objectivec\nAVCaptureAudioDataOutput *audioDataOutput = <#Get the audio data output#>;\nNSArray *connections = audioDataOutput.connections;\nif ([connections count] > 0) {\n    // There should be only one connection to an AVCaptureAudioDataOutput.\n    AVCaptureConnection *connection = [connections objectAtIndex:0];\n\n    NSArray *audioChannels = connection.audioChannels;\n\n    for (AVCaptureAudioChannel *channel in audioChannels) {\n        float avg = channel.averagePowerLevel;\n        float peak = channel.peakHoldLevel;\n        // Update the level meter user interface.\n    }\n}\n```\n## 一个完整示例\n\n这里的示例代码将展示如何获取视频并转化为 UIImage。大概包括下面几步：\n\n- 创建一个 AVCaptureSession 对象来协调输入设备到输出的数据流。\n- 找到我们想要的 AVCaptureDevice。\n- 为 device 创建一个 AVCaptureDeviceInput 对象。\n- 创建 AVCaptureVideoDataOutput 来输出视频帧。\n- 实现 AVCaptureVideoDataOutput 的 delegate 方法来处理视频帧。\n- 在实现的代理方法中将 CMSampleBuffer 转为 UIImage。\n代码如下：\n\n```objectivec\n// 创建并配置 Capture Session：\nAVCaptureSession *session = [[AVCaptureSession alloc] init];\nsession.sessionPreset = AVCaptureSessionPresetMedium;\n\n// 创建和配置 Device 和 Device Input：\nAVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n\nNSError *error = nil;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&error];\nif (!input) {\n    // Handle the error appropriately.\n}\n[session addInput:input];\n\n// 创建和配置 Video Data Output：\nAVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];\n[session addOutput:output];\noutput.videoSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};\noutput.minFrameDuration = CMTimeMake(1, 15);\n// 设置 Video Data Output 的 delegate 和处理队列：\ndispatch_queue_t queue = dispatch_queue_create(\"MyQueue\", NULL);\n[output setSampleBufferDelegate:self queue:queue];\n```\n\n代理方法实现：\n\n```objectivec\n- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {\n\n    UIImage *image = imageFromSampleBuffer(sampleBuffer);\n    // Add your code here that uses the image.\n}\n```\n\n开始录制：\n\n录制前，还需要注意申请相机权限：\n\n```objectivec\n// 申请权限：\nNSString *mediaType = AVMediaTypeVideo;\n\n[AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {\n    if (granted) {\n        //Granted access to mediaType\n        [self setDeviceAuthorized:YES];\n    } else {\n        //Not granted access to mediaType\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[[UIAlertView alloc] initWithTitle:@\"AVCam!\"\n                                    message:@\"AVCam doesn't have permission to use Camera, please change privacy settings\"\n                                   delegate:self\n                          cancelButtonTitle:@\"OK\"\n                          otherButtonTitles:nil] show];\n            [self setDeviceAuthorized:NO];\n        });\n    }\n}];\n```\n\n开始录制方法：\n\n```objectivec\n[session startRunning];\n```\n\n停止录制方法：\n```objectivec\n[session stopRunning];\n```\n\n#### 高帧率视频获取\n\niOS 7 以后在一些设备中引入了高帧率视频捕获的支持。我们可以通过 `AVCaptureDeviceFormat` 来查询设备支持的媒体类型、帧率、缩放比、视频防抖等。在 AVFoundation 中：\n\n- 支持捕获分辨率 720p 及以上、帧率 60 fps、视频防抖、P 帧丢帧。\n- 播放方面增强了对音频加速和慢速播放的支持。\n- 编辑方面提供了全面的编辑能力支持。\n- 输出方面支持两种方式输出帧率达 60 fps 的影视文件。一种是输出为可变帧率，支持慢速或快速播放。另一种是输出为任意指定帧率，比如 30 fps。\n需要注意的是，现在最新的 iOS 版本支持的能力会比以上这些更多更强大。\n\n#### 播放\n\n播放时，可以通过 `AVPlayer` 设置 `rate` 属性来设置播放速率。\n\n`AVPlayerItem` 可以支持通过 `audioTimePitchAlgorithm` 属性来设置当你用不同的速率播放视频时，该如何播放音频。以下是相关选项：\n\n- AVAudioTimePitchAlgorithmLowQualityZeroLatency，较低音质，适应多种播放速率。适宜的速率：0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0.\n- AVAudioTimePitchAlgorithmTimeDomain，普通音质。适宜的速率：0.5–2x。\n- AVAudioTimePitchAlgorithmSpectral，最高音质，性能消耗较大。适宜的速率：1/32–32。\n- AVAudioTimePitchAlgorithmVarispeed，高音质。适宜的速率：1/32–32。\n\n\n#### 编辑\n\n通常使用 `AVMutableComposition` 来做音视频编辑：\n\n使用 `composition` 类方法类创建 `AVMutableComposition` 对象。\n使用 `insertTimeRange:ofAsset:atTime:error:` 来插入音视频数据。\n使用 `scaleTimeRange:toDuration:` 来设置音视频数据的时间区间。\n导出\n\n可以使用 `AVAssetExportSession` 来导出 60 fps 的视频，可以用以下两种方式：\n\n使用 `AVAssetExportPresetPassthrough preset` 来编码重新编码视频。它会重新处理那些标记为 60 fps、降速、加速区域的时间。\n使用一个固定帧率来保证导出视频的最大兼容性。比如设置 `video composition` 的 `frameDuration` 为 30 fps。比如设置 `export session` 的 `audioTimePitchAlgorithm` 来配置音频播放选项。\n录制\n\n我们用 `AVCaptureMovieFileOutput` 来录制高帧率的视频，它会默认支持高帧率的视频录制，会默认选择正确的 H264 pitch level 和比特率。\n\n如果想要做一些自定义录制，我们必须使用 `AVAssetWriter`，这个则需要一些额外的创建过程。\n\n通常我们需要设置一下：\n\n```objectivec\netWriterInput.expectsMediaDataInRealTime = YES;\n```\n来保证视频捕获能跟得上传入的数据。\n\n\n","slug":"AVAudioFoundation-4-：音视频录制","published":1,"updated":"2017-07-05T11:13:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tv00005znuzka8vs9vb","content":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(4)：音视频录制 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>采集设备的音视频时，我们需要组装各路数据，这时可以使用 AVCaptureSession 对象来协调。</p>\n<ul>\n<li>一个 <code>AVCaptureDevice</code> 对象表示输入设备，比如摄像头或者麦克风。</li>\n<li>一个 <code>AVCaptureInput</code> 具体子类的实例可以用来配置输出设备的端口。</li>\n<li>一个 <code>AVCaptureOutput</code> 具体子类的实例可以用来将音视频数据输出到一个视频文件或静态图片。</li>\n<li>一个 <code>AVCaptureSession</code> 实例用来协调输入输出的数据流。<br>在录制视频时，为了让用户看到预览效果，我们可以使用 <code>AVCaptureVideoPreviewLayer</code>。</li>\n</ul>\n<p>下图展示了通过一个 <code>capture session</code> 实例来协调多路输入输出数据：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B61.png\" alt=\"图一\"></p>\n<p>对于大多数应用场景，这些细节已经足够我们用了。但是对于有些操作，比如当我们想要监测一个音频通道的强度，我们需要了解不同的输入设备的端口对应的对象，以及这些端口和输出是如何连接起来的。</p>\n<p>在音视频录制时，输入和输出之间的连接是用 <code>AVCaptureConnection</code> 来表示的。输入方(<code>AVCaptureInput</code>)包含一个或多个输入端口(<code>AVCaptureInputPort</code>)，输出端(<code>AVCaptureOutput</code>)可以从一个或多个数据源接收数据，比如一个 <code>AVCaptureMovieFileOutput</code> 就可以同时接收视频和音频数据。</p>\n<p>当你往一次录制 <code>session</code> 中添加一个输入或输出时，这个 <code>session</code> 会生成所有兼容的输入和输出端口间的连接，由 <code>AVCaptureConnection</code> 对象表示。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B62.png\" alt=\"图二\"></p>\n<p>You can use a capture connection to enable or disable the flow of data from a given input or to a given output. You can also use a connection to monitor the average and peak power levels in an audio channel.</p>\n<p>我们可以用 <code>connetion</code> 对象来控制输入输出端之间的数据流的断开或连接，我们还能用它来监控 <code>audio</code> 通道的平均值和峰值。</p>\n<h2 id=\"使用-Capture-Session-来协调数据流\"><a href=\"#使用-Capture-Session-来协调数据流\" class=\"headerlink\" title=\"使用 Capture Session 来协调数据流\"></a>使用 Capture Session 来协调数据流</h2><p><code>AVCaptureSession</code> 是我们用来管理数据捕获的核心协调者，我们用它来协调音视频输入和输出端的数据流。我们可以将我们需要的捕获设备添加到 <code>session</code> 中，然后用 <code>startRunning</code> 接口启动数据流，用 <code>stopRunning</code> 停止数据流。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureSession <span class=\"token operator\">*</span>session <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureSession alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add inputs and outputs.</span>\n<span class=\"token punctuation\">[</span>session startRunning<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"配置-Session\"><a href=\"#配置-Session\" class=\"headerlink\" title=\"配置 Session\"></a>配置 Session</h4><p>我们可以给 <code>session</code> 设置我们需要的图像质量和分辨率。以下是其中的几个配置选项：</p>\n<ul>\n<li>AVCaptureSessionPresetHigh，高分辨率，具体值取决于设备能提供的最高分辨率。</li>\n<li>AVCaptureSessionPresetMedium，中等分辨率，具体值取决于设备。</li>\n<li>AVCaptureSessionPresetLow，低分辨率，具体指取决于设备。</li>\n<li>AVCaptureSessionPreset640x480，分辨率为 640x480，常称为 480P。</li>\n<li>AVCaptureSessionPreset1280x720，分辨率为 1280x720，常称为 720P。</li>\n<li>AVCaptureSessionPresetPhoto，全尺寸相片的分辨率，这个选项不支持输出视频。<br>如果要使用某种分辨率选项，我们需要先测试一下设备是否支持：</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>session canSetSessionPreset<span class=\"token punctuation\">:</span>AVCaptureSessionPreset1280x720<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    session<span class=\"token punctuation\">.</span>sessionPreset <span class=\"token operator\">=</span> AVCaptureSessionPreset1280x720<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle the failure.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果想对 <code>session</code> 的配置参数做更细粒度的控制，或者想修改已经在运行状态的 <code>session</code> 的配置参数，我们需要在 <code>beginConfiguration</code> 和 <code>commitConfiguration</code> 方法直接做修改。这两个方法的配合，可以使得我们队设备的修改是以一个 <code>group</code> 的方式提交，从而尽量避免视觉或者状态上的不一致性。在调用了 <code>beginConfiguration</code> 之后，我们可以增加或删除输出端，修改 <code>sessionPreset</code> 值，单独配置视频捕获的输入或输出参数。知道我们调用了 <code>commitConfiguration</code>，这些修改采用被提交并一起应用。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>session beginConfiguration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Remove an existing capture device.</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add a new capture device.</span>\n<span class=\"token comment\" spellcheck=\"true\">// Reset the preset.</span>\n<span class=\"token punctuation\">[</span>session commitConfiguration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"监控-Session-状态\"><a href=\"#监控-Session-状态\" class=\"headerlink\" title=\"监控 Session 状态\"></a>监控 Session 状态</h4><p>录制过程中 <code>session</code> 会发出通知来告知其对应的状态，比如 <code>session</code> 开始、结束、被打断。我们可以从 <code>AVCaptureSessionRuntimeErrorNotification</code> 来接收 <code>session</code> 运行时的错误。我们也可以差选 <code>session</code> 的运行时属性来获取其状态是在运行中还是被打断。此外，这些属性都是支持 <code>KVO</code> 监测的，并且通知会被发送到主线程。</p>\n<h2 id=\"使用-AVCaptureDevice-来表示输入设备\"><a href=\"#使用-AVCaptureDevice-来表示输入设备\" class=\"headerlink\" title=\"使用 AVCaptureDevice 来表示输入设备\"></a>使用 AVCaptureDevice 来表示输入设备</h2><p><code>AVCaptureDevice</code> 是由我们现实中物理的提供输入数据（比如音频或视频输入）的设备抽象而来，每个 <code>AVCaptureDevice</code> 对象都对应着一个输入设备，比如我们常见的前置摄像头、后置摄像头、麦克风。它们采集的数据将会输出给 <code>AVCaptureSession</code> 实例。</p>\n<p>我们可以使用 <code>AVCaptureDevice</code> 的 <code>devices</code> 和 <code>devicesWithMediaType:</code> 类方法来检查哪些是当前可用的设备。如果需要，我们还可以获取设备支持哪些功能。当前可用的设备列表是会动态变化的，有些设备会因为被别的应用使用而变得不可用，有的设备也有可能突然就可用了，所以我们需要注册 <code>AVCaptureDeviceWasConnectedNotification</code> 和 <code>AVCaptureDeviceWasDisconnectedNotification</code> 通知来感知当前可用设备的变化情况。</p>\n<p>我们可以使用 <code>capture input</code> 来想向一个 <code>AVCaptureSession</code> 中添加输入设备。</p>\n<h4 id=\"设备特性\"><a href=\"#设备特性\" class=\"headerlink\" title=\"设备特性\"></a>设备特性</h4><p>我们可以查询采集设备的不同特性。比如，我们可以使用 hasMediaType: 接口来判断采集设备是否支持某种媒体类型，也可以使用 supportsAVCaptureSessionPreset: 接口来判断采集设备是否支持预设的 session preset。我们还能获取设备的位置、本地化命名等信息以便于展示给用户。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B63.png\" alt=\"图三\"></p>\n<p>下面的示例代码展示了如何遍历设备，并打印设备名：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>devices <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDevice devices<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>AVCaptureDevice <span class=\"token operator\">*</span>device <span class=\"token keyword\">in</span> devices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Device name: %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>device localizedName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>device hasMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>device position<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> AVCaptureDevicePositionBack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Device position : back\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Device position : front\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>此外，你还能查出设备的 model ID 和 unique ID。</p>\n<h2 id=\"设备录制设置\"><a href=\"#设备录制设置\" class=\"headerlink\" title=\"设备录制设置\"></a>设备录制设置</h2><p>不同的设备有不同的能力，比如有些设备支持不同的对焦或刷新模式。下面的代码展示了如何找到一个支持手电筒以及预设的 <code>preset</code> 的设备。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>devices <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDevice devicesWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>torchDevices <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableArray alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>AVCaptureDevice <span class=\"token operator\">*</span>device <span class=\"token keyword\">in</span> devices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>device hasTorch<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span>\n         <span class=\"token punctuation\">[</span>device supportsAVCaptureSessionPreset<span class=\"token punctuation\">:</span>AVCaptureSessionPreset640x480<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">[</span>torchDevices addObject<span class=\"token punctuation\">:</span>device<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果你找到多个设备，你可以向用户展示设备的 <code>localizedName</code> 来让用户选择他们需要的设备。在使用对应的设备时，我们可以设置设备的各种工作模式，但是有一点需要注意的是在设置前需要对设备加锁。</p>\n<h4 id=\"聚焦模式\"><a href=\"#聚焦模式\" class=\"headerlink\" title=\"聚焦模式\"></a>聚焦模式</h4><p>目前支持的聚焦模式有以下几种：</p>\n<ul>\n<li>AVCaptureFocusModeLocked：聚焦点固定。通常以拍摄场景的中点作为焦点。</li>\n<li>AVCaptureFocusModeAutoFocus：自动聚焦。这种模式可以让用户选择一件事物来进行对焦，即使对于的位置不是拍摄场景的中点。</li>\n<li>AVCaptureFocusModeContinuousAutoFocus：相机将持续自动对焦。<br>我们可以使用 isFocusModeSupported: 接口来检查设备是否支持相应的聚焦模式，然后设置对应的 focusMode 属性。</li>\n</ul>\n<p>我们还能用 <code>focusPointOfInterestSupported</code> 来检查设备是否支持指定焦点，如果支持，我们就可以设置对应的 <code>focusPointOfInterest</code>属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。</p>\n<p>我们可以访问 <code>adjustingFocus</code> 属性来获知相机是否正在对焦，这个属性是支持 KVO 的，所以我们可以监测它来获知对焦状态的变化。</p>\n<p>如果你修改过了相机的对焦模式相关的设置，你可以用下面的代码将其恢复到默认状态：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>currentDevice isFocusModeSupported<span class=\"token punctuation\">:</span>AVCaptureFocusModeContinuousAutoFocus<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CGPoint autofocusPoint <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>currentDevice setFocusPointOfInterest<span class=\"token punctuation\">:</span>autofocusPoint<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>currentDevice setFocusMode<span class=\"token punctuation\">:</span>AVCaptureFocusModeContinuousAutoFocus<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"曝光模式\"><a href=\"#曝光模式\" class=\"headerlink\" title=\"曝光模式\"></a>曝光模式</h4><p>目前支持的曝光模式有以下几种：</p>\n<ul>\n<li>AVCaptureExposureModeLocked，曝光等级锁定。</li>\n<li>AVCaptureExposureModeAutoExpose，相机自动根据情况调整一次曝光等级，然后将曝光模式切换到 AVCaptureExposureModeLocked。</li>\n<li>AVCaptureExposureModeContinuousAutoExposure，相机随时根据情况调整曝光等级。</li>\n<li>AVCaptureExposureModeCustom，用户自定义曝光等级。<br>我们可以通过 isExposureModeSupported: 来检查设备是否支持对应的模式，然后设置对应的 exposureMode 属性。</li>\n</ul>\n<p>我们还能用 <code>exposurePointOfInterestSupported</code> 来检查设备是否支持指定曝光点，如果支持，我们就可以设置对应的 <code>exposurePointOfInterest</code> 属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。</p>\n<p>我们可以访问 <code>adjustingExposure</code> 属性来获知相机是否正在改变曝光设置，这个属性是支持 KVO 的，所以我们可以监测它来获知曝光状态的变化。</p>\n<p>如果你修改过了相机的曝光模式相关的设置，你可以用下面的代码将其恢复到默认状态：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>currentDevice isExposureModeSupported<span class=\"token punctuation\">:</span>AVCaptureExposureModeContinuousAutoExposure<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CGPoint exposurePoint <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>currentDevice setExposurePointOfInterest<span class=\"token punctuation\">:</span>exposurePoint<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>currentDevice setExposureMode<span class=\"token punctuation\">:</span>AVCaptureExposureModeContinuousAutoExposure<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"闪光灯模式\"><a href=\"#闪光灯模式\" class=\"headerlink\" title=\"闪光灯模式\"></a>闪光灯模式</h4><p>目前支持的闪光灯模式有如下几种：</p>\n<ul>\n<li>AVCaptureFlashModeOff，不会闪光。</li>\n<li>AVCaptureFlashModeOn，会闪光。</li>\n<li>AVCaptureFlashModeAuto，根据具体情况决定是否闪光。<br>我们可以通过 <code>hasFlash</code> 检查设备是否有闪光灯，可以通过 <code>isFlashModeSupported:</code> 检查设备是否支持对应的模式，通过 <code>flashMode</code> 设置对应的模式。</li>\n</ul>\n<h4 id=\"手电筒模式\"><a href=\"#手电筒模式\" class=\"headerlink\" title=\"手电筒模式\"></a>手电筒模式</h4><p>在手电筒模式下，闪光灯会以低耗电量模式持续打开来为图像录制来照明。目前支持的模式有以下几种：</p>\n<ul>\n<li>AVCaptureTorchModeOff，关闭。</li>\n<li>AVCaptureTorchModeOn，开启。</li>\n<li>AVCaptureTorchModeAuto，自动。<br>我们可以通过 <code>hasTorch</code> 检查设备是否有闪光灯，可以通过 <code>isTorchModeSupported:</code> 检查设备是否支持对应的手电筒模式，通过 <code>torchMode</code> 设置对应的模式。</li>\n</ul>\n<h4 id=\"视频防抖\"><a href=\"#视频防抖\" class=\"headerlink\" title=\"视频防抖\"></a>视频防抖</h4><p>视频防抖主要依赖于硬件，虽然如此，也不是所有的视频格式和分辨率都能支持。此外，开启防抖也会带来为视频录制带来一定的延迟。我们可以通过 <code>videoStabilizationEnabled</code> 来检查是否启动了防抖，通过 <code>enablesVideoStabilizationWhenAvailable</code> 来允许应用在条件支持的情况下自动开启防抖。</p>\n<h4 id=\"白平衡\"><a href=\"#白平衡\" class=\"headerlink\" title=\"白平衡\"></a>白平衡</h4><p>目前支持面几种白平衡模式：</p>\n<ul>\n<li>AVCaptureWhiteBalanceModeLocked，固定模式。</li>\n<li>AVCaptureWhiteBalanceModeAutoWhiteBalance，自动模式。相机根据情况调整一次白平衡，然后切换至 AVCaptureWhiteBalanceModeLocked 模式。</li>\n<li>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance，相机随时根据情况调整白平衡。<br>我们可以通过 <code>isWhiteBalanceModeSupported:</code> 检查是否支持给定的模式，然后通过 <code>whiteBalanceMode</code> 设置对应模式。</li>\n</ul>\n<p>我们可以访问 <code>adjustingWhiteBalance</code> 属性来获知相机是否正在改变白平衡设置，这个属性是支持 KVO 的，所以我们可以监测它来获知白平衡状态的变化。</p>\n<h4 id=\"设置方向\"><a href=\"#设置方向\" class=\"headerlink\" title=\"设置方向\"></a>设置方向</h4><p>我们可以通过 <code>AVCaptureConnection</code> 实例来设置想要在 AVCaptureOutput(AVCaptureMovieFileOutput, AVCaptureStillImageOutput, AVCaptureVideoDataOutput) 获得的图像方向。</p>\n<p>我们通过 <code>isVideoOrientationSupported</code> 检查是否支持改变视频方向，通过 <code>videoOrientation</code> 设置方向。</p>\n<p>下面是示例代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureConnection <span class=\"token operator\">*</span>captureConnection <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A capture connection#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>captureConnection isVideoOrientationSupported<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    AVCaptureVideoOrientation orientation <span class=\"token operator\">=</span> AVCaptureVideoOrientationLandscapeLeft<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>captureConnection setVideoOrientation<span class=\"token punctuation\">:</span>orientation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"配置设备\"><a href=\"#配置设备\" class=\"headerlink\" title=\"配置设备\"></a>配置设备</h4><p>在设置设备的相关属性前，我们需要使用 lockForConfiguration: 来获取一个对设备操作的锁，这样可以避免你在使用设备时被别的应用更改了设置而导致不兼容等问题。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>device isFocusModeSupported<span class=\"token punctuation\">:</span>AVCaptureFocusModeLocked<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    NSError <span class=\"token operator\">*</span>error <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>device lockForConfiguration<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        device<span class=\"token punctuation\">.</span>focusMode <span class=\"token operator\">=</span> AVCaptureFocusModeLocked<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>device unlockForConfiguration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Respond to the failure as appropriate.</span>\n            <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>你应该只在希望设备的设置不能被修改时保持设备锁，不正确的持有设备锁可能会影响其他程序的录制质量。</p>\n<h4 id=\"设备切换\"><a href=\"#设备切换\" class=\"headerlink\" title=\"设备切换\"></a>设备切换</h4><p>有时候你可能需要在使用时切换设备，比如切换前后摄像头。这时为了避免卡顿或者闪屏，我们可以重新配置一个正在执行的 <code>session</code>，但是我们在修改前后需要分别使用 <code>beginConfiguration</code> 和 <code>commitConfiguration:</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureSession <span class=\"token operator\">*</span>session <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A capture session#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>session beginConfiguration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>session removeInput<span class=\"token punctuation\">:</span>frontFacingCameraDeviceInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>session addInput<span class=\"token punctuation\">:</span>backFacingCameraDeviceInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>session commitConfiguration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当最外的 <code>commitConfiguration</code> 被调用时，所有的配置修改会被一起提交，这样可以保证平滑的切换。</p>\n<h2 id=\"使用-Capture-Inputs-来给一个-Session-添加设备\"><a href=\"#使用-Capture-Inputs-来给一个-Session-添加设备\" class=\"headerlink\" title=\"使用 Capture Inputs 来给一个 Session 添加设备\"></a>使用 Capture Inputs 来给一个 Session 添加设备</h2><p>我们可以用 <code>AVCaptureDeviceInput</code> 来给一个 <code>session</code> 添加设备。<code>AVCaptureDeviceInput</code> 是用来管理设备的端口。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\nAVCaptureDeviceInput <span class=\"token operator\">*</span>input <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDeviceInput deviceInputWithDevice<span class=\"token punctuation\">:</span>device error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle the error appropriately.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们用 <code>addInput:</code> 来添加设备。我们还可以在添加前用 <code>canAddInput:</code> 来检查一下。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureSession <span class=\"token operator\">*</span>captureSession <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a capture session#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVCaptureDeviceInput <span class=\"token operator\">*</span>captureDeviceInput <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a capture device input#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>captureSession canAddInput<span class=\"token punctuation\">:</span>captureDeviceInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>captureSession addInput<span class=\"token punctuation\">:</span>captureDeviceInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle the failure.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>AVCaptureInput</code> 声明一个或者多个媒体数据流。例如，输入设备可以同时提供音频和视频数据。输入提供的每个媒体流都被一个 <code>AVCaptureInputPort</code> 所表示。一个会话使用 <code>AVCaptureConnection</code> 对象来定义一组 <code>AVCaptureInputPort</code> 对象和一个 <code>AVCaptureOutput</code> 之间的映射。</p>\n<h2 id=\"使用-Capture-Outputs-来从一个-Session-获取输出\"><a href=\"#使用-Capture-Outputs-来从一个-Session-获取输出\" class=\"headerlink\" title=\"使用 Capture Outputs 来从一个 Session 获取输出\"></a>使用 Capture Outputs 来从一个 Session 获取输出</h2><p>要从一个 <code>capture session</code> 中获取输出，我们需要给它添加一个或多个输出实例，输出实例都是 <code>AVCaptureOutput</code> 的子类。比如：</p>\n<ul>\n<li>AVCaptureMovieFileOutput，输出电影文件。</li>\n<li>AVCaptureVideoDataOutput，当我们需要处理录制得到的视频帧时（比如创建自定义的渲染层），可以用这个。</li>\n<li>AVCaptureAudioDataOutput，当我们需要处理录制到的音频数据时，可以用这个。</li>\n<li>AVCaptureStillImageOutput，当我们需要获取静态图片以及对应的 metadata 时，可以用这个。<br>我们可以使用 <code>addOutput:</code> 向 <code>session</code> 中添加输出实例，我们也可以在加之前，通过 <code>canAddOutput:</code> 来检测要添加的输出实例是否是兼容的。我们可以往一个正在运行状态的 <code>session</code> 中添加输出实例。</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureSession <span class=\"token operator\">*</span>captureSession <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a capture session#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVCaptureMovieFileOutput <span class=\"token operator\">*</span>movieOutput <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Create and configure a movie output#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>captureSession canAddOutput<span class=\"token punctuation\">:</span>movieOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>captureSession addOutput<span class=\"token punctuation\">:</span>movieOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle the failure.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"保存电影文件\"><a href=\"#保存电影文件\" class=\"headerlink\" title=\"保存电影文件\"></a>保存电影文件</h2><p>使用 <code>AVCaptureMovieFileOutput</code> 将音视频数据保存到文件中时，我们可以做一些输出设置，比如最大录制时长、最大文件尺寸等等。我们还能够在硬盘空间不够时停止录制。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureMovieFileOutput <span class=\"token operator\">*</span>aMovieFileOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureMovieFileOutput alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCMTime maxDuration <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Create a CMTime to represent the maximum duration#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\naMovieFileOutput<span class=\"token punctuation\">.</span>maxRecordedDuration <span class=\"token operator\">=</span> maxDuration<span class=\"token punctuation\">;</span>\naMovieFileOutput<span class=\"token punctuation\">.</span>minFreeDiskSpaceLimit <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An appropriate minimum given the quality of the movie format and the duration#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>录制时输出的分辨率和码率是根据 capture session 的 sessionPreset 属性而定的。其中视频的编码类型是 H.264，音频的编码类型是 AAC，这个也是由不同的设备类型决定的。</p>\n<h4 id=\"开始录制\"><a href=\"#开始录制\" class=\"headerlink\" title=\"开始录制\"></a>开始录制</h4><p>我们通过 <code>startRecordingToOutputFileURL:recordingDelegate:</code> 来开始录制，这时你需要提供一个文件 <code>URL</code> 和一个 <code>delegate</code>。这个 <code>URL</code> 不能指向已存在的文件，因为这里的音视频输出不会去覆盖已有的资源。同时我们也必须要有对这个 <code>URL</code> 指向位置的写权限。这里的 <code>delegate</code> 必须遵循 <code>AVCaptureFileOutputRecordingDelegate</code> 协议，而且必须实现 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureMovieFileOutput <span class=\"token operator\">*</span>aMovieFileOutput <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a movie file output#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nNSURL <span class=\"token operator\">*</span>fileURL <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#A file URL that identifies the output location#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>aMovieFileOutput startRecordingToOutputFileURL<span class=\"token punctuation\">:</span>fileURL recordingDelegate<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#The delegate#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法中，<code>delegate</code> 可以将最终输出的文件写入相册，同时也需要检查和处理各种可能出现的错误。</p>\n<h4 id=\"确保文件写入成功\"><a href=\"#确保文件写入成功\" class=\"headerlink\" title=\"确保文件写入成功\"></a>确保文件写入成功</h4><p>要确保文件是否成功，我们可以在 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法中检查 <code>AVErrorRecordingSuccessfullyFinishedKey</code>。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>captureOutput<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>AVCaptureFileOutput <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>captureOutput didFinishRecordingToOutputFileAtURL<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSURL <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>outputFileURL fromConnections<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSArray <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>connections error<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSError <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>error <span class=\"token punctuation\">{</span>\n\n    BOOL recordedSuccessfully <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>error code<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// A problem occurred: Find out if the recording was successful.</span>\n        id value <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>error userInfo<span class=\"token punctuation\">]</span> objectForKey<span class=\"token punctuation\">:</span>AVErrorRecordingSuccessfullyFinishedKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            recordedSuccessfully <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>value boolValue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Continue as appropriate...</span>\n</code></pre>\n<p>我们需要检查 <code>error</code> 的 <code>userInfo</code> 的 <code>AVErrorRecordingSuccessfullyFinishedKey</code> 对应的值，因为有时候即使我们收到了错误，文件也可能是保存成功的，这时候，有可能是触及了我们设置的某些限制，比如 <code>AVErrorMaximumDurationReached</code> 或者 <code>AVErrorMaximumFileSizeReached</code>，其他的原因还有：</p>\n<ul>\n<li>AVErrorDiskFull，磁盘空间不够。</li>\n<li>AVErrorDeviceWasDisconnected，录制设备断开连接。</li>\n<li>AVErrorSessionWasInterrupted，录制 <code>session</code> 被打断了，比如来电话了。</li>\n</ul>\n<h4 id=\"给文件添加-Metadata\"><a href=\"#给文件添加-Metadata\" class=\"headerlink\" title=\"给文件添加 Metadata\"></a>给文件添加 Metadata</h4><p>我们可以在任何时候给录制的文件设置 <code>metadata</code>，即使是在录制过程中。文件的 <code>metadata</code> 是由一系列的 <code>AVMetadataItem</code> 对象表示，我们可以用 <code>AVMutableMetadataItem</code> 来创建我们自己的 <code>metadata</code>。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureMovieFileOutput <span class=\"token operator\">*</span>aMovieFileOutput <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a movie file output#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>existingMetadataArray <span class=\"token operator\">=</span> aMovieFileOutput<span class=\"token punctuation\">.</span>metadata<span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>newMetadataArray <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>existingMetadataArray<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    newMetadataArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>existingMetadataArray mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    newMetadataArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableArray alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nAVMutableMetadataItem <span class=\"token operator\">*</span>item <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVMutableMetadataItem alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nitem<span class=\"token punctuation\">.</span>keySpace <span class=\"token operator\">=</span> AVMetadataKeySpaceCommon<span class=\"token punctuation\">;</span>\nitem<span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> AVMetadataCommonKeyLocation<span class=\"token punctuation\">;</span>\n\nCLLocation <span class=\"token operator\">*</span>location <span class=\"token operator\">-</span> <span class=\"token operator\">&lt;</span>#The location to set#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nitem<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%+08.4lf%+09.4lf/\"</span> location<span class=\"token punctuation\">.</span>coordinate<span class=\"token punctuation\">.</span>latitude<span class=\"token punctuation\">,</span> location<span class=\"token punctuation\">.</span>coordinate<span class=\"token punctuation\">.</span>longitude<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>newMetadataArray addObject<span class=\"token punctuation\">:</span>item<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\naMovieFileOutput<span class=\"token punctuation\">.</span>metadata <span class=\"token operator\">=</span> newMetadataArray<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"处理视频帧\"><a href=\"#处理视频帧\" class=\"headerlink\" title=\"处理视频帧\"></a>处理视频帧</h4><p><code>AVCaptureVideoDataOutput</code><br> 对象使用代理来对外暴露视频帧，我们通过 <code>setSampleBufferDelegate:queue:</code><br> 来设置代理。除了设置代理以外，还需要设置一个 <code>serial queue</code> 来供代理调用，这里必须使用 <code>serial queue</code> 来保证传给 <code>delegate</code> 的帧数据的顺序正确。我们可以使用这个 queue 来分发和处理视频帧，这里可以参考一下例子 <a href=\"https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190\" target=\"_blank\" rel=\"external\">SquareCam</a>。<br><code>captureOutput:didOutputSampleBuffer:fromConnection:</code><br> 中输出的视频帧数据是用 <code>CMSampleBufferRef</code><br> 来表示的。默认情况下，这个 <code>buffer</code> 的数据格式来自于相机能最高效处理的格式。我们可以通过 <code>videoSettings</code><br> 来设置一个自定义的输出格式，这个值是一个字典，现在支持的键包括 <code>kCVPixelBufferPixelFormatTypeKey</code><br>。推荐的 <code>pixel formats</code> 可以通过 <code>availableVideoCVPixelFormatTypes</code><br> 属性获得，此外还能通过 <code>availableVideoCodecTypes</code><br> 获得支持编码类型。<code>Core Graphics</code> 和 <code>OpenGL</code> 都能很好地处理 <code>BGRA</code><br> 格式。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureVideoDataOutput <span class=\"token operator\">*</span>videoDataOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureVideoDataOutput new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>NSDictionary <span class=\"token operator\">*</span>newSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> kCVPixelBufferPixelFormatTypeKey<span class=\"token punctuation\">:</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>kCVPixelFormatType_32BGRA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>videoDataOutput<span class=\"token punctuation\">.</span>videoSettings <span class=\"token operator\">=</span> newSettings<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// discard if the data output queue is blocked (as we process the still image[videoDataOutput setAlwaysDiscardsLateVideoFrames:YES];)// create a serial dispatch queue used for the sample buffer delegate as well as when a still image is captured// a serial dispatch queue must be used to guarantee that video frames will be delivered in order// see the header doc for setSampleBufferDelegate:queue: for more informationvideoDataOutputQueue = dispatch_queue_create(\"VideoDataOutputQueue\", DISPATCH_QUEUE_SERIAL);[videoDataOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];AVCaptureSession *captureSession = &lt;#The Capture Session#>;if ([captureSession canAddOutput:videoDataOutput]) { [captureSession addOutput:videoDataOutput];}</span>\n</code></pre>\n<h4 id=\"处理视频的性能问题\"><a href=\"#处理视频的性能问题\" class=\"headerlink\" title=\"处理视频的性能问题\"></a>处理视频的性能问题</h4><p>对于我们的应用，设置够用的分辨率就好了，不要太高，那样性能会降低。</p>\n<p>我们需要确保，在 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中处理视频帧的时间开销不要超过分配给一帧的处理时长。如果这里处理的太长，那么 <code>AV Foundation</code> 将会停止发送视频帧给代理，也会停止发给其他输出端，比如 <code>preview layer</code>。</p>\n<p>你可以使用 <code>AVCaptureVideoDataOutput</code> 的 <code>minFrameDuration</code> 属性来确保你有足够的时间来处理一帧。同时，我们还可以设置 <code>alwaysDiscardsLateVideoFrames</code> 为 YES 来确保晚到的帧会被丢掉来避免延迟。如果你不介意延迟，而更想要处理更多的帧，那就设置这个值为 NO，但是这并不意味着不会丢帧，只是不会被那么早或那么高效的丢掉。</p>\n<h2 id=\"截取静态图片\"><a href=\"#截取静态图片\" class=\"headerlink\" title=\"截取静态图片\"></a>截取静态图片</h2><p>当我们想要截取带着 <code>metadata</code> 的静态图片时，我们可以用 <code>AVCaptureStillImageOutput</code>。截出的图的分辨率依赖于 <code>session</code> 的 <code>preset</code> 和具体的设备。</p>\n<h4 id=\"像素和编码类型\"><a href=\"#像素和编码类型\" class=\"headerlink\" title=\"像素和编码类型\"></a>像素和编码类型</h4><p>不同的类型支持不同的图片格式。我们可以用 <code>availableImageDataCVPixelFormatTypes</code> 和 <code>availableImageDataCodecTypes</code> 来检查当前的设备支持的像素类型和编码类型。然后，我们可以通过设置 <code>outputSettings</code> 属性指定图片的格式。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureStillImageOutput <span class=\"token operator\">*</span>stillImageOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureStillImageOutput alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSDictionary <span class=\"token operator\">*</span>outputSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>AVVideoCodecKey<span class=\"token punctuation\">:</span> AVVideoCodecJPEG<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>stillImageOutput setOutputSettings<span class=\"token punctuation\">:</span>outputSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n`\n</code></pre>\n<p>如果我们要截取一张 JPEG 图片，你最好不要指定你自己的压缩格式，相反，你需要做的是让 <code>AVCaptureStillImageOutput</code> 帮你做压缩，因为它使用硬件加速来压缩。如果这时你需要图像的数据，可以用 <code>jpegStillImageNSDataRepresentation:</code> 来获取对应的 <code>NSData</code> 对象，这个数据是未经压缩的，甚至你都可以修改它。</p>\n<h4 id=\"捕获图像\"><a href=\"#捕获图像\" class=\"headerlink\" title=\"捕获图像\"></a>捕获图像</h4><p>当截图时，我们使用 <code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code>方法，其中的第一个参数是对应的 <code>connection</code>，这是你需要查找一下哪个 <code>connection</code> 的输出端口是在手机视频：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureConnection <span class=\"token operator\">*</span>videoConnection <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>AVCaptureConnection <span class=\"token operator\">*</span>connection <span class=\"token keyword\">in</span> stillImageOutput<span class=\"token punctuation\">.</span>connections<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>AVCaptureInputPort <span class=\"token operator\">*</span>port <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span>connection inputPorts<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>port mediaType<span class=\"token punctuation\">]</span> isEqual<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            videoConnection <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>videoConnection<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第二个参数是一个 <code>block</code> 回调，其中带回两个参数：一个包含图像数据的 <code>CMSampleBuffer</code>，一个 <code>NSError</code>。这个 <code>sample buffer</code> 中可能包含着 <code>metadata</code>，比如一个 EXIF 字典作为附属信息。我们可以去修改附属信息，但是需要注意针对 JPEG 图像的像素和编码上的优化。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>stillImageOutput captureStillImageAsynchronouslyFromConnection<span class=\"token punctuation\">:</span>videoConnection completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>CMSampleBufferRef imageSampleBuffer<span class=\"token punctuation\">,</span> NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CFDictionaryRef exifAttachments <span class=\"token operator\">=</span>\n        <span class=\"token function\">CMGetAttachment</span><span class=\"token punctuation\">(</span>imageSampleBuffer<span class=\"token punctuation\">,</span> kCGImagePropertyExifDictionary<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exifAttachments<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Do something with the attachments.</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Continue as appropriate.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h2><h4 id=\"视频预览\"><a href=\"#视频预览\" class=\"headerlink\" title=\"视频预览\"></a>视频预览</h4><p>我们可以用 <code>AVCaptureVideoPreviewLayer</code> 来给用户提供预览，我们不需要任何 <code>output</code> 对象来展示预览。此外，我们可以使用 <code>AVCaptureVideoDataOutput</code> 来在给用户预览之前获取到图像像素级别的数据。</p>\n<p>Unlike a capture output, a video preview layer maintains a strong reference to the session with which it is associated. This is to ensure that the session is not deallocated while the layer is attempting to display video. This is reflected in the way you initialize a preview layer:</p>\n<p>不像 <code>capture output</code>，一个 <code>video preview layer</code> 会持有一个关联 <code>session</code> 的强引用。这样来防止 <code>layer</code> 在展示预览时而 <code>session</code> 被释放引起问题。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureSession <span class=\"token operator\">*</span>captureSession <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a capture session#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nCALayer <span class=\"token operator\">*</span>viewLayer <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a layer from the view <span class=\"token keyword\">in</span> which you want to present the preview#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\nAVCaptureVideoPreviewLayer <span class=\"token operator\">*</span>captureVideoPreviewLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureVideoPreviewLayer alloc<span class=\"token punctuation\">]</span> initWithSession<span class=\"token punctuation\">:</span>captureSession<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>viewLayer addSublayer<span class=\"token punctuation\">:</span>captureVideoPreviewLayer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>一般来说，<code>preview layer</code> 和其他 <code>CALayer</code> 对象一样，我们可以缩放它的图像，执行变换，旋转。一个不同的地方是，我们需要设置 <code>layer</code> 的 <code>orientation</code> 属性来指定它改如何旋转从相机获得的图像。此外，我们可以用 <code>supportsVideoMirroring</code> 来测试设备是否支持视频镜面效果(左右翻转)，我们可以设置 <code>videoMirrored</code> 来配置是否开启镜面效果，即使 <code>automaticallyAdjustsVideoMirroring</code> 被设置为默认的 YES 也没问题(这个值是在配置 <code>session</code> 时被自动设置的)。</p>\n<h4 id=\"视频重力模式\"><a href=\"#视频重力模式\" class=\"headerlink\" title=\"视频重力模式\"></a>视频重力模式</h4><p>我们可以通过 <code>videoGravity</code><br> 属性设置视频重力模式，比如：</p>\n<ul>\n<li>AVLayerVideoGravityResizeAspect<br>，保持视频的宽高比；不一定完全填充，可能留黑边；不裁剪视频，。</li>\n<li>AVLayerVideoGravityResizeAspectFill<br>，保持视频的宽高比；完全填充，不留黑边；可能裁剪视频。</li>\n<li>AVLayerVideoGravityResize<br>，不保持视频宽高比，可能扭曲画面；完全填充；不裁剪视频。</li>\n</ul>\n<h4 id=\"使用预览时的点击聚焦\"><a href=\"#使用预览时的点击聚焦\" class=\"headerlink\" title=\"使用预览时的点击聚焦\"></a>使用预览时的点击聚焦</h4><p>需要注意的是，在实现点击聚焦时必须考虑到该层的预览方向和重力，并考虑预览变为镜像显示的可能性。可以参考实例项目：<a href=\"https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112\" target=\"_blank\" rel=\"external\">AVCam-iOS: Using AVFoundation to Capture Images and Movies</a>。</p>\n<h2 id=\"显示音频等级\"><a href=\"#显示音频等级\" class=\"headerlink\" title=\"显示音频等级\"></a>显示音频等级</h2><p>To monitor the average and peak power levels in an audio channel in a capture connection, you use an AVCaptureAudioChannel object. Audio levels are not key-value observable, so you must poll for updated levels as often as you want to update your user interface (for example, 10 times a second).</p>\n<p>要监测 capture connection 中音频通道的平均强度和峰值强度，我们可以用 <code>AVCaptureAudioChannel</code>。音频等级是不支持 KVO 监测的，所以当我们想更新用户界面时，我们需要去查询。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVCaptureAudioDataOutput <span class=\"token operator\">*</span>audioDataOutput <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get the audio data output#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>connections <span class=\"token operator\">=</span> audioDataOutput<span class=\"token punctuation\">.</span>connections<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>connections count<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// There should be only one connection to an AVCaptureAudioDataOutput.</span>\n    AVCaptureConnection <span class=\"token operator\">*</span>connection <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>connections objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    NSArray <span class=\"token operator\">*</span>audioChannels <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>audioChannels<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>AVCaptureAudioChannel <span class=\"token operator\">*</span>channel <span class=\"token keyword\">in</span> audioChannels<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">float</span> avg <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span>averagePowerLevel<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">float</span> peak <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span>peakHoldLevel<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Update the level meter user interface.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h2><p>这里的示例代码将展示如何获取视频并转化为 UIImage。大概包括下面几步：</p>\n<ul>\n<li>创建一个 AVCaptureSession 对象来协调输入设备到输出的数据流。</li>\n<li>找到我们想要的 AVCaptureDevice。</li>\n<li>为 device 创建一个 AVCaptureDeviceInput 对象。</li>\n<li>创建 AVCaptureVideoDataOutput 来输出视频帧。</li>\n<li>实现 AVCaptureVideoDataOutput 的 delegate 方法来处理视频帧。</li>\n<li>在实现的代理方法中将 CMSampleBuffer 转为 UIImage。<br>代码如下：</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 创建并配置 Capture Session：</span>\nAVCaptureSession <span class=\"token operator\">*</span>session <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureSession alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nsession<span class=\"token punctuation\">.</span>sessionPreset <span class=\"token operator\">=</span> AVCaptureSessionPresetMedium<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建和配置 Device 和 Device Input：</span>\nAVCaptureDevice <span class=\"token operator\">*</span>device <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDevice defaultDeviceWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nNSError <span class=\"token operator\">*</span>error <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\nAVCaptureDeviceInput <span class=\"token operator\">*</span>input <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDeviceInput deviceInputWithDevice<span class=\"token punctuation\">:</span>device error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Handle the error appropriately.</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span>session addInput<span class=\"token punctuation\">:</span>input<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建和配置 Video Data Output：</span>\nAVCaptureVideoDataOutput <span class=\"token operator\">*</span>output <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVCaptureVideoDataOutput alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>session addOutput<span class=\"token punctuation\">:</span>output<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\noutput<span class=\"token punctuation\">.</span>videoSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> kCVPixelBufferPixelFormatTypeKey<span class=\"token punctuation\">:</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>kCVPixelFormatType_32BGRA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\noutput<span class=\"token punctuation\">.</span>minFrameDuration <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 设置 Video Data Output 的 delegate 和处理队列：</span>\ndispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyQueue\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>output setSampleBufferDelegate<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> queue<span class=\"token punctuation\">:</span>queue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>代理方法实现：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>captureOutput<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>AVCaptureOutput <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>captureOutput didOutputSampleBuffer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CMSampleBufferRef<span class=\"token punctuation\">)</span>sampleBuffer fromConnection<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>AVCaptureConnection <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>connection <span class=\"token punctuation\">{</span>\n\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">imageFromSampleBuffer</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Add your code here that uses the image.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>开始录制：</p>\n<p>录制前，还需要注意申请相机权限：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 申请权限：</span>\nNSString <span class=\"token operator\">*</span>mediaType <span class=\"token operator\">=</span> AVMediaTypeVideo<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>AVCaptureDevice requestAccessForMediaType<span class=\"token punctuation\">:</span>mediaType completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>BOOL granted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>granted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//Granted access to mediaType</span>\n        <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setDeviceAuthorized<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//Not granted access to mediaType</span>\n        <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIAlertView alloc<span class=\"token punctuation\">]</span> initWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"AVCam!\"</span>\n                                    message<span class=\"token punctuation\">:</span><span class=\"token string\">@\"AVCam doesn't have permission to use Camera, please change privacy settings\"</span>\n                                   delegate<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span>\n                          cancelButtonTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"OK\"</span>\n                          otherButtonTitles<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span> show<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setDeviceAuthorized<span class=\"token punctuation\">:</span>NO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>开始录制方法：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>session startRunning<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>停止录制方法：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>session stopRunning<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"高帧率视频获取\"><a href=\"#高帧率视频获取\" class=\"headerlink\" title=\"高帧率视频获取\"></a>高帧率视频获取</h4><p>iOS 7 以后在一些设备中引入了高帧率视频捕获的支持。我们可以通过 <code>AVCaptureDeviceFormat</code> 来查询设备支持的媒体类型、帧率、缩放比、视频防抖等。在 AVFoundation 中：</p>\n<ul>\n<li>支持捕获分辨率 720p 及以上、帧率 60 fps、视频防抖、P 帧丢帧。</li>\n<li>播放方面增强了对音频加速和慢速播放的支持。</li>\n<li>编辑方面提供了全面的编辑能力支持。</li>\n<li>输出方面支持两种方式输出帧率达 60 fps 的影视文件。一种是输出为可变帧率，支持慢速或快速播放。另一种是输出为任意指定帧率，比如 30 fps。<br>需要注意的是，现在最新的 iOS 版本支持的能力会比以上这些更多更强大。</li>\n</ul>\n<h4 id=\"播放\"><a href=\"#播放\" class=\"headerlink\" title=\"播放\"></a>播放</h4><p>播放时，可以通过 <code>AVPlayer</code> 设置 <code>rate</code> 属性来设置播放速率。</p>\n<p><code>AVPlayerItem</code> 可以支持通过 <code>audioTimePitchAlgorithm</code> 属性来设置当你用不同的速率播放视频时，该如何播放音频。以下是相关选项：</p>\n<ul>\n<li>AVAudioTimePitchAlgorithmLowQualityZeroLatency，较低音质，适应多种播放速率。适宜的速率：0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0.</li>\n<li>AVAudioTimePitchAlgorithmTimeDomain，普通音质。适宜的速率：0.5–2x。</li>\n<li>AVAudioTimePitchAlgorithmSpectral，最高音质，性能消耗较大。适宜的速率：1/32–32。</li>\n<li>AVAudioTimePitchAlgorithmVarispeed，高音质。适宜的速率：1/32–32。</li>\n</ul>\n<h4 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h4><p>通常使用 <code>AVMutableComposition</code> 来做音视频编辑：</p>\n<p>使用 <code>composition</code> 类方法类创建 <code>AVMutableComposition</code> 对象。<br>使用 <code>insertTimeRange:ofAsset:atTime:error:</code> 来插入音视频数据。<br>使用 <code>scaleTimeRange:toDuration:</code> 来设置音视频数据的时间区间。<br>导出</p>\n<p>可以使用 <code>AVAssetExportSession</code> 来导出 60 fps 的视频，可以用以下两种方式：</p>\n<p>使用 <code>AVAssetExportPresetPassthrough preset</code> 来编码重新编码视频。它会重新处理那些标记为 60 fps、降速、加速区域的时间。<br>使用一个固定帧率来保证导出视频的最大兼容性。比如设置 <code>video composition</code> 的 <code>frameDuration</code> 为 30 fps。比如设置 <code>export session</code> 的 <code>audioTimePitchAlgorithm</code> 来配置音频播放选项。<br>录制</p>\n<p>我们用 <code>AVCaptureMovieFileOutput</code> 来录制高帧率的视频，它会默认支持高帧率的视频录制，会默认选择正确的 H264 pitch level 和比特率。</p>\n<p>如果想要做一些自定义录制，我们必须使用 <code>AVAssetWriter</code>，这个则需要一些额外的创建过程。</p>\n<p>通常我们需要设置一下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">etWriterInput<span class=\"token punctuation\">.</span>expectsMediaDataInRealTime <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>来保证视频捕获能跟得上传入的数据。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(4)：音视频录制 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>采集设备的音视频时，我们需要组装各路数据，这时可以使用 AVCaptureSession 对象来协调。</p>\n<ul>\n<li>一个 <code>AVCaptureDevice</code> 对象表示输入设备，比如摄像头或者麦克风。</li>\n<li>一个 <code>AVCaptureInput</code> 具体子类的实例可以用来配置输出设备的端口。</li>\n<li>一个 <code>AVCaptureOutput</code> 具体子类的实例可以用来将音视频数据输出到一个视频文件或静态图片。</li>\n<li>一个 <code>AVCaptureSession</code> 实例用来协调输入输出的数据流。<br>在录制视频时，为了让用户看到预览效果，我们可以使用 <code>AVCaptureVideoPreviewLayer</code>。</li>\n</ul>\n<p>下图展示了通过一个 <code>capture session</code> 实例来协调多路输入输出数据：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B61.png\" alt=\"图一\"></p>\n<p>对于大多数应用场景，这些细节已经足够我们用了。但是对于有些操作，比如当我们想要监测一个音频通道的强度，我们需要了解不同的输入设备的端口对应的对象，以及这些端口和输出是如何连接起来的。</p>\n<p>在音视频录制时，输入和输出之间的连接是用 <code>AVCaptureConnection</code> 来表示的。输入方(<code>AVCaptureInput</code>)包含一个或多个输入端口(<code>AVCaptureInputPort</code>)，输出端(<code>AVCaptureOutput</code>)可以从一个或多个数据源接收数据，比如一个 <code>AVCaptureMovieFileOutput</code> 就可以同时接收视频和音频数据。</p>\n<p>当你往一次录制 <code>session</code> 中添加一个输入或输出时，这个 <code>session</code> 会生成所有兼容的输入和输出端口间的连接，由 <code>AVCaptureConnection</code> 对象表示。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B62.png\" alt=\"图二\"></p>\n<p>You can use a capture connection to enable or disable the flow of data from a given input or to a given output. You can also use a connection to monitor the average and peak power levels in an audio channel.</p>\n<p>我们可以用 <code>connetion</code> 对象来控制输入输出端之间的数据流的断开或连接，我们还能用它来监控 <code>audio</code> 通道的平均值和峰值。</p>\n<h2 id=\"使用-Capture-Session-来协调数据流\"><a href=\"#使用-Capture-Session-来协调数据流\" class=\"headerlink\" title=\"使用 Capture Session 来协调数据流\"></a>使用 Capture Session 来协调数据流</h2><p><code>AVCaptureSession</code> 是我们用来管理数据捕获的核心协调者，我们用它来协调音视频输入和输出端的数据流。我们可以将我们需要的捕获设备添加到 <code>session</code> 中，然后用 <code>startRunning</code> 接口启动数据流，用 <code>stopRunning</code> 停止数据流。</p>\n<pre><code class=\"objectivec\">AVCaptureSession *session = [[AVCaptureSession alloc] init];\n// Add inputs and outputs.\n[session startRunning];\n</code></pre>\n<h4 id=\"配置-Session\"><a href=\"#配置-Session\" class=\"headerlink\" title=\"配置 Session\"></a>配置 Session</h4><p>我们可以给 <code>session</code> 设置我们需要的图像质量和分辨率。以下是其中的几个配置选项：</p>\n<ul>\n<li>AVCaptureSessionPresetHigh，高分辨率，具体值取决于设备能提供的最高分辨率。</li>\n<li>AVCaptureSessionPresetMedium，中等分辨率，具体值取决于设备。</li>\n<li>AVCaptureSessionPresetLow，低分辨率，具体指取决于设备。</li>\n<li>AVCaptureSessionPreset640x480，分辨率为 640x480，常称为 480P。</li>\n<li>AVCaptureSessionPreset1280x720，分辨率为 1280x720，常称为 720P。</li>\n<li>AVCaptureSessionPresetPhoto，全尺寸相片的分辨率，这个选项不支持输出视频。<br>如果要使用某种分辨率选项，我们需要先测试一下设备是否支持：</li>\n</ul>\n<pre><code class=\"objectivec\">if ([session canSetSessionPreset:AVCaptureSessionPreset1280x720]) {\n    session.sessionPreset = AVCaptureSessionPreset1280x720;\n}\nelse {\n    // Handle the failure.\n}\n</code></pre>\n<p>如果想对 <code>session</code> 的配置参数做更细粒度的控制，或者想修改已经在运行状态的 <code>session</code> 的配置参数，我们需要在 <code>beginConfiguration</code> 和 <code>commitConfiguration</code> 方法直接做修改。这两个方法的配合，可以使得我们队设备的修改是以一个 <code>group</code> 的方式提交，从而尽量避免视觉或者状态上的不一致性。在调用了 <code>beginConfiguration</code> 之后，我们可以增加或删除输出端，修改 <code>sessionPreset</code> 值，单独配置视频捕获的输入或输出参数。知道我们调用了 <code>commitConfiguration</code>，这些修改采用被提交并一起应用。</p>\n<pre><code class=\"objectivec\">[session beginConfiguration];\n// Remove an existing capture device.\n// Add a new capture device.\n// Reset the preset.\n[session commitConfiguration];\n</code></pre>\n<h4 id=\"监控-Session-状态\"><a href=\"#监控-Session-状态\" class=\"headerlink\" title=\"监控 Session 状态\"></a>监控 Session 状态</h4><p>录制过程中 <code>session</code> 会发出通知来告知其对应的状态，比如 <code>session</code> 开始、结束、被打断。我们可以从 <code>AVCaptureSessionRuntimeErrorNotification</code> 来接收 <code>session</code> 运行时的错误。我们也可以差选 <code>session</code> 的运行时属性来获取其状态是在运行中还是被打断。此外，这些属性都是支持 <code>KVO</code> 监测的，并且通知会被发送到主线程。</p>\n<h2 id=\"使用-AVCaptureDevice-来表示输入设备\"><a href=\"#使用-AVCaptureDevice-来表示输入设备\" class=\"headerlink\" title=\"使用 AVCaptureDevice 来表示输入设备\"></a>使用 AVCaptureDevice 来表示输入设备</h2><p><code>AVCaptureDevice</code> 是由我们现实中物理的提供输入数据（比如音频或视频输入）的设备抽象而来，每个 <code>AVCaptureDevice</code> 对象都对应着一个输入设备，比如我们常见的前置摄像头、后置摄像头、麦克风。它们采集的数据将会输出给 <code>AVCaptureSession</code> 实例。</p>\n<p>我们可以使用 <code>AVCaptureDevice</code> 的 <code>devices</code> 和 <code>devicesWithMediaType:</code> 类方法来检查哪些是当前可用的设备。如果需要，我们还可以获取设备支持哪些功能。当前可用的设备列表是会动态变化的，有些设备会因为被别的应用使用而变得不可用，有的设备也有可能突然就可用了，所以我们需要注册 <code>AVCaptureDeviceWasConnectedNotification</code> 和 <code>AVCaptureDeviceWasDisconnectedNotification</code> 通知来感知当前可用设备的变化情况。</p>\n<p>我们可以使用 <code>capture input</code> 来想向一个 <code>AVCaptureSession</code> 中添加输入设备。</p>\n<h4 id=\"设备特性\"><a href=\"#设备特性\" class=\"headerlink\" title=\"设备特性\"></a>设备特性</h4><p>我们可以查询采集设备的不同特性。比如，我们可以使用 hasMediaType: 接口来判断采集设备是否支持某种媒体类型，也可以使用 supportsAVCaptureSessionPreset: 接口来判断采集设备是否支持预设的 session preset。我们还能获取设备的位置、本地化命名等信息以便于展示给用户。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B63.png\" alt=\"图三\"></p>\n<p>下面的示例代码展示了如何遍历设备，并打印设备名：</p>\n<pre><code class=\"objectivec\">NSArray *devices = [AVCaptureDevice devices];\nfor (AVCaptureDevice *device in devices) {\n\n    NSLog(@&quot;Device name: %@&quot;, [device localizedName]);\n    if ([device hasMediaType:AVMediaTypeVideo]) {\n        if ([device position] == AVCaptureDevicePositionBack) {\n            NSLog(@&quot;Device position : back&quot;);\n        }\n        else {\n            NSLog(@&quot;Device position : front&quot;);\n        }\n    }\n}\n</code></pre>\n<p>此外，你还能查出设备的 model ID 和 unique ID。</p>\n<h2 id=\"设备录制设置\"><a href=\"#设备录制设置\" class=\"headerlink\" title=\"设备录制设置\"></a>设备录制设置</h2><p>不同的设备有不同的能力，比如有些设备支持不同的对焦或刷新模式。下面的代码展示了如何找到一个支持手电筒以及预设的 <code>preset</code> 的设备。</p>\n<pre><code class=\"objectivec\">NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];\nNSMutableArray *torchDevices = [[NSMutableArray alloc] init];\n\nfor (AVCaptureDevice *device in devices) {\n    [if ([device hasTorch] &amp;&amp;\n         [device supportsAVCaptureSessionPreset:AVCaptureSessionPreset640x480]) {\n        [torchDevices addObject:device];\n    }\n}\n</code></pre>\n<p>如果你找到多个设备，你可以向用户展示设备的 <code>localizedName</code> 来让用户选择他们需要的设备。在使用对应的设备时，我们可以设置设备的各种工作模式，但是有一点需要注意的是在设置前需要对设备加锁。</p>\n<h4 id=\"聚焦模式\"><a href=\"#聚焦模式\" class=\"headerlink\" title=\"聚焦模式\"></a>聚焦模式</h4><p>目前支持的聚焦模式有以下几种：</p>\n<ul>\n<li>AVCaptureFocusModeLocked：聚焦点固定。通常以拍摄场景的中点作为焦点。</li>\n<li>AVCaptureFocusModeAutoFocus：自动聚焦。这种模式可以让用户选择一件事物来进行对焦，即使对于的位置不是拍摄场景的中点。</li>\n<li>AVCaptureFocusModeContinuousAutoFocus：相机将持续自动对焦。<br>我们可以使用 isFocusModeSupported: 接口来检查设备是否支持相应的聚焦模式，然后设置对应的 focusMode 属性。</li>\n</ul>\n<p>我们还能用 <code>focusPointOfInterestSupported</code> 来检查设备是否支持指定焦点，如果支持，我们就可以设置对应的 <code>focusPointOfInterest</code>属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。</p>\n<p>我们可以访问 <code>adjustingFocus</code> 属性来获知相机是否正在对焦，这个属性是支持 KVO 的，所以我们可以监测它来获知对焦状态的变化。</p>\n<p>如果你修改过了相机的对焦模式相关的设置，你可以用下面的代码将其恢复到默认状态：</p>\n<pre><code class=\"objectivec\">if ([currentDevice isFocusModeSupported:AVCaptureFocusModeContinuousAutoFocus]) {\n    CGPoint autofocusPoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setFocusPointOfInterest:autofocusPoint];\n    [currentDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus];\n}\n</code></pre>\n<h4 id=\"曝光模式\"><a href=\"#曝光模式\" class=\"headerlink\" title=\"曝光模式\"></a>曝光模式</h4><p>目前支持的曝光模式有以下几种：</p>\n<ul>\n<li>AVCaptureExposureModeLocked，曝光等级锁定。</li>\n<li>AVCaptureExposureModeAutoExpose，相机自动根据情况调整一次曝光等级，然后将曝光模式切换到 AVCaptureExposureModeLocked。</li>\n<li>AVCaptureExposureModeContinuousAutoExposure，相机随时根据情况调整曝光等级。</li>\n<li>AVCaptureExposureModeCustom，用户自定义曝光等级。<br>我们可以通过 isExposureModeSupported: 来检查设备是否支持对应的模式，然后设置对应的 exposureMode 属性。</li>\n</ul>\n<p>我们还能用 <code>exposurePointOfInterestSupported</code> 来检查设备是否支持指定曝光点，如果支持，我们就可以设置对应的 <code>exposurePointOfInterest</code> 属性。其中 {0, 0} 表示左上角，{1, 1} 表示右下角。</p>\n<p>我们可以访问 <code>adjustingExposure</code> 属性来获知相机是否正在改变曝光设置，这个属性是支持 KVO 的，所以我们可以监测它来获知曝光状态的变化。</p>\n<p>如果你修改过了相机的曝光模式相关的设置，你可以用下面的代码将其恢复到默认状态：</p>\n<pre><code class=\"objectivec\">if ([currentDevice isExposureModeSupported:AVCaptureExposureModeContinuousAutoExposure]) {\n    CGPoint exposurePoint = CGPointMake(0.5f, 0.5f);\n    [currentDevice setExposurePointOfInterest:exposurePoint];\n    [currentDevice setExposureMode:AVCaptureExposureModeContinuousAutoExposure];\n}\n</code></pre>\n<h4 id=\"闪光灯模式\"><a href=\"#闪光灯模式\" class=\"headerlink\" title=\"闪光灯模式\"></a>闪光灯模式</h4><p>目前支持的闪光灯模式有如下几种：</p>\n<ul>\n<li>AVCaptureFlashModeOff，不会闪光。</li>\n<li>AVCaptureFlashModeOn，会闪光。</li>\n<li>AVCaptureFlashModeAuto，根据具体情况决定是否闪光。<br>我们可以通过 <code>hasFlash</code> 检查设备是否有闪光灯，可以通过 <code>isFlashModeSupported:</code> 检查设备是否支持对应的模式，通过 <code>flashMode</code> 设置对应的模式。</li>\n</ul>\n<h4 id=\"手电筒模式\"><a href=\"#手电筒模式\" class=\"headerlink\" title=\"手电筒模式\"></a>手电筒模式</h4><p>在手电筒模式下，闪光灯会以低耗电量模式持续打开来为图像录制来照明。目前支持的模式有以下几种：</p>\n<ul>\n<li>AVCaptureTorchModeOff，关闭。</li>\n<li>AVCaptureTorchModeOn，开启。</li>\n<li>AVCaptureTorchModeAuto，自动。<br>我们可以通过 <code>hasTorch</code> 检查设备是否有闪光灯，可以通过 <code>isTorchModeSupported:</code> 检查设备是否支持对应的手电筒模式，通过 <code>torchMode</code> 设置对应的模式。</li>\n</ul>\n<h4 id=\"视频防抖\"><a href=\"#视频防抖\" class=\"headerlink\" title=\"视频防抖\"></a>视频防抖</h4><p>视频防抖主要依赖于硬件，虽然如此，也不是所有的视频格式和分辨率都能支持。此外，开启防抖也会带来为视频录制带来一定的延迟。我们可以通过 <code>videoStabilizationEnabled</code> 来检查是否启动了防抖，通过 <code>enablesVideoStabilizationWhenAvailable</code> 来允许应用在条件支持的情况下自动开启防抖。</p>\n<h4 id=\"白平衡\"><a href=\"#白平衡\" class=\"headerlink\" title=\"白平衡\"></a>白平衡</h4><p>目前支持面几种白平衡模式：</p>\n<ul>\n<li>AVCaptureWhiteBalanceModeLocked，固定模式。</li>\n<li>AVCaptureWhiteBalanceModeAutoWhiteBalance，自动模式。相机根据情况调整一次白平衡，然后切换至 AVCaptureWhiteBalanceModeLocked 模式。</li>\n<li>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance，相机随时根据情况调整白平衡。<br>我们可以通过 <code>isWhiteBalanceModeSupported:</code> 检查是否支持给定的模式，然后通过 <code>whiteBalanceMode</code> 设置对应模式。</li>\n</ul>\n<p>我们可以访问 <code>adjustingWhiteBalance</code> 属性来获知相机是否正在改变白平衡设置，这个属性是支持 KVO 的，所以我们可以监测它来获知白平衡状态的变化。</p>\n<h4 id=\"设置方向\"><a href=\"#设置方向\" class=\"headerlink\" title=\"设置方向\"></a>设置方向</h4><p>我们可以通过 <code>AVCaptureConnection</code> 实例来设置想要在 AVCaptureOutput(AVCaptureMovieFileOutput, AVCaptureStillImageOutput, AVCaptureVideoDataOutput) 获得的图像方向。</p>\n<p>我们通过 <code>isVideoOrientationSupported</code> 检查是否支持改变视频方向，通过 <code>videoOrientation</code> 设置方向。</p>\n<p>下面是示例代码：</p>\n<pre><code class=\"objectivec\">AVCaptureConnection *captureConnection = &lt;#A capture connection#&gt;;\nif ([captureConnection isVideoOrientationSupported]) {\n    AVCaptureVideoOrientation orientation = AVCaptureVideoOrientationLandscapeLeft;\n    [captureConnection setVideoOrientation:orientation];\n}\n</code></pre>\n<h4 id=\"配置设备\"><a href=\"#配置设备\" class=\"headerlink\" title=\"配置设备\"></a>配置设备</h4><p>在设置设备的相关属性前，我们需要使用 lockForConfiguration: 来获取一个对设备操作的锁，这样可以避免你在使用设备时被别的应用更改了设置而导致不兼容等问题。</p>\n<pre><code class=\"objectivec\">if ([device isFocusModeSupported:AVCaptureFocusModeLocked]) {\n    NSError *error = nil;\n    if ([device lockForConfiguration:&amp;error]) {\n        device.focusMode = AVCaptureFocusModeLocked;\n        [device unlockForConfiguration];\n    }\n    else {\n        // Respond to the failure as appropriate.\n            }\n</code></pre>\n<p>你应该只在希望设备的设置不能被修改时保持设备锁，不正确的持有设备锁可能会影响其他程序的录制质量。</p>\n<h4 id=\"设备切换\"><a href=\"#设备切换\" class=\"headerlink\" title=\"设备切换\"></a>设备切换</h4><p>有时候你可能需要在使用时切换设备，比如切换前后摄像头。这时为了避免卡顿或者闪屏，我们可以重新配置一个正在执行的 <code>session</code>，但是我们在修改前后需要分别使用 <code>beginConfiguration</code> 和 <code>commitConfiguration:</code></p>\n<pre><code class=\"objectivec\">AVCaptureSession *session = &lt;#A capture session#&gt;;\n[session beginConfiguration];\n\n[session removeInput:frontFacingCameraDeviceInput];\n[session addInput:backFacingCameraDeviceInput];\n\n[session commitConfiguration];\n</code></pre>\n<p>当最外的 <code>commitConfiguration</code> 被调用时，所有的配置修改会被一起提交，这样可以保证平滑的切换。</p>\n<h2 id=\"使用-Capture-Inputs-来给一个-Session-添加设备\"><a href=\"#使用-Capture-Inputs-来给一个-Session-添加设备\" class=\"headerlink\" title=\"使用 Capture Inputs 来给一个 Session 添加设备\"></a>使用 Capture Inputs 来给一个 Session 添加设备</h2><p>我们可以用 <code>AVCaptureDeviceInput</code> 来给一个 <code>session</code> 添加设备。<code>AVCaptureDeviceInput</code> 是用来管理设备的端口。</p>\n<pre><code class=\"objectivec\">NSError *error;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];\nif (!input) {\n    // Handle the error appropriately.\n}\n</code></pre>\n<p>我们用 <code>addInput:</code> 来添加设备。我们还可以在添加前用 <code>canAddInput:</code> 来检查一下。</p>\n<pre><code class=\"objectivec\">AVCaptureSession *captureSession = &lt;#Get a capture session#&gt;;\nAVCaptureDeviceInput *captureDeviceInput = &lt;#Get a capture device input#&gt;;\nif ([captureSession canAddInput:captureDeviceInput]) {\n    [captureSession addInput:captureDeviceInput];\n}\nelse {\n    // Handle the failure.\n}\n</code></pre>\n<p><code>AVCaptureInput</code> 声明一个或者多个媒体数据流。例如，输入设备可以同时提供音频和视频数据。输入提供的每个媒体流都被一个 <code>AVCaptureInputPort</code> 所表示。一个会话使用 <code>AVCaptureConnection</code> 对象来定义一组 <code>AVCaptureInputPort</code> 对象和一个 <code>AVCaptureOutput</code> 之间的映射。</p>\n<h2 id=\"使用-Capture-Outputs-来从一个-Session-获取输出\"><a href=\"#使用-Capture-Outputs-来从一个-Session-获取输出\" class=\"headerlink\" title=\"使用 Capture Outputs 来从一个 Session 获取输出\"></a>使用 Capture Outputs 来从一个 Session 获取输出</h2><p>要从一个 <code>capture session</code> 中获取输出，我们需要给它添加一个或多个输出实例，输出实例都是 <code>AVCaptureOutput</code> 的子类。比如：</p>\n<ul>\n<li>AVCaptureMovieFileOutput，输出电影文件。</li>\n<li>AVCaptureVideoDataOutput，当我们需要处理录制得到的视频帧时（比如创建自定义的渲染层），可以用这个。</li>\n<li>AVCaptureAudioDataOutput，当我们需要处理录制到的音频数据时，可以用这个。</li>\n<li>AVCaptureStillImageOutput，当我们需要获取静态图片以及对应的 metadata 时，可以用这个。<br>我们可以使用 <code>addOutput:</code> 向 <code>session</code> 中添加输出实例，我们也可以在加之前，通过 <code>canAddOutput:</code> 来检测要添加的输出实例是否是兼容的。我们可以往一个正在运行状态的 <code>session</code> 中添加输出实例。</li>\n</ul>\n<pre><code class=\"objectivec\">AVCaptureSession *captureSession = &lt;#Get a capture session#&gt;;\nAVCaptureMovieFileOutput *movieOutput = &lt;#Create and configure a movie output#&gt;;\nif ([captureSession canAddOutput:movieOutput]) {\n    [captureSession addOutput:movieOutput];\n} else {\n    // Handle the failure.\n}\n</code></pre>\n<h2 id=\"保存电影文件\"><a href=\"#保存电影文件\" class=\"headerlink\" title=\"保存电影文件\"></a>保存电影文件</h2><p>使用 <code>AVCaptureMovieFileOutput</code> 将音视频数据保存到文件中时，我们可以做一些输出设置，比如最大录制时长、最大文件尺寸等等。我们还能够在硬盘空间不够时停止录制。</p>\n<pre><code class=\"objectivec\">AVCaptureMovieFileOutput *aMovieFileOutput = [[AVCaptureMovieFileOutput alloc] init];\nCMTime maxDuration = &lt;#Create a CMTime to represent the maximum duration#&gt;;\naMovieFileOutput.maxRecordedDuration = maxDuration;\naMovieFileOutput.minFreeDiskSpaceLimit = &lt;#An appropriate minimum given the quality of the movie format and the duration#&gt;;\n</code></pre>\n<p>录制时输出的分辨率和码率是根据 capture session 的 sessionPreset 属性而定的。其中视频的编码类型是 H.264，音频的编码类型是 AAC，这个也是由不同的设备类型决定的。</p>\n<h4 id=\"开始录制\"><a href=\"#开始录制\" class=\"headerlink\" title=\"开始录制\"></a>开始录制</h4><p>我们通过 <code>startRecordingToOutputFileURL:recordingDelegate:</code> 来开始录制，这时你需要提供一个文件 <code>URL</code> 和一个 <code>delegate</code>。这个 <code>URL</code> 不能指向已存在的文件，因为这里的音视频输出不会去覆盖已有的资源。同时我们也必须要有对这个 <code>URL</code> 指向位置的写权限。这里的 <code>delegate</code> 必须遵循 <code>AVCaptureFileOutputRecordingDelegate</code> 协议，而且必须实现 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法。</p>\n<pre><code class=\"objectivec\">AVCaptureMovieFileOutput *aMovieFileOutput = &lt;#Get a movie file output#&gt;;\nNSURL *fileURL = &lt;#A file URL that identifies the output location#&gt;;\n[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;#The delegate#&gt;];\n</code></pre>\n<p>在 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法中，<code>delegate</code> 可以将最终输出的文件写入相册，同时也需要检查和处理各种可能出现的错误。</p>\n<h4 id=\"确保文件写入成功\"><a href=\"#确保文件写入成功\" class=\"headerlink\" title=\"确保文件写入成功\"></a>确保文件写入成功</h4><p>要确保文件是否成功，我们可以在 <code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code> 方法中检查 <code>AVErrorRecordingSuccessfullyFinishedKey</code>。</p>\n<pre><code class=\"objectivec\">- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error {\n\n    BOOL recordedSuccessfully = YES;\n    if ([error code] != noErr) {\n        // A problem occurred: Find out if the recording was successful.\n        id value = [[error userInfo] objectForKey:AVErrorRecordingSuccessfullyFinishedKey];\n        if (value) {\n            recordedSuccessfully = [value boolValue];\n        }\n    }\n    // Continue as appropriate...\n</code></pre>\n<p>我们需要检查 <code>error</code> 的 <code>userInfo</code> 的 <code>AVErrorRecordingSuccessfullyFinishedKey</code> 对应的值，因为有时候即使我们收到了错误，文件也可能是保存成功的，这时候，有可能是触及了我们设置的某些限制，比如 <code>AVErrorMaximumDurationReached</code> 或者 <code>AVErrorMaximumFileSizeReached</code>，其他的原因还有：</p>\n<ul>\n<li>AVErrorDiskFull，磁盘空间不够。</li>\n<li>AVErrorDeviceWasDisconnected，录制设备断开连接。</li>\n<li>AVErrorSessionWasInterrupted，录制 <code>session</code> 被打断了，比如来电话了。</li>\n</ul>\n<h4 id=\"给文件添加-Metadata\"><a href=\"#给文件添加-Metadata\" class=\"headerlink\" title=\"给文件添加 Metadata\"></a>给文件添加 Metadata</h4><p>我们可以在任何时候给录制的文件设置 <code>metadata</code>，即使是在录制过程中。文件的 <code>metadata</code> 是由一系列的 <code>AVMetadataItem</code> 对象表示，我们可以用 <code>AVMutableMetadataItem</code> 来创建我们自己的 <code>metadata</code>。</p>\n<pre><code class=\"objectivec\">AVCaptureMovieFileOutput *aMovieFileOutput = &lt;#Get a movie file output#&gt;;\nNSArray *existingMetadataArray = aMovieFileOutput.metadata;\nNSMutableArray *newMetadataArray = nil;\nif (existingMetadataArray) {\n    newMetadataArray = [existingMetadataArray mutableCopy];\n} else {\n    newMetadataArray = [[NSMutableArray alloc] init];\n}\n\nAVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];\nitem.keySpace = AVMetadataKeySpaceCommon;\nitem.key = AVMetadataCommonKeyLocation;\n\nCLLocation *location - &lt;#The location to set#&gt;;\nitem.value = [NSString stringWithFormat:@&quot;%+08.4lf%+09.4lf/&quot; location.coordinate.latitude, location.coordinate.longitude];\n\n[newMetadataArray addObject:item];\n\naMovieFileOutput.metadata = newMetadataArray;\n</code></pre>\n<h4 id=\"处理视频帧\"><a href=\"#处理视频帧\" class=\"headerlink\" title=\"处理视频帧\"></a>处理视频帧</h4><p><code>AVCaptureVideoDataOutput</code><br> 对象使用代理来对外暴露视频帧，我们通过 <code>setSampleBufferDelegate:queue:</code><br> 来设置代理。除了设置代理以外，还需要设置一个 <code>serial queue</code> 来供代理调用，这里必须使用 <code>serial queue</code> 来保证传给 <code>delegate</code> 的帧数据的顺序正确。我们可以使用这个 queue 来分发和处理视频帧，这里可以参考一下例子 <a href=\"https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190\" target=\"_blank\" rel=\"external\">SquareCam</a>。<br><code>captureOutput:didOutputSampleBuffer:fromConnection:</code><br> 中输出的视频帧数据是用 <code>CMSampleBufferRef</code><br> 来表示的。默认情况下，这个 <code>buffer</code> 的数据格式来自于相机能最高效处理的格式。我们可以通过 <code>videoSettings</code><br> 来设置一个自定义的输出格式，这个值是一个字典，现在支持的键包括 <code>kCVPixelBufferPixelFormatTypeKey</code><br>。推荐的 <code>pixel formats</code> 可以通过 <code>availableVideoCVPixelFormatTypes</code><br> 属性获得，此外还能通过 <code>availableVideoCodecTypes</code><br> 获得支持编码类型。<code>Core Graphics</code> 和 <code>OpenGL</code> 都能很好地处理 <code>BGRA</code><br> 格式。</p>\n<pre><code class=\"objectivec\">AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];NSDictionary *newSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};videoDataOutput.videoSettings = newSettings; // discard if the data output queue is blocked (as we process the still image[videoDataOutput setAlwaysDiscardsLateVideoFrames:YES];)// create a serial dispatch queue used for the sample buffer delegate as well as when a still image is captured// a serial dispatch queue must be used to guarantee that video frames will be delivered in order// see the header doc for setSampleBufferDelegate:queue: for more informationvideoDataOutputQueue = dispatch_queue_create(&quot;VideoDataOutputQueue&quot;, DISPATCH_QUEUE_SERIAL);[videoDataOutput setSampleBufferDelegate:self queue:videoDataOutputQueue];AVCaptureSession *captureSession = &lt;#The Capture Session#&gt;;if ([captureSession canAddOutput:videoDataOutput]) { [captureSession addOutput:videoDataOutput];}\n</code></pre>\n<h4 id=\"处理视频的性能问题\"><a href=\"#处理视频的性能问题\" class=\"headerlink\" title=\"处理视频的性能问题\"></a>处理视频的性能问题</h4><p>对于我们的应用，设置够用的分辨率就好了，不要太高，那样性能会降低。</p>\n<p>我们需要确保，在 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中处理视频帧的时间开销不要超过分配给一帧的处理时长。如果这里处理的太长，那么 <code>AV Foundation</code> 将会停止发送视频帧给代理，也会停止发给其他输出端，比如 <code>preview layer</code>。</p>\n<p>你可以使用 <code>AVCaptureVideoDataOutput</code> 的 <code>minFrameDuration</code> 属性来确保你有足够的时间来处理一帧。同时，我们还可以设置 <code>alwaysDiscardsLateVideoFrames</code> 为 YES 来确保晚到的帧会被丢掉来避免延迟。如果你不介意延迟，而更想要处理更多的帧，那就设置这个值为 NO，但是这并不意味着不会丢帧，只是不会被那么早或那么高效的丢掉。</p>\n<h2 id=\"截取静态图片\"><a href=\"#截取静态图片\" class=\"headerlink\" title=\"截取静态图片\"></a>截取静态图片</h2><p>当我们想要截取带着 <code>metadata</code> 的静态图片时，我们可以用 <code>AVCaptureStillImageOutput</code>。截出的图的分辨率依赖于 <code>session</code> 的 <code>preset</code> 和具体的设备。</p>\n<h4 id=\"像素和编码类型\"><a href=\"#像素和编码类型\" class=\"headerlink\" title=\"像素和编码类型\"></a>像素和编码类型</h4><p>不同的类型支持不同的图片格式。我们可以用 <code>availableImageDataCVPixelFormatTypes</code> 和 <code>availableImageDataCodecTypes</code> 来检查当前的设备支持的像素类型和编码类型。然后，我们可以通过设置 <code>outputSettings</code> 属性指定图片的格式。</p>\n<pre><code class=\"objectivec\">AVCaptureStillImageOutput *stillImageOutput = [[AVCaptureStillImageOutput alloc] init];\nNSDictionary *outputSettings = @{AVVideoCodecKey: AVVideoCodecJPEG};\n[stillImageOutput setOutputSettings:outputSettings];\n`\n</code></pre>\n<p>如果我们要截取一张 JPEG 图片，你最好不要指定你自己的压缩格式，相反，你需要做的是让 <code>AVCaptureStillImageOutput</code> 帮你做压缩，因为它使用硬件加速来压缩。如果这时你需要图像的数据，可以用 <code>jpegStillImageNSDataRepresentation:</code> 来获取对应的 <code>NSData</code> 对象，这个数据是未经压缩的，甚至你都可以修改它。</p>\n<h4 id=\"捕获图像\"><a href=\"#捕获图像\" class=\"headerlink\" title=\"捕获图像\"></a>捕获图像</h4><p>当截图时，我们使用 <code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code>方法，其中的第一个参数是对应的 <code>connection</code>，这是你需要查找一下哪个 <code>connection</code> 的输出端口是在手机视频：</p>\n<pre><code class=\"objectivec\">AVCaptureConnection *videoConnection = nil;\nfor (AVCaptureConnection *connection in stillImageOutput.connections) {\n    for (AVCaptureInputPort *port in [connection inputPorts]) {\n        if ([[port mediaType] isEqual:AVMediaTypeVideo] ) {\n            videoConnection = connection;\n            break;\n        }\n    }\n    if (videoConnection) { break; }\n}\n</code></pre>\n<p>第二个参数是一个 <code>block</code> 回调，其中带回两个参数：一个包含图像数据的 <code>CMSampleBuffer</code>，一个 <code>NSError</code>。这个 <code>sample buffer</code> 中可能包含着 <code>metadata</code>，比如一个 EXIF 字典作为附属信息。我们可以去修改附属信息，但是需要注意针对 JPEG 图像的像素和编码上的优化。</p>\n<pre><code class=\"objectivec\">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageSampleBuffer, NSError *error) {\n    CFDictionaryRef exifAttachments =\n        CMGetAttachment(imageSampleBuffer, kCGImagePropertyExifDictionary, NULL);\n    if (exifAttachments) {\n        // Do something with the attachments.\n    }\n    // Continue as appropriate.\n}];\n</code></pre>\n<h2 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h2><h4 id=\"视频预览\"><a href=\"#视频预览\" class=\"headerlink\" title=\"视频预览\"></a>视频预览</h4><p>我们可以用 <code>AVCaptureVideoPreviewLayer</code> 来给用户提供预览，我们不需要任何 <code>output</code> 对象来展示预览。此外，我们可以使用 <code>AVCaptureVideoDataOutput</code> 来在给用户预览之前获取到图像像素级别的数据。</p>\n<p>Unlike a capture output, a video preview layer maintains a strong reference to the session with which it is associated. This is to ensure that the session is not deallocated while the layer is attempting to display video. This is reflected in the way you initialize a preview layer:</p>\n<p>不像 <code>capture output</code>，一个 <code>video preview layer</code> 会持有一个关联 <code>session</code> 的强引用。这样来防止 <code>layer</code> 在展示预览时而 <code>session</code> 被释放引起问题。</p>\n<pre><code class=\"objectivec\">AVCaptureSession *captureSession = &lt;#Get a capture session#&gt;;\nCALayer *viewLayer = &lt;#Get a layer from the view in which you want to present the preview#&gt;;\n\nAVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:captureSession];\n[viewLayer addSublayer:captureVideoPreviewLayer];\n</code></pre>\n<p>一般来说，<code>preview layer</code> 和其他 <code>CALayer</code> 对象一样，我们可以缩放它的图像，执行变换，旋转。一个不同的地方是，我们需要设置 <code>layer</code> 的 <code>orientation</code> 属性来指定它改如何旋转从相机获得的图像。此外，我们可以用 <code>supportsVideoMirroring</code> 来测试设备是否支持视频镜面效果(左右翻转)，我们可以设置 <code>videoMirrored</code> 来配置是否开启镜面效果，即使 <code>automaticallyAdjustsVideoMirroring</code> 被设置为默认的 YES 也没问题(这个值是在配置 <code>session</code> 时被自动设置的)。</p>\n<h4 id=\"视频重力模式\"><a href=\"#视频重力模式\" class=\"headerlink\" title=\"视频重力模式\"></a>视频重力模式</h4><p>我们可以通过 <code>videoGravity</code><br> 属性设置视频重力模式，比如：</p>\n<ul>\n<li>AVLayerVideoGravityResizeAspect<br>，保持视频的宽高比；不一定完全填充，可能留黑边；不裁剪视频，。</li>\n<li>AVLayerVideoGravityResizeAspectFill<br>，保持视频的宽高比；完全填充，不留黑边；可能裁剪视频。</li>\n<li>AVLayerVideoGravityResize<br>，不保持视频宽高比，可能扭曲画面；完全填充；不裁剪视频。</li>\n</ul>\n<h4 id=\"使用预览时的点击聚焦\"><a href=\"#使用预览时的点击聚焦\" class=\"headerlink\" title=\"使用预览时的点击聚焦\"></a>使用预览时的点击聚焦</h4><p>需要注意的是，在实现点击聚焦时必须考虑到该层的预览方向和重力，并考虑预览变为镜像显示的可能性。可以参考实例项目：<a href=\"https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112\" target=\"_blank\" rel=\"external\">AVCam-iOS: Using AVFoundation to Capture Images and Movies</a>。</p>\n<h2 id=\"显示音频等级\"><a href=\"#显示音频等级\" class=\"headerlink\" title=\"显示音频等级\"></a>显示音频等级</h2><p>To monitor the average and peak power levels in an audio channel in a capture connection, you use an AVCaptureAudioChannel object. Audio levels are not key-value observable, so you must poll for updated levels as often as you want to update your user interface (for example, 10 times a second).</p>\n<p>要监测 capture connection 中音频通道的平均强度和峰值强度，我们可以用 <code>AVCaptureAudioChannel</code>。音频等级是不支持 KVO 监测的，所以当我们想更新用户界面时，我们需要去查询。</p>\n<pre><code class=\"objectivec\">AVCaptureAudioDataOutput *audioDataOutput = &lt;#Get the audio data output#&gt;;\nNSArray *connections = audioDataOutput.connections;\nif ([connections count] &gt; 0) {\n    // There should be only one connection to an AVCaptureAudioDataOutput.\n    AVCaptureConnection *connection = [connections objectAtIndex:0];\n\n    NSArray *audioChannels = connection.audioChannels;\n\n    for (AVCaptureAudioChannel *channel in audioChannels) {\n        float avg = channel.averagePowerLevel;\n        float peak = channel.peakHoldLevel;\n        // Update the level meter user interface.\n    }\n}\n</code></pre>\n<h2 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h2><p>这里的示例代码将展示如何获取视频并转化为 UIImage。大概包括下面几步：</p>\n<ul>\n<li>创建一个 AVCaptureSession 对象来协调输入设备到输出的数据流。</li>\n<li>找到我们想要的 AVCaptureDevice。</li>\n<li>为 device 创建一个 AVCaptureDeviceInput 对象。</li>\n<li>创建 AVCaptureVideoDataOutput 来输出视频帧。</li>\n<li>实现 AVCaptureVideoDataOutput 的 delegate 方法来处理视频帧。</li>\n<li>在实现的代理方法中将 CMSampleBuffer 转为 UIImage。<br>代码如下：</li>\n</ul>\n<pre><code class=\"objectivec\">// 创建并配置 Capture Session：\nAVCaptureSession *session = [[AVCaptureSession alloc] init];\nsession.sessionPreset = AVCaptureSessionPresetMedium;\n\n// 创建和配置 Device 和 Device Input：\nAVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n\nNSError *error = nil;\nAVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];\nif (!input) {\n    // Handle the error appropriately.\n}\n[session addInput:input];\n\n// 创建和配置 Video Data Output：\nAVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];\n[session addOutput:output];\noutput.videoSettings = @{(NSString *) kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};\noutput.minFrameDuration = CMTimeMake(1, 15);\n// 设置 Video Data Output 的 delegate 和处理队列：\ndispatch_queue_t queue = dispatch_queue_create(&quot;MyQueue&quot;, NULL);\n[output setSampleBufferDelegate:self queue:queue];\n</code></pre>\n<p>代理方法实现：</p>\n<pre><code class=\"objectivec\">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {\n\n    UIImage *image = imageFromSampleBuffer(sampleBuffer);\n    // Add your code here that uses the image.\n}\n</code></pre>\n<p>开始录制：</p>\n<p>录制前，还需要注意申请相机权限：</p>\n<pre><code class=\"objectivec\">// 申请权限：\nNSString *mediaType = AVMediaTypeVideo;\n\n[AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {\n    if (granted) {\n        //Granted access to mediaType\n        [self setDeviceAuthorized:YES];\n    } else {\n        //Not granted access to mediaType\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[[UIAlertView alloc] initWithTitle:@&quot;AVCam!&quot;\n                                    message:@&quot;AVCam doesn&#39;t have permission to use Camera, please change privacy settings&quot;\n                                   delegate:self\n                          cancelButtonTitle:@&quot;OK&quot;\n                          otherButtonTitles:nil] show];\n            [self setDeviceAuthorized:NO];\n        });\n    }\n}];\n</code></pre>\n<p>开始录制方法：</p>\n<pre><code class=\"objectivec\">[session startRunning];\n</code></pre>\n<p>停止录制方法：</p>\n<pre><code class=\"objectivec\">[session stopRunning];\n</code></pre>\n<h4 id=\"高帧率视频获取\"><a href=\"#高帧率视频获取\" class=\"headerlink\" title=\"高帧率视频获取\"></a>高帧率视频获取</h4><p>iOS 7 以后在一些设备中引入了高帧率视频捕获的支持。我们可以通过 <code>AVCaptureDeviceFormat</code> 来查询设备支持的媒体类型、帧率、缩放比、视频防抖等。在 AVFoundation 中：</p>\n<ul>\n<li>支持捕获分辨率 720p 及以上、帧率 60 fps、视频防抖、P 帧丢帧。</li>\n<li>播放方面增强了对音频加速和慢速播放的支持。</li>\n<li>编辑方面提供了全面的编辑能力支持。</li>\n<li>输出方面支持两种方式输出帧率达 60 fps 的影视文件。一种是输出为可变帧率，支持慢速或快速播放。另一种是输出为任意指定帧率，比如 30 fps。<br>需要注意的是，现在最新的 iOS 版本支持的能力会比以上这些更多更强大。</li>\n</ul>\n<h4 id=\"播放\"><a href=\"#播放\" class=\"headerlink\" title=\"播放\"></a>播放</h4><p>播放时，可以通过 <code>AVPlayer</code> 设置 <code>rate</code> 属性来设置播放速率。</p>\n<p><code>AVPlayerItem</code> 可以支持通过 <code>audioTimePitchAlgorithm</code> 属性来设置当你用不同的速率播放视频时，该如何播放音频。以下是相关选项：</p>\n<ul>\n<li>AVAudioTimePitchAlgorithmLowQualityZeroLatency，较低音质，适应多种播放速率。适宜的速率：0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0.</li>\n<li>AVAudioTimePitchAlgorithmTimeDomain，普通音质。适宜的速率：0.5–2x。</li>\n<li>AVAudioTimePitchAlgorithmSpectral，最高音质，性能消耗较大。适宜的速率：1/32–32。</li>\n<li>AVAudioTimePitchAlgorithmVarispeed，高音质。适宜的速率：1/32–32。</li>\n</ul>\n<h4 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h4><p>通常使用 <code>AVMutableComposition</code> 来做音视频编辑：</p>\n<p>使用 <code>composition</code> 类方法类创建 <code>AVMutableComposition</code> 对象。<br>使用 <code>insertTimeRange:ofAsset:atTime:error:</code> 来插入音视频数据。<br>使用 <code>scaleTimeRange:toDuration:</code> 来设置音视频数据的时间区间。<br>导出</p>\n<p>可以使用 <code>AVAssetExportSession</code> 来导出 60 fps 的视频，可以用以下两种方式：</p>\n<p>使用 <code>AVAssetExportPresetPassthrough preset</code> 来编码重新编码视频。它会重新处理那些标记为 60 fps、降速、加速区域的时间。<br>使用一个固定帧率来保证导出视频的最大兼容性。比如设置 <code>video composition</code> 的 <code>frameDuration</code> 为 30 fps。比如设置 <code>export session</code> 的 <code>audioTimePitchAlgorithm</code> 来配置音频播放选项。<br>录制</p>\n<p>我们用 <code>AVCaptureMovieFileOutput</code> 来录制高帧率的视频，它会默认支持高帧率的视频录制，会默认选择正确的 H264 pitch level 和比特率。</p>\n<p>如果想要做一些自定义录制，我们必须使用 <code>AVAssetWriter</code>，这个则需要一些额外的创建过程。</p>\n<p>通常我们需要设置一下：</p>\n<pre><code class=\"objectivec\">etWriterInput.expectsMediaDataInRealTime = YES;\n</code></pre>\n<p>来保证视频捕获能跟得上传入的数据。</p>\n"},{"title":"AVAudioFoundation(3)：音视频编辑","date":"2017-07-03T08:28:38.000Z","_content":"\n本文转自：[AVAudioFoundation(3)：音视频编辑 | www.samirchen.com](http://www.samirchen.com/ios-av-edit)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n#### 音视频编辑\n\n上面简单了解了下   `AVFoundation` 框架后，我们来看看跟音视频编辑相关的接口。\n\n一个 `composition` 可以简单的认为是一组轨道（`tracks`）的集合，这些轨道可以是来自不同媒体资源（`asset`）。`AVMutableComposition` 提供了接口来插入或者删除轨道，也可以调整这些轨道的顺序。\n\n下面这张图反映了一个新的 `composition` 是怎么从已有的 `asset` 中获取对应的 `track` 并进行拼接形成新的 `asset`。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%911.png)\n\n在处理音频时，你可以在使用 `AVMutableAudioMix` 类的接口来做一些自定义的操作，如下图所示。现在，你可以做到指定一个最大音量或设置一个音频轨道的音量渐变。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%912.png)\n\n\n如下图所示，我们还可以使用 `AVMutableVideoComposition` 来直接处理 `composition` 中的视频轨道。处理一个单独的 `video composition` 时，你可以指定它的渲染尺寸、缩放比例、帧率等参数并输出最终的视频文件。通过一些针对 `video composition` 的指令（`AVMutableVideoCompositionInstruction` 等），我们可以修改视频的背景颜色、应用 `layer instructions`。这些 `layer instructions`（`AVMutableVideoCompositionLayerInstruction` 等）可以用来对 `composition` 中的视频轨道实施图形变换、添加图形渐变、透明度变换、增加透明度渐变。此外，你还能通过设置 `video composition` 的 `animationTool` 属性来应用 `Core Animation Framework` 框架中的动画效果。\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%913.png)\n\n\n如下图所示，你可以使用 `AVAssetExportSession` 相关的接口来合并你的 `composition` 中的 `audio mix` 和 `video composition`。你只需要初始化一个 `AVAssetExportSession` 对象，然后将其 `audioMix` 和 `videoComposition` 属性分别设置为你的 `audio mix` 和 `video composition` 即可。\n\n\n![图四](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%914.png)\n\n#### 创建 Composition\n\n上面简单介绍了集中音视频编辑的场景，现在我们来详细介绍具体的接口。从 `AVMutableComposition` 开始。\n\n当使用 `AVMutableComposition` 创建自己的 `composition` 时，最典型的，我们可以使用 `AVMutableCompositionTrack` 来向 `composition` 中添加一个或多个 `composition tracks`，比如下面这个简单的例子便是向一个 `composition` 中添加一个音频轨道和一个视频轨道：\n\n\n```objectivec\nAVMutableComposition *mutableComposition = [AVMutableComposition composition];\n// Create the video composition track.\nAVMutableCompositionTrack *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n// Create the audio composition track.\nAVMutableCompositionTrack *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n```\n\n当为 `composition` 添加一个新的 `track` 的时候，需要设置其媒体类型（`media type`）和 `track ID`，主要的媒体类型包括：音频、视频、字幕、文本等等。\n\n这里需要注意的是，每个 `track` 都需要一个唯一的 `track ID`，比较方便的做法是：设置 `track ID` 为 `kCMPersistentTrackID_Invalid` 来为对应的 `track` 获得一个自动生成的唯一 `ID`。\n\n\n#### 向 Composition 添加视听数据\n\n\n要将媒体数据添加到一个 `composition track` 中需要访问媒体数据所在的 `AVAsset`，可以使用 `AVMutableCompositionTrack` 的接口将具有相同媒体类型的多个 `track` 添加到同一个 `composition track` 中。下面的例子便是从两个 `AVAsset` 中各取出一份 `video asset track`，再添加到一个新的 `composition track` 中去：\n\n```objectivec\n// You can retrieve AVAssets from a number of places, like the camera roll for example.\nAVAsset *videoAsset = <#AVAsset with at least one video track#>;\nAVAsset *anotherVideoAsset = <#another AVAsset with at least one video track#>;\n// Get the first video track from each asset.\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\n// Add them both to the composition.\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil];\n```\n\n\n\n#### 检索兼容的 Composition Tracks\n\n如果可能，每一种媒体类型最好只使用一个 `composition track`，这样能够优化资源的使用。当你连续播放媒体数据时，应该将相同类型的媒体数据放到同一个 `composition track` 中，你可以通过类似下面的代码来从 `composition` 中查找是否有与当前的 `asset track` 兼容的 `composition track`，然后拿来使用：\n\n```objectivec\nAVMutableCompositionTrack *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:<#the AVAssetTrack you want to insert#>];\nif (compatibleCompositionTrack) {\n    // Implementation continues.\n}\n```\n\n需要注意的是，在同一个 `composition track` 中添加多个视频段时，当视频段之间切换时可能会丢帧，尤其在嵌入式设备上。基于这个问题，应该合理选择一个 `composition track` 里的视频段数量。\n\n\n#### 设置音量渐变\n\n只使用一个 `AVMutableAudioMix` 对象就能够为 `composition` 中的每一个 `audio track` 单独做音频处理。\n\n下面代码展示了如果使用 `AVMutableAudioMix` 给一个 `audio track` 设置音量渐变给声音增加一个淡出效果。使用 `audioMix` 类方法获取 `AVMutableAudioMix` 实例；然后使用 `AVMutableAudioMixInputParameters` 类的 `audioMixInputParametersWithTrack:` 接口将 `AVMutableAudioMix` 实例与 `composition` 中的某一个 `audio track` 关联起来；之后便可以通过 `AVMutableAudioMix` 实例来处理音量了。\n\n```objectivec\nAVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];\n// Create the audio mix input parameters object.\nAVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];\n// Set the volume ramp to slowly fade the audio out over the duration of the composition.\n[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];\n// Attach the input parameters to the audio mix.\nmutableAudioMix.inputParameters = @[mixParameters];\n```\n\n#### 自定义视频处理\n\n处理音频是我们使用 `AVMutableAudioMix`，那么处理视频时，我们就使用 `AVMutableVideoComposition`，只需要一个 `AVMutableVideoComposition` 实例就可以为 `composition` 中所有的 `video track` 做处理，比如设置渲染尺寸、缩放、播放帧率等等。\n\n下面我们依次来看一些场景。\n\n#### 设置视频背景色\n\n所有的 `video composition` 也必然对应一组 `AVVideoCompositionInstruction` 实例，每个 `AVVideoCompositionInstruction` 中至少包含一条 `video composition instruction`。我们可以使用 `AVMutableVideoCompositionInstruction` 来创建我们自己的 `video composition instruction`，通过这些指令，我们可以修改 `composition` 的背景颜色、后处理、`layer instruction` 等等。\n\n下面的实例代码展示了如何创建 `video composition instruction` 并将一个 `composition` 的整个时长都设置为红色背景色：\n\n```objectivec\nAVMutableVideoCompositionInstruction *mutableVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\nmutableVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, mutableComposition.duration);\nmutableVideoCompositionInstruction.backgroundColor = [[UIColor redColor] CGColor];\n```\n\n\n\n#### 设置透明度渐变\n\n我们也可以用 `video composition instructions` 来应用 `video composition layer instructions`。`AVMutableVideoCompositionLayerInstruction` 可以用来设置 `video track` 的图形变换、图形渐变、透明度、透明度渐变等等。一个 `video composition instruction` 的 `layerInstructions` 属性中所存储的 `layer instructions` 的顺序决定了 `tracks` 中的视频帧是如何被放置和组合的。\n\n下面的示例代码展示了如何在从一个视频切换到第二个视频时添加一个透明度渐变的效果：\n\n```objectivec\nAVAsset *firstVideoAssetTrack = <#AVAssetTrack representing the first video segment played in the composition#>;\nAVAsset *secondVideoAssetTrack = <#AVAssetTrack representing the second video segment played in the composition#>;\n// Create the first video composition instruction.\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\n// Create the layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Create the opacity ramp to fade out the first video track over its entire duration.\n[firstVideoLayerInstruction setOpacityRampFromStartOpacity:1.f toEndOpacity:0.f timeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];\n// Create the second video composition instruction so that the second video track isn't transparent.\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n// Create the second layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Attach the first layer instruction to the first video composition instruction.\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\n// Attach the second layer instruction to the second video composition instruction.\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\n// Attach both of the video composition instructions to the video composition.\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n```\n\n#### 动画效果\n\n我们还能通过设置 `video composition` 的 `animationTool` 属性来使用 `Core Animation Framework` 框架的强大能力。比如：设置视频水印、视频标题、动画浮层等。\n\n在 `video composition` 中使用 `Core Animation` 有两种不同的方式：\n\n添加一个 `Core Animation Layer` 作为独立的 `composition track`\n直接使用 `Core Animation Layer` 在视频帧中渲染动画效果\n下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：\n\n\n```objectivec\nCALayer *watermarkLayer = <#CALayer representing your desired watermark image#>;\nCALayer *parentLayer = [CALayer layer];\nCALayer *videoLayer = [CALayer layer];\nparentLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\nvideoLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\n[parentLayer addSublayer:videoLayer];\nwatermarkLayer.position = CGPointMake(mutableVideoComposition.renderSize.width/2, mutableVideoComposition.renderSize.height/4);\n[parentLayer addSublayer:watermarkLayer];\nmutableVideoComposition.animationTool = [AVVideoCompositionCoreAnimationTool videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];\n```\n\n#### 一个完整示例\n\n这里的示例将展示如何合并两个 `video asset tracks` 和一个 `audio asset track` 到一个视频文件，其中大体步骤如下：\n\n- 创建一个 `AVMutableComposition` 对象，添加多个 `AVMutableCompositionTrack` 对象\n- 在各个 `composition tracks` 中添加 `AVAssetTrack` 对应的时间范围\n- 检查 `video asset track` 的 `preferredTransform` 属性决定视频方向\n- 使用 `AVMutableVideoCompositionLayerInstruction` 对象对视频进行图形变换\n- 设置 `video composition` 的 `renderSize` 和 `frameDuration` 属性\n- 导出视频文件\n- 保存视频文件到相册\n下面的示例代码省略了一些内存管理和通知移除相关的代码。\n\n```objectivec\n// 1、创建 composition。创建一个 composition，并添加一个 audio track 和一个 video track。\nAVMutableComposition *mutableComposition = [AVMutableComposition composition];\nAVMutableCompositionTrack *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\nAVMutableCompositionTrack *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n\n// 2、添加 asset。从源 assets 中取得两个 video track 和一个 audio track，在上面的 video composition track 中依次添加两个 video track，在 audio composition track 中添加一个 video track。\nAVAsset *firstVideoAsset = <#First AVAsset with at least one video track#>;\nAVAsset *secondVideoAsset = <#Second AVAsset with at least one video track#>;\nAVAsset *audioAsset = <#AVAsset with at least one audio track#>;\nAVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *audioAssetTrack = [[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0]\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack atTime:kCMTimeZero error:nil];\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil];\n[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:audioAssetTrack atTime:kCMTimeZero error:nil];\n\n// 3、检查 composition 方向。在 composition 中添加了 audio track 和 video track 后，还必须确保其中所有的 video track 的视频方向都是一致的。在默认情况下 video track 默认为横屏模式，如果这时添加进来的 video track 是在竖屏模式下采集的，那么导出的视频会出现方向错误。同理，将一个横向的视频和一个纵向的视频进行合并导出，export session 会报错。\nBOOL isFirstVideoPortrait = NO;\nCGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;\n// Check the first video track's preferred transform to determine if it was recorded in portrait mode.\nif (firstTransform.a == 0 && firstTransform.d == 0 && (firstTransform.b == 1.0 || firstTransform.b == -1.0) && (firstTransform.c == 1.0 || firstTransform.c == -1.0)) {\n    isFirstVideoPortrait = YES;\n}\nBOOL isSecondVideoPortrait = NO;\nCGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;\n// Check the second video track's preferred transform to determine if it was recorded in portrait mode.\nif (secondTransform.a == 0 && secondTransform.d == 0 && (secondTransform.b == 1.0 || secondTransform.b == -1.0) && (secondTransform.c == 1.0 || secondTransform.c == -1.0)) {\n    isSecondVideoPortrait = YES;\n}\nif ((isFirstVideoAssetPortrait && !isSecondVideoAssetPortrait) || (!isFirstVideoAssetPortrait && isSecondVideoAssetPortrait)) {\n    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc] initWithTitle:@\"Error!\" message:@\"Cannot combine a video shot in portrait mode with a video shot in landscape mode.\" delegate:self cancelButtonTitle:@\"Dismiss\" otherButtonTitles:nil];\n    [incompatibleVideoOrientationAlert show];\n    return;\n}\n\n// 4、应用 Video Composition Layer Instructions。一旦你知道你要合并的视频片段的方向是兼容的，那么你接下来就可以为每个片段应用必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中。\n// 所有的 `AVAssetTrack` 对象都有一个 `preferredTransform` 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面的代码中，layer instruction 的 transform 被设置为 asset track 的 transform，便于在你修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the first instruction to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the second instruction to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n\n// 创建两个 video layer instruction，关联对应的 video composition track，并设置 transform 为 preferredTransform。\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the first layer instruction to the preferred transform of the first video track.\n[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the second layer instruction to the preferred transform of the second video track.\n[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];\n\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n\n// 5、设置渲染尺寸和帧率。要完全解决视频方向问题，你还需要调整 video composition 的 `renderSize` 属性，同时也需要设置一个合适的 `frameDuration`，比如 1/30 表示 30 帧每秒。此外，`renderScale` 默认值为 1.0。\nCGSize naturalSizeFirst, naturalSizeSecond;\n// If the first video asset was shot in portrait mode, then so was the second one if we made it here.\nif (isFirstVideoAssetPortrait) {\n    // Invert the width and height for the video tracks to ensure that they display properly.\n    naturalSizeFirst = CGSizeMake(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);\n    naturalSizeSecond = CGSizeMake(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);\n} else {\n    // If the videos weren't shot in portrait mode, we can just use their natural sizes.\n    naturalSizeFirst = firstVideoAssetTrack.naturalSize;\n    naturalSizeSecond = secondVideoAssetTrack.naturalSize;\n}\nfloat renderWidth, renderHeight;\n// Set the renderWidth and renderHeight to the max of the two videos widths and heights.\nif (naturalSizeFirst.width > naturalSizeSecond.width) {\n    renderWidth = naturalSizeFirst.width;\n} else {\n    renderWidth = naturalSizeSecond.width;\n}\nif (naturalSizeFirst.height > naturalSizeSecond.height) {\n    renderHeight = naturalSizeFirst.height;\n} else {\n    renderHeight = naturalSizeSecond.height;\n}\nmutableVideoComposition.renderSize = CGSizeMake(renderWidth, renderHeight);\n// Set the frame duration to an appropriate value (i.e. 30 frames per second for video).\nmutableVideoComposition.frameDuration = CMTimeMake(1,30);\n\n\n// 6、导出 composition 并保持到相册。创建一个 `AVAssetExportSession` 对象，设置对应的 `outputURL` 来将视频导出到指定的文件。同时，我们还可以用 `ALAssetsLibrary` 接口来将导出的视频文件存储到相册中去。\n// Create a static date formatter so we only have to initialize it once.\nstatic NSDateFormatter *kDateFormatter;\nif (!kDateFormatter) {\n    kDateFormatter = [[NSDateFormatter alloc] init];\n    kDateFormatter.dateStyle = NSDateFormatterMediumStyle;\n    kDateFormatter.timeStyle = NSDateFormatterShortStyle;\n}\n// Create the export session with the composition and set the preset to the highest quality.\nAVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mutableComposition presetName:AVAssetExportPresetHighestQuality];\n// Set the desired output URL for the file created by the export process.\nexporter.outputURL = [[[[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:@YES error:nil] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[NSDate date]]] URLByAppendingPathExtension:CFBridgingRelease(UTTypeCopyPreferredTagWithClass((CFStringRef)AVFileTypeQuickTimeMovie, kUTTagClassFilenameExtension))];\n// Set the output file type to be a QuickTime movie.\nexporter.outputFileType = AVFileTypeQuickTimeMovie;\nexporter.shouldOptimizeForNetworkUse = YES;\nexporter.videoComposition = mutableVideoComposition;\n// Asynchronously export the composition to a video file and save this file to the camera roll once export completes.\n[exporter exportAsynchronouslyWithCompletionHandler:^{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (exporter.status == AVAssetExportSessionStatusCompleted) {\n            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];\n            if ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {\n                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:NULL];\n            }\n        }\n    });\n}];\n```\n\n\n","source":"_posts/AVAudioFoundation-3-：音视频编辑.md","raw":"---\ntitle: AVAudioFoundation(3)：音视频编辑\ndate: 2017-07-03 16:28:38\ncategories: \n\t- iOS合集\n---\n\n本文转自：[AVAudioFoundation(3)：音视频编辑 | www.samirchen.com](http://www.samirchen.com/ios-av-edit)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n#### 音视频编辑\n\n上面简单了解了下   `AVFoundation` 框架后，我们来看看跟音视频编辑相关的接口。\n\n一个 `composition` 可以简单的认为是一组轨道（`tracks`）的集合，这些轨道可以是来自不同媒体资源（`asset`）。`AVMutableComposition` 提供了接口来插入或者删除轨道，也可以调整这些轨道的顺序。\n\n下面这张图反映了一个新的 `composition` 是怎么从已有的 `asset` 中获取对应的 `track` 并进行拼接形成新的 `asset`。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%911.png)\n\n在处理音频时，你可以在使用 `AVMutableAudioMix` 类的接口来做一些自定义的操作，如下图所示。现在，你可以做到指定一个最大音量或设置一个音频轨道的音量渐变。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%912.png)\n\n\n如下图所示，我们还可以使用 `AVMutableVideoComposition` 来直接处理 `composition` 中的视频轨道。处理一个单独的 `video composition` 时，你可以指定它的渲染尺寸、缩放比例、帧率等参数并输出最终的视频文件。通过一些针对 `video composition` 的指令（`AVMutableVideoCompositionInstruction` 等），我们可以修改视频的背景颜色、应用 `layer instructions`。这些 `layer instructions`（`AVMutableVideoCompositionLayerInstruction` 等）可以用来对 `composition` 中的视频轨道实施图形变换、添加图形渐变、透明度变换、增加透明度渐变。此外，你还能通过设置 `video composition` 的 `animationTool` 属性来应用 `Core Animation Framework` 框架中的动画效果。\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%913.png)\n\n\n如下图所示，你可以使用 `AVAssetExportSession` 相关的接口来合并你的 `composition` 中的 `audio mix` 和 `video composition`。你只需要初始化一个 `AVAssetExportSession` 对象，然后将其 `audioMix` 和 `videoComposition` 属性分别设置为你的 `audio mix` 和 `video composition` 即可。\n\n\n![图四](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%914.png)\n\n#### 创建 Composition\n\n上面简单介绍了集中音视频编辑的场景，现在我们来详细介绍具体的接口。从 `AVMutableComposition` 开始。\n\n当使用 `AVMutableComposition` 创建自己的 `composition` 时，最典型的，我们可以使用 `AVMutableCompositionTrack` 来向 `composition` 中添加一个或多个 `composition tracks`，比如下面这个简单的例子便是向一个 `composition` 中添加一个音频轨道和一个视频轨道：\n\n\n```objectivec\nAVMutableComposition *mutableComposition = [AVMutableComposition composition];\n// Create the video composition track.\nAVMutableCompositionTrack *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n// Create the audio composition track.\nAVMutableCompositionTrack *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n```\n\n当为 `composition` 添加一个新的 `track` 的时候，需要设置其媒体类型（`media type`）和 `track ID`，主要的媒体类型包括：音频、视频、字幕、文本等等。\n\n这里需要注意的是，每个 `track` 都需要一个唯一的 `track ID`，比较方便的做法是：设置 `track ID` 为 `kCMPersistentTrackID_Invalid` 来为对应的 `track` 获得一个自动生成的唯一 `ID`。\n\n\n#### 向 Composition 添加视听数据\n\n\n要将媒体数据添加到一个 `composition track` 中需要访问媒体数据所在的 `AVAsset`，可以使用 `AVMutableCompositionTrack` 的接口将具有相同媒体类型的多个 `track` 添加到同一个 `composition track` 中。下面的例子便是从两个 `AVAsset` 中各取出一份 `video asset track`，再添加到一个新的 `composition track` 中去：\n\n```objectivec\n// You can retrieve AVAssets from a number of places, like the camera roll for example.\nAVAsset *videoAsset = <#AVAsset with at least one video track#>;\nAVAsset *anotherVideoAsset = <#another AVAsset with at least one video track#>;\n// Get the first video track from each asset.\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\n// Add them both to the composition.\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil];\n```\n\n\n\n#### 检索兼容的 Composition Tracks\n\n如果可能，每一种媒体类型最好只使用一个 `composition track`，这样能够优化资源的使用。当你连续播放媒体数据时，应该将相同类型的媒体数据放到同一个 `composition track` 中，你可以通过类似下面的代码来从 `composition` 中查找是否有与当前的 `asset track` 兼容的 `composition track`，然后拿来使用：\n\n```objectivec\nAVMutableCompositionTrack *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:<#the AVAssetTrack you want to insert#>];\nif (compatibleCompositionTrack) {\n    // Implementation continues.\n}\n```\n\n需要注意的是，在同一个 `composition track` 中添加多个视频段时，当视频段之间切换时可能会丢帧，尤其在嵌入式设备上。基于这个问题，应该合理选择一个 `composition track` 里的视频段数量。\n\n\n#### 设置音量渐变\n\n只使用一个 `AVMutableAudioMix` 对象就能够为 `composition` 中的每一个 `audio track` 单独做音频处理。\n\n下面代码展示了如果使用 `AVMutableAudioMix` 给一个 `audio track` 设置音量渐变给声音增加一个淡出效果。使用 `audioMix` 类方法获取 `AVMutableAudioMix` 实例；然后使用 `AVMutableAudioMixInputParameters` 类的 `audioMixInputParametersWithTrack:` 接口将 `AVMutableAudioMix` 实例与 `composition` 中的某一个 `audio track` 关联起来；之后便可以通过 `AVMutableAudioMix` 实例来处理音量了。\n\n```objectivec\nAVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];\n// Create the audio mix input parameters object.\nAVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];\n// Set the volume ramp to slowly fade the audio out over the duration of the composition.\n[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];\n// Attach the input parameters to the audio mix.\nmutableAudioMix.inputParameters = @[mixParameters];\n```\n\n#### 自定义视频处理\n\n处理音频是我们使用 `AVMutableAudioMix`，那么处理视频时，我们就使用 `AVMutableVideoComposition`，只需要一个 `AVMutableVideoComposition` 实例就可以为 `composition` 中所有的 `video track` 做处理，比如设置渲染尺寸、缩放、播放帧率等等。\n\n下面我们依次来看一些场景。\n\n#### 设置视频背景色\n\n所有的 `video composition` 也必然对应一组 `AVVideoCompositionInstruction` 实例，每个 `AVVideoCompositionInstruction` 中至少包含一条 `video composition instruction`。我们可以使用 `AVMutableVideoCompositionInstruction` 来创建我们自己的 `video composition instruction`，通过这些指令，我们可以修改 `composition` 的背景颜色、后处理、`layer instruction` 等等。\n\n下面的实例代码展示了如何创建 `video composition instruction` 并将一个 `composition` 的整个时长都设置为红色背景色：\n\n```objectivec\nAVMutableVideoCompositionInstruction *mutableVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\nmutableVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, mutableComposition.duration);\nmutableVideoCompositionInstruction.backgroundColor = [[UIColor redColor] CGColor];\n```\n\n\n\n#### 设置透明度渐变\n\n我们也可以用 `video composition instructions` 来应用 `video composition layer instructions`。`AVMutableVideoCompositionLayerInstruction` 可以用来设置 `video track` 的图形变换、图形渐变、透明度、透明度渐变等等。一个 `video composition instruction` 的 `layerInstructions` 属性中所存储的 `layer instructions` 的顺序决定了 `tracks` 中的视频帧是如何被放置和组合的。\n\n下面的示例代码展示了如何在从一个视频切换到第二个视频时添加一个透明度渐变的效果：\n\n```objectivec\nAVAsset *firstVideoAssetTrack = <#AVAssetTrack representing the first video segment played in the composition#>;\nAVAsset *secondVideoAssetTrack = <#AVAssetTrack representing the second video segment played in the composition#>;\n// Create the first video composition instruction.\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\n// Create the layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Create the opacity ramp to fade out the first video track over its entire duration.\n[firstVideoLayerInstruction setOpacityRampFromStartOpacity:1.f toEndOpacity:0.f timeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];\n// Create the second video composition instruction so that the second video track isn't transparent.\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n// Create the second layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Attach the first layer instruction to the first video composition instruction.\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\n// Attach the second layer instruction to the second video composition instruction.\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\n// Attach both of the video composition instructions to the video composition.\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n```\n\n#### 动画效果\n\n我们还能通过设置 `video composition` 的 `animationTool` 属性来使用 `Core Animation Framework` 框架的强大能力。比如：设置视频水印、视频标题、动画浮层等。\n\n在 `video composition` 中使用 `Core Animation` 有两种不同的方式：\n\n添加一个 `Core Animation Layer` 作为独立的 `composition track`\n直接使用 `Core Animation Layer` 在视频帧中渲染动画效果\n下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：\n\n\n```objectivec\nCALayer *watermarkLayer = <#CALayer representing your desired watermark image#>;\nCALayer *parentLayer = [CALayer layer];\nCALayer *videoLayer = [CALayer layer];\nparentLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\nvideoLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\n[parentLayer addSublayer:videoLayer];\nwatermarkLayer.position = CGPointMake(mutableVideoComposition.renderSize.width/2, mutableVideoComposition.renderSize.height/4);\n[parentLayer addSublayer:watermarkLayer];\nmutableVideoComposition.animationTool = [AVVideoCompositionCoreAnimationTool videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];\n```\n\n#### 一个完整示例\n\n这里的示例将展示如何合并两个 `video asset tracks` 和一个 `audio asset track` 到一个视频文件，其中大体步骤如下：\n\n- 创建一个 `AVMutableComposition` 对象，添加多个 `AVMutableCompositionTrack` 对象\n- 在各个 `composition tracks` 中添加 `AVAssetTrack` 对应的时间范围\n- 检查 `video asset track` 的 `preferredTransform` 属性决定视频方向\n- 使用 `AVMutableVideoCompositionLayerInstruction` 对象对视频进行图形变换\n- 设置 `video composition` 的 `renderSize` 和 `frameDuration` 属性\n- 导出视频文件\n- 保存视频文件到相册\n下面的示例代码省略了一些内存管理和通知移除相关的代码。\n\n```objectivec\n// 1、创建 composition。创建一个 composition，并添加一个 audio track 和一个 video track。\nAVMutableComposition *mutableComposition = [AVMutableComposition composition];\nAVMutableCompositionTrack *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\nAVMutableCompositionTrack *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n\n// 2、添加 asset。从源 assets 中取得两个 video track 和一个 audio track，在上面的 video composition track 中依次添加两个 video track，在 audio composition track 中添加一个 video track。\nAVAsset *firstVideoAsset = <#First AVAsset with at least one video track#>;\nAVAsset *secondVideoAsset = <#Second AVAsset with at least one video track#>;\nAVAsset *audioAsset = <#AVAsset with at least one audio track#>;\nAVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *audioAssetTrack = [[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0]\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack atTime:kCMTimeZero error:nil];\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil];\n[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:audioAssetTrack atTime:kCMTimeZero error:nil];\n\n// 3、检查 composition 方向。在 composition 中添加了 audio track 和 video track 后，还必须确保其中所有的 video track 的视频方向都是一致的。在默认情况下 video track 默认为横屏模式，如果这时添加进来的 video track 是在竖屏模式下采集的，那么导出的视频会出现方向错误。同理，将一个横向的视频和一个纵向的视频进行合并导出，export session 会报错。\nBOOL isFirstVideoPortrait = NO;\nCGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;\n// Check the first video track's preferred transform to determine if it was recorded in portrait mode.\nif (firstTransform.a == 0 && firstTransform.d == 0 && (firstTransform.b == 1.0 || firstTransform.b == -1.0) && (firstTransform.c == 1.0 || firstTransform.c == -1.0)) {\n    isFirstVideoPortrait = YES;\n}\nBOOL isSecondVideoPortrait = NO;\nCGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;\n// Check the second video track's preferred transform to determine if it was recorded in portrait mode.\nif (secondTransform.a == 0 && secondTransform.d == 0 && (secondTransform.b == 1.0 || secondTransform.b == -1.0) && (secondTransform.c == 1.0 || secondTransform.c == -1.0)) {\n    isSecondVideoPortrait = YES;\n}\nif ((isFirstVideoAssetPortrait && !isSecondVideoAssetPortrait) || (!isFirstVideoAssetPortrait && isSecondVideoAssetPortrait)) {\n    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc] initWithTitle:@\"Error!\" message:@\"Cannot combine a video shot in portrait mode with a video shot in landscape mode.\" delegate:self cancelButtonTitle:@\"Dismiss\" otherButtonTitles:nil];\n    [incompatibleVideoOrientationAlert show];\n    return;\n}\n\n// 4、应用 Video Composition Layer Instructions。一旦你知道你要合并的视频片段的方向是兼容的，那么你接下来就可以为每个片段应用必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中。\n// 所有的 `AVAssetTrack` 对象都有一个 `preferredTransform` 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面的代码中，layer instruction 的 transform 被设置为 asset track 的 transform，便于在你修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the first instruction to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the second instruction to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n\n// 创建两个 video layer instruction，关联对应的 video composition track，并设置 transform 为 preferredTransform。\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the first layer instruction to the preferred transform of the first video track.\n[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the second layer instruction to the preferred transform of the second video track.\n[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];\n\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n\n// 5、设置渲染尺寸和帧率。要完全解决视频方向问题，你还需要调整 video composition 的 `renderSize` 属性，同时也需要设置一个合适的 `frameDuration`，比如 1/30 表示 30 帧每秒。此外，`renderScale` 默认值为 1.0。\nCGSize naturalSizeFirst, naturalSizeSecond;\n// If the first video asset was shot in portrait mode, then so was the second one if we made it here.\nif (isFirstVideoAssetPortrait) {\n    // Invert the width and height for the video tracks to ensure that they display properly.\n    naturalSizeFirst = CGSizeMake(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);\n    naturalSizeSecond = CGSizeMake(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);\n} else {\n    // If the videos weren't shot in portrait mode, we can just use their natural sizes.\n    naturalSizeFirst = firstVideoAssetTrack.naturalSize;\n    naturalSizeSecond = secondVideoAssetTrack.naturalSize;\n}\nfloat renderWidth, renderHeight;\n// Set the renderWidth and renderHeight to the max of the two videos widths and heights.\nif (naturalSizeFirst.width > naturalSizeSecond.width) {\n    renderWidth = naturalSizeFirst.width;\n} else {\n    renderWidth = naturalSizeSecond.width;\n}\nif (naturalSizeFirst.height > naturalSizeSecond.height) {\n    renderHeight = naturalSizeFirst.height;\n} else {\n    renderHeight = naturalSizeSecond.height;\n}\nmutableVideoComposition.renderSize = CGSizeMake(renderWidth, renderHeight);\n// Set the frame duration to an appropriate value (i.e. 30 frames per second for video).\nmutableVideoComposition.frameDuration = CMTimeMake(1,30);\n\n\n// 6、导出 composition 并保持到相册。创建一个 `AVAssetExportSession` 对象，设置对应的 `outputURL` 来将视频导出到指定的文件。同时，我们还可以用 `ALAssetsLibrary` 接口来将导出的视频文件存储到相册中去。\n// Create a static date formatter so we only have to initialize it once.\nstatic NSDateFormatter *kDateFormatter;\nif (!kDateFormatter) {\n    kDateFormatter = [[NSDateFormatter alloc] init];\n    kDateFormatter.dateStyle = NSDateFormatterMediumStyle;\n    kDateFormatter.timeStyle = NSDateFormatterShortStyle;\n}\n// Create the export session with the composition and set the preset to the highest quality.\nAVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mutableComposition presetName:AVAssetExportPresetHighestQuality];\n// Set the desired output URL for the file created by the export process.\nexporter.outputURL = [[[[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:@YES error:nil] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[NSDate date]]] URLByAppendingPathExtension:CFBridgingRelease(UTTypeCopyPreferredTagWithClass((CFStringRef)AVFileTypeQuickTimeMovie, kUTTagClassFilenameExtension))];\n// Set the output file type to be a QuickTime movie.\nexporter.outputFileType = AVFileTypeQuickTimeMovie;\nexporter.shouldOptimizeForNetworkUse = YES;\nexporter.videoComposition = mutableVideoComposition;\n// Asynchronously export the composition to a video file and save this file to the camera roll once export completes.\n[exporter exportAsynchronouslyWithCompletionHandler:^{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (exporter.status == AVAssetExportSessionStatusCompleted) {\n            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];\n            if ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {\n                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:NULL];\n            }\n        }\n    });\n}];\n```\n\n\n","slug":"AVAudioFoundation-3-：音视频编辑","published":1,"updated":"2017-07-03T08:30:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tv20006znuzyhh7r47w","content":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-edit\" target=\"_blank\" rel=\"external\">AVAudioFoundation(3)：音视频编辑 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<h4 id=\"音视频编辑\"><a href=\"#音视频编辑\" class=\"headerlink\" title=\"音视频编辑\"></a>音视频编辑</h4><p>上面简单了解了下   <code>AVFoundation</code> 框架后，我们来看看跟音视频编辑相关的接口。</p>\n<p>一个 <code>composition</code> 可以简单的认为是一组轨道（<code>tracks</code>）的集合，这些轨道可以是来自不同媒体资源（<code>asset</code>）。<code>AVMutableComposition</code> 提供了接口来插入或者删除轨道，也可以调整这些轨道的顺序。</p>\n<p>下面这张图反映了一个新的 <code>composition</code> 是怎么从已有的 <code>asset</code> 中获取对应的 <code>track</code> 并进行拼接形成新的 <code>asset</code>。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%911.png\" alt=\"图一\"></p>\n<p>在处理音频时，你可以在使用 <code>AVMutableAudioMix</code> 类的接口来做一些自定义的操作，如下图所示。现在，你可以做到指定一个最大音量或设置一个音频轨道的音量渐变。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%912.png\" alt=\"图二\"></p>\n<p>如下图所示，我们还可以使用 <code>AVMutableVideoComposition</code> 来直接处理 <code>composition</code> 中的视频轨道。处理一个单独的 <code>video composition</code> 时，你可以指定它的渲染尺寸、缩放比例、帧率等参数并输出最终的视频文件。通过一些针对 <code>video composition</code> 的指令（<code>AVMutableVideoCompositionInstruction</code> 等），我们可以修改视频的背景颜色、应用 <code>layer instructions</code>。这些 <code>layer instructions</code>（<code>AVMutableVideoCompositionLayerInstruction</code> 等）可以用来对 <code>composition</code> 中的视频轨道实施图形变换、添加图形渐变、透明度变换、增加透明度渐变。此外，你还能通过设置 <code>video composition</code> 的 <code>animationTool</code> 属性来应用 <code>Core Animation Framework</code> 框架中的动画效果。<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%913.png\" alt=\"图三\"></p>\n<p>如下图所示，你可以使用 <code>AVAssetExportSession</code> 相关的接口来合并你的 <code>composition</code> 中的 <code>audio mix</code> 和 <code>video composition</code>。你只需要初始化一个 <code>AVAssetExportSession</code> 对象，然后将其 <code>audioMix</code> 和 <code>videoComposition</code> 属性分别设置为你的 <code>audio mix</code> 和 <code>video composition</code> 即可。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%914.png\" alt=\"图四\"></p>\n<h4 id=\"创建-Composition\"><a href=\"#创建-Composition\" class=\"headerlink\" title=\"创建 Composition\"></a>创建 Composition</h4><p>上面简单介绍了集中音视频编辑的场景，现在我们来详细介绍具体的接口。从 <code>AVMutableComposition</code> 开始。</p>\n<p>当使用 <code>AVMutableComposition</code> 创建自己的 <code>composition</code> 时，最典型的，我们可以使用 <code>AVMutableCompositionTrack</code> 来向 <code>composition</code> 中添加一个或多个 <code>composition tracks</code>，比如下面这个简单的例子便是向一个 <code>composition</code> 中添加一个音频轨道和一个视频轨道：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVMutableComposition <span class=\"token operator\">*</span>mutableComposition <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableComposition composition<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the video composition track.</span>\nAVMutableCompositionTrack <span class=\"token operator\">*</span>mutableCompositionVideoTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableComposition addMutableTrackWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo preferredTrackID<span class=\"token punctuation\">:</span>kCMPersistentTrackID_Invalid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the audio composition track.</span>\nAVMutableCompositionTrack <span class=\"token operator\">*</span>mutableCompositionAudioTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableComposition addMutableTrackWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio preferredTrackID<span class=\"token punctuation\">:</span>kCMPersistentTrackID_Invalid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当为 <code>composition</code> 添加一个新的 <code>track</code> 的时候，需要设置其媒体类型（<code>media type</code>）和 <code>track ID</code>，主要的媒体类型包括：音频、视频、字幕、文本等等。</p>\n<p>这里需要注意的是，每个 <code>track</code> 都需要一个唯一的 <code>track ID</code>，比较方便的做法是：设置 <code>track ID</code> 为 <code>kCMPersistentTrackID_Invalid</code> 来为对应的 <code>track</code> 获得一个自动生成的唯一 <code>ID</code>。</p>\n<h4 id=\"向-Composition-添加视听数据\"><a href=\"#向-Composition-添加视听数据\" class=\"headerlink\" title=\"向 Composition 添加视听数据\"></a>向 Composition 添加视听数据</h4><p>要将媒体数据添加到一个 <code>composition track</code> 中需要访问媒体数据所在的 <code>AVAsset</code>，可以使用 <code>AVMutableCompositionTrack</code> 的接口将具有相同媒体类型的多个 <code>track</code> 添加到同一个 <code>composition track</code> 中。下面的例子便是从两个 <code>AVAsset</code> 中各取出一份 <code>video asset track</code>，再添加到一个新的 <code>composition track</code> 中去：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// You can retrieve AVAssets from a number of places, like the camera roll for example.</span>\nAVAsset <span class=\"token operator\">*</span>videoAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAsset with at least one video track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAsset <span class=\"token operator\">*</span>anotherVideoAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#another AVAsset with at least one video track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Get the first video track from each asset.</span>\nAVAssetTrack <span class=\"token operator\">*</span>videoAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>videoAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetTrack <span class=\"token operator\">*</span>anotherVideoAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>anotherVideoAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add them both to the composition.</span>\n<span class=\"token punctuation\">[</span>mutableCompositionVideoTrack insertTimeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span>videoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span> ofTrack<span class=\"token punctuation\">:</span>videoAssetTrack atTime<span class=\"token punctuation\">:</span>kCMTimeZero error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>mutableCompositionVideoTrack insertTimeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span>anotherVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span> ofTrack<span class=\"token punctuation\">:</span>anotherVideoAssetTrack atTime<span class=\"token punctuation\">:</span>videoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"检索兼容的-Composition-Tracks\"><a href=\"#检索兼容的-Composition-Tracks\" class=\"headerlink\" title=\"检索兼容的 Composition Tracks\"></a>检索兼容的 Composition Tracks</h4><p>如果可能，每一种媒体类型最好只使用一个 <code>composition track</code>，这样能够优化资源的使用。当你连续播放媒体数据时，应该将相同类型的媒体数据放到同一个 <code>composition track</code> 中，你可以通过类似下面的代码来从 <code>composition</code> 中查找是否有与当前的 <code>asset track</code> 兼容的 <code>composition track</code>，然后拿来使用：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVMutableCompositionTrack <span class=\"token operator\">*</span>compatibleCompositionTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableComposition mutableTrackCompatibleWithTrack<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#the AVAssetTrack you want to insert#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>compatibleCompositionTrack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Implementation continues.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>需要注意的是，在同一个 <code>composition track</code> 中添加多个视频段时，当视频段之间切换时可能会丢帧，尤其在嵌入式设备上。基于这个问题，应该合理选择一个 <code>composition track</code> 里的视频段数量。</p>\n<h4 id=\"设置音量渐变\"><a href=\"#设置音量渐变\" class=\"headerlink\" title=\"设置音量渐变\"></a>设置音量渐变</h4><p>只使用一个 <code>AVMutableAudioMix</code> 对象就能够为 <code>composition</code> 中的每一个 <code>audio track</code> 单独做音频处理。</p>\n<p>下面代码展示了如果使用 <code>AVMutableAudioMix</code> 给一个 <code>audio track</code> 设置音量渐变给声音增加一个淡出效果。使用 <code>audioMix</code> 类方法获取 <code>AVMutableAudioMix</code> 实例；然后使用 <code>AVMutableAudioMixInputParameters</code> 类的 <code>audioMixInputParametersWithTrack:</code> 接口将 <code>AVMutableAudioMix</code> 实例与 <code>composition</code> 中的某一个 <code>audio track</code> 关联起来；之后便可以通过 <code>AVMutableAudioMix</code> 实例来处理音量了。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVMutableAudioMix <span class=\"token operator\">*</span>mutableAudioMix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableAudioMix audioMix<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the audio mix input parameters object.</span>\nAVMutableAudioMixInputParameters <span class=\"token operator\">*</span>mixParameters <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableAudioMixInputParameters audioMixInputParametersWithTrack<span class=\"token punctuation\">:</span>mutableCompositionAudioTrack<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the volume ramp to slowly fade the audio out over the duration of the composition.</span>\n<span class=\"token punctuation\">[</span>mixParameters setVolumeRampFromStartVolume<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">.</span>f toEndVolume<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>f timeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> mutableComposition<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Attach the input parameters to the audio mix.</span>\nmutableAudioMix<span class=\"token punctuation\">.</span>inputParameters <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>mixParameters<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"自定义视频处理\"><a href=\"#自定义视频处理\" class=\"headerlink\" title=\"自定义视频处理\"></a>自定义视频处理</h4><p>处理音频是我们使用 <code>AVMutableAudioMix</code>，那么处理视频时，我们就使用 <code>AVMutableVideoComposition</code>，只需要一个 <code>AVMutableVideoComposition</code> 实例就可以为 <code>composition</code> 中所有的 <code>video track</code> 做处理，比如设置渲染尺寸、缩放、播放帧率等等。</p>\n<p>下面我们依次来看一些场景。</p>\n<h4 id=\"设置视频背景色\"><a href=\"#设置视频背景色\" class=\"headerlink\" title=\"设置视频背景色\"></a>设置视频背景色</h4><p>所有的 <code>video composition</code> 也必然对应一组 <code>AVVideoCompositionInstruction</code> 实例，每个 <code>AVVideoCompositionInstruction</code> 中至少包含一条 <code>video composition instruction</code>。我们可以使用 <code>AVMutableVideoCompositionInstruction</code> 来创建我们自己的 <code>video composition instruction</code>，通过这些指令，我们可以修改 <code>composition</code> 的背景颜色、后处理、<code>layer instruction</code> 等等。</p>\n<p>下面的实例代码展示了如何创建 <code>video composition instruction</code> 并将一个 <code>composition</code> 的整个时长都设置为红色背景色：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVMutableVideoCompositionInstruction <span class=\"token operator\">*</span>mutableVideoCompositionInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionInstruction videoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmutableVideoCompositionInstruction<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> mutableComposition<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmutableVideoCompositionInstruction<span class=\"token punctuation\">.</span>backgroundColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span> CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"设置透明度渐变\"><a href=\"#设置透明度渐变\" class=\"headerlink\" title=\"设置透明度渐变\"></a>设置透明度渐变</h4><p>我们也可以用 <code>video composition instructions</code> 来应用 <code>video composition layer instructions</code>。<code>AVMutableVideoCompositionLayerInstruction</code> 可以用来设置 <code>video track</code> 的图形变换、图形渐变、透明度、透明度渐变等等。一个 <code>video composition instruction</code> 的 <code>layerInstructions</code> 属性中所存储的 <code>layer instructions</code> 的顺序决定了 <code>tracks</code> 中的视频帧是如何被放置和组合的。</p>\n<p>下面的示例代码展示了如何在从一个视频切换到第二个视频时添加一个透明度渐变的效果：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAsset <span class=\"token operator\">*</span>firstVideoAssetTrack <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAssetTrack representing the first video segment played <span class=\"token keyword\">in</span> the composition#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAsset <span class=\"token operator\">*</span>secondVideoAssetTrack <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAssetTrack representing the second video segment played <span class=\"token keyword\">in</span> the composition#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the first video composition instruction.</span>\nAVMutableVideoCompositionInstruction <span class=\"token operator\">*</span>firstVideoCompositionInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionInstruction videoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set its time range to span the duration of the first video track.</span>\nfirstVideoCompositionInstruction<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the layer instruction and associate it with the composition video track.</span>\nAVMutableVideoCompositionLayerInstruction <span class=\"token operator\">*</span>firstVideoLayerInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack<span class=\"token punctuation\">:</span>mutableCompositionVideoTrack<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the opacity ramp to fade out the first video track over its entire duration.</span>\n<span class=\"token punctuation\">[</span>firstVideoLayerInstruction setOpacityRampFromStartOpacity<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">.</span>f toEndOpacity<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span>f timeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the second video composition instruction so that the second video track isn't transparent.</span>\nAVMutableVideoCompositionInstruction <span class=\"token operator\">*</span>secondVideoCompositionInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionInstruction videoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set its time range to span the duration of the second video track.</span>\nsecondVideoCompositionInstruction<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> <span class=\"token function\">CMTimeAdd</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the second layer instruction and associate it with the composition video track.</span>\nAVMutableVideoCompositionLayerInstruction <span class=\"token operator\">*</span>secondVideoLayerInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack<span class=\"token punctuation\">:</span>mutableCompositionVideoTrack<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Attach the first layer instruction to the first video composition instruction.</span>\nfirstVideoCompositionInstruction<span class=\"token punctuation\">.</span>layerInstructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>firstVideoLayerInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Attach the second layer instruction to the second video composition instruction.</span>\nsecondVideoCompositionInstruction<span class=\"token punctuation\">.</span>layerInstructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>secondVideoLayerInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Attach both of the video composition instructions to the video composition.</span>\nAVMutableVideoComposition <span class=\"token operator\">*</span>mutableVideoComposition <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoComposition videoComposition<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmutableVideoComposition<span class=\"token punctuation\">.</span>instructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>firstVideoCompositionInstruction<span class=\"token punctuation\">,</span> secondVideoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"动画效果\"><a href=\"#动画效果\" class=\"headerlink\" title=\"动画效果\"></a>动画效果</h4><p>我们还能通过设置 <code>video composition</code> 的 <code>animationTool</code> 属性来使用 <code>Core Animation Framework</code> 框架的强大能力。比如：设置视频水印、视频标题、动画浮层等。</p>\n<p>在 <code>video composition</code> 中使用 <code>Core Animation</code> 有两种不同的方式：</p>\n<p>添加一个 <code>Core Animation Layer</code> 作为独立的 <code>composition track</code><br>直接使用 <code>Core Animation Layer</code> 在视频帧中渲染动画效果<br>下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CALayer <span class=\"token operator\">*</span>watermarkLayer <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#CALayer representing your desired watermark image#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nCALayer <span class=\"token operator\">*</span>parentLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CALayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCALayer <span class=\"token operator\">*</span>videoLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CALayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nparentLayer<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvideoLayer<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>parentLayer addSublayer<span class=\"token punctuation\">:</span>videoLayer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nwatermarkLayer<span class=\"token punctuation\">.</span>position <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span>mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>width<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> mutableVideoComposition<span class=\"token punctuation\">.</span>renderSize<span class=\"token punctuation\">.</span>height<span class=\"token operator\">/</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>parentLayer addSublayer<span class=\"token punctuation\">:</span>watermarkLayer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmutableVideoComposition<span class=\"token punctuation\">.</span>animationTool <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVVideoCompositionCoreAnimationTool videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer<span class=\"token punctuation\">:</span>videoLayer inLayer<span class=\"token punctuation\">:</span>parentLayer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>这里的示例将展示如何合并两个 <code>video asset tracks</code> 和一个 <code>audio asset track</code> 到一个视频文件，其中大体步骤如下：</p>\n<ul>\n<li>创建一个 <code>AVMutableComposition</code> 对象，添加多个 <code>AVMutableCompositionTrack</code> 对象</li>\n<li>在各个 <code>composition tracks</code> 中添加 <code>AVAssetTrack</code> 对应的时间范围</li>\n<li>检查 <code>video asset track</code> 的 <code>preferredTransform</code> 属性决定视频方向</li>\n<li>使用 <code>AVMutableVideoCompositionLayerInstruction</code> 对象对视频进行图形变换</li>\n<li>设置 <code>video composition</code> 的 <code>renderSize</code> 和 <code>frameDuration</code> 属性</li>\n<li>导出视频文件</li>\n<li>保存视频文件到相册<br>下面的示例代码省略了一些内存管理和通知移除相关的代码。</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 1、创建 composition。创建一个 composition，并添加一个 audio track 和一个 video track。</span>\nAVMutableComposition <span class=\"token operator\">*</span>mutableComposition <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableComposition composition<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVMutableCompositionTrack <span class=\"token operator\">*</span>videoCompositionTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableComposition addMutableTrackWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo preferredTrackID<span class=\"token punctuation\">:</span>kCMPersistentTrackID_Invalid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVMutableCompositionTrack <span class=\"token operator\">*</span>audioCompositionTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableComposition addMutableTrackWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio preferredTrackID<span class=\"token punctuation\">:</span>kCMPersistentTrackID_Invalid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2、添加 asset。从源 assets 中取得两个 video track 和一个 audio track，在上面的 video composition track 中依次添加两个 video track，在 audio composition track 中添加一个 video track。</span>\nAVAsset <span class=\"token operator\">*</span>firstVideoAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#First AVAsset with at least one video track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAsset <span class=\"token operator\">*</span>secondVideoAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Second AVAsset with at least one video track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAsset <span class=\"token operator\">*</span>audioAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAsset with at least one audio track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAssetTrack <span class=\"token operator\">*</span>firstVideoAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>firstVideoAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetTrack <span class=\"token operator\">*</span>secondVideoAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>secondVideoAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetTrack <span class=\"token operator\">*</span>audioAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>audioAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span>videoCompositionTrack insertTimeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span> ofTrack<span class=\"token punctuation\">:</span>firstVideoAssetTrack atTime<span class=\"token punctuation\">:</span>kCMTimeZero error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>videoCompositionTrack insertTimeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span> ofTrack<span class=\"token punctuation\">:</span>secondVideoAssetTrack atTime<span class=\"token punctuation\">:</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>audioCompositionTrack insertTimeRange<span class=\"token punctuation\">:</span><span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> <span class=\"token function\">CMTimeAdd</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> ofTrack<span class=\"token punctuation\">:</span>audioAssetTrack atTime<span class=\"token punctuation\">:</span>kCMTimeZero error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 3、检查 composition 方向。在 composition 中添加了 audio track 和 video track 后，还必须确保其中所有的 video track 的视频方向都是一致的。在默认情况下 video track 默认为横屏模式，如果这时添加进来的 video track 是在竖屏模式下采集的，那么导出的视频会出现方向错误。同理，将一个横向的视频和一个纵向的视频进行合并导出，export session 会报错。</span>\nBOOL isFirstVideoPortrait <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\nCGAffineTransform firstTransform <span class=\"token operator\">=</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>preferredTransform<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Check the first video track's preferred transform to determine if it was recorded in portrait mode.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstTransform<span class=\"token punctuation\">.</span>a <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> firstTransform<span class=\"token punctuation\">.</span>d <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>firstTransform<span class=\"token punctuation\">.</span>b <span class=\"token operator\">==</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> firstTransform<span class=\"token punctuation\">.</span>b <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>firstTransform<span class=\"token punctuation\">.</span>c <span class=\"token operator\">==</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> firstTransform<span class=\"token punctuation\">.</span>c <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    isFirstVideoPortrait <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nBOOL isSecondVideoPortrait <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\nCGAffineTransform secondTransform <span class=\"token operator\">=</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>preferredTransform<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Check the second video track's preferred transform to determine if it was recorded in portrait mode.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>secondTransform<span class=\"token punctuation\">.</span>a <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> secondTransform<span class=\"token punctuation\">.</span>d <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>secondTransform<span class=\"token punctuation\">.</span>b <span class=\"token operator\">==</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> secondTransform<span class=\"token punctuation\">.</span>b <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>secondTransform<span class=\"token punctuation\">.</span>c <span class=\"token operator\">==</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> secondTransform<span class=\"token punctuation\">.</span>c <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    isSecondVideoPortrait <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>isFirstVideoAssetPortrait <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>isSecondVideoAssetPortrait<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isFirstVideoAssetPortrait <span class=\"token operator\">&amp;&amp;</span> isSecondVideoAssetPortrait<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    UIAlertView <span class=\"token operator\">*</span>incompatibleVideoOrientationAlert <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIAlertView alloc<span class=\"token punctuation\">]</span> initWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Error!\"</span> message<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Cannot combine a video shot in portrait mode with a video shot in landscape mode.\"</span> delegate<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> cancelButtonTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Dismiss\"</span> otherButtonTitles<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>incompatibleVideoOrientationAlert show<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 4、应用 Video Composition Layer Instructions。一旦你知道你要合并的视频片段的方向是兼容的，那么你接下来就可以为每个片段应用必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 所有的 `AVAssetTrack` 对象都有一个 `preferredTransform` 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面的代码中，layer instruction 的 transform 被设置为 asset track 的 transform，便于在你修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。</span>\nAVMutableVideoCompositionInstruction <span class=\"token operator\">*</span>firstVideoCompositionInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionInstruction videoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the time range of the first instruction to span the duration of the first video track.</span>\nfirstVideoCompositionInstruction<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>kCMTimeZero<span class=\"token punctuation\">,</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nAVMutableVideoCompositionInstruction <span class=\"token operator\">*</span>secondVideoCompositionInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionInstruction videoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the time range of the second instruction to span the duration of the second video track.</span>\nsecondVideoCompositionInstruction<span class=\"token punctuation\">.</span>timeRange <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeRangeMake</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> <span class=\"token function\">CMTimeAdd</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建两个 video layer instruction，关联对应的 video composition track，并设置 transform 为 preferredTransform。</span>\nAVMutableVideoCompositionLayerInstruction <span class=\"token operator\">*</span>firstVideoLayerInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack<span class=\"token punctuation\">:</span>videoCompositionTrack<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the transform of the first layer instruction to the preferred transform of the first video track.</span>\n<span class=\"token punctuation\">[</span>firstVideoLayerInstruction setTransform<span class=\"token punctuation\">:</span>firstTransform atTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVMutableVideoCompositionLayerInstruction <span class=\"token operator\">*</span>secondVideoLayerInstruction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack<span class=\"token punctuation\">:</span>videoCompositionTrack<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the transform of the second layer instruction to the preferred transform of the second video track.</span>\n<span class=\"token punctuation\">[</span>secondVideoLayerInstruction setTransform<span class=\"token punctuation\">:</span>secondTransform atTime<span class=\"token punctuation\">:</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>timeRange<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nfirstVideoCompositionInstruction<span class=\"token punctuation\">.</span>layerInstructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>firstVideoLayerInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nsecondVideoCompositionInstruction<span class=\"token punctuation\">.</span>layerInstructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>secondVideoLayerInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVMutableVideoComposition <span class=\"token operator\">*</span>mutableVideoComposition <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVMutableVideoComposition videoComposition<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmutableVideoComposition<span class=\"token punctuation\">.</span>instructions <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>firstVideoCompositionInstruction<span class=\"token punctuation\">,</span> secondVideoCompositionInstruction<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 5、设置渲染尺寸和帧率。要完全解决视频方向问题，你还需要调整 video composition 的 `renderSize` 属性，同时也需要设置一个合适的 `frameDuration`，比如 1/30 表示 30 帧每秒。此外，`renderScale` 默认值为 1.0。</span>\nCGSize naturalSizeFirst<span class=\"token punctuation\">,</span> naturalSizeSecond<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// If the first video asset was shot in portrait mode, then so was the second one if we made it here.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isFirstVideoAssetPortrait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Invert the width and height for the video tracks to ensure that they display properly.</span>\n    naturalSizeFirst <span class=\"token operator\">=</span> <span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span>firstVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    naturalSizeSecond <span class=\"token operator\">=</span> <span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span>secondVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// If the videos weren't shot in portrait mode, we can just use their natural sizes.</span>\n    naturalSizeFirst <span class=\"token operator\">=</span> firstVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">;</span>\n    naturalSizeSecond <span class=\"token operator\">=</span> secondVideoAssetTrack<span class=\"token punctuation\">.</span>naturalSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">float</span> renderWidth<span class=\"token punctuation\">,</span> renderHeight<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the renderWidth and renderHeight to the max of the two videos widths and heights.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>naturalSizeFirst<span class=\"token punctuation\">.</span>width <span class=\"token operator\">></span> naturalSizeSecond<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    renderWidth <span class=\"token operator\">=</span> naturalSizeFirst<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    renderWidth <span class=\"token operator\">=</span> naturalSizeSecond<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>naturalSizeFirst<span class=\"token punctuation\">.</span>height <span class=\"token operator\">></span> naturalSizeSecond<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    renderHeight <span class=\"token operator\">=</span> naturalSizeFirst<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    renderHeight <span class=\"token operator\">=</span> naturalSizeSecond<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nmutableVideoComposition<span class=\"token punctuation\">.</span>renderSize <span class=\"token operator\">=</span> <span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span>renderWidth<span class=\"token punctuation\">,</span> renderHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the frame duration to an appropriate value (i.e. 30 frames per second for video).</span>\nmutableVideoComposition<span class=\"token punctuation\">.</span>frameDuration <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 6、导出 composition 并保持到相册。创建一个 `AVAssetExportSession` 对象，设置对应的 `outputURL` 来将视频导出到指定的文件。同时，我们还可以用 `ALAssetsLibrary` 接口来将导出的视频文件存储到相册中去。</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create a static date formatter so we only have to initialize it once.</span>\n<span class=\"token keyword\">static</span> NSDateFormatter <span class=\"token operator\">*</span>kDateFormatter<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>kDateFormatter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    kDateFormatter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    kDateFormatter<span class=\"token punctuation\">.</span>dateStyle <span class=\"token operator\">=</span> NSDateFormatterMediumStyle<span class=\"token punctuation\">;</span>\n    kDateFormatter<span class=\"token punctuation\">.</span>timeStyle <span class=\"token operator\">=</span> NSDateFormatterShortStyle<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the export session with the composition and set the preset to the highest quality.</span>\nAVAssetExportSession <span class=\"token operator\">*</span>exporter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetExportSession alloc<span class=\"token punctuation\">]</span> initWithAsset<span class=\"token punctuation\">:</span>mutableComposition presetName<span class=\"token punctuation\">:</span>AVAssetExportPresetHighestQuality<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the desired output URL for the file created by the export process.</span>\nexporter<span class=\"token punctuation\">.</span>outputURL <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> URLForDirectory<span class=\"token punctuation\">:</span>NSDocumentDirectory inDomain<span class=\"token punctuation\">:</span>NSUserDomainMask appropriateForURL<span class=\"token punctuation\">:</span>nil create<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span>YES error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span> URLByAppendingPathComponent<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>kDateFormatter stringFromDate<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSDate date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> URLByAppendingPathExtension<span class=\"token punctuation\">:</span><span class=\"token function\">CFBridgingRelease</span><span class=\"token punctuation\">(</span><span class=\"token function\">UTTypeCopyPreferredTagWithClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFStringRef<span class=\"token punctuation\">)</span>AVFileTypeQuickTimeMovie<span class=\"token punctuation\">,</span> kUTTagClassFilenameExtension<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Set the output file type to be a QuickTime movie.</span>\nexporter<span class=\"token punctuation\">.</span>outputFileType <span class=\"token operator\">=</span> AVFileTypeQuickTimeMovie<span class=\"token punctuation\">;</span>\nexporter<span class=\"token punctuation\">.</span>shouldOptimizeForNetworkUse <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\nexporter<span class=\"token punctuation\">.</span>videoComposition <span class=\"token operator\">=</span> mutableVideoComposition<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Asynchronously export the composition to a video file and save this file to the camera roll once export completes.</span>\n<span class=\"token punctuation\">[</span>exporter exportAsynchronouslyWithCompletionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exporter<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> AVAssetExportSessionStatusCompleted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            ALAssetsLibrary <span class=\"token operator\">*</span>assetsLibrary <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>ALAssetsLibrary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum<span class=\"token punctuation\">:</span>exporter<span class=\"token punctuation\">.</span>outputURL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token punctuation\">[</span>assetsLibrary writeVideoAtPathToSavedPhotosAlbum<span class=\"token punctuation\">:</span>exporter<span class=\"token punctuation\">.</span>outputURL completionBlock<span class=\"token punctuation\">:</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-edit\" target=\"_blank\" rel=\"external\">AVAudioFoundation(3)：音视频编辑 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<h4 id=\"音视频编辑\"><a href=\"#音视频编辑\" class=\"headerlink\" title=\"音视频编辑\"></a>音视频编辑</h4><p>上面简单了解了下   <code>AVFoundation</code> 框架后，我们来看看跟音视频编辑相关的接口。</p>\n<p>一个 <code>composition</code> 可以简单的认为是一组轨道（<code>tracks</code>）的集合，这些轨道可以是来自不同媒体资源（<code>asset</code>）。<code>AVMutableComposition</code> 提供了接口来插入或者删除轨道，也可以调整这些轨道的顺序。</p>\n<p>下面这张图反映了一个新的 <code>composition</code> 是怎么从已有的 <code>asset</code> 中获取对应的 <code>track</code> 并进行拼接形成新的 <code>asset</code>。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%911.png\" alt=\"图一\"></p>\n<p>在处理音频时，你可以在使用 <code>AVMutableAudioMix</code> 类的接口来做一些自定义的操作，如下图所示。现在，你可以做到指定一个最大音量或设置一个音频轨道的音量渐变。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%912.png\" alt=\"图二\"></p>\n<p>如下图所示，我们还可以使用 <code>AVMutableVideoComposition</code> 来直接处理 <code>composition</code> 中的视频轨道。处理一个单独的 <code>video composition</code> 时，你可以指定它的渲染尺寸、缩放比例、帧率等参数并输出最终的视频文件。通过一些针对 <code>video composition</code> 的指令（<code>AVMutableVideoCompositionInstruction</code> 等），我们可以修改视频的背景颜色、应用 <code>layer instructions</code>。这些 <code>layer instructions</code>（<code>AVMutableVideoCompositionLayerInstruction</code> 等）可以用来对 <code>composition</code> 中的视频轨道实施图形变换、添加图形渐变、透明度变换、增加透明度渐变。此外，你还能通过设置 <code>video composition</code> 的 <code>animationTool</code> 属性来应用 <code>Core Animation Framework</code> 框架中的动画效果。<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%913.png\" alt=\"图三\"></p>\n<p>如下图所示，你可以使用 <code>AVAssetExportSession</code> 相关的接口来合并你的 <code>composition</code> 中的 <code>audio mix</code> 和 <code>video composition</code>。你只需要初始化一个 <code>AVAssetExportSession</code> 对象，然后将其 <code>audioMix</code> 和 <code>videoComposition</code> 属性分别设置为你的 <code>audio mix</code> 和 <code>video composition</code> 即可。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%914.png\" alt=\"图四\"></p>\n<h4 id=\"创建-Composition\"><a href=\"#创建-Composition\" class=\"headerlink\" title=\"创建 Composition\"></a>创建 Composition</h4><p>上面简单介绍了集中音视频编辑的场景，现在我们来详细介绍具体的接口。从 <code>AVMutableComposition</code> 开始。</p>\n<p>当使用 <code>AVMutableComposition</code> 创建自己的 <code>composition</code> 时，最典型的，我们可以使用 <code>AVMutableCompositionTrack</code> 来向 <code>composition</code> 中添加一个或多个 <code>composition tracks</code>，比如下面这个简单的例子便是向一个 <code>composition</code> 中添加一个音频轨道和一个视频轨道：</p>\n<pre><code class=\"objectivec\">AVMutableComposition *mutableComposition = [AVMutableComposition composition];\n// Create the video composition track.\nAVMutableCompositionTrack *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n// Create the audio composition track.\nAVMutableCompositionTrack *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n</code></pre>\n<p>当为 <code>composition</code> 添加一个新的 <code>track</code> 的时候，需要设置其媒体类型（<code>media type</code>）和 <code>track ID</code>，主要的媒体类型包括：音频、视频、字幕、文本等等。</p>\n<p>这里需要注意的是，每个 <code>track</code> 都需要一个唯一的 <code>track ID</code>，比较方便的做法是：设置 <code>track ID</code> 为 <code>kCMPersistentTrackID_Invalid</code> 来为对应的 <code>track</code> 获得一个自动生成的唯一 <code>ID</code>。</p>\n<h4 id=\"向-Composition-添加视听数据\"><a href=\"#向-Composition-添加视听数据\" class=\"headerlink\" title=\"向 Composition 添加视听数据\"></a>向 Composition 添加视听数据</h4><p>要将媒体数据添加到一个 <code>composition track</code> 中需要访问媒体数据所在的 <code>AVAsset</code>，可以使用 <code>AVMutableCompositionTrack</code> 的接口将具有相同媒体类型的多个 <code>track</code> 添加到同一个 <code>composition track</code> 中。下面的例子便是从两个 <code>AVAsset</code> 中各取出一份 <code>video asset track</code>，再添加到一个新的 <code>composition track</code> 中去：</p>\n<pre><code class=\"objectivec\">// You can retrieve AVAssets from a number of places, like the camera roll for example.\nAVAsset *videoAsset = &lt;#AVAsset with at least one video track#&gt;;\nAVAsset *anotherVideoAsset = &lt;#another AVAsset with at least one video track#&gt;;\n// Get the first video track from each asset.\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\n// Add them both to the composition.\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];\n[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil];\n</code></pre>\n<h4 id=\"检索兼容的-Composition-Tracks\"><a href=\"#检索兼容的-Composition-Tracks\" class=\"headerlink\" title=\"检索兼容的 Composition Tracks\"></a>检索兼容的 Composition Tracks</h4><p>如果可能，每一种媒体类型最好只使用一个 <code>composition track</code>，这样能够优化资源的使用。当你连续播放媒体数据时，应该将相同类型的媒体数据放到同一个 <code>composition track</code> 中，你可以通过类似下面的代码来从 <code>composition</code> 中查找是否有与当前的 <code>asset track</code> 兼容的 <code>composition track</code>，然后拿来使用：</p>\n<pre><code class=\"objectivec\">AVMutableCompositionTrack *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:&lt;#the AVAssetTrack you want to insert#&gt;];\nif (compatibleCompositionTrack) {\n    // Implementation continues.\n}\n</code></pre>\n<p>需要注意的是，在同一个 <code>composition track</code> 中添加多个视频段时，当视频段之间切换时可能会丢帧，尤其在嵌入式设备上。基于这个问题，应该合理选择一个 <code>composition track</code> 里的视频段数量。</p>\n<h4 id=\"设置音量渐变\"><a href=\"#设置音量渐变\" class=\"headerlink\" title=\"设置音量渐变\"></a>设置音量渐变</h4><p>只使用一个 <code>AVMutableAudioMix</code> 对象就能够为 <code>composition</code> 中的每一个 <code>audio track</code> 单独做音频处理。</p>\n<p>下面代码展示了如果使用 <code>AVMutableAudioMix</code> 给一个 <code>audio track</code> 设置音量渐变给声音增加一个淡出效果。使用 <code>audioMix</code> 类方法获取 <code>AVMutableAudioMix</code> 实例；然后使用 <code>AVMutableAudioMixInputParameters</code> 类的 <code>audioMixInputParametersWithTrack:</code> 接口将 <code>AVMutableAudioMix</code> 实例与 <code>composition</code> 中的某一个 <code>audio track</code> 关联起来；之后便可以通过 <code>AVMutableAudioMix</code> 实例来处理音量了。</p>\n<pre><code class=\"objectivec\">AVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];\n// Create the audio mix input parameters object.\nAVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];\n// Set the volume ramp to slowly fade the audio out over the duration of the composition.\n[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];\n// Attach the input parameters to the audio mix.\nmutableAudioMix.inputParameters = @[mixParameters];\n</code></pre>\n<h4 id=\"自定义视频处理\"><a href=\"#自定义视频处理\" class=\"headerlink\" title=\"自定义视频处理\"></a>自定义视频处理</h4><p>处理音频是我们使用 <code>AVMutableAudioMix</code>，那么处理视频时，我们就使用 <code>AVMutableVideoComposition</code>，只需要一个 <code>AVMutableVideoComposition</code> 实例就可以为 <code>composition</code> 中所有的 <code>video track</code> 做处理，比如设置渲染尺寸、缩放、播放帧率等等。</p>\n<p>下面我们依次来看一些场景。</p>\n<h4 id=\"设置视频背景色\"><a href=\"#设置视频背景色\" class=\"headerlink\" title=\"设置视频背景色\"></a>设置视频背景色</h4><p>所有的 <code>video composition</code> 也必然对应一组 <code>AVVideoCompositionInstruction</code> 实例，每个 <code>AVVideoCompositionInstruction</code> 中至少包含一条 <code>video composition instruction</code>。我们可以使用 <code>AVMutableVideoCompositionInstruction</code> 来创建我们自己的 <code>video composition instruction</code>，通过这些指令，我们可以修改 <code>composition</code> 的背景颜色、后处理、<code>layer instruction</code> 等等。</p>\n<p>下面的实例代码展示了如何创建 <code>video composition instruction</code> 并将一个 <code>composition</code> 的整个时长都设置为红色背景色：</p>\n<pre><code class=\"objectivec\">AVMutableVideoCompositionInstruction *mutableVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\nmutableVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, mutableComposition.duration);\nmutableVideoCompositionInstruction.backgroundColor = [[UIColor redColor] CGColor];\n</code></pre>\n<h4 id=\"设置透明度渐变\"><a href=\"#设置透明度渐变\" class=\"headerlink\" title=\"设置透明度渐变\"></a>设置透明度渐变</h4><p>我们也可以用 <code>video composition instructions</code> 来应用 <code>video composition layer instructions</code>。<code>AVMutableVideoCompositionLayerInstruction</code> 可以用来设置 <code>video track</code> 的图形变换、图形渐变、透明度、透明度渐变等等。一个 <code>video composition instruction</code> 的 <code>layerInstructions</code> 属性中所存储的 <code>layer instructions</code> 的顺序决定了 <code>tracks</code> 中的视频帧是如何被放置和组合的。</p>\n<p>下面的示例代码展示了如何在从一个视频切换到第二个视频时添加一个透明度渐变的效果：</p>\n<pre><code class=\"objectivec\">AVAsset *firstVideoAssetTrack = &lt;#AVAssetTrack representing the first video segment played in the composition#&gt;;\nAVAsset *secondVideoAssetTrack = &lt;#AVAssetTrack representing the second video segment played in the composition#&gt;;\n// Create the first video composition instruction.\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\n// Create the layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Create the opacity ramp to fade out the first video track over its entire duration.\n[firstVideoLayerInstruction setOpacityRampFromStartOpacity:1.f toEndOpacity:0.f timeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];\n// Create the second video composition instruction so that the second video track isn&#39;t transparent.\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set its time range to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n// Create the second layer instruction and associate it with the composition video track.\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];\n// Attach the first layer instruction to the first video composition instruction.\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\n// Attach the second layer instruction to the second video composition instruction.\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\n// Attach both of the video composition instructions to the video composition.\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n</code></pre>\n<h4 id=\"动画效果\"><a href=\"#动画效果\" class=\"headerlink\" title=\"动画效果\"></a>动画效果</h4><p>我们还能通过设置 <code>video composition</code> 的 <code>animationTool</code> 属性来使用 <code>Core Animation Framework</code> 框架的强大能力。比如：设置视频水印、视频标题、动画浮层等。</p>\n<p>在 <code>video composition</code> 中使用 <code>Core Animation</code> 有两种不同的方式：</p>\n<p>添加一个 <code>Core Animation Layer</code> 作为独立的 <code>composition track</code><br>直接使用 <code>Core Animation Layer</code> 在视频帧中渲染动画效果<br>下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：</p>\n<pre><code class=\"objectivec\">CALayer *watermarkLayer = &lt;#CALayer representing your desired watermark image#&gt;;\nCALayer *parentLayer = [CALayer layer];\nCALayer *videoLayer = [CALayer layer];\nparentLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\nvideoLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);\n[parentLayer addSublayer:videoLayer];\nwatermarkLayer.position = CGPointMake(mutableVideoComposition.renderSize.width/2, mutableVideoComposition.renderSize.height/4);\n[parentLayer addSublayer:watermarkLayer];\nmutableVideoComposition.animationTool = [AVVideoCompositionCoreAnimationTool videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];\n</code></pre>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>这里的示例将展示如何合并两个 <code>video asset tracks</code> 和一个 <code>audio asset track</code> 到一个视频文件，其中大体步骤如下：</p>\n<ul>\n<li>创建一个 <code>AVMutableComposition</code> 对象，添加多个 <code>AVMutableCompositionTrack</code> 对象</li>\n<li>在各个 <code>composition tracks</code> 中添加 <code>AVAssetTrack</code> 对应的时间范围</li>\n<li>检查 <code>video asset track</code> 的 <code>preferredTransform</code> 属性决定视频方向</li>\n<li>使用 <code>AVMutableVideoCompositionLayerInstruction</code> 对象对视频进行图形变换</li>\n<li>设置 <code>video composition</code> 的 <code>renderSize</code> 和 <code>frameDuration</code> 属性</li>\n<li>导出视频文件</li>\n<li>保存视频文件到相册<br>下面的示例代码省略了一些内存管理和通知移除相关的代码。</li>\n</ul>\n<pre><code class=\"objectivec\">// 1、创建 composition。创建一个 composition，并添加一个 audio track 和一个 video track。\nAVMutableComposition *mutableComposition = [AVMutableComposition composition];\nAVMutableCompositionTrack *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\nAVMutableCompositionTrack *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n\n// 2、添加 asset。从源 assets 中取得两个 video track 和一个 audio track，在上面的 video composition track 中依次添加两个 video track，在 audio composition track 中添加一个 video track。\nAVAsset *firstVideoAsset = &lt;#First AVAsset with at least one video track#&gt;;\nAVAsset *secondVideoAsset = &lt;#Second AVAsset with at least one video track#&gt;;\nAVAsset *audioAsset = &lt;#AVAsset with at least one audio track#&gt;;\nAVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nAVAssetTrack *audioAssetTrack = [[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0]\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack atTime:kCMTimeZero error:nil];\n[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil];\n[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:audioAssetTrack atTime:kCMTimeZero error:nil];\n\n// 3、检查 composition 方向。在 composition 中添加了 audio track 和 video track 后，还必须确保其中所有的 video track 的视频方向都是一致的。在默认情况下 video track 默认为横屏模式，如果这时添加进来的 video track 是在竖屏模式下采集的，那么导出的视频会出现方向错误。同理，将一个横向的视频和一个纵向的视频进行合并导出，export session 会报错。\nBOOL isFirstVideoPortrait = NO;\nCGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;\n// Check the first video track&#39;s preferred transform to determine if it was recorded in portrait mode.\nif (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 || firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c == -1.0)) {\n    isFirstVideoPortrait = YES;\n}\nBOOL isSecondVideoPortrait = NO;\nCGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;\n// Check the second video track&#39;s preferred transform to determine if it was recorded in portrait mode.\nif (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0 || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c == -1.0)) {\n    isSecondVideoPortrait = YES;\n}\nif ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) || (!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) {\n    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc] initWithTitle:@&quot;Error!&quot; message:@&quot;Cannot combine a video shot in portrait mode with a video shot in landscape mode.&quot; delegate:self cancelButtonTitle:@&quot;Dismiss&quot; otherButtonTitles:nil];\n    [incompatibleVideoOrientationAlert show];\n    return;\n}\n\n// 4、应用 Video Composition Layer Instructions。一旦你知道你要合并的视频片段的方向是兼容的，那么你接下来就可以为每个片段应用必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中。\n// 所有的 `AVAssetTrack` 对象都有一个 `preferredTransform` 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面的代码中，layer instruction 的 transform 被设置为 asset track 的 transform，便于在你修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。\nAVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the first instruction to span the duration of the first video track.\nfirstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);\nAVMutableVideoCompositionInstruction *secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];\n// Set the time range of the second instruction to span the duration of the second video track.\nsecondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));\n\n// 创建两个 video layer instruction，关联对应的 video composition track，并设置 transform 为 preferredTransform。\nAVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the first layer instruction to the preferred transform of the first video track.\n[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];\nAVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];\n// Set the transform of the second layer instruction to the preferred transform of the second video track.\n[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];\n\nfirstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];\nsecondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];\nAVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];\nmutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];\n\n// 5、设置渲染尺寸和帧率。要完全解决视频方向问题，你还需要调整 video composition 的 `renderSize` 属性，同时也需要设置一个合适的 `frameDuration`，比如 1/30 表示 30 帧每秒。此外，`renderScale` 默认值为 1.0。\nCGSize naturalSizeFirst, naturalSizeSecond;\n// If the first video asset was shot in portrait mode, then so was the second one if we made it here.\nif (isFirstVideoAssetPortrait) {\n    // Invert the width and height for the video tracks to ensure that they display properly.\n    naturalSizeFirst = CGSizeMake(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);\n    naturalSizeSecond = CGSizeMake(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);\n} else {\n    // If the videos weren&#39;t shot in portrait mode, we can just use their natural sizes.\n    naturalSizeFirst = firstVideoAssetTrack.naturalSize;\n    naturalSizeSecond = secondVideoAssetTrack.naturalSize;\n}\nfloat renderWidth, renderHeight;\n// Set the renderWidth and renderHeight to the max of the two videos widths and heights.\nif (naturalSizeFirst.width &gt; naturalSizeSecond.width) {\n    renderWidth = naturalSizeFirst.width;\n} else {\n    renderWidth = naturalSizeSecond.width;\n}\nif (naturalSizeFirst.height &gt; naturalSizeSecond.height) {\n    renderHeight = naturalSizeFirst.height;\n} else {\n    renderHeight = naturalSizeSecond.height;\n}\nmutableVideoComposition.renderSize = CGSizeMake(renderWidth, renderHeight);\n// Set the frame duration to an appropriate value (i.e. 30 frames per second for video).\nmutableVideoComposition.frameDuration = CMTimeMake(1,30);\n\n\n// 6、导出 composition 并保持到相册。创建一个 `AVAssetExportSession` 对象，设置对应的 `outputURL` 来将视频导出到指定的文件。同时，我们还可以用 `ALAssetsLibrary` 接口来将导出的视频文件存储到相册中去。\n// Create a static date formatter so we only have to initialize it once.\nstatic NSDateFormatter *kDateFormatter;\nif (!kDateFormatter) {\n    kDateFormatter = [[NSDateFormatter alloc] init];\n    kDateFormatter.dateStyle = NSDateFormatterMediumStyle;\n    kDateFormatter.timeStyle = NSDateFormatterShortStyle;\n}\n// Create the export session with the composition and set the preset to the highest quality.\nAVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mutableComposition presetName:AVAssetExportPresetHighestQuality];\n// Set the desired output URL for the file created by the export process.\nexporter.outputURL = [[[[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:@YES error:nil] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[NSDate date]]] URLByAppendingPathExtension:CFBridgingRelease(UTTypeCopyPreferredTagWithClass((CFStringRef)AVFileTypeQuickTimeMovie, kUTTagClassFilenameExtension))];\n// Set the output file type to be a QuickTime movie.\nexporter.outputFileType = AVFileTypeQuickTimeMovie;\nexporter.shouldOptimizeForNetworkUse = YES;\nexporter.videoComposition = mutableVideoComposition;\n// Asynchronously export the composition to a video file and save this file to the camera roll once export completes.\n[exporter exportAsynchronouslyWithCompletionHandler:^{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        if (exporter.status == AVAssetExportSessionStatusCompleted) {\n            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];\n            if ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {\n                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:NULL];\n            }\n        }\n    });\n}];\n</code></pre>\n"},{"title":"AVAudioFoundation(6)：时间和媒体表示","date":"2017-07-07T00:57:37.000Z","_content":"\n\n本文转自：[AVAudioFoundation(6)：时间和媒体表示 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n基于时间的音视频数据，例如电影文件或视频流，在 `AVFoundation` 框架中用 `AVAsset` 来表示。`AVFoundation` 用于表示时间和媒体的几个底层数据结构，来自 `Core Media` 框架。\n\n#### 资源的表示方式\n\n`AVAsset` 是 `AVFoundation` 框架中的核心类。它对基于时间的音视频数据的进行了抽象，例如电影文件或视频流。主要关系如下图所示。在许多情况下，我们需要使用其子类之一。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA1.png)\n\n`Asset` 包含了将在一起显示或处理的多个轨道，每个轨道均包含（但不限于）音频、视频、文本、可隐藏字幕和字幕。 `Asset` 提供了关于资源的完整信息，比如时长、标题，以及渲染时的提示、视频源尺寸等等。 资产还可以包含由 `AVMetadataItem` 表示的元数据。\n\n轨道用 `AVAssetTrack` 的实例表示，如下图所示。在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，音频和视频可能有多个重叠的轨道。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA2.png)\n\n轨道具有许多属性，例如其类型（视频或音频），视频和/或音频特征，元数据和时间轴。轨道有一个数组用来描述其格式。该数组包含一组 `CMFormatDescription` 对象，每个对象描述轨道对应的媒体样本的格式。包含统一媒体的轨道（比如，都使用相同的设置来编码）将提供一个计数为 1 的数组。\n\n轨道本身可以被划分成多段，由 `AVAssetTrackSegment` 的实例表示。段是从源到资产轨道时间轴的时间映射。\n\n\n#### 时间的表示\n\n`AVFoundation` 中用来表示时间的数据结构主要来自于 `Core Media` 框架。\n\n##### 用 CMTime 表示时长\n\n`CMTime` 是一个 C 的数据结构，它表示时间为有理数，包含分子和分母。分子表示时间值，分母表示时间刻度，分子除以分母则表示时间，单位为秒。比如当时间刻度是 10，则表示每个单位的时间值表示 1/10 秒。最常用的时间刻度是 600，因为在场景的场景中，我们用 24 fps 的电影，30 fps 的 NTSC，25 fps 的 PAL。使用 600 的时间刻度，可以准确地表示这些系统中的任何数量的帧。\n\n除了简单的时间值之外，`CMTime` 结构可以表示非数值的值：正无穷大，负无穷大和无定义。 它也可以指示时间是否在某一点被舍入，并且它能保持一个纪元数字。\n\n##### 使用 CMTime\n\n下面是一些使用 `CMTime` 示例：\n\n\n```objectivec\nCMTime time1 = CMTimeMake(200, 2); // 200 half-seconds\nCMTime time2 = CMTimeMake(400, 4); // 400 quarter-seconds\n\n// time1 and time2 both represent 100 seconds, but using different timescales.\nif (CMTimeCompare(time1, time2) == 0) {\n    NSLog(@\"time1 and time2 are the same\");\n}\n\nFloat64 float64Seconds = 200.0 / 3;\nCMTime time3 = CMTimeMakeWithSeconds(float64Seconds , 3); // 66.66... third-seconds\ntime3 = CMTimeMultiply(time3, 3);\n// time3 now represents 200 seconds; next subtract time1 (100 seconds).\ntime3 = CMTimeSubtract(time3, time1);\nCMTimeShow(time3);\n\nif (CMTIME_COMPARE_INLINE(time2, ==, time3)) {\n    NSLog(@\"time2 and time3 are the same\");\n}\n```\n\n##### CMTime 的特殊值\n\n`Core Media` 提供了一些关于 `CMTime` 的特殊值，比如：`kCMTimeZero`，`kCMTimeInvalid`，`kCMTimePositiveInfinity`，`kCMTimeNegativeInfinity`。要检查一个表示非数值的 `CMTime` 是否是合法的，可以用 `CMTIME_IS_INVALID`，`CMTIME_IS_POSITIVE_INFINITY`，`CMTIME_IS_INDEFINITE` 这些宏。\n\n```objectivec\nCMTime myTime = <#Get a CMTime#>;\nif (CMTIME_IS_INVALID(myTime)) {\n    // Perhaps treat this as an error; display a suitable alert to the user.\n}\n```\n\n不要去拿一个 `CMTime` 和 `kCMTimeInvalid` 做比较。\n\n\n##### 用对象的方式使用 CMTime\n\n如果要使用 `Core Foundation` 中的一些容器来存储 `CMTime`，我们需要进行 `CMTime` 和 `CFDictionary` 之间的转换。这时我们需要用到 `CMTimeCopyAsDictionary` 和 `CMTimeMakeFromDictionary` 这些方法。我们还能用 `CMTimeCopyDescription` 来输出描述 `CMTime` 的字符串。\n\n##### 纪元\n\n通常 `CMTime` 中的 `epoch` 设置为 0，不过我们也可以设置它为其他值来区分不相关的时间轴。比如，我们可以在循环遍历中递增`epoch` 的值，每一个 0 到 N 的循序递增一下 `epoch` 来区分不同的轮回。\n\n##### 用 CMTimeRange 来表示时间范围\n\n`CMTimeRange` 表示的时间范围包含两个字段：开始时间（start）和时长（duration），这两个字段都是 CMTime 类型。需要注意的是一个 `CMTimeRange` 不含开始时间加上时长算出来的那个时间点，即 [start, start + duration)。\n\n我们可以用 `CMTimeRangeMake` 和 `CMTimeRangeFromTimeToTime` 来创建 `CMTimeRange`。但是这里有一些限制：\n\n`CMTimeRange` 不能跨越不同的纪元。\n`CMTime` 中的 `epoch` 字段可能不为 0，但是我们只能对 start 字段具有相同 `epoch` 的  `CMTimeRange` 执行相关操作（比如 `CMTimeRangeGetUnion`）。\n表示 `duration` 的 `CMTime` 结构中的 `epoch` 应始终为 0，`value` 必须为非负数。\n\n\n##### 使用 CMTimeRange\n\n`Core Media` 提供了一系列操作 `CMTimeRange` 的方法，比如 `CMTimeRangeContainsTime`、`CMTimeRangeEqual`、`CMTimeRangeContainsTimeRange`、`CMTimeRangeGetUnion`.\n\n下面的代码返回值永远为 `false`：\n\n\n```objectivec\nCMTimeRangeContainsTime(range, CMTimeRangeGetEnd(range))\nCMTimeRange 的特殊值\n```\n\n`Core Media` 提供了 `kCMTimeRangeZero` 和 `kCMTimeRangeInvalid` 表示零长度 `range` 和错误 `range`。在很多情况下，`CMTimeRange` 结构可能无效，或者是零或不定式（如果其中一个 `CMTime` 字段是不确定的）。如果要测试 `CMTimeRange` 结构是否有效、零或不确定，可以使用一个适当的宏：`CMTIMERANGE_IS_VALID`，`CMTIMERANGE_IS_INVALID`，`CMTIMERANGE_IS_EMPTY` 或 `CMTIMERANGE_IS_EMPTY`。\n\n```objectivec\nCMTimeRange myTimeRange = <#Get a CMTimeRange#>;\nif (CMTIMERANGE_IS_EMPTY(myTimeRange)) {\n    // The time range is zero.\n}\n```\n\n不要拿任何 `CMTimeRange` 和 `kCMTimeRangeInvalid` 做比较。\n\n##### 用对象的方式使用 `CMTimeRange`\n\n如果要在 `Core Foundation` 提供的容器中使用 `CMTimeRange` 结构，则可以分别使用 `CMTimeRangeCopyAsDictionary `和 `CMTimeRangeMakeFromDictionary` 将 `CMTimeRange` 结构转换为 `CFDictionary` 类型。 还可以使用 `CMTimeRangeCopyDescription` 函数获取 `CMTimeRange` 结构的字符串表示形式。\n\n##### 媒体的表示\n\n视频数据及其关联的元数据在 `AVFoundation` 中由 `Core Media` 框架中的对象表示。 `Core Media` 使用 `CMSampleBuffer` 表示视频数据。`CMSampleBuffer` 是一种 `Core Foundation` 风格的类型。`CMSampleBuffer` 的一个实例在对应的 `Core Video pixel buffer` 中包含了视频帧的数据（参见 `CVPixelBufferRef`）。 我们可以使用 `CMSampleBufferGetImageBuffer` 从样本缓冲区访问 `pixel buffer`：\n\n```objectivec\nCVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(<#A CMSampleBuffer#>);\n ```\n\n从 `pixel buffer` 中，我们可以访问实际的视频数据。\n\n除了视频数据之外，您还可以检索视频帧的其他方面的数据：\n\n时间信息。我们可以分别使用 `CMSampleBufferGetPresentationTimeStamp` 和 `CMSampleBufferGetDecodeTimeStamp `获得原始演示时间和解码时间的准确时间戳。\n格式信息。格式信息封装在 `CMFormatDescription` 对象中。从格式描述中，可以分别使用 `CMVideoFormatDescriptionGetCodecType` 和 `CMVideoFormatDescriptionGetDimensions` 获取像素类型和视频尺寸。\n元数据。元数据作为附件存储在字典中。您使用 CMGetAttachment 检索字典。如下面代码所示：\n\n```objectivec\nCMSampleBufferRef sampleBuffer = <#Get a sample buffer#>;\nCFDictionaryRef metadataDictionary = CMGetAttachment(sampleBuffer, CFSTR(\"MetadataDictionary\", NULL);\nif (metadataDictionary) {\n    // Do something with the metadata.\n}\n```\n\n#### 将 CMSampleBuffer 转换为 UIImage\n\n以下代码显示如何将 `CMSampleBuffer` 转换为 `UIImage` 对象。 使用前，我们要仔细考虑对应的需求。 执行转换是比较昂贵的操作。例如，从每隔一秒钟拍摄的视频数据帧创建静止图像是合适的，但不应该使用它来实时操纵来自录制设备的每一帧视频。\n\n```objectivec\n// Create a UIImage from sample buffer data.\n- (UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer {\n    // Get a CMSampleBuffer's Core Video image buffer for the media data\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n    // Lock the base address of the pixel buffer\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n\n    // Get the number of bytes per row for the pixel buffer\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n\n    // Get the number of bytes per row for the pixel buffer\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    // Get the pixel buffer width and height\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n\n    // Create a device-dependent RGB color space\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\n    // Create a bitmap graphics context with the sample buffer data\n    CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8,\n      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    // Create a Quartz image from the pixel data in the bitmap graphics context\n    CGImageRef quartzImage = CGBitmapContextCreateImage(context);\n    // Unlock the pixel buffer\n    CVPixelBufferUnlockBaseAddress(imageBuffer,0);\n\n    // Free up the context and color space\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    // Create an image object from the Quartz image\n    UIImage *image = [UIImage imageWithCGImage:quartzImage];\n\n    // Release the Quartz image\n    CGImageRelease(quartzImage);\n\n    return (image);\n}\n```\n\n","source":"_posts/AVAudioFoundation-6-：时间和媒体表示.md","raw":"---\ntitle: AVAudioFoundation(6)：时间和媒体表示\ndate: 2017-07-07 08:57:37\ncategories: \n\t- iOS合集\n---\n\n\n本文转自：[AVAudioFoundation(6)：时间和媒体表示 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n基于时间的音视频数据，例如电影文件或视频流，在 `AVFoundation` 框架中用 `AVAsset` 来表示。`AVFoundation` 用于表示时间和媒体的几个底层数据结构，来自 `Core Media` 框架。\n\n#### 资源的表示方式\n\n`AVAsset` 是 `AVFoundation` 框架中的核心类。它对基于时间的音视频数据的进行了抽象，例如电影文件或视频流。主要关系如下图所示。在许多情况下，我们需要使用其子类之一。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA1.png)\n\n`Asset` 包含了将在一起显示或处理的多个轨道，每个轨道均包含（但不限于）音频、视频、文本、可隐藏字幕和字幕。 `Asset` 提供了关于资源的完整信息，比如时长、标题，以及渲染时的提示、视频源尺寸等等。 资产还可以包含由 `AVMetadataItem` 表示的元数据。\n\n轨道用 `AVAssetTrack` 的实例表示，如下图所示。在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，音频和视频可能有多个重叠的轨道。\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA2.png)\n\n轨道具有许多属性，例如其类型（视频或音频），视频和/或音频特征，元数据和时间轴。轨道有一个数组用来描述其格式。该数组包含一组 `CMFormatDescription` 对象，每个对象描述轨道对应的媒体样本的格式。包含统一媒体的轨道（比如，都使用相同的设置来编码）将提供一个计数为 1 的数组。\n\n轨道本身可以被划分成多段，由 `AVAssetTrackSegment` 的实例表示。段是从源到资产轨道时间轴的时间映射。\n\n\n#### 时间的表示\n\n`AVFoundation` 中用来表示时间的数据结构主要来自于 `Core Media` 框架。\n\n##### 用 CMTime 表示时长\n\n`CMTime` 是一个 C 的数据结构，它表示时间为有理数，包含分子和分母。分子表示时间值，分母表示时间刻度，分子除以分母则表示时间，单位为秒。比如当时间刻度是 10，则表示每个单位的时间值表示 1/10 秒。最常用的时间刻度是 600，因为在场景的场景中，我们用 24 fps 的电影，30 fps 的 NTSC，25 fps 的 PAL。使用 600 的时间刻度，可以准确地表示这些系统中的任何数量的帧。\n\n除了简单的时间值之外，`CMTime` 结构可以表示非数值的值：正无穷大，负无穷大和无定义。 它也可以指示时间是否在某一点被舍入，并且它能保持一个纪元数字。\n\n##### 使用 CMTime\n\n下面是一些使用 `CMTime` 示例：\n\n\n```objectivec\nCMTime time1 = CMTimeMake(200, 2); // 200 half-seconds\nCMTime time2 = CMTimeMake(400, 4); // 400 quarter-seconds\n\n// time1 and time2 both represent 100 seconds, but using different timescales.\nif (CMTimeCompare(time1, time2) == 0) {\n    NSLog(@\"time1 and time2 are the same\");\n}\n\nFloat64 float64Seconds = 200.0 / 3;\nCMTime time3 = CMTimeMakeWithSeconds(float64Seconds , 3); // 66.66... third-seconds\ntime3 = CMTimeMultiply(time3, 3);\n// time3 now represents 200 seconds; next subtract time1 (100 seconds).\ntime3 = CMTimeSubtract(time3, time1);\nCMTimeShow(time3);\n\nif (CMTIME_COMPARE_INLINE(time2, ==, time3)) {\n    NSLog(@\"time2 and time3 are the same\");\n}\n```\n\n##### CMTime 的特殊值\n\n`Core Media` 提供了一些关于 `CMTime` 的特殊值，比如：`kCMTimeZero`，`kCMTimeInvalid`，`kCMTimePositiveInfinity`，`kCMTimeNegativeInfinity`。要检查一个表示非数值的 `CMTime` 是否是合法的，可以用 `CMTIME_IS_INVALID`，`CMTIME_IS_POSITIVE_INFINITY`，`CMTIME_IS_INDEFINITE` 这些宏。\n\n```objectivec\nCMTime myTime = <#Get a CMTime#>;\nif (CMTIME_IS_INVALID(myTime)) {\n    // Perhaps treat this as an error; display a suitable alert to the user.\n}\n```\n\n不要去拿一个 `CMTime` 和 `kCMTimeInvalid` 做比较。\n\n\n##### 用对象的方式使用 CMTime\n\n如果要使用 `Core Foundation` 中的一些容器来存储 `CMTime`，我们需要进行 `CMTime` 和 `CFDictionary` 之间的转换。这时我们需要用到 `CMTimeCopyAsDictionary` 和 `CMTimeMakeFromDictionary` 这些方法。我们还能用 `CMTimeCopyDescription` 来输出描述 `CMTime` 的字符串。\n\n##### 纪元\n\n通常 `CMTime` 中的 `epoch` 设置为 0，不过我们也可以设置它为其他值来区分不相关的时间轴。比如，我们可以在循环遍历中递增`epoch` 的值，每一个 0 到 N 的循序递增一下 `epoch` 来区分不同的轮回。\n\n##### 用 CMTimeRange 来表示时间范围\n\n`CMTimeRange` 表示的时间范围包含两个字段：开始时间（start）和时长（duration），这两个字段都是 CMTime 类型。需要注意的是一个 `CMTimeRange` 不含开始时间加上时长算出来的那个时间点，即 [start, start + duration)。\n\n我们可以用 `CMTimeRangeMake` 和 `CMTimeRangeFromTimeToTime` 来创建 `CMTimeRange`。但是这里有一些限制：\n\n`CMTimeRange` 不能跨越不同的纪元。\n`CMTime` 中的 `epoch` 字段可能不为 0，但是我们只能对 start 字段具有相同 `epoch` 的  `CMTimeRange` 执行相关操作（比如 `CMTimeRangeGetUnion`）。\n表示 `duration` 的 `CMTime` 结构中的 `epoch` 应始终为 0，`value` 必须为非负数。\n\n\n##### 使用 CMTimeRange\n\n`Core Media` 提供了一系列操作 `CMTimeRange` 的方法，比如 `CMTimeRangeContainsTime`、`CMTimeRangeEqual`、`CMTimeRangeContainsTimeRange`、`CMTimeRangeGetUnion`.\n\n下面的代码返回值永远为 `false`：\n\n\n```objectivec\nCMTimeRangeContainsTime(range, CMTimeRangeGetEnd(range))\nCMTimeRange 的特殊值\n```\n\n`Core Media` 提供了 `kCMTimeRangeZero` 和 `kCMTimeRangeInvalid` 表示零长度 `range` 和错误 `range`。在很多情况下，`CMTimeRange` 结构可能无效，或者是零或不定式（如果其中一个 `CMTime` 字段是不确定的）。如果要测试 `CMTimeRange` 结构是否有效、零或不确定，可以使用一个适当的宏：`CMTIMERANGE_IS_VALID`，`CMTIMERANGE_IS_INVALID`，`CMTIMERANGE_IS_EMPTY` 或 `CMTIMERANGE_IS_EMPTY`。\n\n```objectivec\nCMTimeRange myTimeRange = <#Get a CMTimeRange#>;\nif (CMTIMERANGE_IS_EMPTY(myTimeRange)) {\n    // The time range is zero.\n}\n```\n\n不要拿任何 `CMTimeRange` 和 `kCMTimeRangeInvalid` 做比较。\n\n##### 用对象的方式使用 `CMTimeRange`\n\n如果要在 `Core Foundation` 提供的容器中使用 `CMTimeRange` 结构，则可以分别使用 `CMTimeRangeCopyAsDictionary `和 `CMTimeRangeMakeFromDictionary` 将 `CMTimeRange` 结构转换为 `CFDictionary` 类型。 还可以使用 `CMTimeRangeCopyDescription` 函数获取 `CMTimeRange` 结构的字符串表示形式。\n\n##### 媒体的表示\n\n视频数据及其关联的元数据在 `AVFoundation` 中由 `Core Media` 框架中的对象表示。 `Core Media` 使用 `CMSampleBuffer` 表示视频数据。`CMSampleBuffer` 是一种 `Core Foundation` 风格的类型。`CMSampleBuffer` 的一个实例在对应的 `Core Video pixel buffer` 中包含了视频帧的数据（参见 `CVPixelBufferRef`）。 我们可以使用 `CMSampleBufferGetImageBuffer` 从样本缓冲区访问 `pixel buffer`：\n\n```objectivec\nCVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(<#A CMSampleBuffer#>);\n ```\n\n从 `pixel buffer` 中，我们可以访问实际的视频数据。\n\n除了视频数据之外，您还可以检索视频帧的其他方面的数据：\n\n时间信息。我们可以分别使用 `CMSampleBufferGetPresentationTimeStamp` 和 `CMSampleBufferGetDecodeTimeStamp `获得原始演示时间和解码时间的准确时间戳。\n格式信息。格式信息封装在 `CMFormatDescription` 对象中。从格式描述中，可以分别使用 `CMVideoFormatDescriptionGetCodecType` 和 `CMVideoFormatDescriptionGetDimensions` 获取像素类型和视频尺寸。\n元数据。元数据作为附件存储在字典中。您使用 CMGetAttachment 检索字典。如下面代码所示：\n\n```objectivec\nCMSampleBufferRef sampleBuffer = <#Get a sample buffer#>;\nCFDictionaryRef metadataDictionary = CMGetAttachment(sampleBuffer, CFSTR(\"MetadataDictionary\", NULL);\nif (metadataDictionary) {\n    // Do something with the metadata.\n}\n```\n\n#### 将 CMSampleBuffer 转换为 UIImage\n\n以下代码显示如何将 `CMSampleBuffer` 转换为 `UIImage` 对象。 使用前，我们要仔细考虑对应的需求。 执行转换是比较昂贵的操作。例如，从每隔一秒钟拍摄的视频数据帧创建静止图像是合适的，但不应该使用它来实时操纵来自录制设备的每一帧视频。\n\n```objectivec\n// Create a UIImage from sample buffer data.\n- (UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer {\n    // Get a CMSampleBuffer's Core Video image buffer for the media data\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n    // Lock the base address of the pixel buffer\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n\n    // Get the number of bytes per row for the pixel buffer\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n\n    // Get the number of bytes per row for the pixel buffer\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    // Get the pixel buffer width and height\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n\n    // Create a device-dependent RGB color space\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\n    // Create a bitmap graphics context with the sample buffer data\n    CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8,\n      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    // Create a Quartz image from the pixel data in the bitmap graphics context\n    CGImageRef quartzImage = CGBitmapContextCreateImage(context);\n    // Unlock the pixel buffer\n    CVPixelBufferUnlockBaseAddress(imageBuffer,0);\n\n    // Free up the context and color space\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    // Create an image object from the Quartz image\n    UIImage *image = [UIImage imageWithCGImage:quartzImage];\n\n    // Release the Quartz image\n    CGImageRelease(quartzImage);\n\n    return (image);\n}\n```\n\n","slug":"AVAudioFoundation-6-：时间和媒体表示","published":1,"updated":"2017-07-07T11:15:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tv30007znuz8rhalhmi","content":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(6)：时间和媒体表示 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>基于时间的音视频数据，例如电影文件或视频流，在 <code>AVFoundation</code> 框架中用 <code>AVAsset</code> 来表示。<code>AVFoundation</code> 用于表示时间和媒体的几个底层数据结构，来自 <code>Core Media</code> 框架。</p>\n<h4 id=\"资源的表示方式\"><a href=\"#资源的表示方式\" class=\"headerlink\" title=\"资源的表示方式\"></a>资源的表示方式</h4><p><code>AVAsset</code> 是 <code>AVFoundation</code> 框架中的核心类。它对基于时间的音视频数据的进行了抽象，例如电影文件或视频流。主要关系如下图所示。在许多情况下，我们需要使用其子类之一。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA1.png\" alt=\"图一\"></p>\n<p><code>Asset</code> 包含了将在一起显示或处理的多个轨道，每个轨道均包含（但不限于）音频、视频、文本、可隐藏字幕和字幕。 <code>Asset</code> 提供了关于资源的完整信息，比如时长、标题，以及渲染时的提示、视频源尺寸等等。 资产还可以包含由 <code>AVMetadataItem</code> 表示的元数据。</p>\n<p>轨道用 <code>AVAssetTrack</code> 的实例表示，如下图所示。在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，音频和视频可能有多个重叠的轨道。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA2.png\" alt=\"图一\"></p>\n<p>轨道具有许多属性，例如其类型（视频或音频），视频和/或音频特征，元数据和时间轴。轨道有一个数组用来描述其格式。该数组包含一组 <code>CMFormatDescription</code> 对象，每个对象描述轨道对应的媒体样本的格式。包含统一媒体的轨道（比如，都使用相同的设置来编码）将提供一个计数为 1 的数组。</p>\n<p>轨道本身可以被划分成多段，由 <code>AVAssetTrackSegment</code> 的实例表示。段是从源到资产轨道时间轴的时间映射。</p>\n<h4 id=\"时间的表示\"><a href=\"#时间的表示\" class=\"headerlink\" title=\"时间的表示\"></a>时间的表示</h4><p><code>AVFoundation</code> 中用来表示时间的数据结构主要来自于 <code>Core Media</code> 框架。</p>\n<h5 id=\"用-CMTime-表示时长\"><a href=\"#用-CMTime-表示时长\" class=\"headerlink\" title=\"用 CMTime 表示时长\"></a>用 CMTime 表示时长</h5><p><code>CMTime</code> 是一个 C 的数据结构，它表示时间为有理数，包含分子和分母。分子表示时间值，分母表示时间刻度，分子除以分母则表示时间，单位为秒。比如当时间刻度是 10，则表示每个单位的时间值表示 1/10 秒。最常用的时间刻度是 600，因为在场景的场景中，我们用 24 fps 的电影，30 fps 的 NTSC，25 fps 的 PAL。使用 600 的时间刻度，可以准确地表示这些系统中的任何数量的帧。</p>\n<p>除了简单的时间值之外，<code>CMTime</code> 结构可以表示非数值的值：正无穷大，负无穷大和无定义。 它也可以指示时间是否在某一点被舍入，并且它能保持一个纪元数字。</p>\n<h5 id=\"使用-CMTime\"><a href=\"#使用-CMTime\" class=\"headerlink\" title=\"使用 CMTime\"></a>使用 CMTime</h5><p>下面是一些使用 <code>CMTime</code> 示例：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTime time1 <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 200 half-seconds</span>\nCMTime time2 <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 400 quarter-seconds</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// time1 and time2 both represent 100 seconds, but using different timescales.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CMTimeCompare</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"time1 and time2 are the same\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nFloat64 float64Seconds <span class=\"token operator\">=</span> <span class=\"token number\">200.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nCMTime time3 <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>float64Seconds <span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 66.66... third-seconds</span>\ntime3 <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMultiply</span><span class=\"token punctuation\">(</span>time3<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// time3 now represents 200 seconds; next subtract time1 (100 seconds).</span>\ntime3 <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeSubtract</span><span class=\"token punctuation\">(</span>time3<span class=\"token punctuation\">,</span> time1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">CMTimeShow</span><span class=\"token punctuation\">(</span>time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CMTIME_COMPARE_INLINE</span><span class=\"token punctuation\">(</span>time2<span class=\"token punctuation\">,</span> <span class=\"token operator\">==</span><span class=\"token punctuation\">,</span> time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"time2 and time3 are the same\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h5 id=\"CMTime-的特殊值\"><a href=\"#CMTime-的特殊值\" class=\"headerlink\" title=\"CMTime 的特殊值\"></a>CMTime 的特殊值</h5><p><code>Core Media</code> 提供了一些关于 <code>CMTime</code> 的特殊值，比如：<code>kCMTimeZero</code>，<code>kCMTimeInvalid</code>，<code>kCMTimePositiveInfinity</code>，<code>kCMTimeNegativeInfinity</code>。要检查一个表示非数值的 <code>CMTime</code> 是否是合法的，可以用 <code>CMTIME_IS_INVALID</code>，<code>CMTIME_IS_POSITIVE_INFINITY</code>，<code>CMTIME_IS_INDEFINITE</code> 这些宏。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTime myTime <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a CMTime#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CMTIME_IS_INVALID</span><span class=\"token punctuation\">(</span>myTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Perhaps treat this as an error; display a suitable alert to the user.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>不要去拿一个 <code>CMTime</code> 和 <code>kCMTimeInvalid</code> 做比较。</p>\n<h5 id=\"用对象的方式使用-CMTime\"><a href=\"#用对象的方式使用-CMTime\" class=\"headerlink\" title=\"用对象的方式使用 CMTime\"></a>用对象的方式使用 CMTime</h5><p>如果要使用 <code>Core Foundation</code> 中的一些容器来存储 <code>CMTime</code>，我们需要进行 <code>CMTime</code> 和 <code>CFDictionary</code> 之间的转换。这时我们需要用到 <code>CMTimeCopyAsDictionary</code> 和 <code>CMTimeMakeFromDictionary</code> 这些方法。我们还能用 <code>CMTimeCopyDescription</code> 来输出描述 <code>CMTime</code> 的字符串。</p>\n<h5 id=\"纪元\"><a href=\"#纪元\" class=\"headerlink\" title=\"纪元\"></a>纪元</h5><p>通常 <code>CMTime</code> 中的 <code>epoch</code> 设置为 0，不过我们也可以设置它为其他值来区分不相关的时间轴。比如，我们可以在循环遍历中递增<code>epoch</code> 的值，每一个 0 到 N 的循序递增一下 <code>epoch</code> 来区分不同的轮回。</p>\n<h5 id=\"用-CMTimeRange-来表示时间范围\"><a href=\"#用-CMTimeRange-来表示时间范围\" class=\"headerlink\" title=\"用 CMTimeRange 来表示时间范围\"></a>用 CMTimeRange 来表示时间范围</h5><p><code>CMTimeRange</code> 表示的时间范围包含两个字段：开始时间（start）和时长（duration），这两个字段都是 CMTime 类型。需要注意的是一个 <code>CMTimeRange</code> 不含开始时间加上时长算出来的那个时间点，即 [start, start + duration)。</p>\n<p>我们可以用 <code>CMTimeRangeMake</code> 和 <code>CMTimeRangeFromTimeToTime</code> 来创建 <code>CMTimeRange</code>。但是这里有一些限制：</p>\n<p><code>CMTimeRange</code> 不能跨越不同的纪元。<br><code>CMTime</code> 中的 <code>epoch</code> 字段可能不为 0，但是我们只能对 start 字段具有相同 <code>epoch</code> 的  <code>CMTimeRange</code> 执行相关操作（比如 <code>CMTimeRangeGetUnion</code>）。<br>表示 <code>duration</code> 的 <code>CMTime</code> 结构中的 <code>epoch</code> 应始终为 0，<code>value</code> 必须为非负数。</p>\n<h5 id=\"使用-CMTimeRange\"><a href=\"#使用-CMTimeRange\" class=\"headerlink\" title=\"使用 CMTimeRange\"></a>使用 CMTimeRange</h5><p><code>Core Media</code> 提供了一系列操作 <code>CMTimeRange</code> 的方法，比如 <code>CMTimeRangeContainsTime</code>、<code>CMTimeRangeEqual</code>、<code>CMTimeRangeContainsTimeRange</code>、<code>CMTimeRangeGetUnion</code>.</p>\n<p>下面的代码返回值永远为 <code>false</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">CMTimeRangeContainsTime</span><span class=\"token punctuation\">(</span>range<span class=\"token punctuation\">,</span> <span class=\"token function\">CMTimeRangeGetEnd</span><span class=\"token punctuation\">(</span>range<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nCMTimeRange 的特殊值\n</code></pre>\n<p><code>Core Media</code> 提供了 <code>kCMTimeRangeZero</code> 和 <code>kCMTimeRangeInvalid</code> 表示零长度 <code>range</code> 和错误 <code>range</code>。在很多情况下，<code>CMTimeRange</code> 结构可能无效，或者是零或不定式（如果其中一个 <code>CMTime</code> 字段是不确定的）。如果要测试 <code>CMTimeRange</code> 结构是否有效、零或不确定，可以使用一个适当的宏：<code>CMTIMERANGE_IS_VALID</code>，<code>CMTIMERANGE_IS_INVALID</code>，<code>CMTIMERANGE_IS_EMPTY</code> 或 <code>CMTIMERANGE_IS_EMPTY</code>。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTimeRange myTimeRange <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a CMTimeRange#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CMTIMERANGE_IS_EMPTY</span><span class=\"token punctuation\">(</span>myTimeRange<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// The time range is zero.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>不要拿任何 <code>CMTimeRange</code> 和 <code>kCMTimeRangeInvalid</code> 做比较。</p>\n<h5 id=\"用对象的方式使用-CMTimeRange\"><a href=\"#用对象的方式使用-CMTimeRange\" class=\"headerlink\" title=\"用对象的方式使用 CMTimeRange\"></a>用对象的方式使用 <code>CMTimeRange</code></h5><p>如果要在 <code>Core Foundation</code> 提供的容器中使用 <code>CMTimeRange</code> 结构，则可以分别使用 <code>CMTimeRangeCopyAsDictionary</code>和 <code>CMTimeRangeMakeFromDictionary</code> 将 <code>CMTimeRange</code> 结构转换为 <code>CFDictionary</code> 类型。 还可以使用 <code>CMTimeRangeCopyDescription</code> 函数获取 <code>CMTimeRange</code> 结构的字符串表示形式。</p>\n<h5 id=\"媒体的表示\"><a href=\"#媒体的表示\" class=\"headerlink\" title=\"媒体的表示\"></a>媒体的表示</h5><p>视频数据及其关联的元数据在 <code>AVFoundation</code> 中由 <code>Core Media</code> 框架中的对象表示。 <code>Core Media</code> 使用 <code>CMSampleBuffer</code> 表示视频数据。<code>CMSampleBuffer</code> 是一种 <code>Core Foundation</code> 风格的类型。<code>CMSampleBuffer</code> 的一个实例在对应的 <code>Core Video pixel buffer</code> 中包含了视频帧的数据（参见 <code>CVPixelBufferRef</code>）。 我们可以使用 <code>CMSampleBufferGetImageBuffer</code> 从样本缓冲区访问 <code>pixel buffer</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CVPixelBufferRef pixelBuffer <span class=\"token operator\">=</span> <span class=\"token function\">CMSampleBufferGetImageBuffer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>#A CMSampleBuffer#<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>从 <code>pixel buffer</code> 中，我们可以访问实际的视频数据。</p>\n<p>除了视频数据之外，您还可以检索视频帧的其他方面的数据：</p>\n<p>时间信息。我们可以分别使用 <code>CMSampleBufferGetPresentationTimeStamp</code> 和 <code>CMSampleBufferGetDecodeTimeStamp</code>获得原始演示时间和解码时间的准确时间戳。<br>格式信息。格式信息封装在 <code>CMFormatDescription</code> 对象中。从格式描述中，可以分别使用 <code>CMVideoFormatDescriptionGetCodecType</code> 和 <code>CMVideoFormatDescriptionGetDimensions</code> 获取像素类型和视频尺寸。<br>元数据。元数据作为附件存储在字典中。您使用 CMGetAttachment 检索字典。如下面代码所示：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMSampleBufferRef sampleBuffer <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a sample buffer#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nCFDictionaryRef metadataDictionary <span class=\"token operator\">=</span> <span class=\"token function\">CMGetAttachment</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">,</span> <span class=\"token function\">CFSTR</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MetadataDictionary\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>metadataDictionary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Do something with the metadata.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"将-CMSampleBuffer-转换为-UIImage\"><a href=\"#将-CMSampleBuffer-转换为-UIImage\" class=\"headerlink\" title=\"将 CMSampleBuffer 转换为 UIImage\"></a>将 CMSampleBuffer 转换为 UIImage</h4><p>以下代码显示如何将 <code>CMSampleBuffer</code> 转换为 <code>UIImage</code> 对象。 使用前，我们要仔细考虑对应的需求。 执行转换是比较昂贵的操作。例如，从每隔一秒钟拍摄的视频数据帧创建静止图像是合适的，但不应该使用它来实时操纵来自录制设备的每一帧视频。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Create a UIImage from sample buffer data.</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imageFromSampleBuffer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CMSampleBufferRef<span class=\"token punctuation\">)</span>sampleBuffer <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Get a CMSampleBuffer's Core Video image buffer for the media data</span>\n    CVImageBufferRef imageBuffer <span class=\"token operator\">=</span> <span class=\"token function\">CMSampleBufferGetImageBuffer</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Lock the base address of the pixel buffer</span>\n    <span class=\"token function\">CVPixelBufferLockBaseAddress</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Get the number of bytes per row for the pixel buffer</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>baseAddress <span class=\"token operator\">=</span> <span class=\"token function\">CVPixelBufferGetBaseAddress</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Get the number of bytes per row for the pixel buffer</span>\n    size_t bytesPerRow <span class=\"token operator\">=</span> <span class=\"token function\">CVPixelBufferGetBytesPerRow</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Get the pixel buffer width and height</span>\n    size_t width <span class=\"token operator\">=</span> <span class=\"token function\">CVPixelBufferGetWidth</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    size_t height <span class=\"token operator\">=</span> <span class=\"token function\">CVPixelBufferGetHeight</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Create a device-dependent RGB color space</span>\n    CGColorSpaceRef colorSpace <span class=\"token operator\">=</span> <span class=\"token function\">CGColorSpaceCreateDeviceRGB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Create a bitmap graphics context with the sample buffer data</span>\n    CGContextRef context <span class=\"token operator\">=</span> <span class=\"token function\">CGBitmapContextCreate</span><span class=\"token punctuation\">(</span>baseAddress<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n      bytesPerRow<span class=\"token punctuation\">,</span> colorSpace<span class=\"token punctuation\">,</span> kCGBitmapByteOrder32Little <span class=\"token operator\">|</span> kCGImageAlphaPremultipliedFirst<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Create a Quartz image from the pixel data in the bitmap graphics context</span>\n    CGImageRef quartzImage <span class=\"token operator\">=</span> <span class=\"token function\">CGBitmapContextCreateImage</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Unlock the pixel buffer</span>\n    <span class=\"token function\">CVPixelBufferUnlockBaseAddress</span><span class=\"token punctuation\">(</span>imageBuffer<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Free up the context and color space</span>\n    <span class=\"token function\">CGContextRelease</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGColorSpaceRelease</span><span class=\"token punctuation\">(</span>colorSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Create an image object from the Quartz image</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageWithCGImage<span class=\"token punctuation\">:</span>quartzImage<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Release the Quartz image</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>quartzImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(6)：时间和媒体表示 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>基于时间的音视频数据，例如电影文件或视频流，在 <code>AVFoundation</code> 框架中用 <code>AVAsset</code> 来表示。<code>AVFoundation</code> 用于表示时间和媒体的几个底层数据结构，来自 <code>Core Media</code> 框架。</p>\n<h4 id=\"资源的表示方式\"><a href=\"#资源的表示方式\" class=\"headerlink\" title=\"资源的表示方式\"></a>资源的表示方式</h4><p><code>AVAsset</code> 是 <code>AVFoundation</code> 框架中的核心类。它对基于时间的音视频数据的进行了抽象，例如电影文件或视频流。主要关系如下图所示。在许多情况下，我们需要使用其子类之一。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA1.png\" alt=\"图一\"></p>\n<p><code>Asset</code> 包含了将在一起显示或处理的多个轨道，每个轨道均包含（但不限于）音频、视频、文本、可隐藏字幕和字幕。 <code>Asset</code> 提供了关于资源的完整信息，比如时长、标题，以及渲染时的提示、视频源尺寸等等。 资产还可以包含由 <code>AVMetadataItem</code> 表示的元数据。</p>\n<p>轨道用 <code>AVAssetTrack</code> 的实例表示，如下图所示。在典型的简单情况下，一个轨道表示音频分量，另一个表示视频分量; 在复杂的组合中，音频和视频可能有多个重叠的轨道。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E8%A1%A8%E7%A4%BA2.png\" alt=\"图一\"></p>\n<p>轨道具有许多属性，例如其类型（视频或音频），视频和/或音频特征，元数据和时间轴。轨道有一个数组用来描述其格式。该数组包含一组 <code>CMFormatDescription</code> 对象，每个对象描述轨道对应的媒体样本的格式。包含统一媒体的轨道（比如，都使用相同的设置来编码）将提供一个计数为 1 的数组。</p>\n<p>轨道本身可以被划分成多段，由 <code>AVAssetTrackSegment</code> 的实例表示。段是从源到资产轨道时间轴的时间映射。</p>\n<h4 id=\"时间的表示\"><a href=\"#时间的表示\" class=\"headerlink\" title=\"时间的表示\"></a>时间的表示</h4><p><code>AVFoundation</code> 中用来表示时间的数据结构主要来自于 <code>Core Media</code> 框架。</p>\n<h5 id=\"用-CMTime-表示时长\"><a href=\"#用-CMTime-表示时长\" class=\"headerlink\" title=\"用 CMTime 表示时长\"></a>用 CMTime 表示时长</h5><p><code>CMTime</code> 是一个 C 的数据结构，它表示时间为有理数，包含分子和分母。分子表示时间值，分母表示时间刻度，分子除以分母则表示时间，单位为秒。比如当时间刻度是 10，则表示每个单位的时间值表示 1/10 秒。最常用的时间刻度是 600，因为在场景的场景中，我们用 24 fps 的电影，30 fps 的 NTSC，25 fps 的 PAL。使用 600 的时间刻度，可以准确地表示这些系统中的任何数量的帧。</p>\n<p>除了简单的时间值之外，<code>CMTime</code> 结构可以表示非数值的值：正无穷大，负无穷大和无定义。 它也可以指示时间是否在某一点被舍入，并且它能保持一个纪元数字。</p>\n<h5 id=\"使用-CMTime\"><a href=\"#使用-CMTime\" class=\"headerlink\" title=\"使用 CMTime\"></a>使用 CMTime</h5><p>下面是一些使用 <code>CMTime</code> 示例：</p>\n<pre><code class=\"objectivec\">CMTime time1 = CMTimeMake(200, 2); // 200 half-seconds\nCMTime time2 = CMTimeMake(400, 4); // 400 quarter-seconds\n\n// time1 and time2 both represent 100 seconds, but using different timescales.\nif (CMTimeCompare(time1, time2) == 0) {\n    NSLog(@&quot;time1 and time2 are the same&quot;);\n}\n\nFloat64 float64Seconds = 200.0 / 3;\nCMTime time3 = CMTimeMakeWithSeconds(float64Seconds , 3); // 66.66... third-seconds\ntime3 = CMTimeMultiply(time3, 3);\n// time3 now represents 200 seconds; next subtract time1 (100 seconds).\ntime3 = CMTimeSubtract(time3, time1);\nCMTimeShow(time3);\n\nif (CMTIME_COMPARE_INLINE(time2, ==, time3)) {\n    NSLog(@&quot;time2 and time3 are the same&quot;);\n}\n</code></pre>\n<h5 id=\"CMTime-的特殊值\"><a href=\"#CMTime-的特殊值\" class=\"headerlink\" title=\"CMTime 的特殊值\"></a>CMTime 的特殊值</h5><p><code>Core Media</code> 提供了一些关于 <code>CMTime</code> 的特殊值，比如：<code>kCMTimeZero</code>，<code>kCMTimeInvalid</code>，<code>kCMTimePositiveInfinity</code>，<code>kCMTimeNegativeInfinity</code>。要检查一个表示非数值的 <code>CMTime</code> 是否是合法的，可以用 <code>CMTIME_IS_INVALID</code>，<code>CMTIME_IS_POSITIVE_INFINITY</code>，<code>CMTIME_IS_INDEFINITE</code> 这些宏。</p>\n<pre><code class=\"objectivec\">CMTime myTime = &lt;#Get a CMTime#&gt;;\nif (CMTIME_IS_INVALID(myTime)) {\n    // Perhaps treat this as an error; display a suitable alert to the user.\n}\n</code></pre>\n<p>不要去拿一个 <code>CMTime</code> 和 <code>kCMTimeInvalid</code> 做比较。</p>\n<h5 id=\"用对象的方式使用-CMTime\"><a href=\"#用对象的方式使用-CMTime\" class=\"headerlink\" title=\"用对象的方式使用 CMTime\"></a>用对象的方式使用 CMTime</h5><p>如果要使用 <code>Core Foundation</code> 中的一些容器来存储 <code>CMTime</code>，我们需要进行 <code>CMTime</code> 和 <code>CFDictionary</code> 之间的转换。这时我们需要用到 <code>CMTimeCopyAsDictionary</code> 和 <code>CMTimeMakeFromDictionary</code> 这些方法。我们还能用 <code>CMTimeCopyDescription</code> 来输出描述 <code>CMTime</code> 的字符串。</p>\n<h5 id=\"纪元\"><a href=\"#纪元\" class=\"headerlink\" title=\"纪元\"></a>纪元</h5><p>通常 <code>CMTime</code> 中的 <code>epoch</code> 设置为 0，不过我们也可以设置它为其他值来区分不相关的时间轴。比如，我们可以在循环遍历中递增<code>epoch</code> 的值，每一个 0 到 N 的循序递增一下 <code>epoch</code> 来区分不同的轮回。</p>\n<h5 id=\"用-CMTimeRange-来表示时间范围\"><a href=\"#用-CMTimeRange-来表示时间范围\" class=\"headerlink\" title=\"用 CMTimeRange 来表示时间范围\"></a>用 CMTimeRange 来表示时间范围</h5><p><code>CMTimeRange</code> 表示的时间范围包含两个字段：开始时间（start）和时长（duration），这两个字段都是 CMTime 类型。需要注意的是一个 <code>CMTimeRange</code> 不含开始时间加上时长算出来的那个时间点，即 [start, start + duration)。</p>\n<p>我们可以用 <code>CMTimeRangeMake</code> 和 <code>CMTimeRangeFromTimeToTime</code> 来创建 <code>CMTimeRange</code>。但是这里有一些限制：</p>\n<p><code>CMTimeRange</code> 不能跨越不同的纪元。<br><code>CMTime</code> 中的 <code>epoch</code> 字段可能不为 0，但是我们只能对 start 字段具有相同 <code>epoch</code> 的  <code>CMTimeRange</code> 执行相关操作（比如 <code>CMTimeRangeGetUnion</code>）。<br>表示 <code>duration</code> 的 <code>CMTime</code> 结构中的 <code>epoch</code> 应始终为 0，<code>value</code> 必须为非负数。</p>\n<h5 id=\"使用-CMTimeRange\"><a href=\"#使用-CMTimeRange\" class=\"headerlink\" title=\"使用 CMTimeRange\"></a>使用 CMTimeRange</h5><p><code>Core Media</code> 提供了一系列操作 <code>CMTimeRange</code> 的方法，比如 <code>CMTimeRangeContainsTime</code>、<code>CMTimeRangeEqual</code>、<code>CMTimeRangeContainsTimeRange</code>、<code>CMTimeRangeGetUnion</code>.</p>\n<p>下面的代码返回值永远为 <code>false</code>：</p>\n<pre><code class=\"objectivec\">CMTimeRangeContainsTime(range, CMTimeRangeGetEnd(range))\nCMTimeRange 的特殊值\n</code></pre>\n<p><code>Core Media</code> 提供了 <code>kCMTimeRangeZero</code> 和 <code>kCMTimeRangeInvalid</code> 表示零长度 <code>range</code> 和错误 <code>range</code>。在很多情况下，<code>CMTimeRange</code> 结构可能无效，或者是零或不定式（如果其中一个 <code>CMTime</code> 字段是不确定的）。如果要测试 <code>CMTimeRange</code> 结构是否有效、零或不确定，可以使用一个适当的宏：<code>CMTIMERANGE_IS_VALID</code>，<code>CMTIMERANGE_IS_INVALID</code>，<code>CMTIMERANGE_IS_EMPTY</code> 或 <code>CMTIMERANGE_IS_EMPTY</code>。</p>\n<pre><code class=\"objectivec\">CMTimeRange myTimeRange = &lt;#Get a CMTimeRange#&gt;;\nif (CMTIMERANGE_IS_EMPTY(myTimeRange)) {\n    // The time range is zero.\n}\n</code></pre>\n<p>不要拿任何 <code>CMTimeRange</code> 和 <code>kCMTimeRangeInvalid</code> 做比较。</p>\n<h5 id=\"用对象的方式使用-CMTimeRange\"><a href=\"#用对象的方式使用-CMTimeRange\" class=\"headerlink\" title=\"用对象的方式使用 CMTimeRange\"></a>用对象的方式使用 <code>CMTimeRange</code></h5><p>如果要在 <code>Core Foundation</code> 提供的容器中使用 <code>CMTimeRange</code> 结构，则可以分别使用 <code>CMTimeRangeCopyAsDictionary</code>和 <code>CMTimeRangeMakeFromDictionary</code> 将 <code>CMTimeRange</code> 结构转换为 <code>CFDictionary</code> 类型。 还可以使用 <code>CMTimeRangeCopyDescription</code> 函数获取 <code>CMTimeRange</code> 结构的字符串表示形式。</p>\n<h5 id=\"媒体的表示\"><a href=\"#媒体的表示\" class=\"headerlink\" title=\"媒体的表示\"></a>媒体的表示</h5><p>视频数据及其关联的元数据在 <code>AVFoundation</code> 中由 <code>Core Media</code> 框架中的对象表示。 <code>Core Media</code> 使用 <code>CMSampleBuffer</code> 表示视频数据。<code>CMSampleBuffer</code> 是一种 <code>Core Foundation</code> 风格的类型。<code>CMSampleBuffer</code> 的一个实例在对应的 <code>Core Video pixel buffer</code> 中包含了视频帧的数据（参见 <code>CVPixelBufferRef</code>）。 我们可以使用 <code>CMSampleBufferGetImageBuffer</code> 从样本缓冲区访问 <code>pixel buffer</code>：</p>\n<pre><code class=\"objectivec\">CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(&lt;#A CMSampleBuffer#&gt;);\n</code></pre>\n<p>从 <code>pixel buffer</code> 中，我们可以访问实际的视频数据。</p>\n<p>除了视频数据之外，您还可以检索视频帧的其他方面的数据：</p>\n<p>时间信息。我们可以分别使用 <code>CMSampleBufferGetPresentationTimeStamp</code> 和 <code>CMSampleBufferGetDecodeTimeStamp</code>获得原始演示时间和解码时间的准确时间戳。<br>格式信息。格式信息封装在 <code>CMFormatDescription</code> 对象中。从格式描述中，可以分别使用 <code>CMVideoFormatDescriptionGetCodecType</code> 和 <code>CMVideoFormatDescriptionGetDimensions</code> 获取像素类型和视频尺寸。<br>元数据。元数据作为附件存储在字典中。您使用 CMGetAttachment 检索字典。如下面代码所示：</p>\n<pre><code class=\"objectivec\">CMSampleBufferRef sampleBuffer = &lt;#Get a sample buffer#&gt;;\nCFDictionaryRef metadataDictionary = CMGetAttachment(sampleBuffer, CFSTR(&quot;MetadataDictionary&quot;, NULL);\nif (metadataDictionary) {\n    // Do something with the metadata.\n}\n</code></pre>\n<h4 id=\"将-CMSampleBuffer-转换为-UIImage\"><a href=\"#将-CMSampleBuffer-转换为-UIImage\" class=\"headerlink\" title=\"将 CMSampleBuffer 转换为 UIImage\"></a>将 CMSampleBuffer 转换为 UIImage</h4><p>以下代码显示如何将 <code>CMSampleBuffer</code> 转换为 <code>UIImage</code> 对象。 使用前，我们要仔细考虑对应的需求。 执行转换是比较昂贵的操作。例如，从每隔一秒钟拍摄的视频数据帧创建静止图像是合适的，但不应该使用它来实时操纵来自录制设备的每一帧视频。</p>\n<pre><code class=\"objectivec\">// Create a UIImage from sample buffer data.\n- (UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer {\n    // Get a CMSampleBuffer&#39;s Core Video image buffer for the media data\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n    // Lock the base address of the pixel buffer\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n\n    // Get the number of bytes per row for the pixel buffer\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n\n    // Get the number of bytes per row for the pixel buffer\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    // Get the pixel buffer width and height\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n\n    // Create a device-dependent RGB color space\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n\n    // Create a bitmap graphics context with the sample buffer data\n    CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8,\n      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    // Create a Quartz image from the pixel data in the bitmap graphics context\n    CGImageRef quartzImage = CGBitmapContextCreateImage(context);\n    // Unlock the pixel buffer\n    CVPixelBufferUnlockBaseAddress(imageBuffer,0);\n\n    // Free up the context and color space\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    // Create an image object from the Quartz image\n    UIImage *image = [UIImage imageWithCGImage:quartzImage];\n\n    // Release the Quartz image\n    CGImageRelease(quartzImage);\n\n    return (image);\n}\n</code></pre>\n"},{"title":"GIF的秘密","date":"2017-06-13T14:10:27.000Z","_content":"#### GIF\n\nGIF是一种使用LZW压缩，支持多张图像的容器。支持256色，透明通道为1bit。作为互联网表情包的载体，GIF这项80年代的技术依然生生不息。\n但它的弊端也是显而易见的：易出现毛边，色彩表现低劣，文件压缩比不高。针对这些问题，Mozilla发布了APNG来代替老旧的GIF技术，同时许多开源组件也用WebP格式来代替GIF。\n\n#### GIF在iOS的尴尬处境\n\n长久以来，iOS一直被吐槽不能用GIF。造成这一局面的主要原因是：\n\n- iOS关于照片的场景不会自动播放GIF,也没有角标。\n- 一些应用将GIF视为静态图像去操作，导致用户保持了一个GIF后，结果应用将其保存成JPG。\n- iOS只能通过imageI/O去操作GIF数据，UIKit对其绝缘。\n\n#### GIF的存储结构\n\n由于历史的原因，GIF有两个版本，但它们的文件结构是一样的，都是由不同用途的数据块构成，可分为控制块和数据块。控制块里是决定GIF表现的参数，数据块里的数据由前面的控制块里的参数来解释。\n一个GIF文件的内部结构如下图：\n![GIF结构](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%861.png)\n**Header**：包含文件签名与版本号。\n**Trailer**: 文件结束标识符。\n**GIF Data**: Header 与 trailer 之间就是GIF文件的数据。\n我们从一个简单的GIF图入手，它包含两张图像：\n![GIF图](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%868.gif\n)\n\n这是它的十六进制数据,我用颜色区分了不同的数据块：\n![数据块](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%862.png\n)\n\n#### Header\n\nGIF文件的开头是 Header 数据块，长度为6字节，ASCII值为“GIF87a”或\"GIF89a\",前三位为GIF签名，后三位为不同年份的版本号。\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%863.png\n)\n利用这点，在iOS中判断二进制文件是否为GIF时，可以简单去判断它的前四位是否是\"GIF8\"。事实上绝大多数图像都可以用文件签名来判断类型。\n\n#### GIF 内容\n\nGIF数据包含多个数据块，其结构如下:\n**逻辑屏幕**描述符\n\n> 0A000A00 B30000\n\n这一数据块由7个字节组成，前四个字节分别是图像渲染区域的宽高。GIF的数据是按照大端序存储的，0x0A00为10，所以这个GIF的宽高均为10。\n接下来是一个压缩字节，第一个 Bit 为标志位，表示全局颜色列表是否存在。接下来三个Bit表示图像调色板中每个颜色的原色所占用的Bit数，011表示占用4个Bit，111占用8个Bit，以此类推。调色板最多只包含由24-Bit颜色中选出的256个颜色（实际有很多优化方案能提高颜色分辨率，如加入局部调色板）。第五个Bit为标志位，表示颜色列表排序方式。若为1，表示颜色列表是按照颜色在图像中出现的频率降序排列。随后三个Bit表示全局颜色列表的大小，计算方法是2^N+1 ，其中N为这三个Bit的二进制数值。\n第六个字节是表示背景色在全局颜色列表中的索引，若无全局颜色列表则此字节无效。在GIF的图像数据中，没有被指定颜色的像素会被背景色填充。\n最后一个字节是像素的宽高比，大多数时候这个值都是0，若值为N, 则图像的宽高比：\n\n```\naspectRatio = (pixelAspectRatio + 15) / 64\n```\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%864.png\n)\n\n\n#### 全局颜色列表\n\n> 000000 80000000 80008080 00000080 80008000 8080C0C0 C0808080 FF000000 FF00FFFF 000000FF FF00FF00 FFFFFFFF FF\n\n由前面的逻辑屏幕描述符可知，全局颜色列表的大小是16，每个颜色占三个字节，按照RGB排列，所以它占有48个字节。数据流中，颜色是按照列表中的索引存储的。\n应用程序扩展\n\n>21FF0B 4E455453 43415045 322E3003 01000000\n\nGIF中扩展块都以0x21开始，后一个字节是扩展标签，标识扩展用途。\n应用程序扩展的标签是0xFF，它包含有应用程序的标识信息和应用程序数据。其中 Netscape 应用程序扩展常用于控制GIF的动画循环次数。Netscape 扩展长19个字节，前14个是应用程序的ACSII信息，后四个是数据子块，用于指定GIF的循环次数, 按无符号整型存储，0表示无限循环。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%865.png\n)\n\n\n#### 图形控制扩展\n\n> 21F90409 32000F00\n\n图形控制扩展块属于\"89a\"版本的定义。它在一个图像数据块的最前端，用来指定图像的透明度与动画属性。图形控制扩展的开端两字节是0x21F9，其中0x21表示这是一个扩展，F9表示扩展用于图形控制。第三个字节是块大小(它到结束符之间的数据)。第四个字节是压缩字段，前三个Bit保留，四到六Bit是disposal method。第四、五个字节是图像控制扩展后面的图像的动画时间，以无符号整型存储。第六个字节是透明色索引，之后是块结束符0x00。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%866.png\n)\n\n\n#### 图像描述符\n\n> 2C000000 000A000A 0000\n\n图像描述符位于GIF中每一个图像数据的前端，由0x2C开始，长度为10个字节。第一个字节是图像描述符的标识0x2c，后面八个字节表示图像的frame（left, top, width, height），用来在动画中局部更新图像。最后一个是压缩字节，主要是关于局部颜色列表的信息，其中第二个Bit表示图像的存储方式是交织还是连续。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%867.png\n)\n\n#### 局部颜色列表\n\n如果上面的局部颜色列表标志位为1，那么局部颜色列表会排列在图像描述符后面，它只对紧跟在它之后的图像数据有效。如果局部颜色列表标志位为0，那么图像数据将使用全局颜色列表索引颜色。局部颜色列表的大小计算方法和像素颜色格式与全局颜色列表相同。\n\n#### 图像数据\n\n> 041C 1080472B 0549DA9B BAAE58E7 4D4F288E E629A519 697E1C0C 92DB1301 00\n\nGIF的图像数据是经过LZW压缩的二进制流，通过解码可以将其按照颜色列表中的颜色进行像素填充。第一个字节是LZW最小编码大小，用来进行数据解码。第二个字节是图像数据的大小，之后的都是图像数据，直到块结束符。\n\n#### 结束符\n\n> 3B\n\n#### GIF的动画原理\n\nGIF动画的循环次数是由应用扩展来控制的，而GIF动画每一帧的过渡方式是由图形控制扩展控制,图像描述符控制图像绘制的区域。\n图形控制扩展中控制动画的参数分别是：`disposal method`，`user input flag`，`delay time`，`transparency color`。\n\n`disposal method`\n`disposal method`占3Bit，能够表示0-7。\n\n- disposal method = 1\n\n解码器不会清理画布，直接将下一幅图像渲染上一幅图像上。\n\n- disposal method = 2\n解码器会以背景色清理画布，然后渲染下一幅图像。背景色在逻辑屏幕描述符中设置。\n\ndisposal method = 3\n解码器会将画布设置为上之前的状态，然后渲染下一幅图像。\n\n- disposal method = 4-7\n保留值\n\n**user input flag**\n当user input flag为1时，GIF会在有用户输入事件（鼠标、键盘）时才会过渡到下一幅图像。\n\n**delay time**\ndelay time占两个字节，为无符号整数，控制当前帧的展示时间，单位是0.01秒。\n\n**transparency color**\n如果图形控制扩展的透明色标志位为1，那么解码器会通过透明色索引在颜色列表中找到改颜色，标记为透明，当渲染图像时，标记为透明色的颜色将不会绘制，显示下面的背景。\n\n**图像渲染区域**\nGIF中图像描述符指定了当前帧需要渲染的区域，这样GIF的过渡动画就只用绘制两帧之间不同的区域，前提是`diposal method`的值为1。\n\n\n","source":"_posts/GIF的秘密.md","raw":"---\ntitle: GIF的秘密\ndate: 2017-06-13 22:10:27\ncategories: \n\t- 知识簿\n---\n#### GIF\n\nGIF是一种使用LZW压缩，支持多张图像的容器。支持256色，透明通道为1bit。作为互联网表情包的载体，GIF这项80年代的技术依然生生不息。\n但它的弊端也是显而易见的：易出现毛边，色彩表现低劣，文件压缩比不高。针对这些问题，Mozilla发布了APNG来代替老旧的GIF技术，同时许多开源组件也用WebP格式来代替GIF。\n\n#### GIF在iOS的尴尬处境\n\n长久以来，iOS一直被吐槽不能用GIF。造成这一局面的主要原因是：\n\n- iOS关于照片的场景不会自动播放GIF,也没有角标。\n- 一些应用将GIF视为静态图像去操作，导致用户保持了一个GIF后，结果应用将其保存成JPG。\n- iOS只能通过imageI/O去操作GIF数据，UIKit对其绝缘。\n\n#### GIF的存储结构\n\n由于历史的原因，GIF有两个版本，但它们的文件结构是一样的，都是由不同用途的数据块构成，可分为控制块和数据块。控制块里是决定GIF表现的参数，数据块里的数据由前面的控制块里的参数来解释。\n一个GIF文件的内部结构如下图：\n![GIF结构](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%861.png)\n**Header**：包含文件签名与版本号。\n**Trailer**: 文件结束标识符。\n**GIF Data**: Header 与 trailer 之间就是GIF文件的数据。\n我们从一个简单的GIF图入手，它包含两张图像：\n![GIF图](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%868.gif\n)\n\n这是它的十六进制数据,我用颜色区分了不同的数据块：\n![数据块](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%862.png\n)\n\n#### Header\n\nGIF文件的开头是 Header 数据块，长度为6字节，ASCII值为“GIF87a”或\"GIF89a\",前三位为GIF签名，后三位为不同年份的版本号。\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%863.png\n)\n利用这点，在iOS中判断二进制文件是否为GIF时，可以简单去判断它的前四位是否是\"GIF8\"。事实上绝大多数图像都可以用文件签名来判断类型。\n\n#### GIF 内容\n\nGIF数据包含多个数据块，其结构如下:\n**逻辑屏幕**描述符\n\n> 0A000A00 B30000\n\n这一数据块由7个字节组成，前四个字节分别是图像渲染区域的宽高。GIF的数据是按照大端序存储的，0x0A00为10，所以这个GIF的宽高均为10。\n接下来是一个压缩字节，第一个 Bit 为标志位，表示全局颜色列表是否存在。接下来三个Bit表示图像调色板中每个颜色的原色所占用的Bit数，011表示占用4个Bit，111占用8个Bit，以此类推。调色板最多只包含由24-Bit颜色中选出的256个颜色（实际有很多优化方案能提高颜色分辨率，如加入局部调色板）。第五个Bit为标志位，表示颜色列表排序方式。若为1，表示颜色列表是按照颜色在图像中出现的频率降序排列。随后三个Bit表示全局颜色列表的大小，计算方法是2^N+1 ，其中N为这三个Bit的二进制数值。\n第六个字节是表示背景色在全局颜色列表中的索引，若无全局颜色列表则此字节无效。在GIF的图像数据中，没有被指定颜色的像素会被背景色填充。\n最后一个字节是像素的宽高比，大多数时候这个值都是0，若值为N, 则图像的宽高比：\n\n```\naspectRatio = (pixelAspectRatio + 15) / 64\n```\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%864.png\n)\n\n\n#### 全局颜色列表\n\n> 000000 80000000 80008080 00000080 80008000 8080C0C0 C0808080 FF000000 FF00FFFF 000000FF FF00FF00 FFFFFFFF FF\n\n由前面的逻辑屏幕描述符可知，全局颜色列表的大小是16，每个颜色占三个字节，按照RGB排列，所以它占有48个字节。数据流中，颜色是按照列表中的索引存储的。\n应用程序扩展\n\n>21FF0B 4E455453 43415045 322E3003 01000000\n\nGIF中扩展块都以0x21开始，后一个字节是扩展标签，标识扩展用途。\n应用程序扩展的标签是0xFF，它包含有应用程序的标识信息和应用程序数据。其中 Netscape 应用程序扩展常用于控制GIF的动画循环次数。Netscape 扩展长19个字节，前14个是应用程序的ACSII信息，后四个是数据子块，用于指定GIF的循环次数, 按无符号整型存储，0表示无限循环。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%865.png\n)\n\n\n#### 图形控制扩展\n\n> 21F90409 32000F00\n\n图形控制扩展块属于\"89a\"版本的定义。它在一个图像数据块的最前端，用来指定图像的透明度与动画属性。图形控制扩展的开端两字节是0x21F9，其中0x21表示这是一个扩展，F9表示扩展用于图形控制。第三个字节是块大小(它到结束符之间的数据)。第四个字节是压缩字段，前三个Bit保留，四到六Bit是disposal method。第四、五个字节是图像控制扩展后面的图像的动画时间，以无符号整型存储。第六个字节是透明色索引，之后是块结束符0x00。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%866.png\n)\n\n\n#### 图像描述符\n\n> 2C000000 000A000A 0000\n\n图像描述符位于GIF中每一个图像数据的前端，由0x2C开始，长度为10个字节。第一个字节是图像描述符的标识0x2c，后面八个字节表示图像的frame（left, top, width, height），用来在动画中局部更新图像。最后一个是压缩字节，主要是关于局部颜色列表的信息，其中第二个Bit表示图像的存储方式是交织还是连续。\n\n![](http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%867.png\n)\n\n#### 局部颜色列表\n\n如果上面的局部颜色列表标志位为1，那么局部颜色列表会排列在图像描述符后面，它只对紧跟在它之后的图像数据有效。如果局部颜色列表标志位为0，那么图像数据将使用全局颜色列表索引颜色。局部颜色列表的大小计算方法和像素颜色格式与全局颜色列表相同。\n\n#### 图像数据\n\n> 041C 1080472B 0549DA9B BAAE58E7 4D4F288E E629A519 697E1C0C 92DB1301 00\n\nGIF的图像数据是经过LZW压缩的二进制流，通过解码可以将其按照颜色列表中的颜色进行像素填充。第一个字节是LZW最小编码大小，用来进行数据解码。第二个字节是图像数据的大小，之后的都是图像数据，直到块结束符。\n\n#### 结束符\n\n> 3B\n\n#### GIF的动画原理\n\nGIF动画的循环次数是由应用扩展来控制的，而GIF动画每一帧的过渡方式是由图形控制扩展控制,图像描述符控制图像绘制的区域。\n图形控制扩展中控制动画的参数分别是：`disposal method`，`user input flag`，`delay time`，`transparency color`。\n\n`disposal method`\n`disposal method`占3Bit，能够表示0-7。\n\n- disposal method = 1\n\n解码器不会清理画布，直接将下一幅图像渲染上一幅图像上。\n\n- disposal method = 2\n解码器会以背景色清理画布，然后渲染下一幅图像。背景色在逻辑屏幕描述符中设置。\n\ndisposal method = 3\n解码器会将画布设置为上之前的状态，然后渲染下一幅图像。\n\n- disposal method = 4-7\n保留值\n\n**user input flag**\n当user input flag为1时，GIF会在有用户输入事件（鼠标、键盘）时才会过渡到下一幅图像。\n\n**delay time**\ndelay time占两个字节，为无符号整数，控制当前帧的展示时间，单位是0.01秒。\n\n**transparency color**\n如果图形控制扩展的透明色标志位为1，那么解码器会通过透明色索引在颜色列表中找到改颜色，标记为透明，当渲染图像时，标记为透明色的颜色将不会绘制，显示下面的背景。\n\n**图像渲染区域**\nGIF中图像描述符指定了当前帧需要渲染的区域，这样GIF的过渡动画就只用绘制两帧之间不同的区域，前提是`diposal method`的值为1。\n\n\n","slug":"GIF的秘密","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tv70009znuzr0icl6ix","content":"<h4 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h4><p>GIF是一种使用LZW压缩，支持多张图像的容器。支持256色，透明通道为1bit。作为互联网表情包的载体，GIF这项80年代的技术依然生生不息。<br>但它的弊端也是显而易见的：易出现毛边，色彩表现低劣，文件压缩比不高。针对这些问题，Mozilla发布了APNG来代替老旧的GIF技术，同时许多开源组件也用WebP格式来代替GIF。</p>\n<h4 id=\"GIF在iOS的尴尬处境\"><a href=\"#GIF在iOS的尴尬处境\" class=\"headerlink\" title=\"GIF在iOS的尴尬处境\"></a>GIF在iOS的尴尬处境</h4><p>长久以来，iOS一直被吐槽不能用GIF。造成这一局面的主要原因是：</p>\n<ul>\n<li>iOS关于照片的场景不会自动播放GIF,也没有角标。</li>\n<li>一些应用将GIF视为静态图像去操作，导致用户保持了一个GIF后，结果应用将其保存成JPG。</li>\n<li>iOS只能通过imageI/O去操作GIF数据，UIKit对其绝缘。</li>\n</ul>\n<h4 id=\"GIF的存储结构\"><a href=\"#GIF的存储结构\" class=\"headerlink\" title=\"GIF的存储结构\"></a>GIF的存储结构</h4><p>由于历史的原因，GIF有两个版本，但它们的文件结构是一样的，都是由不同用途的数据块构成，可分为控制块和数据块。控制块里是决定GIF表现的参数，数据块里的数据由前面的控制块里的参数来解释。<br>一个GIF文件的内部结构如下图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%861.png\" alt=\"GIF结构\"><br><strong>Header</strong>：包含文件签名与版本号。<br><strong>Trailer</strong>: 文件结束标识符。<br><strong>GIF Data</strong>: Header 与 trailer 之间就是GIF文件的数据。<br>我们从一个简单的GIF图入手，它包含两张图像：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%868.gif\" alt=\"GIF图\"></p>\n<p>这是它的十六进制数据,我用颜色区分了不同的数据块：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%862.png\" alt=\"数据块\"></p>\n<h4 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h4><p>GIF文件的开头是 Header 数据块，长度为6字节，ASCII值为“GIF87a”或”GIF89a”,前三位为GIF签名，后三位为不同年份的版本号。<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%863.png\" alt=\"\"><br>利用这点，在iOS中判断二进制文件是否为GIF时，可以简单去判断它的前四位是否是”GIF8”。事实上绝大多数图像都可以用文件签名来判断类型。</p>\n<h4 id=\"GIF-内容\"><a href=\"#GIF-内容\" class=\"headerlink\" title=\"GIF 内容\"></a>GIF 内容</h4><p>GIF数据包含多个数据块，其结构如下:<br><strong>逻辑屏幕</strong>描述符</p>\n<blockquote>\n<p>0A000A00 B30000</p>\n</blockquote>\n<p>这一数据块由7个字节组成，前四个字节分别是图像渲染区域的宽高。GIF的数据是按照大端序存储的，0x0A00为10，所以这个GIF的宽高均为10。<br>接下来是一个压缩字节，第一个 Bit 为标志位，表示全局颜色列表是否存在。接下来三个Bit表示图像调色板中每个颜色的原色所占用的Bit数，011表示占用4个Bit，111占用8个Bit，以此类推。调色板最多只包含由24-Bit颜色中选出的256个颜色（实际有很多优化方案能提高颜色分辨率，如加入局部调色板）。第五个Bit为标志位，表示颜色列表排序方式。若为1，表示颜色列表是按照颜色在图像中出现的频率降序排列。随后三个Bit表示全局颜色列表的大小，计算方法是2^N+1 ，其中N为这三个Bit的二进制数值。<br>第六个字节是表示背景色在全局颜色列表中的索引，若无全局颜色列表则此字节无效。在GIF的图像数据中，没有被指定颜色的像素会被背景色填充。<br>最后一个字节是像素的宽高比，大多数时候这个值都是0，若值为N, 则图像的宽高比：</p>\n<pre><code>aspectRatio = (pixelAspectRatio + 15) / 64\n</code></pre><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%864.png\" alt=\"\"></p>\n<h4 id=\"全局颜色列表\"><a href=\"#全局颜色列表\" class=\"headerlink\" title=\"全局颜色列表\"></a>全局颜色列表</h4><blockquote>\n<p>000000 80000000 80008080 00000080 80008000 8080C0C0 C0808080 FF000000 FF00FFFF 000000FF FF00FF00 FFFFFFFF FF</p>\n</blockquote>\n<p>由前面的逻辑屏幕描述符可知，全局颜色列表的大小是16，每个颜色占三个字节，按照RGB排列，所以它占有48个字节。数据流中，颜色是按照列表中的索引存储的。<br>应用程序扩展</p>\n<blockquote>\n<p>21FF0B 4E455453 43415045 322E3003 01000000</p>\n</blockquote>\n<p>GIF中扩展块都以0x21开始，后一个字节是扩展标签，标识扩展用途。<br>应用程序扩展的标签是0xFF，它包含有应用程序的标识信息和应用程序数据。其中 Netscape 应用程序扩展常用于控制GIF的动画循环次数。Netscape 扩展长19个字节，前14个是应用程序的ACSII信息，后四个是数据子块，用于指定GIF的循环次数, 按无符号整型存储，0表示无限循环。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%865.png\" alt=\"\"></p>\n<h4 id=\"图形控制扩展\"><a href=\"#图形控制扩展\" class=\"headerlink\" title=\"图形控制扩展\"></a>图形控制扩展</h4><blockquote>\n<p>21F90409 32000F00</p>\n</blockquote>\n<p>图形控制扩展块属于”89a”版本的定义。它在一个图像数据块的最前端，用来指定图像的透明度与动画属性。图形控制扩展的开端两字节是0x21F9，其中0x21表示这是一个扩展，F9表示扩展用于图形控制。第三个字节是块大小(它到结束符之间的数据)。第四个字节是压缩字段，前三个Bit保留，四到六Bit是disposal method。第四、五个字节是图像控制扩展后面的图像的动画时间，以无符号整型存储。第六个字节是透明色索引，之后是块结束符0x00。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%866.png\" alt=\"\"></p>\n<h4 id=\"图像描述符\"><a href=\"#图像描述符\" class=\"headerlink\" title=\"图像描述符\"></a>图像描述符</h4><blockquote>\n<p>2C000000 000A000A 0000</p>\n</blockquote>\n<p>图像描述符位于GIF中每一个图像数据的前端，由0x2C开始，长度为10个字节。第一个字节是图像描述符的标识0x2c，后面八个字节表示图像的frame（left, top, width, height），用来在动画中局部更新图像。最后一个是压缩字节，主要是关于局部颜色列表的信息，其中第二个Bit表示图像的存储方式是交织还是连续。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%867.png\" alt=\"\"></p>\n<h4 id=\"局部颜色列表\"><a href=\"#局部颜色列表\" class=\"headerlink\" title=\"局部颜色列表\"></a>局部颜色列表</h4><p>如果上面的局部颜色列表标志位为1，那么局部颜色列表会排列在图像描述符后面，它只对紧跟在它之后的图像数据有效。如果局部颜色列表标志位为0，那么图像数据将使用全局颜色列表索引颜色。局部颜色列表的大小计算方法和像素颜色格式与全局颜色列表相同。</p>\n<h4 id=\"图像数据\"><a href=\"#图像数据\" class=\"headerlink\" title=\"图像数据\"></a>图像数据</h4><blockquote>\n<p>041C 1080472B 0549DA9B BAAE58E7 4D4F288E E629A519 697E1C0C 92DB1301 00</p>\n</blockquote>\n<p>GIF的图像数据是经过LZW压缩的二进制流，通过解码可以将其按照颜色列表中的颜色进行像素填充。第一个字节是LZW最小编码大小，用来进行数据解码。第二个字节是图像数据的大小，之后的都是图像数据，直到块结束符。</p>\n<h4 id=\"结束符\"><a href=\"#结束符\" class=\"headerlink\" title=\"结束符\"></a>结束符</h4><blockquote>\n<p>3B</p>\n</blockquote>\n<h4 id=\"GIF的动画原理\"><a href=\"#GIF的动画原理\" class=\"headerlink\" title=\"GIF的动画原理\"></a>GIF的动画原理</h4><p>GIF动画的循环次数是由应用扩展来控制的，而GIF动画每一帧的过渡方式是由图形控制扩展控制,图像描述符控制图像绘制的区域。<br>图形控制扩展中控制动画的参数分别是：<code>disposal method</code>，<code>user input flag</code>，<code>delay time</code>，<code>transparency color</code>。</p>\n<p><code>disposal method</code><br><code>disposal method</code>占3Bit，能够表示0-7。</p>\n<ul>\n<li>disposal method = 1</li>\n</ul>\n<p>解码器不会清理画布，直接将下一幅图像渲染上一幅图像上。</p>\n<ul>\n<li>disposal method = 2<br>解码器会以背景色清理画布，然后渲染下一幅图像。背景色在逻辑屏幕描述符中设置。</li>\n</ul>\n<p>disposal method = 3<br>解码器会将画布设置为上之前的状态，然后渲染下一幅图像。</p>\n<ul>\n<li>disposal method = 4-7<br>保留值</li>\n</ul>\n<p><strong>user input flag</strong><br>当user input flag为1时，GIF会在有用户输入事件（鼠标、键盘）时才会过渡到下一幅图像。</p>\n<p><strong>delay time</strong><br>delay time占两个字节，为无符号整数，控制当前帧的展示时间，单位是0.01秒。</p>\n<p><strong>transparency color</strong><br>如果图形控制扩展的透明色标志位为1，那么解码器会通过透明色索引在颜色列表中找到改颜色，标记为透明，当渲染图像时，标记为透明色的颜色将不会绘制，显示下面的背景。</p>\n<p><strong>图像渲染区域</strong><br>GIF中图像描述符指定了当前帧需要渲染的区域，这样GIF的过渡动画就只用绘制两帧之间不同的区域，前提是<code>diposal method</code>的值为1。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"GIF\"><a href=\"#GIF\" class=\"headerlink\" title=\"GIF\"></a>GIF</h4><p>GIF是一种使用LZW压缩，支持多张图像的容器。支持256色，透明通道为1bit。作为互联网表情包的载体，GIF这项80年代的技术依然生生不息。<br>但它的弊端也是显而易见的：易出现毛边，色彩表现低劣，文件压缩比不高。针对这些问题，Mozilla发布了APNG来代替老旧的GIF技术，同时许多开源组件也用WebP格式来代替GIF。</p>\n<h4 id=\"GIF在iOS的尴尬处境\"><a href=\"#GIF在iOS的尴尬处境\" class=\"headerlink\" title=\"GIF在iOS的尴尬处境\"></a>GIF在iOS的尴尬处境</h4><p>长久以来，iOS一直被吐槽不能用GIF。造成这一局面的主要原因是：</p>\n<ul>\n<li>iOS关于照片的场景不会自动播放GIF,也没有角标。</li>\n<li>一些应用将GIF视为静态图像去操作，导致用户保持了一个GIF后，结果应用将其保存成JPG。</li>\n<li>iOS只能通过imageI/O去操作GIF数据，UIKit对其绝缘。</li>\n</ul>\n<h4 id=\"GIF的存储结构\"><a href=\"#GIF的存储结构\" class=\"headerlink\" title=\"GIF的存储结构\"></a>GIF的存储结构</h4><p>由于历史的原因，GIF有两个版本，但它们的文件结构是一样的，都是由不同用途的数据块构成，可分为控制块和数据块。控制块里是决定GIF表现的参数，数据块里的数据由前面的控制块里的参数来解释。<br>一个GIF文件的内部结构如下图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%861.png\" alt=\"GIF结构\"><br><strong>Header</strong>：包含文件签名与版本号。<br><strong>Trailer</strong>: 文件结束标识符。<br><strong>GIF Data</strong>: Header 与 trailer 之间就是GIF文件的数据。<br>我们从一个简单的GIF图入手，它包含两张图像：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%868.gif\" alt=\"GIF图\"></p>\n<p>这是它的十六进制数据,我用颜色区分了不同的数据块：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%862.png\" alt=\"数据块\"></p>\n<h4 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h4><p>GIF文件的开头是 Header 数据块，长度为6字节，ASCII值为“GIF87a”或”GIF89a”,前三位为GIF签名，后三位为不同年份的版本号。<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%863.png\" alt=\"\"><br>利用这点，在iOS中判断二进制文件是否为GIF时，可以简单去判断它的前四位是否是”GIF8”。事实上绝大多数图像都可以用文件签名来判断类型。</p>\n<h4 id=\"GIF-内容\"><a href=\"#GIF-内容\" class=\"headerlink\" title=\"GIF 内容\"></a>GIF 内容</h4><p>GIF数据包含多个数据块，其结构如下:<br><strong>逻辑屏幕</strong>描述符</p>\n<blockquote>\n<p>0A000A00 B30000</p>\n</blockquote>\n<p>这一数据块由7个字节组成，前四个字节分别是图像渲染区域的宽高。GIF的数据是按照大端序存储的，0x0A00为10，所以这个GIF的宽高均为10。<br>接下来是一个压缩字节，第一个 Bit 为标志位，表示全局颜色列表是否存在。接下来三个Bit表示图像调色板中每个颜色的原色所占用的Bit数，011表示占用4个Bit，111占用8个Bit，以此类推。调色板最多只包含由24-Bit颜色中选出的256个颜色（实际有很多优化方案能提高颜色分辨率，如加入局部调色板）。第五个Bit为标志位，表示颜色列表排序方式。若为1，表示颜色列表是按照颜色在图像中出现的频率降序排列。随后三个Bit表示全局颜色列表的大小，计算方法是2^N+1 ，其中N为这三个Bit的二进制数值。<br>第六个字节是表示背景色在全局颜色列表中的索引，若无全局颜色列表则此字节无效。在GIF的图像数据中，没有被指定颜色的像素会被背景色填充。<br>最后一个字节是像素的宽高比，大多数时候这个值都是0，若值为N, 则图像的宽高比：</p>\n<pre><code>aspectRatio = (pixelAspectRatio + 15) / 64\n</code></pre><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%864.png\" alt=\"\"></p>\n<h4 id=\"全局颜色列表\"><a href=\"#全局颜色列表\" class=\"headerlink\" title=\"全局颜色列表\"></a>全局颜色列表</h4><blockquote>\n<p>000000 80000000 80008080 00000080 80008000 8080C0C0 C0808080 FF000000 FF00FFFF 000000FF FF00FF00 FFFFFFFF FF</p>\n</blockquote>\n<p>由前面的逻辑屏幕描述符可知，全局颜色列表的大小是16，每个颜色占三个字节，按照RGB排列，所以它占有48个字节。数据流中，颜色是按照列表中的索引存储的。<br>应用程序扩展</p>\n<blockquote>\n<p>21FF0B 4E455453 43415045 322E3003 01000000</p>\n</blockquote>\n<p>GIF中扩展块都以0x21开始，后一个字节是扩展标签，标识扩展用途。<br>应用程序扩展的标签是0xFF，它包含有应用程序的标识信息和应用程序数据。其中 Netscape 应用程序扩展常用于控制GIF的动画循环次数。Netscape 扩展长19个字节，前14个是应用程序的ACSII信息，后四个是数据子块，用于指定GIF的循环次数, 按无符号整型存储，0表示无限循环。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%865.png\" alt=\"\"></p>\n<h4 id=\"图形控制扩展\"><a href=\"#图形控制扩展\" class=\"headerlink\" title=\"图形控制扩展\"></a>图形控制扩展</h4><blockquote>\n<p>21F90409 32000F00</p>\n</blockquote>\n<p>图形控制扩展块属于”89a”版本的定义。它在一个图像数据块的最前端，用来指定图像的透明度与动画属性。图形控制扩展的开端两字节是0x21F9，其中0x21表示这是一个扩展，F9表示扩展用于图形控制。第三个字节是块大小(它到结束符之间的数据)。第四个字节是压缩字段，前三个Bit保留，四到六Bit是disposal method。第四、五个字节是图像控制扩展后面的图像的动画时间，以无符号整型存储。第六个字节是透明色索引，之后是块结束符0x00。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%866.png\" alt=\"\"></p>\n<h4 id=\"图像描述符\"><a href=\"#图像描述符\" class=\"headerlink\" title=\"图像描述符\"></a>图像描述符</h4><blockquote>\n<p>2C000000 000A000A 0000</p>\n</blockquote>\n<p>图像描述符位于GIF中每一个图像数据的前端，由0x2C开始，长度为10个字节。第一个字节是图像描述符的标识0x2c，后面八个字节表示图像的frame（left, top, width, height），用来在动画中局部更新图像。最后一个是压缩字节，主要是关于局部颜色列表的信息，其中第二个Bit表示图像的存储方式是交织还是连续。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gif%E7%9A%84%E7%A7%98%E5%AF%867.png\" alt=\"\"></p>\n<h4 id=\"局部颜色列表\"><a href=\"#局部颜色列表\" class=\"headerlink\" title=\"局部颜色列表\"></a>局部颜色列表</h4><p>如果上面的局部颜色列表标志位为1，那么局部颜色列表会排列在图像描述符后面，它只对紧跟在它之后的图像数据有效。如果局部颜色列表标志位为0，那么图像数据将使用全局颜色列表索引颜色。局部颜色列表的大小计算方法和像素颜色格式与全局颜色列表相同。</p>\n<h4 id=\"图像数据\"><a href=\"#图像数据\" class=\"headerlink\" title=\"图像数据\"></a>图像数据</h4><blockquote>\n<p>041C 1080472B 0549DA9B BAAE58E7 4D4F288E E629A519 697E1C0C 92DB1301 00</p>\n</blockquote>\n<p>GIF的图像数据是经过LZW压缩的二进制流，通过解码可以将其按照颜色列表中的颜色进行像素填充。第一个字节是LZW最小编码大小，用来进行数据解码。第二个字节是图像数据的大小，之后的都是图像数据，直到块结束符。</p>\n<h4 id=\"结束符\"><a href=\"#结束符\" class=\"headerlink\" title=\"结束符\"></a>结束符</h4><blockquote>\n<p>3B</p>\n</blockquote>\n<h4 id=\"GIF的动画原理\"><a href=\"#GIF的动画原理\" class=\"headerlink\" title=\"GIF的动画原理\"></a>GIF的动画原理</h4><p>GIF动画的循环次数是由应用扩展来控制的，而GIF动画每一帧的过渡方式是由图形控制扩展控制,图像描述符控制图像绘制的区域。<br>图形控制扩展中控制动画的参数分别是：<code>disposal method</code>，<code>user input flag</code>，<code>delay time</code>，<code>transparency color</code>。</p>\n<p><code>disposal method</code><br><code>disposal method</code>占3Bit，能够表示0-7。</p>\n<ul>\n<li>disposal method = 1</li>\n</ul>\n<p>解码器不会清理画布，直接将下一幅图像渲染上一幅图像上。</p>\n<ul>\n<li>disposal method = 2<br>解码器会以背景色清理画布，然后渲染下一幅图像。背景色在逻辑屏幕描述符中设置。</li>\n</ul>\n<p>disposal method = 3<br>解码器会将画布设置为上之前的状态，然后渲染下一幅图像。</p>\n<ul>\n<li>disposal method = 4-7<br>保留值</li>\n</ul>\n<p><strong>user input flag</strong><br>当user input flag为1时，GIF会在有用户输入事件（鼠标、键盘）时才会过渡到下一幅图像。</p>\n<p><strong>delay time</strong><br>delay time占两个字节，为无符号整数，控制当前帧的展示时间，单位是0.01秒。</p>\n<p><strong>transparency color</strong><br>如果图形控制扩展的透明色标志位为1，那么解码器会通过透明色索引在颜色列表中找到改颜色，标记为透明，当渲染图像时，标记为透明色的颜色将不会绘制，显示下面的背景。</p>\n<p><strong>图像渲染区域</strong><br>GIF中图像描述符指定了当前帧需要渲染的区域，这样GIF的过渡动画就只用绘制两帧之间不同的区域，前提是<code>diposal method</code>的值为1。</p>\n"},{"title":"AVAudioFoundation(2)：音视频播放","date":"2017-06-28T14:23:31.000Z","_content":"要播放  `AVAsset` 可以使用 `AVPlayer`。在播放期间，可以使用一个 `AVPlayerItem` 实例来管理 `asset` 的整体的播放状态，使用 `AVPlayerItemTrack` 来管理各个 `track` 的播放状态。对于视频的渲染，使用 `AVPlayerLayer` 来处理。\n\n#### 播放 Asset\n\n`AVPlayer` 是一个控制 `asset` 播放的控制器，它的功能包括：开始播放、停止播放、`seek` 等等。你可以使用 `AVPlayer` 来播放单个 `asset`。如果你想播放一组 `asset`，你可以使用 `AVQueuePlayer`，`AVQueuePlayer` 是 `AVPlayer` 的子类。\n\n`AVPlayer` 也会提供当前的播放状态，这样我们就可以根据当前的播放状态调整交互。我们需要将 `AVPlayer` 的画面输出到一个特定的 `Core Animation Layer` 上，通常是一个 `AVPlayerLayer` 或 `AVSynchronizedLayer` 实例。\n\n需要注意的是，你可以从一个 `AVPlayer` 实例创建多个 `AVPlayerLayer` 对象，但是只有最新创建的那个才会渲染画面到屏幕。\n\n对于 `AVPlayer` 来说，虽然最终播放的是 `asset`，但是我们并不直接提供一个 `AVAsset` 给它，而是提供一个 `AVPlayerItem` 实例。`AVPlayerItem` 是用来管理与之关联的 `asset` 的播放状态的，一个 `AVPlayerItem` 包含了一组 `AVPlayerItemTrack` 实例，对应着 `asset` 中的音视频轨道。它们直接的关系大致如下图所示：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE1.png)\n\n注意：该图的原图是苹果官方文档上的，但是原图是有错的，把 `AVPlayerItemTrack` 所属的框标成了 `AVAsset`，这里做了修正。\n\n这种实现方式就意味着，我们可以用多个播放器同时播放一个 `asset`，并且各个播放器可以使用不同的模式来渲染。下图就展示了一种用两个不同的 `AVPlayer` 采用不同的设置播放同一个 `AVAsset` 的场景。在播放中，还可以禁掉某些 `track` 的播放。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE2.png)\n我们可以通过网络来加载 `asset`，通常简单的初始化 `AVPlayerItem` 后并不意味着它就直接能播放，所以我们可以 `KVO AVPlayerItem` 的 `status` 属性来监听它是否已经可播再决定后续的行为。\n\n#### 处理不同类型的 Asset\n\n我们配置 `asset` 来播放的方式多多少少会依赖 `asset` 的类型，一般我们有两种不同类型的 `asset`：\n\n- 1）基于文件的 asset，一般可以来源于本地视频文件、相册资源库等等。\n- 2）流式 `asset`，比如 `HLS` 格式的视频。\n\n加载基于文件的 `asset` 一般分为如下几步：\n- 基于文件路径的 `URL` 创建 `AVURLAsset` 实例。\n- 基于 `AVURLAsset` 实例创建 `AVPlayerItem` 实例。\n- 将 `AVPlayerItem` 实例与一个 `AVPlayer` 实例关联。\n- `KVO` 监测 `AVPlayerItem` 的 `status` 属性来等待其已经可播，即加载完成。\n\n创建并加载一个 `HTTP Live Stream`（HLS）格式的资源来播放时，可以按照下面几步来做：\n\n- 基于资源的 `URL` 初始化一个 `AVPlayerItem` 实例，因为你无法直接创建一个 `AVAsset` 来表示 `HLS` 资源。\n- 当你将 `AVPlayerItem` 和 `AVPlayer` 实例关联起来后，他就开始为播放做准备，当一切就绪时 `AVPlayerItem` 会创建出  `AVAsset` 和 `AVAssetTrack` 实例以用来对接 `HLS` 视频流的音视频内容。\n- 要获取视频流的时长，你需要 `KVO` 监测 `AVPlayerItem` 的 `duration` 属性，当资源可以播放时，它会被更新为正确的值。\n\n```objectivec\nNSURL *url = [NSURL URLWithString:@\"<#Live stream URL#>];\n// You may find a test stream at <http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8>.\nself.playerItem = [AVPlayerItem playerItemWithURL:url];\n[playerItem addObserver:self forKeyPath:@\"status\" options:0 context:&ItemStatusContext];\nself.player = [AVPlayer playerWithPlayerItem:playerItem];\n```\n当你不知道一个 `URL` 对应的是什么类型的 `asset` 时，你可以这样做：\n\n- 尝试基于 `URL` 来初始化一个 `AVURLAsset`，并加载它的 `tracks` 属性。如果 `tracks` 属性加载成功，就基于 `asset` 来创建一个 `AVPlayerItem` 实例。\n- 如果 `tracks` 属性加载失败，那么就直接基于 `URL` 创建一个 `AVPlayerItem` 实例，并 `KVO` 监测 `AVPlayer` 的 `status` 属性来看它何时可以播放。\n- 如果上述尝试都失败，那就清理掉 `AVPlayerItem`。\n\n#### 播放一个 AVPlayerItem\n\n调用 `AVPlayer` 的 `play` 接口即可开始播放。\n\n```objectivec\n- (IBAction)play:sender {\n    [player play];\n}\n```\n除了简单的播放，还可以通过设置 rate 属性设置播放速率。\n\n```objectivec\nplayer.rate = 0.5;\nplayer.rate = 2.0;\n```\n播放速率设置为 1.0 表示正常播放，设置为 0.0 表示暂停（等同调用 pause 效果）。\n\n除了正向播放，有的音视频还能支持倒播，不过需要需要检查几个属性：\n\n- `canPlayReverse`：支持设置播放速率为 -1.0。\n- `canPlaySlowReverse`：支持设置播放速率为 -1.0 到 0.0。\n- `canPlayFastReverse`：支持设置播放速率为小于 -1.0 的值。\n可以通过 `seekToTime`: 接口来调整播放位置。但是这个接口主要是为性能考虑，不保证精确。\n\n\n```objectivec\nCMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn];\n```\n\n如果要精确调整，可以用 `seekToTime:toleranceBefore:toleranceAfter:` 接口。\n\n```objectivec\nCMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];\n```\n\n需要注意的是，设置 `tolerance` 为 `zero` 会耗费较大的计算性能，所以一般只在编写复杂的音视频编辑功能是这样设置。\n\n我们可以通过监听 `AVPlayerItemDidPlayToEndTimeNotification` 来获得播放结束事件，在播放结束后可以用 `seekToTime:` 调整播放位置到 `zero`，否则调用 `play` 会无效。\n\n\n```objectivec\n// Register with the notification center after creating the player item.\n[[NSNotificationCenter defaultCenter] \n    addObserver:self \n       selector:@selector(playerItemDidReachEnd:)\n           name:AVPlayerItemDidPlayToEndTimeNotification\n         object:<#The player item#>];\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [player seekToTime:kCMTimeZero];\n}\n```\n\n此外，我们还能设置播放器的 `actionAtItemEnd` 属性来设置其在播放结束后的行为，比如 `AVPlayerActionAtItemEndPause` 表示播放结束后会暂停。\n\n#### 播放多个 AVPlayerItem\n\n我们可以用 `AVQueuePlayer` 来顺序播放多个 `AVPlayerItem`。`AVQueuePlayer` 是 `AVPlayer` 的子类。\n\n```objectivec\nNSArray *items = <#An array of player items#>;\nAVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];\n```\n\n通过调用 `play` 即可顺序播放，也可以调用 `advanceToNextItem` 跳到下个 `item`。除此之外，我们还可以用 `insertItem:afterItem:`、`removeItem:`、`removeAllItems` 来控制播放资源。\n\n当插入一个 `item` 的时候，可以需要用 `canInsertItem:afterItem:` 检查下是否可以插入， 对 `afterItem` 传入 `nil`，则检查是否可以插入到队尾。\n\n```objectivec\nAVPlayerItem *anItem = <#Get a player item#>;\nif ([queuePlayer canInsertItem:anItem afterItem:nil]) {\n    [queuePlayer insertItem:anItem afterItem:nil];\n}\n```\n#### 监测播放状态\n\n我们可以监测一些 `AVPlayer` 的状态和正在播放的 `AVPlayerItem` 的状态，这对于处理那些不在你直接控制下的 `state` 是很有用的，比如：\n\n- 如果用户使用多任务处理切换到另一个应用程序，播放器的 `rate` 属性将下降到 0.0。\n- 当播放远程媒体资源（比如网络视频）时，监测 `AVPlayerItem` 的 `loadedTimeRanges` 和 `seekableTimeRanges` 可以知道可以播放和 `seek` 的资源时长。\n- 当播放 `HTTP Live Stream` 时，播放器的 `currentItem` 可能发生变化。\n- 当播放 `HTTP Live Stream` 时，`AVPlayerItem` 的 `tracks` 可能发生变化。这种情况可能发生在播放流切换了编码。\n- 当播放失败时，`AVPlayer` 或 `AVPlayerItem` 的 `status` 可能发生变化。\n\n#### 响应 status 属性的变化\n\n通过 `KVO` 监测 `AVPlayer` 和正在播放的 `AVPlayerItem` 的 `status` 属性，可以获得对应的通知，比如当播放出现错误时，你可能会收到 `AVPlayerStatusFailed` 或 `AVPlayerItemStatusFailed` 通知，这时你就可以做相应的处理。\n\n需要注意的是，由于 `AVFoundation` 不会指定在哪个线程发送通知，所以如果你需要在收到通知后更新用户界面的话，你需要切到主线程。\n\n```objectivec\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == <#Player status context#>) {\n        AVPlayer *thePlayer = (AVPlayer *) object;\n        if ([thePlayer status] == AVPlayerStatusFailed) {\n            NSError *error = [<#The AVPlayer object#> error];\n            // Respond to error: for example, display an alert sheet.\n            return;\n        }\n        // Deal with other status change if appropriate.\n    }\n    // Deal with other change notifications if appropriate.\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n```\n\n#### 跟踪视觉内容就绪状态\n\n我们可以监测 `AVPlayerLayer` 实例的 `readyForDisplay` 属性来获得播放器已经可以开始渲染视觉内容的通知。\n\n基于这个能力，我们就能实现在播放器的视觉内容就绪时才将 `player layer` 插入到 `layer` 树中去展示给用户。\n\n#### 追踪播放时间变化\n\n我们可以使用 `AVPlayer` 的 `addPeriodicTimeObserverForInterval:queue:usingBlock:` 和 `addBoundaryTimeObserverForTimes:queue:usingBlock:` 这两个接口来追踪当前播放位置的变化，这样我们就可以在用户界面上做出更新，反馈给用户当前的播放时间和剩余的播放时间等等。\n\n- `addPeriodicTimeObserverForInterval:queue:usingBlock:`，这个接口将会在播放时间发生变化时在回调 block 中通知我们当前播放时间。\n- `addBoundaryTimeObserverForTimes:queue:usingBlock:`，这个接口允许我们传入一组时间（CMTime 数组）当播放器播到这些时间时会在回调 `block` 中通知我们。\n这两个接口都会返回一个 `observer` 角色的对象给我们，我们需要在监测时间的这个过程中强引用这个对象，同时在不需要使用它时调用 r`emoveTimeObserver:` 接口来移除它。\n\n此外，AVFoundation 也不保证在每次时间变化或设置时间到达时都回调 block 来通知你。比如当上一次回调 block 还没完成的情况时，又到了此次回调 block 的时机，AVFoundation 这次就不会调用 block。所以我们需要确保不要在 block 回调里做开销太大、耗时太长的任务。\n\n```objectivec\n// Assume a property: @property (strong) id playerObserver;\n\nFloat64 durationSeconds = CMTimeGetSeconds([<#An asset#> duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);\nNSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird]];\n\nself.playerObserver = [<#A player#> addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{\n\n    NSString *timeDescription = (NSString *)\n        CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime]));\n    NSLog(@\"Passed a boundary at %@\", timeDescription);\n}];\n```\n\n#### 播放结束\n监听 `AVPlayerItemDidPlayToEndTimeNotification` 这个通知即可。上文有提到，这里不再重复。\n\n#### 一个完整示例\n\n这里的示例将展示如果使用 `AVPlayer` 来播放一个视频文件，主要包括下面几个步骤：\n\n- 配置一个使用 `AVPlayerLayer layer` 的 `UIView`。\n- 创建一个 `AVPlayer` 实例。\n- 基于文件类型的 `asset` 创建一个 `AVPlayerItem` 实例，并用 `KVO` 监测其 `status` 属性。\n- 响应 `AVPlayerItem` 实例可以播放的通知，显示出一个按钮。\n- 播放 `AVPlayerItem` 并播放完成后将其播放位置调整到开始位置。\n首先是 `PlayerView`：\n\n```objectivec\n#import <UIKit/UIKit.h>\n#import <AVFoundation/AVFoundation.h>\n\n@interface PlayerView : UIView\n@property (nonatomic) AVPlayer *player;\n@end\n\n@implementation PlayerView\n+ (Class)layerClass {\n    return [AVPlayerLayer class];\n}\n- (AVPlayer*)player {\n    return [(AVPlayerLayer *)[self layer] player];\n}\n- (void)setPlayer:(AVPlayer *)player {\n    [(AVPlayerLayer *)[self layer] setPlayer:player];\n}\n@end\n```\n\n一个简单的 `PlayerViewController`：\n\n```objectivec\n@class PlayerView;\n@interface PlayerViewController : UIViewController\n\n@property (nonatomic) AVPlayer *player;\n@property (nonatomic) AVPlayerItem *playerItem;\n@property (nonatomic, weak) IBOutlet PlayerView *playerView;\n@property (nonatomic, weak) IBOutlet UIButton *playButton;\n- (IBAction)loadAssetFromFile:sender;\n- (IBAction)play:sender;\n- (void)syncUI;\n@end\n```\n同步 `UI` 的方法：\n\n```objectivec\n- (void)syncUI {\n    if ((self.player.currentItem != nil) &&\n        ([self.player.currentItem status] == AVPlayerItemStatusReadyToPlay)) {\n        self.playButton.enabled = YES;\n    }\n    else {\n        self.playButton.enabled = NO;\n    }\n}\n```\n\n在 `viewDidLoad` 时先调用一下 `syncUI`：\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self syncUI];\n}\n```\n\n创建并加载 `AVURLAsset`，在加载成功时，创建 `item`、初始化播放器以及添加各种监听：\n\n```objectivec\nstatic const NSString *ItemStatusContext;\n\n- (IBAction)loadAssetFromFile:sender {\n\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:<#@\"VideoFileName\"#> withExtension:<#@\"extension\"#>];\n\n    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];\n    NSString *tracksKey = @\"tracks\";\n\n    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler: ^{\n        // The completion block goes here.\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSError *error;\n            AVKeyValueStatus status = [asset statusOfValueForKey:tracksKey error:&error];\n\n            if (status == AVKeyValueStatusLoaded) {\n                self.playerItem = [AVPlayerItem playerItemWithAsset:asset];\n                 // ensure that this is done before the playerItem is associated with the player\n                [self.playerItem addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionInitial context:&ItemStatusContext];\n                [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerItemDidReachEnd:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.playerItem];\n                self.player = [AVPlayer playerWithPlayerItem:self.playerItem];\n                [self.playerView setPlayer:self.player];\n            } else {\n                // You should deal with the error appropriately.\n                NSLog(@\"The asset's tracks were not loaded:\\n%@\", [error localizedDescription]);\n            }\n        });\n    }];\n}\n```\n\n响应 `status` 的监听通知：\n\n```objectivec\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == &ItemStatusContext) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self syncUI];\n        });\n        return;\n    }\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n```\n\n播放，以及播放完成时的处理：\n\n\n```objectivec\n- (IBAction)play:sender {\n    [self.player play];\n}\n\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [self.player seekToTime:kCMTimeZero];\n}\n```\n\n\n","source":"_posts/AVAudioFoundation-2-：音视频播放.md","raw":"---\ntitle: AVAudioFoundation(2)：音视频播放\ndate: 2017-06-28 22:23:31\ncategories: \n\t- iOS合集\n---\n要播放  `AVAsset` 可以使用 `AVPlayer`。在播放期间，可以使用一个 `AVPlayerItem` 实例来管理 `asset` 的整体的播放状态，使用 `AVPlayerItemTrack` 来管理各个 `track` 的播放状态。对于视频的渲染，使用 `AVPlayerLayer` 来处理。\n\n#### 播放 Asset\n\n`AVPlayer` 是一个控制 `asset` 播放的控制器，它的功能包括：开始播放、停止播放、`seek` 等等。你可以使用 `AVPlayer` 来播放单个 `asset`。如果你想播放一组 `asset`，你可以使用 `AVQueuePlayer`，`AVQueuePlayer` 是 `AVPlayer` 的子类。\n\n`AVPlayer` 也会提供当前的播放状态，这样我们就可以根据当前的播放状态调整交互。我们需要将 `AVPlayer` 的画面输出到一个特定的 `Core Animation Layer` 上，通常是一个 `AVPlayerLayer` 或 `AVSynchronizedLayer` 实例。\n\n需要注意的是，你可以从一个 `AVPlayer` 实例创建多个 `AVPlayerLayer` 对象，但是只有最新创建的那个才会渲染画面到屏幕。\n\n对于 `AVPlayer` 来说，虽然最终播放的是 `asset`，但是我们并不直接提供一个 `AVAsset` 给它，而是提供一个 `AVPlayerItem` 实例。`AVPlayerItem` 是用来管理与之关联的 `asset` 的播放状态的，一个 `AVPlayerItem` 包含了一组 `AVPlayerItemTrack` 实例，对应着 `asset` 中的音视频轨道。它们直接的关系大致如下图所示：\n\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE1.png)\n\n注意：该图的原图是苹果官方文档上的，但是原图是有错的，把 `AVPlayerItemTrack` 所属的框标成了 `AVAsset`，这里做了修正。\n\n这种实现方式就意味着，我们可以用多个播放器同时播放一个 `asset`，并且各个播放器可以使用不同的模式来渲染。下图就展示了一种用两个不同的 `AVPlayer` 采用不同的设置播放同一个 `AVAsset` 的场景。在播放中，还可以禁掉某些 `track` 的播放。\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE2.png)\n我们可以通过网络来加载 `asset`，通常简单的初始化 `AVPlayerItem` 后并不意味着它就直接能播放，所以我们可以 `KVO AVPlayerItem` 的 `status` 属性来监听它是否已经可播再决定后续的行为。\n\n#### 处理不同类型的 Asset\n\n我们配置 `asset` 来播放的方式多多少少会依赖 `asset` 的类型，一般我们有两种不同类型的 `asset`：\n\n- 1）基于文件的 asset，一般可以来源于本地视频文件、相册资源库等等。\n- 2）流式 `asset`，比如 `HLS` 格式的视频。\n\n加载基于文件的 `asset` 一般分为如下几步：\n- 基于文件路径的 `URL` 创建 `AVURLAsset` 实例。\n- 基于 `AVURLAsset` 实例创建 `AVPlayerItem` 实例。\n- 将 `AVPlayerItem` 实例与一个 `AVPlayer` 实例关联。\n- `KVO` 监测 `AVPlayerItem` 的 `status` 属性来等待其已经可播，即加载完成。\n\n创建并加载一个 `HTTP Live Stream`（HLS）格式的资源来播放时，可以按照下面几步来做：\n\n- 基于资源的 `URL` 初始化一个 `AVPlayerItem` 实例，因为你无法直接创建一个 `AVAsset` 来表示 `HLS` 资源。\n- 当你将 `AVPlayerItem` 和 `AVPlayer` 实例关联起来后，他就开始为播放做准备，当一切就绪时 `AVPlayerItem` 会创建出  `AVAsset` 和 `AVAssetTrack` 实例以用来对接 `HLS` 视频流的音视频内容。\n- 要获取视频流的时长，你需要 `KVO` 监测 `AVPlayerItem` 的 `duration` 属性，当资源可以播放时，它会被更新为正确的值。\n\n```objectivec\nNSURL *url = [NSURL URLWithString:@\"<#Live stream URL#>];\n// You may find a test stream at <http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8>.\nself.playerItem = [AVPlayerItem playerItemWithURL:url];\n[playerItem addObserver:self forKeyPath:@\"status\" options:0 context:&ItemStatusContext];\nself.player = [AVPlayer playerWithPlayerItem:playerItem];\n```\n当你不知道一个 `URL` 对应的是什么类型的 `asset` 时，你可以这样做：\n\n- 尝试基于 `URL` 来初始化一个 `AVURLAsset`，并加载它的 `tracks` 属性。如果 `tracks` 属性加载成功，就基于 `asset` 来创建一个 `AVPlayerItem` 实例。\n- 如果 `tracks` 属性加载失败，那么就直接基于 `URL` 创建一个 `AVPlayerItem` 实例，并 `KVO` 监测 `AVPlayer` 的 `status` 属性来看它何时可以播放。\n- 如果上述尝试都失败，那就清理掉 `AVPlayerItem`。\n\n#### 播放一个 AVPlayerItem\n\n调用 `AVPlayer` 的 `play` 接口即可开始播放。\n\n```objectivec\n- (IBAction)play:sender {\n    [player play];\n}\n```\n除了简单的播放，还可以通过设置 rate 属性设置播放速率。\n\n```objectivec\nplayer.rate = 0.5;\nplayer.rate = 2.0;\n```\n播放速率设置为 1.0 表示正常播放，设置为 0.0 表示暂停（等同调用 pause 效果）。\n\n除了正向播放，有的音视频还能支持倒播，不过需要需要检查几个属性：\n\n- `canPlayReverse`：支持设置播放速率为 -1.0。\n- `canPlaySlowReverse`：支持设置播放速率为 -1.0 到 0.0。\n- `canPlayFastReverse`：支持设置播放速率为小于 -1.0 的值。\n可以通过 `seekToTime`: 接口来调整播放位置。但是这个接口主要是为性能考虑，不保证精确。\n\n\n```objectivec\nCMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn];\n```\n\n如果要精确调整，可以用 `seekToTime:toleranceBefore:toleranceAfter:` 接口。\n\n```objectivec\nCMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];\n```\n\n需要注意的是，设置 `tolerance` 为 `zero` 会耗费较大的计算性能，所以一般只在编写复杂的音视频编辑功能是这样设置。\n\n我们可以通过监听 `AVPlayerItemDidPlayToEndTimeNotification` 来获得播放结束事件，在播放结束后可以用 `seekToTime:` 调整播放位置到 `zero`，否则调用 `play` 会无效。\n\n\n```objectivec\n// Register with the notification center after creating the player item.\n[[NSNotificationCenter defaultCenter] \n    addObserver:self \n       selector:@selector(playerItemDidReachEnd:)\n           name:AVPlayerItemDidPlayToEndTimeNotification\n         object:<#The player item#>];\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [player seekToTime:kCMTimeZero];\n}\n```\n\n此外，我们还能设置播放器的 `actionAtItemEnd` 属性来设置其在播放结束后的行为，比如 `AVPlayerActionAtItemEndPause` 表示播放结束后会暂停。\n\n#### 播放多个 AVPlayerItem\n\n我们可以用 `AVQueuePlayer` 来顺序播放多个 `AVPlayerItem`。`AVQueuePlayer` 是 `AVPlayer` 的子类。\n\n```objectivec\nNSArray *items = <#An array of player items#>;\nAVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];\n```\n\n通过调用 `play` 即可顺序播放，也可以调用 `advanceToNextItem` 跳到下个 `item`。除此之外，我们还可以用 `insertItem:afterItem:`、`removeItem:`、`removeAllItems` 来控制播放资源。\n\n当插入一个 `item` 的时候，可以需要用 `canInsertItem:afterItem:` 检查下是否可以插入， 对 `afterItem` 传入 `nil`，则检查是否可以插入到队尾。\n\n```objectivec\nAVPlayerItem *anItem = <#Get a player item#>;\nif ([queuePlayer canInsertItem:anItem afterItem:nil]) {\n    [queuePlayer insertItem:anItem afterItem:nil];\n}\n```\n#### 监测播放状态\n\n我们可以监测一些 `AVPlayer` 的状态和正在播放的 `AVPlayerItem` 的状态，这对于处理那些不在你直接控制下的 `state` 是很有用的，比如：\n\n- 如果用户使用多任务处理切换到另一个应用程序，播放器的 `rate` 属性将下降到 0.0。\n- 当播放远程媒体资源（比如网络视频）时，监测 `AVPlayerItem` 的 `loadedTimeRanges` 和 `seekableTimeRanges` 可以知道可以播放和 `seek` 的资源时长。\n- 当播放 `HTTP Live Stream` 时，播放器的 `currentItem` 可能发生变化。\n- 当播放 `HTTP Live Stream` 时，`AVPlayerItem` 的 `tracks` 可能发生变化。这种情况可能发生在播放流切换了编码。\n- 当播放失败时，`AVPlayer` 或 `AVPlayerItem` 的 `status` 可能发生变化。\n\n#### 响应 status 属性的变化\n\n通过 `KVO` 监测 `AVPlayer` 和正在播放的 `AVPlayerItem` 的 `status` 属性，可以获得对应的通知，比如当播放出现错误时，你可能会收到 `AVPlayerStatusFailed` 或 `AVPlayerItemStatusFailed` 通知，这时你就可以做相应的处理。\n\n需要注意的是，由于 `AVFoundation` 不会指定在哪个线程发送通知，所以如果你需要在收到通知后更新用户界面的话，你需要切到主线程。\n\n```objectivec\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == <#Player status context#>) {\n        AVPlayer *thePlayer = (AVPlayer *) object;\n        if ([thePlayer status] == AVPlayerStatusFailed) {\n            NSError *error = [<#The AVPlayer object#> error];\n            // Respond to error: for example, display an alert sheet.\n            return;\n        }\n        // Deal with other status change if appropriate.\n    }\n    // Deal with other change notifications if appropriate.\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n```\n\n#### 跟踪视觉内容就绪状态\n\n我们可以监测 `AVPlayerLayer` 实例的 `readyForDisplay` 属性来获得播放器已经可以开始渲染视觉内容的通知。\n\n基于这个能力，我们就能实现在播放器的视觉内容就绪时才将 `player layer` 插入到 `layer` 树中去展示给用户。\n\n#### 追踪播放时间变化\n\n我们可以使用 `AVPlayer` 的 `addPeriodicTimeObserverForInterval:queue:usingBlock:` 和 `addBoundaryTimeObserverForTimes:queue:usingBlock:` 这两个接口来追踪当前播放位置的变化，这样我们就可以在用户界面上做出更新，反馈给用户当前的播放时间和剩余的播放时间等等。\n\n- `addPeriodicTimeObserverForInterval:queue:usingBlock:`，这个接口将会在播放时间发生变化时在回调 block 中通知我们当前播放时间。\n- `addBoundaryTimeObserverForTimes:queue:usingBlock:`，这个接口允许我们传入一组时间（CMTime 数组）当播放器播到这些时间时会在回调 `block` 中通知我们。\n这两个接口都会返回一个 `observer` 角色的对象给我们，我们需要在监测时间的这个过程中强引用这个对象，同时在不需要使用它时调用 r`emoveTimeObserver:` 接口来移除它。\n\n此外，AVFoundation 也不保证在每次时间变化或设置时间到达时都回调 block 来通知你。比如当上一次回调 block 还没完成的情况时，又到了此次回调 block 的时机，AVFoundation 这次就不会调用 block。所以我们需要确保不要在 block 回调里做开销太大、耗时太长的任务。\n\n```objectivec\n// Assume a property: @property (strong) id playerObserver;\n\nFloat64 durationSeconds = CMTimeGetSeconds([<#An asset#> duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);\nNSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird]];\n\nself.playerObserver = [<#A player#> addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{\n\n    NSString *timeDescription = (NSString *)\n        CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime]));\n    NSLog(@\"Passed a boundary at %@\", timeDescription);\n}];\n```\n\n#### 播放结束\n监听 `AVPlayerItemDidPlayToEndTimeNotification` 这个通知即可。上文有提到，这里不再重复。\n\n#### 一个完整示例\n\n这里的示例将展示如果使用 `AVPlayer` 来播放一个视频文件，主要包括下面几个步骤：\n\n- 配置一个使用 `AVPlayerLayer layer` 的 `UIView`。\n- 创建一个 `AVPlayer` 实例。\n- 基于文件类型的 `asset` 创建一个 `AVPlayerItem` 实例，并用 `KVO` 监测其 `status` 属性。\n- 响应 `AVPlayerItem` 实例可以播放的通知，显示出一个按钮。\n- 播放 `AVPlayerItem` 并播放完成后将其播放位置调整到开始位置。\n首先是 `PlayerView`：\n\n```objectivec\n#import <UIKit/UIKit.h>\n#import <AVFoundation/AVFoundation.h>\n\n@interface PlayerView : UIView\n@property (nonatomic) AVPlayer *player;\n@end\n\n@implementation PlayerView\n+ (Class)layerClass {\n    return [AVPlayerLayer class];\n}\n- (AVPlayer*)player {\n    return [(AVPlayerLayer *)[self layer] player];\n}\n- (void)setPlayer:(AVPlayer *)player {\n    [(AVPlayerLayer *)[self layer] setPlayer:player];\n}\n@end\n```\n\n一个简单的 `PlayerViewController`：\n\n```objectivec\n@class PlayerView;\n@interface PlayerViewController : UIViewController\n\n@property (nonatomic) AVPlayer *player;\n@property (nonatomic) AVPlayerItem *playerItem;\n@property (nonatomic, weak) IBOutlet PlayerView *playerView;\n@property (nonatomic, weak) IBOutlet UIButton *playButton;\n- (IBAction)loadAssetFromFile:sender;\n- (IBAction)play:sender;\n- (void)syncUI;\n@end\n```\n同步 `UI` 的方法：\n\n```objectivec\n- (void)syncUI {\n    if ((self.player.currentItem != nil) &&\n        ([self.player.currentItem status] == AVPlayerItemStatusReadyToPlay)) {\n        self.playButton.enabled = YES;\n    }\n    else {\n        self.playButton.enabled = NO;\n    }\n}\n```\n\n在 `viewDidLoad` 时先调用一下 `syncUI`：\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self syncUI];\n}\n```\n\n创建并加载 `AVURLAsset`，在加载成功时，创建 `item`、初始化播放器以及添加各种监听：\n\n```objectivec\nstatic const NSString *ItemStatusContext;\n\n- (IBAction)loadAssetFromFile:sender {\n\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:<#@\"VideoFileName\"#> withExtension:<#@\"extension\"#>];\n\n    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];\n    NSString *tracksKey = @\"tracks\";\n\n    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler: ^{\n        // The completion block goes here.\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSError *error;\n            AVKeyValueStatus status = [asset statusOfValueForKey:tracksKey error:&error];\n\n            if (status == AVKeyValueStatusLoaded) {\n                self.playerItem = [AVPlayerItem playerItemWithAsset:asset];\n                 // ensure that this is done before the playerItem is associated with the player\n                [self.playerItem addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionInitial context:&ItemStatusContext];\n                [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerItemDidReachEnd:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.playerItem];\n                self.player = [AVPlayer playerWithPlayerItem:self.playerItem];\n                [self.playerView setPlayer:self.player];\n            } else {\n                // You should deal with the error appropriately.\n                NSLog(@\"The asset's tracks were not loaded:\\n%@\", [error localizedDescription]);\n            }\n        });\n    }];\n}\n```\n\n响应 `status` 的监听通知：\n\n```objectivec\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == &ItemStatusContext) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self syncUI];\n        });\n        return;\n    }\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n```\n\n播放，以及播放完成时的处理：\n\n\n```objectivec\n- (IBAction)play:sender {\n    [self.player play];\n}\n\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [self.player seekToTime:kCMTimeZero];\n}\n```\n\n\n","slug":"AVAudioFoundation-2-：音视频播放","published":1,"updated":"2017-06-28T14:59:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tva000bznuzf5spa7lu","content":"<p>要播放  <code>AVAsset</code> 可以使用 <code>AVPlayer</code>。在播放期间，可以使用一个 <code>AVPlayerItem</code> 实例来管理 <code>asset</code> 的整体的播放状态，使用 <code>AVPlayerItemTrack</code> 来管理各个 <code>track</code> 的播放状态。对于视频的渲染，使用 <code>AVPlayerLayer</code> 来处理。</p>\n<h4 id=\"播放-Asset\"><a href=\"#播放-Asset\" class=\"headerlink\" title=\"播放 Asset\"></a>播放 Asset</h4><p><code>AVPlayer</code> 是一个控制 <code>asset</code> 播放的控制器，它的功能包括：开始播放、停止播放、<code>seek</code> 等等。你可以使用 <code>AVPlayer</code> 来播放单个 <code>asset</code>。如果你想播放一组 <code>asset</code>，你可以使用 <code>AVQueuePlayer</code>，<code>AVQueuePlayer</code> 是 <code>AVPlayer</code> 的子类。</p>\n<p><code>AVPlayer</code> 也会提供当前的播放状态，这样我们就可以根据当前的播放状态调整交互。我们需要将 <code>AVPlayer</code> 的画面输出到一个特定的 <code>Core Animation Layer</code> 上，通常是一个 <code>AVPlayerLayer</code> 或 <code>AVSynchronizedLayer</code> 实例。</p>\n<p>需要注意的是，你可以从一个 <code>AVPlayer</code> 实例创建多个 <code>AVPlayerLayer</code> 对象，但是只有最新创建的那个才会渲染画面到屏幕。</p>\n<p>对于 <code>AVPlayer</code> 来说，虽然最终播放的是 <code>asset</code>，但是我们并不直接提供一个 <code>AVAsset</code> 给它，而是提供一个 <code>AVPlayerItem</code> 实例。<code>AVPlayerItem</code> 是用来管理与之关联的 <code>asset</code> 的播放状态的，一个 <code>AVPlayerItem</code> 包含了一组 <code>AVPlayerItemTrack</code> 实例，对应着 <code>asset</code> 中的音视频轨道。它们直接的关系大致如下图所示：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE1.png\" alt=\"图一\"></p>\n<p>注意：该图的原图是苹果官方文档上的，但是原图是有错的，把 <code>AVPlayerItemTrack</code> 所属的框标成了 <code>AVAsset</code>，这里做了修正。</p>\n<p>这种实现方式就意味着，我们可以用多个播放器同时播放一个 <code>asset</code>，并且各个播放器可以使用不同的模式来渲染。下图就展示了一种用两个不同的 <code>AVPlayer</code> 采用不同的设置播放同一个 <code>AVAsset</code> 的场景。在播放中，还可以禁掉某些 <code>track</code> 的播放。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE2.png\" alt=\"图二\"><br>我们可以通过网络来加载 <code>asset</code>，通常简单的初始化 <code>AVPlayerItem</code> 后并不意味着它就直接能播放，所以我们可以 <code>KVO AVPlayerItem</code> 的 <code>status</code> 属性来监听它是否已经可播再决定后续的行为。</p>\n<h4 id=\"处理不同类型的-Asset\"><a href=\"#处理不同类型的-Asset\" class=\"headerlink\" title=\"处理不同类型的 Asset\"></a>处理不同类型的 Asset</h4><p>我们配置 <code>asset</code> 来播放的方式多多少少会依赖 <code>asset</code> 的类型，一般我们有两种不同类型的 <code>asset</code>：</p>\n<ul>\n<li>1）基于文件的 asset，一般可以来源于本地视频文件、相册资源库等等。</li>\n<li>2）流式 <code>asset</code>，比如 <code>HLS</code> 格式的视频。</li>\n</ul>\n<p>加载基于文件的 <code>asset</code> 一般分为如下几步：</p>\n<ul>\n<li>基于文件路径的 <code>URL</code> 创建 <code>AVURLAsset</code> 实例。</li>\n<li>基于 <code>AVURLAsset</code> 实例创建 <code>AVPlayerItem</code> 实例。</li>\n<li>将 <code>AVPlayerItem</code> 实例与一个 <code>AVPlayer</code> 实例关联。</li>\n<li><code>KVO</code> 监测 <code>AVPlayerItem</code> 的 <code>status</code> 属性来等待其已经可播，即加载完成。</li>\n</ul>\n<p>创建并加载一个 <code>HTTP Live Stream</code>（HLS）格式的资源来播放时，可以按照下面几步来做：</p>\n<ul>\n<li>基于资源的 <code>URL</code> 初始化一个 <code>AVPlayerItem</code> 实例，因为你无法直接创建一个 <code>AVAsset</code> 来表示 <code>HLS</code> 资源。</li>\n<li>当你将 <code>AVPlayerItem</code> 和 <code>AVPlayer</code> 实例关联起来后，他就开始为播放做准备，当一切就绪时 <code>AVPlayerItem</code> 会创建出  <code>AVAsset</code> 和 <code>AVAssetTrack</code> 实例以用来对接 <code>HLS</code> 视频流的音视频内容。</li>\n<li>要获取视频流的时长，你需要 <code>KVO</code> 监测 <code>AVPlayerItem</code> 的 <code>duration</code> 属性，当资源可以播放时，它会被更新为正确的值。</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSURL URLWithString<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span>\"<span class=\"token operator\">&lt;</span>#Live stream URL#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8>.</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerItem <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVPlayerItem playerItemWithURL<span class=\"token punctuation\">:</span>url<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>playerItem addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> forKeyPath<span class=\"token punctuation\">:</span><span class=\"token string\">@\"status\"</span> options<span class=\"token punctuation\">:</span><span class=\"token number\">0</span> context<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>ItemStatusContext<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVPlayer playerWithPlayerItem<span class=\"token punctuation\">:</span>playerItem<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当你不知道一个 <code>URL</code> 对应的是什么类型的 <code>asset</code> 时，你可以这样做：</p>\n<ul>\n<li>尝试基于 <code>URL</code> 来初始化一个 <code>AVURLAsset</code>，并加载它的 <code>tracks</code> 属性。如果 <code>tracks</code> 属性加载成功，就基于 <code>asset</code> 来创建一个 <code>AVPlayerItem</code> 实例。</li>\n<li>如果 <code>tracks</code> 属性加载失败，那么就直接基于 <code>URL</code> 创建一个 <code>AVPlayerItem</code> 实例，并 <code>KVO</code> 监测 <code>AVPlayer</code> 的 <code>status</code> 属性来看它何时可以播放。</li>\n<li>如果上述尝试都失败，那就清理掉 <code>AVPlayerItem</code>。</li>\n</ul>\n<h4 id=\"播放一个-AVPlayerItem\"><a href=\"#播放一个-AVPlayerItem\" class=\"headerlink\" title=\"播放一个 AVPlayerItem\"></a>播放一个 AVPlayerItem</h4><p>调用 <code>AVPlayer</code> 的 <code>play</code> 接口即可开始播放。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>IBAction<span class=\"token punctuation\">)</span>play<span class=\"token punctuation\">:</span>sender <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>player play<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>除了简单的播放，还可以通过设置 rate 属性设置播放速率。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">player<span class=\"token punctuation\">.</span>rate <span class=\"token operator\">=</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span>\nplayer<span class=\"token punctuation\">.</span>rate <span class=\"token operator\">=</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>播放速率设置为 1.0 表示正常播放，设置为 0.0 表示暂停（等同调用 pause 效果）。</p>\n<p>除了正向播放，有的音视频还能支持倒播，不过需要需要检查几个属性：</p>\n<ul>\n<li><code>canPlayReverse</code>：支持设置播放速率为 -1.0。</li>\n<li><code>canPlaySlowReverse</code>：支持设置播放速率为 -1.0 到 0.0。</li>\n<li><code>canPlayFastReverse</code>：支持设置播放速率为小于 -1.0 的值。<br>可以通过 <code>seekToTime</code>: 接口来调整播放位置。但是这个接口主要是为性能考虑，不保证精确。</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTime fiveSecondsIn <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>player seekToTime<span class=\"token punctuation\">:</span>fiveSecondsIn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果要精确调整，可以用 <code>seekToTime:toleranceBefore:toleranceAfter:</code> 接口。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTime fiveSecondsIn <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>player seekToTime<span class=\"token punctuation\">:</span>fiveSecondsIn toleranceBefore<span class=\"token punctuation\">:</span>kCMTimeZero toleranceAfter<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>需要注意的是，设置 <code>tolerance</code> 为 <code>zero</code> 会耗费较大的计算性能，所以一般只在编写复杂的音视频编辑功能是这样设置。</p>\n<p>我们可以通过监听 <code>AVPlayerItemDidPlayToEndTimeNotification</code> 来获得播放结束事件，在播放结束后可以用 <code>seekToTime:</code> 调整播放位置到 <code>zero</code>，否则调用 <code>play</code> 会无效。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Register with the notification center after creating the player item.</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSNotificationCenter defaultCenter<span class=\"token punctuation\">]</span> \n    addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> \n       selector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>playerItemDidReachEnd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span>\n           name<span class=\"token punctuation\">:</span>AVPlayerItemDidPlayToEndTimeNotification\n         object<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#The player item#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>playerItemDidReachEnd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSNotification <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>notification <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>player seekToTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>此外，我们还能设置播放器的 <code>actionAtItemEnd</code> 属性来设置其在播放结束后的行为，比如 <code>AVPlayerActionAtItemEndPause</code> 表示播放结束后会暂停。</p>\n<h4 id=\"播放多个-AVPlayerItem\"><a href=\"#播放多个-AVPlayerItem\" class=\"headerlink\" title=\"播放多个 AVPlayerItem\"></a>播放多个 AVPlayerItem</h4><p>我们可以用 <code>AVQueuePlayer</code> 来顺序播放多个 <code>AVPlayerItem</code>。<code>AVQueuePlayer</code> 是 <code>AVPlayer</code> 的子类。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>items <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An array of player items#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVQueuePlayer <span class=\"token operator\">*</span>queuePlayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVQueuePlayer alloc<span class=\"token punctuation\">]</span> initWithItems<span class=\"token punctuation\">:</span>items<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>通过调用 <code>play</code> 即可顺序播放，也可以调用 <code>advanceToNextItem</code> 跳到下个 <code>item</code>。除此之外，我们还可以用 <code>insertItem:afterItem:</code>、<code>removeItem:</code>、<code>removeAllItems</code> 来控制播放资源。</p>\n<p>当插入一个 <code>item</code> 的时候，可以需要用 <code>canInsertItem:afterItem:</code> 检查下是否可以插入， 对 <code>afterItem</code> 传入 <code>nil</code>，则检查是否可以插入到队尾。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVPlayerItem <span class=\"token operator\">*</span>anItem <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#Get a player item#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>queuePlayer canInsertItem<span class=\"token punctuation\">:</span>anItem afterItem<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>queuePlayer insertItem<span class=\"token punctuation\">:</span>anItem afterItem<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"监测播放状态\"><a href=\"#监测播放状态\" class=\"headerlink\" title=\"监测播放状态\"></a>监测播放状态</h4><p>我们可以监测一些 <code>AVPlayer</code> 的状态和正在播放的 <code>AVPlayerItem</code> 的状态，这对于处理那些不在你直接控制下的 <code>state</code> 是很有用的，比如：</p>\n<ul>\n<li>如果用户使用多任务处理切换到另一个应用程序，播放器的 <code>rate</code> 属性将下降到 0.0。</li>\n<li>当播放远程媒体资源（比如网络视频）时，监测 <code>AVPlayerItem</code> 的 <code>loadedTimeRanges</code> 和 <code>seekableTimeRanges</code> 可以知道可以播放和 <code>seek</code> 的资源时长。</li>\n<li>当播放 <code>HTTP Live Stream</code> 时，播放器的 <code>currentItem</code> 可能发生变化。</li>\n<li>当播放 <code>HTTP Live Stream</code> 时，<code>AVPlayerItem</code> 的 <code>tracks</code> 可能发生变化。这种情况可能发生在播放流切换了编码。</li>\n<li>当播放失败时，<code>AVPlayer</code> 或 <code>AVPlayerItem</code> 的 <code>status</code> 可能发生变化。</li>\n</ul>\n<h4 id=\"响应-status-属性的变化\"><a href=\"#响应-status-属性的变化\" class=\"headerlink\" title=\"响应 status 属性的变化\"></a>响应 status 属性的变化</h4><p>通过 <code>KVO</code> 监测 <code>AVPlayer</code> 和正在播放的 <code>AVPlayerItem</code> 的 <code>status</code> 属性，可以获得对应的通知，比如当播放出现错误时，你可能会收到 <code>AVPlayerStatusFailed</code> 或 <code>AVPlayerItemStatusFailed</code> 通知，这时你就可以做相应的处理。</p>\n<p>需要注意的是，由于 <code>AVFoundation</code> 不会指定在哪个线程发送通知，所以如果你需要在收到通知后更新用户界面的话，你需要切到主线程。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>observeValueForKeyPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>keyPath ofObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>object change<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>change context<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>context <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token operator\">==</span> <span class=\"token operator\">&lt;</span>#Player status context#<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        AVPlayer <span class=\"token operator\">*</span>thePlayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>AVPlayer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> object<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>thePlayer status<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> AVPlayerStatusFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSError <span class=\"token operator\">*</span>error <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>#The AVPlayer object#<span class=\"token operator\">></span> error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Respond to error: for example, display an alert sheet.</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Deal with other status change if appropriate.</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Deal with other change notifications if appropriate.</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> observeValueForKeyPath<span class=\"token punctuation\">:</span>keyPath ofObject<span class=\"token punctuation\">:</span>object change<span class=\"token punctuation\">:</span>change context<span class=\"token punctuation\">:</span>context<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"跟踪视觉内容就绪状态\"><a href=\"#跟踪视觉内容就绪状态\" class=\"headerlink\" title=\"跟踪视觉内容就绪状态\"></a>跟踪视觉内容就绪状态</h4><p>我们可以监测 <code>AVPlayerLayer</code> 实例的 <code>readyForDisplay</code> 属性来获得播放器已经可以开始渲染视觉内容的通知。</p>\n<p>基于这个能力，我们就能实现在播放器的视觉内容就绪时才将 <code>player layer</code> 插入到 <code>layer</code> 树中去展示给用户。</p>\n<h4 id=\"追踪播放时间变化\"><a href=\"#追踪播放时间变化\" class=\"headerlink\" title=\"追踪播放时间变化\"></a>追踪播放时间变化</h4><p>我们可以使用 <code>AVPlayer</code> 的 <code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code> 和 <code>addBoundaryTimeObserverForTimes:queue:usingBlock:</code> 这两个接口来追踪当前播放位置的变化，这样我们就可以在用户界面上做出更新，反馈给用户当前的播放时间和剩余的播放时间等等。</p>\n<ul>\n<li><code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code>，这个接口将会在播放时间发生变化时在回调 block 中通知我们当前播放时间。</li>\n<li><code>addBoundaryTimeObserverForTimes:queue:usingBlock:</code>，这个接口允许我们传入一组时间（CMTime 数组）当播放器播到这些时间时会在回调 <code>block</code> 中通知我们。<br>这两个接口都会返回一个 <code>observer</code> 角色的对象给我们，我们需要在监测时间的这个过程中强引用这个对象，同时在不需要使用它时调用 r<code>emoveTimeObserver:</code> 接口来移除它。</li>\n</ul>\n<p>此外，AVFoundation 也不保证在每次时间变化或设置时间到达时都回调 block 来通知你。比如当上一次回调 block 还没完成的情况时，又到了此次回调 block 的时机，AVFoundation 这次就不会调用 block。所以我们需要确保不要在 block 回调里做开销太大、耗时太长的任务。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Assume a property: @property (strong) id playerObserver;</span>\n\nFloat64 durationSeconds <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeGetSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>#An asset#<span class=\"token operator\">></span> duration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime firstThird <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token operator\">/</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCMTime secondThird <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMakeWithSeconds</span><span class=\"token punctuation\">(</span>durationSeconds<span class=\"token operator\">*</span><span class=\"token number\">2.0</span><span class=\"token operator\">/</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>times <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>firstThird<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSValue valueWithCMTime<span class=\"token punctuation\">:</span>secondThird<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerObserver <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>#A player#<span class=\"token operator\">></span> addBoundaryTimeObserverForTimes<span class=\"token punctuation\">:</span>times queue<span class=\"token punctuation\">:</span><span class=\"token constant\">NULL</span> usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n\n    NSString <span class=\"token operator\">*</span>timeDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">CFBridgingRelease</span><span class=\"token punctuation\">(</span><span class=\"token function\">CMTimeCopyDescription</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player currentTime<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Passed a boundary at %@\"</span><span class=\"token punctuation\">,</span> timeDescription<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"播放结束\"><a href=\"#播放结束\" class=\"headerlink\" title=\"播放结束\"></a>播放结束</h4><p>监听 <code>AVPlayerItemDidPlayToEndTimeNotification</code> 这个通知即可。上文有提到，这里不再重复。</p>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>这里的示例将展示如果使用 <code>AVPlayer</code> 来播放一个视频文件，主要包括下面几个步骤：</p>\n<ul>\n<li>配置一个使用 <code>AVPlayerLayer layer</code> 的 <code>UIView</code>。</li>\n<li>创建一个 <code>AVPlayer</code> 实例。</li>\n<li>基于文件类型的 <code>asset</code> 创建一个 <code>AVPlayerItem</code> 实例，并用 <code>KVO</code> 监测其 <code>status</code> 属性。</li>\n<li>响应 <code>AVPlayerItem</code> 实例可以播放的通知，显示出一个按钮。</li>\n<li>播放 <code>AVPlayerItem</code> 并播放完成后将其播放位置调整到开始位置。<br>首先是 <code>PlayerView</code>：</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;UIKit/UIKit.h></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;AVFoundation/AVFoundation.h></span>\n\n<span class=\"token keyword\">@interface</span> PlayerView <span class=\"token punctuation\">:</span> UIView\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">)</span> AVPlayer <span class=\"token operator\">*</span>player<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> PlayerView\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>Class<span class=\"token punctuation\">)</span>layerClass <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>AVPlayerLayer class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>AVPlayer<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>player <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>AVPlayerLayer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> layer<span class=\"token punctuation\">]</span> player<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setPlayer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>AVPlayer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>player <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>AVPlayerLayer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> layer<span class=\"token punctuation\">]</span> setPlayer<span class=\"token punctuation\">:</span>player<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>一个简单的 <code>PlayerViewController</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@class</span> PlayerView<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@interface</span> PlayerViewController <span class=\"token punctuation\">:</span> UIViewController\n\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">)</span> AVPlayer <span class=\"token operator\">*</span>player<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">)</span> AVPlayerItem <span class=\"token operator\">*</span>playerItem<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> weak<span class=\"token punctuation\">)</span> IBOutlet PlayerView <span class=\"token operator\">*</span>playerView<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> weak<span class=\"token punctuation\">)</span> IBOutlet UIButton <span class=\"token operator\">*</span>playButton<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>IBAction<span class=\"token punctuation\">)</span>loadAssetFromFile<span class=\"token punctuation\">:</span>sender<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>IBAction<span class=\"token punctuation\">)</span>play<span class=\"token punctuation\">:</span>sender<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>syncUI<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>同步 <code>UI</code> 的方法：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>syncUI <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player<span class=\"token punctuation\">.</span>currentItem <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player<span class=\"token punctuation\">.</span>currentItem status<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> AVPlayerItemStatusReadyToPlay<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playButton<span class=\"token punctuation\">.</span>enabled <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playButton<span class=\"token punctuation\">.</span>enabled <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 <code>viewDidLoad</code> 时先调用一下 <code>syncUI</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLoad<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> syncUI<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>创建并加载 <code>AVURLAsset</code>，在加载成功时，创建 <code>item</code>、初始化播放器以及添加各种监听：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> NSString <span class=\"token operator\">*</span>ItemStatusContext<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>IBAction<span class=\"token punctuation\">)</span>loadAssetFromFile<span class=\"token punctuation\">:</span>sender <span class=\"token punctuation\">{</span>\n\n    NSURL <span class=\"token operator\">*</span>fileURL <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> URLForResource<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token string\">@\"VideoFileName\"</span>#<span class=\"token operator\">></span> withExtension<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token string\">@\"extension\"</span>#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    AVURLAsset <span class=\"token operator\">*</span>asset <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVURLAsset URLAssetWithURL<span class=\"token punctuation\">:</span>fileURL options<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>tracksKey <span class=\"token operator\">=</span> <span class=\"token string\">@\"tracks\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">[</span>asset loadValuesAsynchronouslyForKeys<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">[</span>tracksKey<span class=\"token punctuation\">]</span> completionHandler<span class=\"token punctuation\">:</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// The completion block goes here.</span>\n        <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n            NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\n            AVKeyValueStatus status <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>asset statusOfValueForKey<span class=\"token punctuation\">:</span>tracksKey error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">==</span> AVKeyValueStatusLoaded<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerItem <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVPlayerItem playerItemWithAsset<span class=\"token punctuation\">:</span>asset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// ensure that this is done before the playerItem is associated with the player</span>\n                <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerItem addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> forKeyPath<span class=\"token punctuation\">:</span><span class=\"token string\">@\"status\"</span> options<span class=\"token punctuation\">:</span>NSKeyValueObservingOptionInitial context<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>ItemStatusContext<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSNotificationCenter defaultCenter<span class=\"token punctuation\">]</span> addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> selector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>playerItemDidReachEnd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span> name<span class=\"token punctuation\">:</span>AVPlayerItemDidPlayToEndTimeNotification object<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerItem<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVPlayer playerWithPlayerItem<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerItem<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>playerView setPlayer<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// You should deal with the error appropriately.</span>\n                <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"The asset's tracks were not loaded:\\n%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>error localizedDescription<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>响应 <code>status</code> 的监听通知：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>observeValueForKeyPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>keyPath ofObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>object change<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>change context<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>context <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token operator\">==</span> <span class=\"token operator\">&amp;</span>ItemStatusContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> syncUI<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> observeValueForKeyPath<span class=\"token punctuation\">:</span>keyPath ofObject<span class=\"token punctuation\">:</span>object change<span class=\"token punctuation\">:</span>change context<span class=\"token punctuation\">:</span>context<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>播放，以及播放完成时的处理：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>IBAction<span class=\"token punctuation\">)</span>play<span class=\"token punctuation\">:</span>sender <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player play<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>playerItemDidReachEnd<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSNotification <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>notification <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>player seekToTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>要播放  <code>AVAsset</code> 可以使用 <code>AVPlayer</code>。在播放期间，可以使用一个 <code>AVPlayerItem</code> 实例来管理 <code>asset</code> 的整体的播放状态，使用 <code>AVPlayerItemTrack</code> 来管理各个 <code>track</code> 的播放状态。对于视频的渲染，使用 <code>AVPlayerLayer</code> 来处理。</p>\n<h4 id=\"播放-Asset\"><a href=\"#播放-Asset\" class=\"headerlink\" title=\"播放 Asset\"></a>播放 Asset</h4><p><code>AVPlayer</code> 是一个控制 <code>asset</code> 播放的控制器，它的功能包括：开始播放、停止播放、<code>seek</code> 等等。你可以使用 <code>AVPlayer</code> 来播放单个 <code>asset</code>。如果你想播放一组 <code>asset</code>，你可以使用 <code>AVQueuePlayer</code>，<code>AVQueuePlayer</code> 是 <code>AVPlayer</code> 的子类。</p>\n<p><code>AVPlayer</code> 也会提供当前的播放状态，这样我们就可以根据当前的播放状态调整交互。我们需要将 <code>AVPlayer</code> 的画面输出到一个特定的 <code>Core Animation Layer</code> 上，通常是一个 <code>AVPlayerLayer</code> 或 <code>AVSynchronizedLayer</code> 实例。</p>\n<p>需要注意的是，你可以从一个 <code>AVPlayer</code> 实例创建多个 <code>AVPlayerLayer</code> 对象，但是只有最新创建的那个才会渲染画面到屏幕。</p>\n<p>对于 <code>AVPlayer</code> 来说，虽然最终播放的是 <code>asset</code>，但是我们并不直接提供一个 <code>AVAsset</code> 给它，而是提供一个 <code>AVPlayerItem</code> 实例。<code>AVPlayerItem</code> 是用来管理与之关联的 <code>asset</code> 的播放状态的，一个 <code>AVPlayerItem</code> 包含了一组 <code>AVPlayerItemTrack</code> 实例，对应着 <code>asset</code> 中的音视频轨道。它们直接的关系大致如下图所示：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE1.png\" alt=\"图一\"></p>\n<p>注意：该图的原图是苹果官方文档上的，但是原图是有错的，把 <code>AVPlayerItemTrack</code> 所属的框标成了 <code>AVAsset</code>，这里做了修正。</p>\n<p>这种实现方式就意味着，我们可以用多个播放器同时播放一个 <code>asset</code>，并且各个播放器可以使用不同的模式来渲染。下图就展示了一种用两个不同的 <code>AVPlayer</code> 采用不同的设置播放同一个 <code>AVAsset</code> 的场景。在播放中，还可以禁掉某些 <code>track</code> 的播放。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE2.png\" alt=\"图二\"><br>我们可以通过网络来加载 <code>asset</code>，通常简单的初始化 <code>AVPlayerItem</code> 后并不意味着它就直接能播放，所以我们可以 <code>KVO AVPlayerItem</code> 的 <code>status</code> 属性来监听它是否已经可播再决定后续的行为。</p>\n<h4 id=\"处理不同类型的-Asset\"><a href=\"#处理不同类型的-Asset\" class=\"headerlink\" title=\"处理不同类型的 Asset\"></a>处理不同类型的 Asset</h4><p>我们配置 <code>asset</code> 来播放的方式多多少少会依赖 <code>asset</code> 的类型，一般我们有两种不同类型的 <code>asset</code>：</p>\n<ul>\n<li>1）基于文件的 asset，一般可以来源于本地视频文件、相册资源库等等。</li>\n<li>2）流式 <code>asset</code>，比如 <code>HLS</code> 格式的视频。</li>\n</ul>\n<p>加载基于文件的 <code>asset</code> 一般分为如下几步：</p>\n<ul>\n<li>基于文件路径的 <code>URL</code> 创建 <code>AVURLAsset</code> 实例。</li>\n<li>基于 <code>AVURLAsset</code> 实例创建 <code>AVPlayerItem</code> 实例。</li>\n<li>将 <code>AVPlayerItem</code> 实例与一个 <code>AVPlayer</code> 实例关联。</li>\n<li><code>KVO</code> 监测 <code>AVPlayerItem</code> 的 <code>status</code> 属性来等待其已经可播，即加载完成。</li>\n</ul>\n<p>创建并加载一个 <code>HTTP Live Stream</code>（HLS）格式的资源来播放时，可以按照下面几步来做：</p>\n<ul>\n<li>基于资源的 <code>URL</code> 初始化一个 <code>AVPlayerItem</code> 实例，因为你无法直接创建一个 <code>AVAsset</code> 来表示 <code>HLS</code> 资源。</li>\n<li>当你将 <code>AVPlayerItem</code> 和 <code>AVPlayer</code> 实例关联起来后，他就开始为播放做准备，当一切就绪时 <code>AVPlayerItem</code> 会创建出  <code>AVAsset</code> 和 <code>AVAssetTrack</code> 实例以用来对接 <code>HLS</code> 视频流的音视频内容。</li>\n<li>要获取视频流的时长，你需要 <code>KVO</code> 监测 <code>AVPlayerItem</code> 的 <code>duration</code> 属性，当资源可以播放时，它会被更新为正确的值。</li>\n</ul>\n<pre><code class=\"objectivec\">NSURL *url = [NSURL URLWithString:@&quot;&lt;#Live stream URL#&gt;];\n// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.\nself.playerItem = [AVPlayerItem playerItemWithURL:url];\n[playerItem addObserver:self forKeyPath:@&quot;status&quot; options:0 context:&amp;ItemStatusContext];\nself.player = [AVPlayer playerWithPlayerItem:playerItem];\n</code></pre>\n<p>当你不知道一个 <code>URL</code> 对应的是什么类型的 <code>asset</code> 时，你可以这样做：</p>\n<ul>\n<li>尝试基于 <code>URL</code> 来初始化一个 <code>AVURLAsset</code>，并加载它的 <code>tracks</code> 属性。如果 <code>tracks</code> 属性加载成功，就基于 <code>asset</code> 来创建一个 <code>AVPlayerItem</code> 实例。</li>\n<li>如果 <code>tracks</code> 属性加载失败，那么就直接基于 <code>URL</code> 创建一个 <code>AVPlayerItem</code> 实例，并 <code>KVO</code> 监测 <code>AVPlayer</code> 的 <code>status</code> 属性来看它何时可以播放。</li>\n<li>如果上述尝试都失败，那就清理掉 <code>AVPlayerItem</code>。</li>\n</ul>\n<h4 id=\"播放一个-AVPlayerItem\"><a href=\"#播放一个-AVPlayerItem\" class=\"headerlink\" title=\"播放一个 AVPlayerItem\"></a>播放一个 AVPlayerItem</h4><p>调用 <code>AVPlayer</code> 的 <code>play</code> 接口即可开始播放。</p>\n<pre><code class=\"objectivec\">- (IBAction)play:sender {\n    [player play];\n}\n</code></pre>\n<p>除了简单的播放，还可以通过设置 rate 属性设置播放速率。</p>\n<pre><code class=\"objectivec\">player.rate = 0.5;\nplayer.rate = 2.0;\n</code></pre>\n<p>播放速率设置为 1.0 表示正常播放，设置为 0.0 表示暂停（等同调用 pause 效果）。</p>\n<p>除了正向播放，有的音视频还能支持倒播，不过需要需要检查几个属性：</p>\n<ul>\n<li><code>canPlayReverse</code>：支持设置播放速率为 -1.0。</li>\n<li><code>canPlaySlowReverse</code>：支持设置播放速率为 -1.0 到 0.0。</li>\n<li><code>canPlayFastReverse</code>：支持设置播放速率为小于 -1.0 的值。<br>可以通过 <code>seekToTime</code>: 接口来调整播放位置。但是这个接口主要是为性能考虑，不保证精确。</li>\n</ul>\n<pre><code class=\"objectivec\">CMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn];\n</code></pre>\n<p>如果要精确调整，可以用 <code>seekToTime:toleranceBefore:toleranceAfter:</code> 接口。</p>\n<pre><code class=\"objectivec\">CMTime fiveSecondsIn = CMTimeMake(5, 1);\n[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];\n</code></pre>\n<p>需要注意的是，设置 <code>tolerance</code> 为 <code>zero</code> 会耗费较大的计算性能，所以一般只在编写复杂的音视频编辑功能是这样设置。</p>\n<p>我们可以通过监听 <code>AVPlayerItemDidPlayToEndTimeNotification</code> 来获得播放结束事件，在播放结束后可以用 <code>seekToTime:</code> 调整播放位置到 <code>zero</code>，否则调用 <code>play</code> 会无效。</p>\n<pre><code class=\"objectivec\">// Register with the notification center after creating the player item.\n[[NSNotificationCenter defaultCenter] \n    addObserver:self \n       selector:@selector(playerItemDidReachEnd:)\n           name:AVPlayerItemDidPlayToEndTimeNotification\n         object:&lt;#The player item#&gt;];\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [player seekToTime:kCMTimeZero];\n}\n</code></pre>\n<p>此外，我们还能设置播放器的 <code>actionAtItemEnd</code> 属性来设置其在播放结束后的行为，比如 <code>AVPlayerActionAtItemEndPause</code> 表示播放结束后会暂停。</p>\n<h4 id=\"播放多个-AVPlayerItem\"><a href=\"#播放多个-AVPlayerItem\" class=\"headerlink\" title=\"播放多个 AVPlayerItem\"></a>播放多个 AVPlayerItem</h4><p>我们可以用 <code>AVQueuePlayer</code> 来顺序播放多个 <code>AVPlayerItem</code>。<code>AVQueuePlayer</code> 是 <code>AVPlayer</code> 的子类。</p>\n<pre><code class=\"objectivec\">NSArray *items = &lt;#An array of player items#&gt;;\nAVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];\n</code></pre>\n<p>通过调用 <code>play</code> 即可顺序播放，也可以调用 <code>advanceToNextItem</code> 跳到下个 <code>item</code>。除此之外，我们还可以用 <code>insertItem:afterItem:</code>、<code>removeItem:</code>、<code>removeAllItems</code> 来控制播放资源。</p>\n<p>当插入一个 <code>item</code> 的时候，可以需要用 <code>canInsertItem:afterItem:</code> 检查下是否可以插入， 对 <code>afterItem</code> 传入 <code>nil</code>，则检查是否可以插入到队尾。</p>\n<pre><code class=\"objectivec\">AVPlayerItem *anItem = &lt;#Get a player item#&gt;;\nif ([queuePlayer canInsertItem:anItem afterItem:nil]) {\n    [queuePlayer insertItem:anItem afterItem:nil];\n}\n</code></pre>\n<h4 id=\"监测播放状态\"><a href=\"#监测播放状态\" class=\"headerlink\" title=\"监测播放状态\"></a>监测播放状态</h4><p>我们可以监测一些 <code>AVPlayer</code> 的状态和正在播放的 <code>AVPlayerItem</code> 的状态，这对于处理那些不在你直接控制下的 <code>state</code> 是很有用的，比如：</p>\n<ul>\n<li>如果用户使用多任务处理切换到另一个应用程序，播放器的 <code>rate</code> 属性将下降到 0.0。</li>\n<li>当播放远程媒体资源（比如网络视频）时，监测 <code>AVPlayerItem</code> 的 <code>loadedTimeRanges</code> 和 <code>seekableTimeRanges</code> 可以知道可以播放和 <code>seek</code> 的资源时长。</li>\n<li>当播放 <code>HTTP Live Stream</code> 时，播放器的 <code>currentItem</code> 可能发生变化。</li>\n<li>当播放 <code>HTTP Live Stream</code> 时，<code>AVPlayerItem</code> 的 <code>tracks</code> 可能发生变化。这种情况可能发生在播放流切换了编码。</li>\n<li>当播放失败时，<code>AVPlayer</code> 或 <code>AVPlayerItem</code> 的 <code>status</code> 可能发生变化。</li>\n</ul>\n<h4 id=\"响应-status-属性的变化\"><a href=\"#响应-status-属性的变化\" class=\"headerlink\" title=\"响应 status 属性的变化\"></a>响应 status 属性的变化</h4><p>通过 <code>KVO</code> 监测 <code>AVPlayer</code> 和正在播放的 <code>AVPlayerItem</code> 的 <code>status</code> 属性，可以获得对应的通知，比如当播放出现错误时，你可能会收到 <code>AVPlayerStatusFailed</code> 或 <code>AVPlayerItemStatusFailed</code> 通知，这时你就可以做相应的处理。</p>\n<p>需要注意的是，由于 <code>AVFoundation</code> 不会指定在哪个线程发送通知，所以如果你需要在收到通知后更新用户界面的话，你需要切到主线程。</p>\n<pre><code class=\"objectivec\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == &lt;#Player status context#&gt;) {\n        AVPlayer *thePlayer = (AVPlayer *) object;\n        if ([thePlayer status] == AVPlayerStatusFailed) {\n            NSError *error = [&lt;#The AVPlayer object#&gt; error];\n            // Respond to error: for example, display an alert sheet.\n            return;\n        }\n        // Deal with other status change if appropriate.\n    }\n    // Deal with other change notifications if appropriate.\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n</code></pre>\n<h4 id=\"跟踪视觉内容就绪状态\"><a href=\"#跟踪视觉内容就绪状态\" class=\"headerlink\" title=\"跟踪视觉内容就绪状态\"></a>跟踪视觉内容就绪状态</h4><p>我们可以监测 <code>AVPlayerLayer</code> 实例的 <code>readyForDisplay</code> 属性来获得播放器已经可以开始渲染视觉内容的通知。</p>\n<p>基于这个能力，我们就能实现在播放器的视觉内容就绪时才将 <code>player layer</code> 插入到 <code>layer</code> 树中去展示给用户。</p>\n<h4 id=\"追踪播放时间变化\"><a href=\"#追踪播放时间变化\" class=\"headerlink\" title=\"追踪播放时间变化\"></a>追踪播放时间变化</h4><p>我们可以使用 <code>AVPlayer</code> 的 <code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code> 和 <code>addBoundaryTimeObserverForTimes:queue:usingBlock:</code> 这两个接口来追踪当前播放位置的变化，这样我们就可以在用户界面上做出更新，反馈给用户当前的播放时间和剩余的播放时间等等。</p>\n<ul>\n<li><code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code>，这个接口将会在播放时间发生变化时在回调 block 中通知我们当前播放时间。</li>\n<li><code>addBoundaryTimeObserverForTimes:queue:usingBlock:</code>，这个接口允许我们传入一组时间（CMTime 数组）当播放器播到这些时间时会在回调 <code>block</code> 中通知我们。<br>这两个接口都会返回一个 <code>observer</code> 角色的对象给我们，我们需要在监测时间的这个过程中强引用这个对象，同时在不需要使用它时调用 r<code>emoveTimeObserver:</code> 接口来移除它。</li>\n</ul>\n<p>此外，AVFoundation 也不保证在每次时间变化或设置时间到达时都回调 block 来通知你。比如当上一次回调 block 还没完成的情况时，又到了此次回调 block 的时机，AVFoundation 这次就不会调用 block。所以我们需要确保不要在 block 回调里做开销太大、耗时太长的任务。</p>\n<pre><code class=\"objectivec\">// Assume a property: @property (strong) id playerObserver;\n\nFloat64 durationSeconds = CMTimeGetSeconds([&lt;#An asset#&gt; duration]);\nCMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);\nCMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);\nNSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird]];\n\nself.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{\n\n    NSString *timeDescription = (NSString *)\n        CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime]));\n    NSLog(@&quot;Passed a boundary at %@&quot;, timeDescription);\n}];\n</code></pre>\n<h4 id=\"播放结束\"><a href=\"#播放结束\" class=\"headerlink\" title=\"播放结束\"></a>播放结束</h4><p>监听 <code>AVPlayerItemDidPlayToEndTimeNotification</code> 这个通知即可。上文有提到，这里不再重复。</p>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>这里的示例将展示如果使用 <code>AVPlayer</code> 来播放一个视频文件，主要包括下面几个步骤：</p>\n<ul>\n<li>配置一个使用 <code>AVPlayerLayer layer</code> 的 <code>UIView</code>。</li>\n<li>创建一个 <code>AVPlayer</code> 实例。</li>\n<li>基于文件类型的 <code>asset</code> 创建一个 <code>AVPlayerItem</code> 实例，并用 <code>KVO</code> 监测其 <code>status</code> 属性。</li>\n<li>响应 <code>AVPlayerItem</code> 实例可以播放的通知，显示出一个按钮。</li>\n<li>播放 <code>AVPlayerItem</code> 并播放完成后将其播放位置调整到开始位置。<br>首先是 <code>PlayerView</code>：</li>\n</ul>\n<pre><code class=\"objectivec\">#import &lt;UIKit/UIKit.h&gt;\n#import &lt;AVFoundation/AVFoundation.h&gt;\n\n@interface PlayerView : UIView\n@property (nonatomic) AVPlayer *player;\n@end\n\n@implementation PlayerView\n+ (Class)layerClass {\n    return [AVPlayerLayer class];\n}\n- (AVPlayer*)player {\n    return [(AVPlayerLayer *)[self layer] player];\n}\n- (void)setPlayer:(AVPlayer *)player {\n    [(AVPlayerLayer *)[self layer] setPlayer:player];\n}\n@end\n</code></pre>\n<p>一个简单的 <code>PlayerViewController</code>：</p>\n<pre><code class=\"objectivec\">@class PlayerView;\n@interface PlayerViewController : UIViewController\n\n@property (nonatomic) AVPlayer *player;\n@property (nonatomic) AVPlayerItem *playerItem;\n@property (nonatomic, weak) IBOutlet PlayerView *playerView;\n@property (nonatomic, weak) IBOutlet UIButton *playButton;\n- (IBAction)loadAssetFromFile:sender;\n- (IBAction)play:sender;\n- (void)syncUI;\n@end\n</code></pre>\n<p>同步 <code>UI</code> 的方法：</p>\n<pre><code class=\"objectivec\">- (void)syncUI {\n    if ((self.player.currentItem != nil) &amp;&amp;\n        ([self.player.currentItem status] == AVPlayerItemStatusReadyToPlay)) {\n        self.playButton.enabled = YES;\n    }\n    else {\n        self.playButton.enabled = NO;\n    }\n}\n</code></pre>\n<p>在 <code>viewDidLoad</code> 时先调用一下 <code>syncUI</code>：</p>\n<pre><code class=\"objectivec\">- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self syncUI];\n}\n</code></pre>\n<p>创建并加载 <code>AVURLAsset</code>，在加载成功时，创建 <code>item</code>、初始化播放器以及添加各种监听：</p>\n<pre><code class=\"objectivec\">static const NSString *ItemStatusContext;\n\n- (IBAction)loadAssetFromFile:sender {\n\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:&lt;#@&quot;VideoFileName&quot;#&gt; withExtension:&lt;#@&quot;extension&quot;#&gt;];\n\n    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];\n    NSString *tracksKey = @&quot;tracks&quot;;\n\n    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler: ^{\n        // The completion block goes here.\n        dispatch_async(dispatch_get_main_queue(), ^{\n            NSError *error;\n            AVKeyValueStatus status = [asset statusOfValueForKey:tracksKey error:&amp;error];\n\n            if (status == AVKeyValueStatusLoaded) {\n                self.playerItem = [AVPlayerItem playerItemWithAsset:asset];\n                 // ensure that this is done before the playerItem is associated with the player\n                [self.playerItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionInitial context:&amp;ItemStatusContext];\n                [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playerItemDidReachEnd:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.playerItem];\n                self.player = [AVPlayer playerWithPlayerItem:self.playerItem];\n                [self.playerView setPlayer:self.player];\n            } else {\n                // You should deal with the error appropriately.\n                NSLog(@&quot;The asset&#39;s tracks were not loaded:\\n%@&quot;, [error localizedDescription]);\n            }\n        });\n    }];\n}\n</code></pre>\n<p>响应 <code>status</code> 的监听通知：</p>\n<pre><code class=\"objectivec\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n\n    if (context == &amp;ItemStatusContext) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self syncUI];\n        });\n        return;\n    }\n    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    return;\n}\n</code></pre>\n<p>播放，以及播放完成时的处理：</p>\n<pre><code class=\"objectivec\">- (IBAction)play:sender {\n    [self.player play];\n}\n\n\n- (void)playerItemDidReachEnd:(NSNotification *)notification {\n    [self.player seekToTime:kCMTimeZero];\n}\n</code></pre>\n"},{"title":"GCD小结","date":"2017-05-31T08:21:06.000Z","_content":"## Tip1.线程、任务和队列的概念\n![图一](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_1.png)\n## Tip2.异步、同步 & 并行、串行的特点\n![图二](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_2.png)\n## 小结：一条重要的准则\n\n一般来说，我们使用GCD的最大目的是在新的线程中同时执行多个任务，这意味着我们需要两项条件：\n\n - 能开启新的线程\n - 任务可以同时执行\n> 结合以上两个条件，也就等价“开启新线程的能力 + 任务同步执行的权利”，只有在满足能力与权利这两个条件的前提下，我们才可以在同时执行多个任务。\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_3.png)\n\n##（一）异步执行 + 并行队列\n#### 实现代码：\n```objectivec\n//异步执行 + 并行队列\n- (void)asyncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@\"---start---\");\n\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n\n    NSLog(@\"---end---\");\n}\n\n```\n\n#### 打印结果：\n\n```objectivec\n ---start---\n  ---end---\n  任务3---<NSThread: 0x600000070f00>{number = 5, name = (null)}\n  任务2---<NSThread: 0x600000070d80>{number = 4, name = (null)}\n  任务1---<NSThread: 0x608000074100>{number = 3, name = (null)}\n```\n#### 解释\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 并行队列意味着\n - 任务之间不需要排队，且具有同时被执行的“权利”\n- 两者组合后的结果\n - 开了三个新线程\n - 函数在执行时，先打印了start和end，再回头执行这三个任务\n - 这三个任务是同时执行的，没有先后，所以打印结果是“任务3-->任务2-->任务1”\n\n#### 步骤图\n\n![图四](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_4.png)\n\n## （二）异步执行 + 串行队列\n\n#### 实现代码：\n\n```objectivec\n//异步执行 + 串行队列\n- (void)asyncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n#### 打印结果：\n\n```objectivec\n---start---\n ---end---\n任务1---<NSThread: 0x608000078480>{number = 3, name = (null)}\n任务2---<NSThread: 0x608000078480>{number = 3, name = (null)}\n任务3---<NSThread: 0x608000078480>{number = 3, name = (null)}\n\n```\n#### 解释:\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 串行队列意味着\n - 任务必须按添加进队列的顺序挨个执行\n- 两者组合后的结果\n - 开了一个新的子线程\n - 函数在执行时，先打印了start和end，再回头执行这三个任务\n - 这三个任务是按顺序执行的，所以打印结果是“任务1-->任务2-->任务3”\n\n\n#### 步骤图\n![图五](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_5.png)\n\n## （三）同步执行 + 并行队列\n#### 实现代码：\n```objectivec\n//同步执行 + 并行队列\n- (void)syncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@\"---start---\");\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n#### 打印结果：\n```objectivec\n  ---start---\n  任务1---<NSThread: 0x608000065400>{number = 1, name = main}\n  任务2---<NSThread: 0x608000065400>{number = 1, name = main}\n  任务3---<NSThread: 0x608000065400>{number = 1, name = main}\n  ---end---\n```\n\n\n- 同步执行执行意味着\n - 不能开启新的线程\n - 任务创建后必须执行完才能往下走\n- 并行队列意味着\n - 任务之间不需要排队，且具有同时被执行的“”\n- 两者组合后的结果\n - 所有任务都只能在主线程中执行\n - 函数在执行时，必须按照代码的书写顺序一行一行地执行完才能继续\n- 注意事项\n - 在这里即便是并行队列，任务可以同时执行，但是由于只存在一个主线程，所以没法把任务分发到不同的线程去同步处理，其结果就是只能在主线程里按顺序挨个挨个执行了\n\n#### 步骤图\n![图六](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_6.png)\n\n## （四）同步执行+ 串行队列\n\n#### 实现代码：\n\n```objectivec\n- (void)syncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n\n#### 打印结果：\n\n```objectivec\n---start---\n任务1---<NSThread: 0x608000065400>{number = 1, name = main}\n任务2---<NSThread: 0x608000065400>{number = 1, name = main}\n任务3---<NSThread: 0x608000065400>{number = 1, name = main}\n---end---\n```\n\n#### 解释\n\n- 这里的执行原理和步骤图跟“同步执行+并发队列”是一样的，只要是同步执行就没法开启新的线程，所以多个任务之间也一样只能按顺序来执行\n\n\n\n##（五）异步执行+主队列\n\n#### 实现代码：\n\n```objectivec\n- (void)asyncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n#### 打印结果：\n\n ```objectivec\n  ---start---\n  ---end---\n  任务1---<NSThread: 0x60800006ff40>{number = 1, name = main}\n  任务2---<NSThread: 0x60800006ff40>{number = 1, name = main}\n  任务3---<NSThread: 0x60800006ff40>{number = 1, name = main}\n ```\n\n\n#### 解释\n\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 主队列跟串行队列的区别\n - 队列中的任务一样要按顺序执行\n - 主队列中的任务必须在主线程中执行，不允许在子线程中执行\n- 以上条件组合后得出结果：\n - 所有任务都可以先跳过，之后再来“按顺序”执行\n\n#### 步骤图\n\n![图七](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_7.png)\n\n##（六）同步执行+主队列（死锁）\n\n#### 实现代码：\n\n ```objectivec\n- (void)syncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@\"---start---\");\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n ```\n\n#### 打印结果：\n\n ```objectivec\n  ---start---\n ```\n\n#### 解释\n\n- 主队列中的任务必须按顺序挨个执行\n- 任务1要等主线程有空的时候（即主队列中的所有任务执行完）才能执行\n- 主线程要执行完“打印end”的任务后才有空\n- “任务1”和“打印end”两个任务互相等待，造成死锁\n\n#### 步骤图\n![图八](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_8.png)\n\n### end.\n\n\n","source":"_posts/GCD小结.md","raw":"---\ntitle: GCD小结\ndate: 2017-05-31 16:21:06\ncategories: \n\t- iOS合集\n---\n## Tip1.线程、任务和队列的概念\n![图一](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_1.png)\n## Tip2.异步、同步 & 并行、串行的特点\n![图二](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_2.png)\n## 小结：一条重要的准则\n\n一般来说，我们使用GCD的最大目的是在新的线程中同时执行多个任务，这意味着我们需要两项条件：\n\n - 能开启新的线程\n - 任务可以同时执行\n> 结合以上两个条件，也就等价“开启新线程的能力 + 任务同步执行的权利”，只有在满足能力与权利这两个条件的前提下，我们才可以在同时执行多个任务。\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_3.png)\n\n##（一）异步执行 + 并行队列\n#### 实现代码：\n```objectivec\n//异步执行 + 并行队列\n- (void)asyncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@\"---start---\");\n\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n\n    NSLog(@\"---end---\");\n}\n\n```\n\n#### 打印结果：\n\n```objectivec\n ---start---\n  ---end---\n  任务3---<NSThread: 0x600000070f00>{number = 5, name = (null)}\n  任务2---<NSThread: 0x600000070d80>{number = 4, name = (null)}\n  任务1---<NSThread: 0x608000074100>{number = 3, name = (null)}\n```\n#### 解释\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 并行队列意味着\n - 任务之间不需要排队，且具有同时被执行的“权利”\n- 两者组合后的结果\n - 开了三个新线程\n - 函数在执行时，先打印了start和end，再回头执行这三个任务\n - 这三个任务是同时执行的，没有先后，所以打印结果是“任务3-->任务2-->任务1”\n\n#### 步骤图\n\n![图四](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_4.png)\n\n## （二）异步执行 + 串行队列\n\n#### 实现代码：\n\n```objectivec\n//异步执行 + 串行队列\n- (void)asyncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n#### 打印结果：\n\n```objectivec\n---start---\n ---end---\n任务1---<NSThread: 0x608000078480>{number = 3, name = (null)}\n任务2---<NSThread: 0x608000078480>{number = 3, name = (null)}\n任务3---<NSThread: 0x608000078480>{number = 3, name = (null)}\n\n```\n#### 解释:\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 串行队列意味着\n - 任务必须按添加进队列的顺序挨个执行\n- 两者组合后的结果\n - 开了一个新的子线程\n - 函数在执行时，先打印了start和end，再回头执行这三个任务\n - 这三个任务是按顺序执行的，所以打印结果是“任务1-->任务2-->任务3”\n\n\n#### 步骤图\n![图五](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_5.png)\n\n## （三）同步执行 + 并行队列\n#### 实现代码：\n```objectivec\n//同步执行 + 并行队列\n- (void)syncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@\"---start---\");\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n#### 打印结果：\n```objectivec\n  ---start---\n  任务1---<NSThread: 0x608000065400>{number = 1, name = main}\n  任务2---<NSThread: 0x608000065400>{number = 1, name = main}\n  任务3---<NSThread: 0x608000065400>{number = 1, name = main}\n  ---end---\n```\n\n\n- 同步执行执行意味着\n - 不能开启新的线程\n - 任务创建后必须执行完才能往下走\n- 并行队列意味着\n - 任务之间不需要排队，且具有同时被执行的“”\n- 两者组合后的结果\n - 所有任务都只能在主线程中执行\n - 函数在执行时，必须按照代码的书写顺序一行一行地执行完才能继续\n- 注意事项\n - 在这里即便是并行队列，任务可以同时执行，但是由于只存在一个主线程，所以没法把任务分发到不同的线程去同步处理，其结果就是只能在主线程里按顺序挨个挨个执行了\n\n#### 步骤图\n![图六](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_6.png)\n\n## （四）同步执行+ 串行队列\n\n#### 实现代码：\n\n```objectivec\n- (void)syncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(\"标识符\", DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n\n#### 打印结果：\n\n```objectivec\n---start---\n任务1---<NSThread: 0x608000065400>{number = 1, name = main}\n任务2---<NSThread: 0x608000065400>{number = 1, name = main}\n任务3---<NSThread: 0x608000065400>{number = 1, name = main}\n---end---\n```\n\n#### 解释\n\n- 这里的执行原理和步骤图跟“同步执行+并发队列”是一样的，只要是同步执行就没法开启新的线程，所以多个任务之间也一样只能按顺序来执行\n\n\n\n##（五）异步执行+主队列\n\n#### 实现代码：\n\n```objectivec\n- (void)asyncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@\"---start---\");\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n```\n\n#### 打印结果：\n\n ```objectivec\n  ---start---\n  ---end---\n  任务1---<NSThread: 0x60800006ff40>{number = 1, name = main}\n  任务2---<NSThread: 0x60800006ff40>{number = 1, name = main}\n  任务3---<NSThread: 0x60800006ff40>{number = 1, name = main}\n ```\n\n\n#### 解释\n\n- 异步执行意味着\n - 可以开启新的线程\n - 任务可以先绕过不执行，回头再来执行\n- 主队列跟串行队列的区别\n - 队列中的任务一样要按顺序执行\n - 主队列中的任务必须在主线程中执行，不允许在子线程中执行\n- 以上条件组合后得出结果：\n - 所有任务都可以先跳过，之后再来“按顺序”执行\n\n#### 步骤图\n\n![图七](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_7.png)\n\n##（六）同步执行+主队列（死锁）\n\n#### 实现代码：\n\n ```objectivec\n- (void)syncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@\"---start---\");\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务1---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务2---%@\", [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@\"任务3---%@\", [NSThread currentThread]);\n    });\n    NSLog(@\"---end---\");\n}\n ```\n\n#### 打印结果：\n\n ```objectivec\n  ---start---\n ```\n\n#### 解释\n\n- 主队列中的任务必须按顺序挨个执行\n- 任务1要等主线程有空的时候（即主队列中的所有任务执行完）才能执行\n- 主线程要执行完“打印end”的任务后才有空\n- “任务1”和“打印end”两个任务互相等待，造成死锁\n\n#### 步骤图\n![图八](http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_8.png)\n\n### end.\n\n\n","slug":"GCD小结","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tve000dznuzb0m8ahbd","content":"<h2 id=\"Tip1-线程、任务和队列的概念\"><a href=\"#Tip1-线程、任务和队列的概念\" class=\"headerlink\" title=\"Tip1.线程、任务和队列的概念\"></a>Tip1.线程、任务和队列的概念</h2><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_1.png\" alt=\"图一\"></p>\n<h2 id=\"Tip2-异步、同步-amp-并行、串行的特点\"><a href=\"#Tip2-异步、同步-amp-并行、串行的特点\" class=\"headerlink\" title=\"Tip2.异步、同步 &amp; 并行、串行的特点\"></a>Tip2.异步、同步 &amp; 并行、串行的特点</h2><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_2.png\" alt=\"图二\"></p>\n<h2 id=\"小结：一条重要的准则\"><a href=\"#小结：一条重要的准则\" class=\"headerlink\" title=\"小结：一条重要的准则\"></a>小结：一条重要的准则</h2><p>一般来说，我们使用GCD的最大目的是在新的线程中同时执行多个任务，这意味着我们需要两项条件：</p>\n<ul>\n<li>能开启新的线程</li>\n<li>任务可以同时执行<blockquote>\n<p>结合以上两个条件，也就等价“开启新线程的能力 + 任务同步执行的权利”，只有在满足能力与权利这两个条件的前提下，我们才可以在同时执行多个任务。</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_3.png\" alt=\"图三\"></p>\n<p>##（一）异步执行 + 并行队列</p>\n<h4 id=\"实现代码：\"><a href=\"#实现代码：\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//异步执行 + 并行队列</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>asyncConcurrent<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建一个并行队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"标识符\"</span><span class=\"token punctuation\">,</span> DISPATCH_QUEUE_CONCURRENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//使用异步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：\"><a href=\"#打印结果：\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> <span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>end<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n  任务<span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x600000070f00</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x600000070d80</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000074100</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>并行队列意味着<ul>\n<li>任务之间不需要排队，且具有同时被执行的“权利”</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>开了三个新线程</li>\n<li>函数在执行时，先打印了start和end，再回头执行这三个任务</li>\n<li>这三个任务是同时执行的，没有先后，所以打印结果是“任务3–&gt;任务2–&gt;任务1”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图\"><a href=\"#步骤图\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_4.png\" alt=\"图四\"></p>\n<h2 id=\"（二）异步执行-串行队列\"><a href=\"#（二）异步执行-串行队列\" class=\"headerlink\" title=\"（二）异步执行 + 串行队列\"></a>（二）异步执行 + 串行队列</h2><h4 id=\"实现代码：-1\"><a href=\"#实现代码：-1\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//异步执行 + 串行队列</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>asyncSerial<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建一个串行队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"标识符\"</span><span class=\"token punctuation\">,</span> DISPATCH_QUEUE_SERIAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用异步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：-1\"><a href=\"#打印结果：-1\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n <span class=\"token operator\">--</span><span class=\"token operator\">-</span>end<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n任务<span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000078480</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n任务<span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000078480</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n任务<span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000078480</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"解释-1\"><a href=\"#解释-1\" class=\"headerlink\" title=\"解释:\"></a>解释:</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>串行队列意味着<ul>\n<li>任务必须按添加进队列的顺序挨个执行</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>开了一个新的子线程</li>\n<li>函数在执行时，先打印了start和end，再回头执行这三个任务</li>\n<li>这三个任务是按顺序执行的，所以打印结果是“任务1–&gt;任务2–&gt;任务3”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-1\"><a href=\"#步骤图-1\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_5.png\" alt=\"图五\"></p>\n<h2 id=\"（三）同步执行-并行队列\"><a href=\"#（三）同步执行-并行队列\" class=\"headerlink\" title=\"（三）同步执行 + 并行队列\"></a>（三）同步执行 + 并行队列</h2><h4 id=\"实现代码：-2\"><a href=\"#实现代码：-2\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//同步执行 + 并行队列</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>syncConcurrent<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建一个并行队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"标识符\"</span><span class=\"token punctuation\">,</span> DISPATCH_QUEUE_CONCURRENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用同步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：-2\"><a href=\"#打印结果：-2\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n  任务<span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>end<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n</code></pre>\n<ul>\n<li>同步执行执行意味着<ul>\n<li>不能开启新的线程</li>\n<li>任务创建后必须执行完才能往下走</li>\n</ul>\n</li>\n<li>并行队列意味着<ul>\n<li>任务之间不需要排队，且具有同时被执行的“”</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>所有任务都只能在主线程中执行</li>\n<li>函数在执行时，必须按照代码的书写顺序一行一行地执行完才能继续</li>\n</ul>\n</li>\n<li>注意事项<ul>\n<li>在这里即便是并行队列，任务可以同时执行，但是由于只存在一个主线程，所以没法把任务分发到不同的线程去同步处理，其结果就是只能在主线程里按顺序挨个挨个执行了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-2\"><a href=\"#步骤图-2\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_6.png\" alt=\"图六\"></p>\n<h2 id=\"（四）同步执行-串行队列\"><a href=\"#（四）同步执行-串行队列\" class=\"headerlink\" title=\"（四）同步执行+ 串行队列\"></a>（四）同步执行+ 串行队列</h2><h4 id=\"实现代码：-3\"><a href=\"#实现代码：-3\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>syncSerial<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建一个串行队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"标识符\"</span><span class=\"token punctuation\">,</span> DISPATCH_QUEUE_SERIAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用异步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：-3\"><a href=\"#打印结果：-3\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n任务<span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n任务<span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n任务<span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x608000065400</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>end<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n</code></pre>\n<h4 id=\"解释-2\"><a href=\"#解释-2\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>这里的执行原理和步骤图跟“同步执行+并发队列”是一样的，只要是同步执行就没法开启新的线程，所以多个任务之间也一样只能按顺序来执行</li>\n</ul>\n<p>##（五）异步执行+主队列</p>\n<h4 id=\"实现代码：-4\"><a href=\"#实现代码：-4\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>asyncMain<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取主队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用异步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：-4\"><a href=\"#打印结果：-4\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>end<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n  任务<span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x60800006ff40</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x60800006ff40</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n  任务<span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">&lt;</span>NSThread<span class=\"token punctuation\">:</span> <span class=\"token number\">0x60800006ff40</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> name <span class=\"token operator\">=</span> main<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"解释-3\"><a href=\"#解释-3\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>主队列跟串行队列的区别<ul>\n<li>队列中的任务一样要按顺序执行</li>\n<li>主队列中的任务必须在主线程中执行，不允许在子线程中执行</li>\n</ul>\n</li>\n<li>以上条件组合后得出结果：<ul>\n<li>所有任务都可以先跳过，之后再来“按顺序”执行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-3\"><a href=\"#步骤图-3\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_7.png\" alt=\"图七\"></p>\n<p>##（六）同步执行+主队列（死锁）</p>\n<h4 id=\"实现代码：-5\"><a href=\"#实现代码：-5\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>syncMain<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取主队列</span>\n    dispatch_queue_t queue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---start---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用同步函数封装三个任务</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务1---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务2---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch_sync</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"任务3---%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSThread currentThread<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"---end---\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"打印结果：-5\"><a href=\"#打印结果：-5\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">  <span class=\"token operator\">--</span><span class=\"token operator\">-</span>start<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n</code></pre>\n<h4 id=\"解释-4\"><a href=\"#解释-4\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>主队列中的任务必须按顺序挨个执行</li>\n<li>任务1要等主线程有空的时候（即主队列中的所有任务执行完）才能执行</li>\n<li>主线程要执行完“打印end”的任务后才有空</li>\n<li>“任务1”和“打印end”两个任务互相等待，造成死锁</li>\n</ul>\n<h4 id=\"步骤图-4\"><a href=\"#步骤图-4\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_8.png\" alt=\"图八\"></p>\n<h3 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end.\"></a>end.</h3>","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h2 id=\"Tip1-线程、任务和队列的概念\"><a href=\"#Tip1-线程、任务和队列的概念\" class=\"headerlink\" title=\"Tip1.线程、任务和队列的概念\"></a>Tip1.线程、任务和队列的概念</h2><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_1.png\" alt=\"图一\"></p>\n<h2 id=\"Tip2-异步、同步-amp-并行、串行的特点\"><a href=\"#Tip2-异步、同步-amp-并行、串行的特点\" class=\"headerlink\" title=\"Tip2.异步、同步 &amp; 并行、串行的特点\"></a>Tip2.异步、同步 &amp; 并行、串行的特点</h2><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_2.png\" alt=\"图二\"></p>\n<h2 id=\"小结：一条重要的准则\"><a href=\"#小结：一条重要的准则\" class=\"headerlink\" title=\"小结：一条重要的准则\"></a>小结：一条重要的准则</h2><p>一般来说，我们使用GCD的最大目的是在新的线程中同时执行多个任务，这意味着我们需要两项条件：</p>\n<ul>\n<li>能开启新的线程</li>\n<li>任务可以同时执行<blockquote>\n<p>结合以上两个条件，也就等价“开启新线程的能力 + 任务同步执行的权利”，只有在满足能力与权利这两个条件的前提下，我们才可以在同时执行多个任务。</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_3.png\" alt=\"图三\"></p>\n<p>##（一）异步执行 + 并行队列</p>\n<h4 id=\"实现代码：\"><a href=\"#实现代码：\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">//异步执行 + 并行队列\n- (void)asyncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;标识符&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@&quot;---start---&quot;);\n\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：\"><a href=\"#打印结果：\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\"> ---start---\n  ---end---\n  任务3---&lt;NSThread: 0x600000070f00&gt;{number = 5, name = (null)}\n  任务2---&lt;NSThread: 0x600000070d80&gt;{number = 4, name = (null)}\n  任务1---&lt;NSThread: 0x608000074100&gt;{number = 3, name = (null)}\n</code></pre>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>并行队列意味着<ul>\n<li>任务之间不需要排队，且具有同时被执行的“权利”</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>开了三个新线程</li>\n<li>函数在执行时，先打印了start和end，再回头执行这三个任务</li>\n<li>这三个任务是同时执行的，没有先后，所以打印结果是“任务3–&gt;任务2–&gt;任务1”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图\"><a href=\"#步骤图\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_4.png\" alt=\"图四\"></p>\n<h2 id=\"（二）异步执行-串行队列\"><a href=\"#（二）异步执行-串行队列\" class=\"headerlink\" title=\"（二）异步执行 + 串行队列\"></a>（二）异步执行 + 串行队列</h2><h4 id=\"实现代码：-1\"><a href=\"#实现代码：-1\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">//异步执行 + 串行队列\n- (void)asyncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;标识符&quot;, DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@&quot;---start---&quot;);\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：-1\"><a href=\"#打印结果：-1\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\">---start---\n ---end---\n任务1---&lt;NSThread: 0x608000078480&gt;{number = 3, name = (null)}\n任务2---&lt;NSThread: 0x608000078480&gt;{number = 3, name = (null)}\n任务3---&lt;NSThread: 0x608000078480&gt;{number = 3, name = (null)}\n</code></pre>\n<h4 id=\"解释-1\"><a href=\"#解释-1\" class=\"headerlink\" title=\"解释:\"></a>解释:</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>串行队列意味着<ul>\n<li>任务必须按添加进队列的顺序挨个执行</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>开了一个新的子线程</li>\n<li>函数在执行时，先打印了start和end，再回头执行这三个任务</li>\n<li>这三个任务是按顺序执行的，所以打印结果是“任务1–&gt;任务2–&gt;任务3”</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-1\"><a href=\"#步骤图-1\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_5.png\" alt=\"图五\"></p>\n<h2 id=\"（三）同步执行-并行队列\"><a href=\"#（三）同步执行-并行队列\" class=\"headerlink\" title=\"（三）同步执行 + 并行队列\"></a>（三）同步执行 + 并行队列</h2><h4 id=\"实现代码：-2\"><a href=\"#实现代码：-2\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">//同步执行 + 并行队列\n- (void)syncConcurrent{\n    //创建一个并行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;标识符&quot;, DISPATCH_QUEUE_CONCURRENT);\n\n    NSLog(@&quot;---start---&quot;);\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：-2\"><a href=\"#打印结果：-2\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\">  ---start---\n  任务1---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n  任务2---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n  任务3---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n  ---end---\n</code></pre>\n<ul>\n<li>同步执行执行意味着<ul>\n<li>不能开启新的线程</li>\n<li>任务创建后必须执行完才能往下走</li>\n</ul>\n</li>\n<li>并行队列意味着<ul>\n<li>任务之间不需要排队，且具有同时被执行的“”</li>\n</ul>\n</li>\n<li>两者组合后的结果<ul>\n<li>所有任务都只能在主线程中执行</li>\n<li>函数在执行时，必须按照代码的书写顺序一行一行地执行完才能继续</li>\n</ul>\n</li>\n<li>注意事项<ul>\n<li>在这里即便是并行队列，任务可以同时执行，但是由于只存在一个主线程，所以没法把任务分发到不同的线程去同步处理，其结果就是只能在主线程里按顺序挨个挨个执行了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-2\"><a href=\"#步骤图-2\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_6.png\" alt=\"图六\"></p>\n<h2 id=\"（四）同步执行-串行队列\"><a href=\"#（四）同步执行-串行队列\" class=\"headerlink\" title=\"（四）同步执行+ 串行队列\"></a>（四）同步执行+ 串行队列</h2><h4 id=\"实现代码：-3\"><a href=\"#实现代码：-3\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">- (void)syncSerial{\n    //创建一个串行队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;标识符&quot;, DISPATCH_QUEUE_SERIAL);\n\n    NSLog(@&quot;---start---&quot;);\n    //使用异步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：-3\"><a href=\"#打印结果：-3\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\">---start---\n任务1---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n任务2---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n任务3---&lt;NSThread: 0x608000065400&gt;{number = 1, name = main}\n---end---\n</code></pre>\n<h4 id=\"解释-2\"><a href=\"#解释-2\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>这里的执行原理和步骤图跟“同步执行+并发队列”是一样的，只要是同步执行就没法开启新的线程，所以多个任务之间也一样只能按顺序来执行</li>\n</ul>\n<p>##（五）异步执行+主队列</p>\n<h4 id=\"实现代码：-4\"><a href=\"#实现代码：-4\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">- (void)asyncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@&quot;---start---&quot;);\n    //使用异步函数封装三个任务\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：-4\"><a href=\"#打印结果：-4\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\">  ---start---\n  ---end---\n  任务1---&lt;NSThread: 0x60800006ff40&gt;{number = 1, name = main}\n  任务2---&lt;NSThread: 0x60800006ff40&gt;{number = 1, name = main}\n  任务3---&lt;NSThread: 0x60800006ff40&gt;{number = 1, name = main}\n</code></pre>\n<h4 id=\"解释-3\"><a href=\"#解释-3\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>异步执行意味着<ul>\n<li>可以开启新的线程</li>\n<li>任务可以先绕过不执行，回头再来执行</li>\n</ul>\n</li>\n<li>主队列跟串行队列的区别<ul>\n<li>队列中的任务一样要按顺序执行</li>\n<li>主队列中的任务必须在主线程中执行，不允许在子线程中执行</li>\n</ul>\n</li>\n<li>以上条件组合后得出结果：<ul>\n<li>所有任务都可以先跳过，之后再来“按顺序”执行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"步骤图-3\"><a href=\"#步骤图-3\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_7.png\" alt=\"图七\"></p>\n<p>##（六）同步执行+主队列（死锁）</p>\n<h4 id=\"实现代码：-5\"><a href=\"#实现代码：-5\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><pre><code class=\"objectivec\">- (void)syncMain{\n    //获取主队列\n    dispatch_queue_t queue = dispatch_get_main_queue();\n\n    NSLog(@&quot;---start---&quot;);\n    //使用同步函数封装三个任务\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务1---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务2---%@&quot;, [NSThread currentThread]);\n    });\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;任务3---%@&quot;, [NSThread currentThread]);\n    });\n    NSLog(@&quot;---end---&quot;);\n}\n</code></pre>\n<h4 id=\"打印结果：-5\"><a href=\"#打印结果：-5\" class=\"headerlink\" title=\"打印结果：\"></a>打印结果：</h4><pre><code class=\"objectivec\">  ---start---\n</code></pre>\n<h4 id=\"解释-4\"><a href=\"#解释-4\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ul>\n<li>主队列中的任务必须按顺序挨个执行</li>\n<li>任务1要等主线程有空的时候（即主队列中的所有任务执行完）才能执行</li>\n<li>主线程要执行完“打印end”的任务后才有空</li>\n<li>“任务1”和“打印end”两个任务互相等待，造成死锁</li>\n</ul>\n<h4 id=\"步骤图-4\"><a href=\"#步骤图-4\" class=\"headerlink\" title=\"步骤图\"></a>步骤图</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/gcd%E5%B0%8F%E7%BB%93_8.png\" alt=\"图八\"></p>\n<h3 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end.\"></a>end.</h3>"},{"title":"Github上的代码添加Cocoapods支持","date":"2017-03-10T03:33:10.000Z","_content":"\n\n####  一、前言\n如何将自己写的`Github`上的代码添加`Cocoapods`支持，此文将以一个[iOS RSA](https://github.com/CoderSteveJones/SJRSAEncryptor.git)加密库文件为例，讲述整个过程。\n\n#### 二、步骤\n这里我将从最初的开始进行介绍，包括`Github`上创建项目已经上传项目，到最后的支持`Cocoapods`。\n步骤如下：\n- 代码上传`Github`\n- 创建`podspec`文件，并验证是否通过\n- 在`Github`上创建`release`版本\n- 注册`CocoaPods`账号\n- 上传代码到`CocoaPods`\n- 检查上传是否成功\n\n##### 1 代码上传Github\n首先我们打开[github.com](https://github.com/)，然后创建自己的项目工程：\n![图一](http://upload-images.jianshu.io/upload_images/2115041-b810fae200c34e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里注意那个`MIT License`，在后面添加`Cocoapods`支持的时候会用到（稍后介绍）。然后点击创建即可。\n然后用`SouceTree`将代码`down`到本地，将自己的项目放到里面，文件夹如图所示：\n\n\n![图二.png](http://upload-images.jianshu.io/upload_images/2115041-a4fed0a898c9e253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的`LICENSE`就是刚才说的`MIT License`添加的文件。`SJRSAEncryptorDemo`是示例工程，`SJRSAEncryptor`就是提供给他人使用的库。然后提交到`Github`就可以了。\n\n#####  2 创建podspec文件\n我们使用终端到工程目录下：\n\n执行:\n```\npod spec create SJRSAEncryptor   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n如图：\n\n![图三.png](http://upload-images.jianshu.io/upload_images/2115041-178816910884e0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编辑`podspec`文件(最好用代码编辑器打开进行编辑)：\n\n```\nPod::Spec.new do |s|\n  s.name         = \"SJRSAEncryptor\"\n  s.version      = \"1.0.0\"\n  s.summary      = \"A iOS RSA Encryptor tool.\"\n  s.description  = \"A iOS RSA Encryptor tool, easy to use it.\"\n  s.homepage     = \"https://github.com/CoderSteveJones/SJRSAEncryptor.git\"\n  s.license      = \"MIT\"\n  s.author             = { \"SteveJones\" => \"benkong_ah@foxmail.com\" }\n  s.source       = { :git => \"https://github.com/CoderSteveJones/SJRSAEncryptor.git\", :tag => \"#{s.version}\" }\n  s.source_files  = \"SJRSAEncryptor/*.{h,m}\"\nend\n```\n`name:`类库的名称这里字段介绍如下：\n`version:`库的版本\n`summary:`就是介绍语\n`homtepage:`Github上项目地址\n`license:`许可证\n`author:`作者\n`source:`项目的https链接地址\n`source_files:`要共享的代码，这里是SJRSAEncryptor下面的所有代码。\n接下来执行下面的命令进行\n验证：\n\n```\npod lib lint SJRSAEncryptor.podspec   // SJRSAEncryptor改为你的上传库文件名即可\n```\n如图：\n\n![图四.png](http://upload-images.jianshu.io/upload_images/2115041-be91d4f955e7352d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n结果多种多样，如果有错，则按照提示进行改错即可。\n发现了多个警告，只要不是错误就行，警告可以直接忽略（红色也提示如何忽略）：\n\n```\npod lib lint SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n如图：\n\n\n![图五.png](http://upload-images.jianshu.io/upload_images/2115041-1e70591d46e72270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当看到`SJRSAEncryptor passed validation.`之后，就说明验证通过了。\n\n##### 3 在Github上创建release版本\n打开项目的目录，然后创建`release`版本的类库：\n\n\n![图六.png](http://upload-images.jianshu.io/upload_images/2115041-3ff33308a2664cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击`release`,添加发布版本（我这已经发步过一次，所以显示1）。\n\n\n![图七.png](http://upload-images.jianshu.io/upload_images/2115041-6ddfad3afb05d11c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 4 注册CocoaPods账号\n执行命令行：\n\n\n```\npod trunk register 邮箱地址  '用户名' --description='描述信息'\n```\n\n发送了一个验证码到邮箱，你可以打开你的邮箱验证即可。打开邮件中的链接后如下：\n\n![图八.png](http://upload-images.jianshu.io/upload_images/2115041-15f20823fa4dfd3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样就成功注册了Cocoapods账号。\n可以用\n```\npod trunk me\n```\n检查是否创建成功。成功的结果如下：\n\n![图九.png](http://upload-images.jianshu.io/upload_images/2115041-ad48ecab1590dea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后执行：\n\n```\npod trunk push SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n执行结果如下：\n\n\n![图十.png](http://upload-images.jianshu.io/upload_images/2115041-14b5c967d4abc892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n说明了已经上传成功。\n\n\n##### 6 检查上传是否成功\n\n```\npod search ZGRSAEncryptor\n```\n\n\n\n#### 四、参考文档：\n[http://www.cnblogs.com/zhanggui/p/6003481.html](http://www.cnblogs.com/zhanggui/p/6003481.html)\n[http://www.cocoachina.com/ios/20160415/15939.html](http://www.cocoachina.com/ios/20160415/15939.html)\n[http://www.cocoachina.com/ios/20160907/17501.html](http://www.cocoachina.com/ios/20160907/17501.html)\n[https://cocoapods.org/](https://cocoapods.org/)\n\n","source":"_posts/Github上的代码添加Cocoapods支持.md","raw":"---\ntitle: Github上的代码添加Cocoapods支持\ndate: 2017-03-10 11:33:10\ncategories: \n\t- iOS合集\n---\n\n\n####  一、前言\n如何将自己写的`Github`上的代码添加`Cocoapods`支持，此文将以一个[iOS RSA](https://github.com/CoderSteveJones/SJRSAEncryptor.git)加密库文件为例，讲述整个过程。\n\n#### 二、步骤\n这里我将从最初的开始进行介绍，包括`Github`上创建项目已经上传项目，到最后的支持`Cocoapods`。\n步骤如下：\n- 代码上传`Github`\n- 创建`podspec`文件，并验证是否通过\n- 在`Github`上创建`release`版本\n- 注册`CocoaPods`账号\n- 上传代码到`CocoaPods`\n- 检查上传是否成功\n\n##### 1 代码上传Github\n首先我们打开[github.com](https://github.com/)，然后创建自己的项目工程：\n![图一](http://upload-images.jianshu.io/upload_images/2115041-b810fae200c34e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里注意那个`MIT License`，在后面添加`Cocoapods`支持的时候会用到（稍后介绍）。然后点击创建即可。\n然后用`SouceTree`将代码`down`到本地，将自己的项目放到里面，文件夹如图所示：\n\n\n![图二.png](http://upload-images.jianshu.io/upload_images/2115041-a4fed0a898c9e253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的`LICENSE`就是刚才说的`MIT License`添加的文件。`SJRSAEncryptorDemo`是示例工程，`SJRSAEncryptor`就是提供给他人使用的库。然后提交到`Github`就可以了。\n\n#####  2 创建podspec文件\n我们使用终端到工程目录下：\n\n执行:\n```\npod spec create SJRSAEncryptor   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n如图：\n\n![图三.png](http://upload-images.jianshu.io/upload_images/2115041-178816910884e0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编辑`podspec`文件(最好用代码编辑器打开进行编辑)：\n\n```\nPod::Spec.new do |s|\n  s.name         = \"SJRSAEncryptor\"\n  s.version      = \"1.0.0\"\n  s.summary      = \"A iOS RSA Encryptor tool.\"\n  s.description  = \"A iOS RSA Encryptor tool, easy to use it.\"\n  s.homepage     = \"https://github.com/CoderSteveJones/SJRSAEncryptor.git\"\n  s.license      = \"MIT\"\n  s.author             = { \"SteveJones\" => \"benkong_ah@foxmail.com\" }\n  s.source       = { :git => \"https://github.com/CoderSteveJones/SJRSAEncryptor.git\", :tag => \"#{s.version}\" }\n  s.source_files  = \"SJRSAEncryptor/*.{h,m}\"\nend\n```\n`name:`类库的名称这里字段介绍如下：\n`version:`库的版本\n`summary:`就是介绍语\n`homtepage:`Github上项目地址\n`license:`许可证\n`author:`作者\n`source:`项目的https链接地址\n`source_files:`要共享的代码，这里是SJRSAEncryptor下面的所有代码。\n接下来执行下面的命令进行\n验证：\n\n```\npod lib lint SJRSAEncryptor.podspec   // SJRSAEncryptor改为你的上传库文件名即可\n```\n如图：\n\n![图四.png](http://upload-images.jianshu.io/upload_images/2115041-be91d4f955e7352d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n结果多种多样，如果有错，则按照提示进行改错即可。\n发现了多个警告，只要不是错误就行，警告可以直接忽略（红色也提示如何忽略）：\n\n```\npod lib lint SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n如图：\n\n\n![图五.png](http://upload-images.jianshu.io/upload_images/2115041-1e70591d46e72270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当看到`SJRSAEncryptor passed validation.`之后，就说明验证通过了。\n\n##### 3 在Github上创建release版本\n打开项目的目录，然后创建`release`版本的类库：\n\n\n![图六.png](http://upload-images.jianshu.io/upload_images/2115041-3ff33308a2664cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击`release`,添加发布版本（我这已经发步过一次，所以显示1）。\n\n\n![图七.png](http://upload-images.jianshu.io/upload_images/2115041-6ddfad3afb05d11c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 4 注册CocoaPods账号\n执行命令行：\n\n\n```\npod trunk register 邮箱地址  '用户名' --description='描述信息'\n```\n\n发送了一个验证码到邮箱，你可以打开你的邮箱验证即可。打开邮件中的链接后如下：\n\n![图八.png](http://upload-images.jianshu.io/upload_images/2115041-15f20823fa4dfd3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样就成功注册了Cocoapods账号。\n可以用\n```\npod trunk me\n```\n检查是否创建成功。成功的结果如下：\n\n![图九.png](http://upload-images.jianshu.io/upload_images/2115041-ad48ecab1590dea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后执行：\n\n```\npod trunk push SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n```\n\n执行结果如下：\n\n\n![图十.png](http://upload-images.jianshu.io/upload_images/2115041-14b5c967d4abc892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n说明了已经上传成功。\n\n\n##### 6 检查上传是否成功\n\n```\npod search ZGRSAEncryptor\n```\n\n\n\n#### 四、参考文档：\n[http://www.cnblogs.com/zhanggui/p/6003481.html](http://www.cnblogs.com/zhanggui/p/6003481.html)\n[http://www.cocoachina.com/ios/20160415/15939.html](http://www.cocoachina.com/ios/20160415/15939.html)\n[http://www.cocoachina.com/ios/20160907/17501.html](http://www.cocoachina.com/ios/20160907/17501.html)\n[https://cocoapods.org/](https://cocoapods.org/)\n\n","slug":"Github上的代码添加Cocoapods支持","published":1,"updated":"2017-07-05T11:13:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvg000eznuzvuikniw8","content":"<h4 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h4><p>如何将自己写的<code>Github</code>上的代码添加<code>Cocoapods</code>支持，此文将以一个<a href=\"https://github.com/CoderSteveJones/SJRSAEncryptor.git\" target=\"_blank\" rel=\"external\">iOS RSA</a>加密库文件为例，讲述整个过程。</p>\n<h4 id=\"二、步骤\"><a href=\"#二、步骤\" class=\"headerlink\" title=\"二、步骤\"></a>二、步骤</h4><p>这里我将从最初的开始进行介绍，包括<code>Github</code>上创建项目已经上传项目，到最后的支持<code>Cocoapods</code>。<br>步骤如下：</p>\n<ul>\n<li>代码上传<code>Github</code></li>\n<li>创建<code>podspec</code>文件，并验证是否通过</li>\n<li>在<code>Github</code>上创建<code>release</code>版本</li>\n<li>注册<code>CocoaPods</code>账号</li>\n<li>上传代码到<code>CocoaPods</code></li>\n<li>检查上传是否成功</li>\n</ul>\n<h5 id=\"1-代码上传Github\"><a href=\"#1-代码上传Github\" class=\"headerlink\" title=\"1 代码上传Github\"></a>1 代码上传Github</h5><p>首先我们打开<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">github.com</a>，然后创建自己的项目工程：<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-b810fae200c34e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图一\"></p>\n<p>这里注意那个<code>MIT License</code>，在后面添加<code>Cocoapods</code>支持的时候会用到（稍后介绍）。然后点击创建即可。<br>然后用<code>SouceTree</code>将代码<code>down</code>到本地，将自己的项目放到里面，文件夹如图所示：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-a4fed0a898c9e253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图二.png\"></p>\n<p>这里的<code>LICENSE</code>就是刚才说的<code>MIT License</code>添加的文件。<code>SJRSAEncryptorDemo</code>是示例工程，<code>SJRSAEncryptor</code>就是提供给他人使用的库。然后提交到<code>Github</code>就可以了。</p>\n<h5 id=\"2-创建podspec文件\"><a href=\"#2-创建podspec文件\" class=\"headerlink\" title=\"2 创建podspec文件\"></a>2 创建podspec文件</h5><p>我们使用终端到工程目录下：</p>\n<p>执行:</p>\n<pre><code>pod spec create SJRSAEncryptor   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-178816910884e0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图三.png\"></p>\n<p>编辑<code>podspec</code>文件(最好用代码编辑器打开进行编辑)：</p>\n<pre><code>Pod::Spec.new do |s|\n  s.name         = &quot;SJRSAEncryptor&quot;\n  s.version      = &quot;1.0.0&quot;\n  s.summary      = &quot;A iOS RSA Encryptor tool.&quot;\n  s.description  = &quot;A iOS RSA Encryptor tool, easy to use it.&quot;\n  s.homepage     = &quot;https://github.com/CoderSteveJones/SJRSAEncryptor.git&quot;\n  s.license      = &quot;MIT&quot;\n  s.author             = { &quot;SteveJones&quot; =&gt; &quot;benkong_ah@foxmail.com&quot; }\n  s.source       = { :git =&gt; &quot;https://github.com/CoderSteveJones/SJRSAEncryptor.git&quot;, :tag =&gt; &quot;#{s.version}&quot; }\n  s.source_files  = &quot;SJRSAEncryptor/*.{h,m}&quot;\nend\n</code></pre><p><code>name:</code>类库的名称这里字段介绍如下：<br><code>version:</code>库的版本<br><code>summary:</code>就是介绍语<br><code>homtepage:</code>Github上项目地址<br><code>license:</code>许可证<br><code>author:</code>作者<br><code>source:</code>项目的https链接地址<br><code>source_files:</code>要共享的代码，这里是SJRSAEncryptor下面的所有代码。<br>接下来执行下面的命令进行<br>验证：</p>\n<pre><code>pod lib lint SJRSAEncryptor.podspec   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-be91d4f955e7352d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图四.png\"></p>\n<p>结果多种多样，如果有错，则按照提示进行改错即可。<br>发现了多个警告，只要不是错误就行，警告可以直接忽略（红色也提示如何忽略）：</p>\n<pre><code>pod lib lint SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-1e70591d46e72270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图五.png\"></p>\n<p>当看到<code>SJRSAEncryptor passed validation.</code>之后，就说明验证通过了。</p>\n<h5 id=\"3-在Github上创建release版本\"><a href=\"#3-在Github上创建release版本\" class=\"headerlink\" title=\"3 在Github上创建release版本\"></a>3 在Github上创建release版本</h5><p>打开项目的目录，然后创建<code>release</code>版本的类库：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-3ff33308a2664cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图六.png\"></p>\n<p>点击<code>release</code>,添加发布版本（我这已经发步过一次，所以显示1）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6ddfad3afb05d11c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图七.png\"></p>\n<h5 id=\"4-注册CocoaPods账号\"><a href=\"#4-注册CocoaPods账号\" class=\"headerlink\" title=\"4 注册CocoaPods账号\"></a>4 注册CocoaPods账号</h5><p>执行命令行：</p>\n<pre><code>pod trunk register 邮箱地址  &#39;用户名&#39; --description=&#39;描述信息&#39;\n</code></pre><p>发送了一个验证码到邮箱，你可以打开你的邮箱验证即可。打开邮件中的链接后如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-15f20823fa4dfd3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图八.png\"></p>\n<p>这样就成功注册了Cocoapods账号。<br>可以用</p>\n<pre><code>pod trunk me\n</code></pre><p>检查是否创建成功。成功的结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-ad48ecab1590dea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图九.png\"></p>\n<p>然后执行：</p>\n<pre><code>pod trunk push SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>执行结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-14b5c967d4abc892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图十.png\"></p>\n<p>说明了已经上传成功。</p>\n<h5 id=\"6-检查上传是否成功\"><a href=\"#6-检查上传是否成功\" class=\"headerlink\" title=\"6 检查上传是否成功\"></a>6 检查上传是否成功</h5><pre><code>pod search ZGRSAEncryptor\n</code></pre><h4 id=\"四、参考文档：\"><a href=\"#四、参考文档：\" class=\"headerlink\" title=\"四、参考文档：\"></a>四、参考文档：</h4><p><a href=\"http://www.cnblogs.com/zhanggui/p/6003481.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zhanggui/p/6003481.html</a><br><a href=\"http://www.cocoachina.com/ios/20160415/15939.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20160415/15939.html</a><br><a href=\"http://www.cocoachina.com/ios/20160907/17501.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20160907/17501.html</a><br><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">https://cocoapods.org/</a></p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h4><p>如何将自己写的<code>Github</code>上的代码添加<code>Cocoapods</code>支持，此文将以一个<a href=\"https://github.com/CoderSteveJones/SJRSAEncryptor.git\" target=\"_blank\" rel=\"external\">iOS RSA</a>加密库文件为例，讲述整个过程。</p>\n<h4 id=\"二、步骤\"><a href=\"#二、步骤\" class=\"headerlink\" title=\"二、步骤\"></a>二、步骤</h4><p>这里我将从最初的开始进行介绍，包括<code>Github</code>上创建项目已经上传项目，到最后的支持<code>Cocoapods</code>。<br>步骤如下：</p>\n<ul>\n<li>代码上传<code>Github</code></li>\n<li>创建<code>podspec</code>文件，并验证是否通过</li>\n<li>在<code>Github</code>上创建<code>release</code>版本</li>\n<li>注册<code>CocoaPods</code>账号</li>\n<li>上传代码到<code>CocoaPods</code></li>\n<li>检查上传是否成功</li>\n</ul>\n<h5 id=\"1-代码上传Github\"><a href=\"#1-代码上传Github\" class=\"headerlink\" title=\"1 代码上传Github\"></a>1 代码上传Github</h5><p>首先我们打开<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">github.com</a>，然后创建自己的项目工程：<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-b810fae200c34e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图一\"></p>\n<p>这里注意那个<code>MIT License</code>，在后面添加<code>Cocoapods</code>支持的时候会用到（稍后介绍）。然后点击创建即可。<br>然后用<code>SouceTree</code>将代码<code>down</code>到本地，将自己的项目放到里面，文件夹如图所示：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-a4fed0a898c9e253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图二.png\"></p>\n<p>这里的<code>LICENSE</code>就是刚才说的<code>MIT License</code>添加的文件。<code>SJRSAEncryptorDemo</code>是示例工程，<code>SJRSAEncryptor</code>就是提供给他人使用的库。然后提交到<code>Github</code>就可以了。</p>\n<h5 id=\"2-创建podspec文件\"><a href=\"#2-创建podspec文件\" class=\"headerlink\" title=\"2 创建podspec文件\"></a>2 创建podspec文件</h5><p>我们使用终端到工程目录下：</p>\n<p>执行:</p>\n<pre><code>pod spec create SJRSAEncryptor   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-178816910884e0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图三.png\"></p>\n<p>编辑<code>podspec</code>文件(最好用代码编辑器打开进行编辑)：</p>\n<pre><code>Pod::Spec.new do |s|\n  s.name         = &quot;SJRSAEncryptor&quot;\n  s.version      = &quot;1.0.0&quot;\n  s.summary      = &quot;A iOS RSA Encryptor tool.&quot;\n  s.description  = &quot;A iOS RSA Encryptor tool, easy to use it.&quot;\n  s.homepage     = &quot;https://github.com/CoderSteveJones/SJRSAEncryptor.git&quot;\n  s.license      = &quot;MIT&quot;\n  s.author             = { &quot;SteveJones&quot; =&gt; &quot;benkong_ah@foxmail.com&quot; }\n  s.source       = { :git =&gt; &quot;https://github.com/CoderSteveJones/SJRSAEncryptor.git&quot;, :tag =&gt; &quot;#{s.version}&quot; }\n  s.source_files  = &quot;SJRSAEncryptor/*.{h,m}&quot;\nend\n</code></pre><p><code>name:</code>类库的名称这里字段介绍如下：<br><code>version:</code>库的版本<br><code>summary:</code>就是介绍语<br><code>homtepage:</code>Github上项目地址<br><code>license:</code>许可证<br><code>author:</code>作者<br><code>source:</code>项目的https链接地址<br><code>source_files:</code>要共享的代码，这里是SJRSAEncryptor下面的所有代码。<br>接下来执行下面的命令进行<br>验证：</p>\n<pre><code>pod lib lint SJRSAEncryptor.podspec   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-be91d4f955e7352d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图四.png\"></p>\n<p>结果多种多样，如果有错，则按照提示进行改错即可。<br>发现了多个警告，只要不是错误就行，警告可以直接忽略（红色也提示如何忽略）：</p>\n<pre><code>pod lib lint SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-1e70591d46e72270.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图五.png\"></p>\n<p>当看到<code>SJRSAEncryptor passed validation.</code>之后，就说明验证通过了。</p>\n<h5 id=\"3-在Github上创建release版本\"><a href=\"#3-在Github上创建release版本\" class=\"headerlink\" title=\"3 在Github上创建release版本\"></a>3 在Github上创建release版本</h5><p>打开项目的目录，然后创建<code>release</code>版本的类库：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-3ff33308a2664cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图六.png\"></p>\n<p>点击<code>release</code>,添加发布版本（我这已经发步过一次，所以显示1）。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6ddfad3afb05d11c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图七.png\"></p>\n<h5 id=\"4-注册CocoaPods账号\"><a href=\"#4-注册CocoaPods账号\" class=\"headerlink\" title=\"4 注册CocoaPods账号\"></a>4 注册CocoaPods账号</h5><p>执行命令行：</p>\n<pre><code>pod trunk register 邮箱地址  &#39;用户名&#39; --description=&#39;描述信息&#39;\n</code></pre><p>发送了一个验证码到邮箱，你可以打开你的邮箱验证即可。打开邮件中的链接后如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-15f20823fa4dfd3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图八.png\"></p>\n<p>这样就成功注册了Cocoapods账号。<br>可以用</p>\n<pre><code>pod trunk me\n</code></pre><p>检查是否创建成功。成功的结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-ad48ecab1590dea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图九.png\"></p>\n<p>然后执行：</p>\n<pre><code>pod trunk push SJRSAEncryptor.podspec --allow-warnings   // SJRSAEncryptor改为你的上传库文件名即可\n</code></pre><p>执行结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-14b5c967d4abc892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图十.png\"></p>\n<p>说明了已经上传成功。</p>\n<h5 id=\"6-检查上传是否成功\"><a href=\"#6-检查上传是否成功\" class=\"headerlink\" title=\"6 检查上传是否成功\"></a>6 检查上传是否成功</h5><pre><code>pod search ZGRSAEncryptor\n</code></pre><h4 id=\"四、参考文档：\"><a href=\"#四、参考文档：\" class=\"headerlink\" title=\"四、参考文档：\"></a>四、参考文档：</h4><p><a href=\"http://www.cnblogs.com/zhanggui/p/6003481.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zhanggui/p/6003481.html</a><br><a href=\"http://www.cocoachina.com/ios/20160415/15939.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20160415/15939.html</a><br><a href=\"http://www.cocoachina.com/ios/20160907/17501.html\" target=\"_blank\" rel=\"external\">http://www.cocoachina.com/ios/20160907/17501.html</a><br><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">https://cocoapods.org/</a></p>\n"},{"title":"NSPredicate 使用小结","date":"2017-06-05T14:37:04.000Z","_content":"> NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。\n\n## 一、NSPredicate 使用\n#### （1）集合中使用NSPredicate\n\nNSArray&NSSet，不可变的集合，有可以通过评估接收到的predicate来返回一个不可变集合的方法filteredArrayUsingPredicate:和filteredSetUsingPredicate:。\n\nNSMutableArray&NSMutableSet，可变集合，可以使用方法filterUsingPredicate:，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。\n\n#### （2）配合正则表达式使用\n\n```objectivec\n-(BOOL)checkPhoneNumber:(NSString *)phoneNumber{\n    NSString *regex = @\"^[1][3-8]\\\\d{9}$\";\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [pred evaluateWithObject:phoneNumber];\n}\n```\n\n#### （3）Core Data中使用NSPredicate\n\nNSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。\n\nself.studentArray 添加200个数据，供筛选，以下是生成self.studentArray的代码\n\n```objectivec\n// 学生对象\n@interface Student :NSObject\n/** 名字 */\n@property (nonatomic, strong) NSString *name;\n/** 班级 */\n@property (nonatomic, assign) NSUInteger class;\n/** 分数 */\n@property (nonatomic, assign) NSUInteger score;\n\n- (instancetype)initWithName:(NSString *)name Class:(NSInteger)class Score:(NSInteger)score;\n@end\n@implementation Student\n\n- (instancetype)initWithName:(NSString *)name\n                       Class:(NSInteger)class\n                       Score:(NSInteger)score{\n    if (self = [super init]) {\n        if (class > 6 || class < 1) class = 1;\n        if (score > 100 || score < 0) score = 0;\n        _name = name;\n        _class = class;\n        _score = score;\n    }\n    return self;\n}\n\n@end\n```\n\n```objectivec\n@interface ViewController ()\n@property (nonatomic, strong) NSMutableArray <Student *> *studentArray;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n#pragma mark - - lazy load\n\n- (NSMutableArray<Student *> *)studentArray{\n    if (!_studentArray) {\n        _studentArray = [NSMutableArray arrayWithCapacity:0];\n        for (int i = 0; i < 200; i ++) {\n            NSString *name = [self randomStringWithLength:5];\n            NSInteger score = arc4random() % 100;\n            NSInteger class = arc4random() % 6;\n\n            Student *student = [[Student alloc] initWithName:name\n                                                       Class:class\n                                                       Score:score];\n            [_studentArray addObject:student];\n        }\n    }\n    return _studentArray;\n}\n\n\n/** 获取随机字符串 */\n- (NSString *)randomStringWithLength:(NSInteger)length{\n    char data[length];\n    for (int x=0;x<length;data[x++] = (char)('a' + (arc4random_uniform(26))));\n    return [[NSString alloc] initWithBytes:data length:length encoding:NSUTF8StringEncoding];\n}\n\n@end\n```\n## 二、谓词语法\n\n#### （1）替换\n\n> - %@ 是对值为字符串，数字或者日期的对象的替换值。\n- %K 是key path的替换值。\n- $VARIABLE_NAME 是可以被NSPredicate -predicateWithSubstitutionVariables:替换的值。\n\n```objectivec\n  //（%K,%d =\\== 使用）\n    // 分数为满分\n    NSPredicate *predicateA = [NSPredicate predicateWithFormat:@\"%K = %d\",@\"score\",100];\n    NSArray *caseA = [self.studentArray filteredArrayUsingPredicate:predicateA];\n\n    //（self、BEGINSWITH、[]、$ 使用）\n    // 名字以 ‘a’开头\n    NSPredicate *predicateB = [NSPredicate predicateWithFormat:@\"self.name BEGINSWITH[az] $beginningChar\"];\n    NSArray *caseB = [self.studentArray filteredArrayUsingPredicate:[predicateB predicateWithSubstitutionVariables:@{@\"beginningChar\": @\"a\"}]];\n```\n\n#### （2）比较运算符\n\n> =, == ：左边的表达式和右边的表达式相等。\n>=, => ：左边的表达式大于或者等于右边的表达式。\n<=, =< ：左边的表达式小于等于右边的表达式。\n> ：左边的表达式大于右边的表达式。\n< ：左边的表达式小于右边的表达式。\n!=, <> ：左边的表达式不等于右边的表达式。\nBETWEEN ：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。\n\n```objectivec\n// 比较运算符 =, ==  >=, =>  <=, =< > < !=, <> BETWEEN 使用\n    // 90~100 优等学生\n    NSPredicate *predicateC = [NSPredicate predicateWithFormat:@\"self.score BETWEEN {90,100}\"];\n    NSArray *caseC = [self.studentArray filteredArrayUsingPredicate:predicateC];\n```\n\n#### （5）集合运算符\n\n> ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age < 18。\nALL：指定下列表达式中的所有元素。比如，ALL children.age < 18。\nNONE：指定下列表达式中没有的元素。比如，NONE children.age < 18。它在逻辑上等于NOT (ANY ...)。\nIN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { 'Ben', 'Melissa', 'Nick' }。\n\n\n#### （6）直接量\n\n>FALSE、NO：代表逻辑假\nTRUE、YES：代表逻辑真\nNULL、NIL：代表空值\nSELF：代表正在被判断的对象自身\n\"string\"或'string'：代表字符串\n数组：和c中的写法相同，如：{'one', 'two', 'three'}。\n数值：包括证书、小数和科学计数法表示的形式\n十六进制数：0x开头的数字\n八进制：0o开头的数字\n二进制：0b开头的数字\n\n#### （7）数组操作\n\n> array[index] ：指定数组中特定索引处的元素。\narray[FIRST] ：指定数组中的第一个元素。\narray[LAST] ：指定数组中的最后一个元素。\narray[SIZE] ：指定数组的大小。\n\n####（8）布尔值谓词\n>TRUEPREDICATE ：结果始终为真的谓词。\nFALSEPREDICATE ：结果始终为假的谓词。\n\n####（9）Block谓词\n\n```objectivec\nNSPredicate *shortNamePredicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {\n            return [[evaluatedObject firstName] length] <= 5;\n        }];\nNSLog(@\"Short Names: %@\", [people filteredArrayUsingPredicate:shortNamePredicate]);\n```\n\n\n","source":"_posts/NSPredicate-使用小结.md","raw":"---\ntitle: NSPredicate 使用小结\ndate: 2017-06-05 22:37:04\ncategories: \n\t- iOS合集\n---\n> NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。\n\n## 一、NSPredicate 使用\n#### （1）集合中使用NSPredicate\n\nNSArray&NSSet，不可变的集合，有可以通过评估接收到的predicate来返回一个不可变集合的方法filteredArrayUsingPredicate:和filteredSetUsingPredicate:。\n\nNSMutableArray&NSMutableSet，可变集合，可以使用方法filterUsingPredicate:，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。\n\n#### （2）配合正则表达式使用\n\n```objectivec\n-(BOOL)checkPhoneNumber:(NSString *)phoneNumber{\n    NSString *regex = @\"^[1][3-8]\\\\d{9}$\";\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex];\n    return [pred evaluateWithObject:phoneNumber];\n}\n```\n\n#### （3）Core Data中使用NSPredicate\n\nNSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。\n\nself.studentArray 添加200个数据，供筛选，以下是生成self.studentArray的代码\n\n```objectivec\n// 学生对象\n@interface Student :NSObject\n/** 名字 */\n@property (nonatomic, strong) NSString *name;\n/** 班级 */\n@property (nonatomic, assign) NSUInteger class;\n/** 分数 */\n@property (nonatomic, assign) NSUInteger score;\n\n- (instancetype)initWithName:(NSString *)name Class:(NSInteger)class Score:(NSInteger)score;\n@end\n@implementation Student\n\n- (instancetype)initWithName:(NSString *)name\n                       Class:(NSInteger)class\n                       Score:(NSInteger)score{\n    if (self = [super init]) {\n        if (class > 6 || class < 1) class = 1;\n        if (score > 100 || score < 0) score = 0;\n        _name = name;\n        _class = class;\n        _score = score;\n    }\n    return self;\n}\n\n@end\n```\n\n```objectivec\n@interface ViewController ()\n@property (nonatomic, strong) NSMutableArray <Student *> *studentArray;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n#pragma mark - - lazy load\n\n- (NSMutableArray<Student *> *)studentArray{\n    if (!_studentArray) {\n        _studentArray = [NSMutableArray arrayWithCapacity:0];\n        for (int i = 0; i < 200; i ++) {\n            NSString *name = [self randomStringWithLength:5];\n            NSInteger score = arc4random() % 100;\n            NSInteger class = arc4random() % 6;\n\n            Student *student = [[Student alloc] initWithName:name\n                                                       Class:class\n                                                       Score:score];\n            [_studentArray addObject:student];\n        }\n    }\n    return _studentArray;\n}\n\n\n/** 获取随机字符串 */\n- (NSString *)randomStringWithLength:(NSInteger)length{\n    char data[length];\n    for (int x=0;x<length;data[x++] = (char)('a' + (arc4random_uniform(26))));\n    return [[NSString alloc] initWithBytes:data length:length encoding:NSUTF8StringEncoding];\n}\n\n@end\n```\n## 二、谓词语法\n\n#### （1）替换\n\n> - %@ 是对值为字符串，数字或者日期的对象的替换值。\n- %K 是key path的替换值。\n- $VARIABLE_NAME 是可以被NSPredicate -predicateWithSubstitutionVariables:替换的值。\n\n```objectivec\n  //（%K,%d =\\== 使用）\n    // 分数为满分\n    NSPredicate *predicateA = [NSPredicate predicateWithFormat:@\"%K = %d\",@\"score\",100];\n    NSArray *caseA = [self.studentArray filteredArrayUsingPredicate:predicateA];\n\n    //（self、BEGINSWITH、[]、$ 使用）\n    // 名字以 ‘a’开头\n    NSPredicate *predicateB = [NSPredicate predicateWithFormat:@\"self.name BEGINSWITH[az] $beginningChar\"];\n    NSArray *caseB = [self.studentArray filteredArrayUsingPredicate:[predicateB predicateWithSubstitutionVariables:@{@\"beginningChar\": @\"a\"}]];\n```\n\n#### （2）比较运算符\n\n> =, == ：左边的表达式和右边的表达式相等。\n>=, => ：左边的表达式大于或者等于右边的表达式。\n<=, =< ：左边的表达式小于等于右边的表达式。\n> ：左边的表达式大于右边的表达式。\n< ：左边的表达式小于右边的表达式。\n!=, <> ：左边的表达式不等于右边的表达式。\nBETWEEN ：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。\n\n```objectivec\n// 比较运算符 =, ==  >=, =>  <=, =< > < !=, <> BETWEEN 使用\n    // 90~100 优等学生\n    NSPredicate *predicateC = [NSPredicate predicateWithFormat:@\"self.score BETWEEN {90,100}\"];\n    NSArray *caseC = [self.studentArray filteredArrayUsingPredicate:predicateC];\n```\n\n#### （5）集合运算符\n\n> ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age < 18。\nALL：指定下列表达式中的所有元素。比如，ALL children.age < 18。\nNONE：指定下列表达式中没有的元素。比如，NONE children.age < 18。它在逻辑上等于NOT (ANY ...)。\nIN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { 'Ben', 'Melissa', 'Nick' }。\n\n\n#### （6）直接量\n\n>FALSE、NO：代表逻辑假\nTRUE、YES：代表逻辑真\nNULL、NIL：代表空值\nSELF：代表正在被判断的对象自身\n\"string\"或'string'：代表字符串\n数组：和c中的写法相同，如：{'one', 'two', 'three'}。\n数值：包括证书、小数和科学计数法表示的形式\n十六进制数：0x开头的数字\n八进制：0o开头的数字\n二进制：0b开头的数字\n\n#### （7）数组操作\n\n> array[index] ：指定数组中特定索引处的元素。\narray[FIRST] ：指定数组中的第一个元素。\narray[LAST] ：指定数组中的最后一个元素。\narray[SIZE] ：指定数组的大小。\n\n####（8）布尔值谓词\n>TRUEPREDICATE ：结果始终为真的谓词。\nFALSEPREDICATE ：结果始终为假的谓词。\n\n####（9）Block谓词\n\n```objectivec\nNSPredicate *shortNamePredicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {\n            return [[evaluatedObject firstName] length] <= 5;\n        }];\nNSLog(@\"Short Names: %@\", [people filteredArrayUsingPredicate:shortNamePredicate]);\n```\n\n\n","slug":"NSPredicate-使用小结","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvj000hznuzrd8udjna","content":"<blockquote>\n<p>NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。</p>\n</blockquote>\n<h2 id=\"一、NSPredicate-使用\"><a href=\"#一、NSPredicate-使用\" class=\"headerlink\" title=\"一、NSPredicate 使用\"></a>一、NSPredicate 使用</h2><h4 id=\"（1）集合中使用NSPredicate\"><a href=\"#（1）集合中使用NSPredicate\" class=\"headerlink\" title=\"（1）集合中使用NSPredicate\"></a>（1）集合中使用NSPredicate</h4><p>NSArray&amp;NSSet，不可变的集合，有可以通过评估接收到的predicate来返回一个不可变集合的方法filteredArrayUsingPredicate:和filteredSetUsingPredicate:。</p>\n<p>NSMutableArray&amp;NSMutableSet，可变集合，可以使用方法filterUsingPredicate:，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。</p>\n<h4 id=\"（2）配合正则表达式使用\"><a href=\"#（2）配合正则表达式使用\" class=\"headerlink\" title=\"（2）配合正则表达式使用\"></a>（2）配合正则表达式使用</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>checkPhoneNumber<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>phoneNumber<span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>regex <span class=\"token operator\">=</span> <span class=\"token string\">@\"^[1][3-8]\\\\d{9}$\"</span><span class=\"token punctuation\">;</span>\n    NSPredicate <span class=\"token operator\">*</span>pred <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span> regex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>pred evaluateWithObject<span class=\"token punctuation\">:</span>phoneNumber<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"（3）Core-Data中使用NSPredicate\"><a href=\"#（3）Core-Data中使用NSPredicate\" class=\"headerlink\" title=\"（3）Core Data中使用NSPredicate\"></a>（3）Core Data中使用NSPredicate</h4><p>NSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。</p>\n<p>self.studentArray 添加200个数据，供筛选，以下是生成self.studentArray的代码</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 学生对象</span>\n<span class=\"token keyword\">@interface</span> Student <span class=\"token punctuation\">:</span>NSObject\n<span class=\"token comment\" spellcheck=\"true\">/** 名字 */</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/** 班级 */</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger class<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/** 分数 */</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger score<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name Class<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>class Score<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>score<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n<span class=\"token keyword\">@implementation</span> Student\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name\n                       Class<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>class\n                       Score<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>score<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>class <span class=\"token operator\">></span> <span class=\"token number\">6</span> <span class=\"token operator\">||</span> class <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> class <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>score <span class=\"token operator\">></span> <span class=\"token number\">100</span> <span class=\"token operator\">||</span> score <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> score <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        _name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        _class <span class=\"token operator\">=</span> class<span class=\"token punctuation\">;</span>\n        _score <span class=\"token operator\">=</span> score<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@interface</span> <span class=\"token function\">ViewController</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">)</span> NSMutableArray <span class=\"token operator\">&lt;</span>Student <span class=\"token operator\">*</span><span class=\"token operator\">></span> <span class=\"token operator\">*</span>studentArray<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> ViewController\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLoad<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - - lazy load</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSMutableArray<span class=\"token operator\">&lt;</span>Student <span class=\"token operator\">*</span><span class=\"token operator\">></span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>studentArray<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>_studentArray<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _studentArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithCapacity<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSString <span class=\"token operator\">*</span>name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> randomStringWithLength<span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            NSInteger score <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n            NSInteger class <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n\n            Student <span class=\"token operator\">*</span>student <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>Student alloc<span class=\"token punctuation\">]</span> initWithName<span class=\"token punctuation\">:</span>name\n                                                       Class<span class=\"token punctuation\">:</span>class\n                                                       Score<span class=\"token punctuation\">:</span>score<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">[</span>_studentArray addObject<span class=\"token punctuation\">:</span>student<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> _studentArray<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">/** 获取随机字符串 */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>randomStringWithLength<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>length<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">[</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>x<span class=\"token operator\">&lt;</span>length<span class=\"token punctuation\">;</span>data<span class=\"token punctuation\">[</span>x<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token function\">arc4random_uniform</span><span class=\"token punctuation\">(</span><span class=\"token number\">26</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithBytes<span class=\"token punctuation\">:</span>data length<span class=\"token punctuation\">:</span>length encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<h2 id=\"二、谓词语法\"><a href=\"#二、谓词语法\" class=\"headerlink\" title=\"二、谓词语法\"></a>二、谓词语法</h2><h4 id=\"（1）替换\"><a href=\"#（1）替换\" class=\"headerlink\" title=\"（1）替换\"></a>（1）替换</h4><blockquote>\n<ul>\n<li>%@ 是对值为字符串，数字或者日期的对象的替换值。</li>\n<li>%K 是key path的替换值。</li>\n<li>$VARIABLE_NAME 是可以被NSPredicate -predicateWithSubstitutionVariables:替换的值。</li>\n</ul>\n</blockquote>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">  <span class=\"token comment\" spellcheck=\"true\">//（%K,%d =\\== 使用）</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 分数为满分</span>\n    NSPredicate <span class=\"token operator\">*</span>predicateA <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%K = %d\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">@\"score\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSArray <span class=\"token operator\">*</span>caseA <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>studentArray filteredArrayUsingPredicate<span class=\"token punctuation\">:</span>predicateA<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//（self、BEGINSWITH、[]、$ 使用）</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 名字以 ‘a’开头</span>\n    NSPredicate <span class=\"token operator\">*</span>predicateB <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"self.name BEGINSWITH[az] $beginningChar\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSArray <span class=\"token operator\">*</span>caseB <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>studentArray filteredArrayUsingPredicate<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>predicateB predicateWithSubstitutionVariables<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token string\">@\"beginningChar\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">@\"a\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"（2）比较运算符\"><a href=\"#（2）比较运算符\" class=\"headerlink\" title=\"（2）比较运算符\"></a>（2）比较运算符</h4><blockquote>\n<p>=, == ：左边的表达式和右边的表达式相等。<br>=, =&gt; ：左边的表达式大于或者等于右边的表达式。<br>&lt;=, =&lt; ：左边的表达式小于等于右边的表达式。<br>：左边的表达式大于右边的表达式。<br>&lt; ：左边的表达式小于右边的表达式。<br>!=, &lt;&gt; ：左边的表达式不等于右边的表达式。<br>BETWEEN ：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。</p>\n</blockquote>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 比较运算符 =, ==  >=, =>  &lt;=, =&lt; > &lt; !=, &lt;> BETWEEN 使用</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 90~100 优等学生</span>\n    NSPredicate <span class=\"token operator\">*</span>predicateC <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"self.score BETWEEN {90,100}\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSArray <span class=\"token operator\">*</span>caseC <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>studentArray filteredArrayUsingPredicate<span class=\"token punctuation\">:</span>predicateC<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"（5）集合运算符\"><a href=\"#（5）集合运算符\" class=\"headerlink\" title=\"（5）集合运算符\"></a>（5）集合运算符</h4><blockquote>\n<p>ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。<br>ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。<br>NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY …)。<br>IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { ‘Ben’, ‘Melissa’, ‘Nick’ }。</p>\n</blockquote>\n<h4 id=\"（6）直接量\"><a href=\"#（6）直接量\" class=\"headerlink\" title=\"（6）直接量\"></a>（6）直接量</h4><blockquote>\n<p>FALSE、NO：代表逻辑假<br>TRUE、YES：代表逻辑真<br>NULL、NIL：代表空值<br>SELF：代表正在被判断的对象自身<br>“string”或’string’：代表字符串<br>数组：和c中的写法相同，如：{‘one’, ‘two’, ‘three’}。<br>数值：包括证书、小数和科学计数法表示的形式<br>十六进制数：0x开头的数字<br>八进制：0o开头的数字<br>二进制：0b开头的数字</p>\n</blockquote>\n<h4 id=\"（7）数组操作\"><a href=\"#（7）数组操作\" class=\"headerlink\" title=\"（7）数组操作\"></a>（7）数组操作</h4><blockquote>\n<p>array[index] ：指定数组中特定索引处的元素。<br>array[FIRST] ：指定数组中的第一个元素。<br>array[LAST] ：指定数组中的最后一个元素。<br>array[SIZE] ：指定数组的大小。</p>\n</blockquote>\n<p>####（8）布尔值谓词</p>\n<blockquote>\n<p>TRUEPREDICATE ：结果始终为真的谓词。<br>FALSEPREDICATE ：结果始终为假的谓词。</p>\n</blockquote>\n<p>####（9）Block谓词</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSPredicate <span class=\"token operator\">*</span>shortNamePredicate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token function\">BOOL</span><span class=\"token punctuation\">(</span>id evaluatedObject<span class=\"token punctuation\">,</span> NSDictionary <span class=\"token operator\">*</span>bindings<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>evaluatedObject firstName<span class=\"token punctuation\">]</span> length<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Short Names: %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>people filteredArrayUsingPredicate<span class=\"token punctuation\">:</span>shortNamePredicate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<blockquote>\n<p>NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。</p>\n</blockquote>\n<h2 id=\"一、NSPredicate-使用\"><a href=\"#一、NSPredicate-使用\" class=\"headerlink\" title=\"一、NSPredicate 使用\"></a>一、NSPredicate 使用</h2><h4 id=\"（1）集合中使用NSPredicate\"><a href=\"#（1）集合中使用NSPredicate\" class=\"headerlink\" title=\"（1）集合中使用NSPredicate\"></a>（1）集合中使用NSPredicate</h4><p>NSArray&amp;NSSet，不可变的集合，有可以通过评估接收到的predicate来返回一个不可变集合的方法filteredArrayUsingPredicate:和filteredSetUsingPredicate:。</p>\n<p>NSMutableArray&amp;NSMutableSet，可变集合，可以使用方法filterUsingPredicate:，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。</p>\n<h4 id=\"（2）配合正则表达式使用\"><a href=\"#（2）配合正则表达式使用\" class=\"headerlink\" title=\"（2）配合正则表达式使用\"></a>（2）配合正则表达式使用</h4><pre><code class=\"objectivec\">-(BOOL)checkPhoneNumber:(NSString *)phoneNumber{\n    NSString *regex = @&quot;^[1][3-8]\\\\d{9}$&quot;;\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];\n    return [pred evaluateWithObject:phoneNumber];\n}\n</code></pre>\n<h4 id=\"（3）Core-Data中使用NSPredicate\"><a href=\"#（3）Core-Data中使用NSPredicate\" class=\"headerlink\" title=\"（3）Core Data中使用NSPredicate\"></a>（3）Core Data中使用NSPredicate</h4><p>NSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。</p>\n<p>self.studentArray 添加200个数据，供筛选，以下是生成self.studentArray的代码</p>\n<pre><code class=\"objectivec\">// 学生对象\n@interface Student :NSObject\n/** 名字 */\n@property (nonatomic, strong) NSString *name;\n/** 班级 */\n@property (nonatomic, assign) NSUInteger class;\n/** 分数 */\n@property (nonatomic, assign) NSUInteger score;\n\n- (instancetype)initWithName:(NSString *)name Class:(NSInteger)class Score:(NSInteger)score;\n@end\n@implementation Student\n\n- (instancetype)initWithName:(NSString *)name\n                       Class:(NSInteger)class\n                       Score:(NSInteger)score{\n    if (self = [super init]) {\n        if (class &gt; 6 || class &lt; 1) class = 1;\n        if (score &gt; 100 || score &lt; 0) score = 0;\n        _name = name;\n        _class = class;\n        _score = score;\n    }\n    return self;\n}\n\n@end\n</code></pre>\n<pre><code class=\"objectivec\">@interface ViewController ()\n@property (nonatomic, strong) NSMutableArray &lt;Student *&gt; *studentArray;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n#pragma mark - - lazy load\n\n- (NSMutableArray&lt;Student *&gt; *)studentArray{\n    if (!_studentArray) {\n        _studentArray = [NSMutableArray arrayWithCapacity:0];\n        for (int i = 0; i &lt; 200; i ++) {\n            NSString *name = [self randomStringWithLength:5];\n            NSInteger score = arc4random() % 100;\n            NSInteger class = arc4random() % 6;\n\n            Student *student = [[Student alloc] initWithName:name\n                                                       Class:class\n                                                       Score:score];\n            [_studentArray addObject:student];\n        }\n    }\n    return _studentArray;\n}\n\n\n/** 获取随机字符串 */\n- (NSString *)randomStringWithLength:(NSInteger)length{\n    char data[length];\n    for (int x=0;x&lt;length;data[x++] = (char)(&#39;a&#39; + (arc4random_uniform(26))));\n    return [[NSString alloc] initWithBytes:data length:length encoding:NSUTF8StringEncoding];\n}\n\n@end\n</code></pre>\n<h2 id=\"二、谓词语法\"><a href=\"#二、谓词语法\" class=\"headerlink\" title=\"二、谓词语法\"></a>二、谓词语法</h2><h4 id=\"（1）替换\"><a href=\"#（1）替换\" class=\"headerlink\" title=\"（1）替换\"></a>（1）替换</h4><blockquote>\n<ul>\n<li>%@ 是对值为字符串，数字或者日期的对象的替换值。</li>\n<li>%K 是key path的替换值。</li>\n<li>$VARIABLE_NAME 是可以被NSPredicate -predicateWithSubstitutionVariables:替换的值。</li>\n</ul>\n</blockquote>\n<pre><code class=\"objectivec\">  //（%K,%d =\\== 使用）\n    // 分数为满分\n    NSPredicate *predicateA = [NSPredicate predicateWithFormat:@&quot;%K = %d&quot;,@&quot;score&quot;,100];\n    NSArray *caseA = [self.studentArray filteredArrayUsingPredicate:predicateA];\n\n    //（self、BEGINSWITH、[]、$ 使用）\n    // 名字以 ‘a’开头\n    NSPredicate *predicateB = [NSPredicate predicateWithFormat:@&quot;self.name BEGINSWITH[az] $beginningChar&quot;];\n    NSArray *caseB = [self.studentArray filteredArrayUsingPredicate:[predicateB predicateWithSubstitutionVariables:@{@&quot;beginningChar&quot;: @&quot;a&quot;}]];\n</code></pre>\n<h4 id=\"（2）比较运算符\"><a href=\"#（2）比较运算符\" class=\"headerlink\" title=\"（2）比较运算符\"></a>（2）比较运算符</h4><blockquote>\n<p>=, == ：左边的表达式和右边的表达式相等。<br>=, =&gt; ：左边的表达式大于或者等于右边的表达式。<br>&lt;=, =&lt; ：左边的表达式小于等于右边的表达式。<br>：左边的表达式大于右边的表达式。<br>&lt; ：左边的表达式小于右边的表达式。<br>!=, &lt;&gt; ：左边的表达式不等于右边的表达式。<br>BETWEEN ：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。</p>\n</blockquote>\n<pre><code class=\"objectivec\">// 比较运算符 =, ==  &gt;=, =&gt;  &lt;=, =&lt; &gt; &lt; !=, &lt;&gt; BETWEEN 使用\n    // 90~100 优等学生\n    NSPredicate *predicateC = [NSPredicate predicateWithFormat:@&quot;self.score BETWEEN {90,100}&quot;];\n    NSArray *caseC = [self.studentArray filteredArrayUsingPredicate:predicateC];\n</code></pre>\n<h4 id=\"（5）集合运算符\"><a href=\"#（5）集合运算符\" class=\"headerlink\" title=\"（5）集合运算符\"></a>（5）集合运算符</h4><blockquote>\n<p>ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。<br>ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。<br>NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY …)。<br>IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { ‘Ben’, ‘Melissa’, ‘Nick’ }。</p>\n</blockquote>\n<h4 id=\"（6）直接量\"><a href=\"#（6）直接量\" class=\"headerlink\" title=\"（6）直接量\"></a>（6）直接量</h4><blockquote>\n<p>FALSE、NO：代表逻辑假<br>TRUE、YES：代表逻辑真<br>NULL、NIL：代表空值<br>SELF：代表正在被判断的对象自身<br>“string”或’string’：代表字符串<br>数组：和c中的写法相同，如：{‘one’, ‘two’, ‘three’}。<br>数值：包括证书、小数和科学计数法表示的形式<br>十六进制数：0x开头的数字<br>八进制：0o开头的数字<br>二进制：0b开头的数字</p>\n</blockquote>\n<h4 id=\"（7）数组操作\"><a href=\"#（7）数组操作\" class=\"headerlink\" title=\"（7）数组操作\"></a>（7）数组操作</h4><blockquote>\n<p>array[index] ：指定数组中特定索引处的元素。<br>array[FIRST] ：指定数组中的第一个元素。<br>array[LAST] ：指定数组中的最后一个元素。<br>array[SIZE] ：指定数组的大小。</p>\n</blockquote>\n<p>####（8）布尔值谓词</p>\n<blockquote>\n<p>TRUEPREDICATE ：结果始终为真的谓词。<br>FALSEPREDICATE ：结果始终为假的谓词。</p>\n</blockquote>\n<p>####（9）Block谓词</p>\n<pre><code class=\"objectivec\">NSPredicate *shortNamePredicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary *bindings) {\n            return [[evaluatedObject firstName] length] &lt;= 5;\n        }];\nNSLog(@&quot;Short Names: %@&quot;, [people filteredArrayUsingPredicate:shortNamePredicate]);\n</code></pre>\n"},{"title":"OC中的load和initialize方法","date":"2017-06-01T05:58:22.000Z","_content":"## 1.load\n顾名思义，`load`方法在这个文件被程序装载时调用。只要是在`Compile Sources`中出现的文件总是会被装载，这与这个类是否被用到无关，因此`load`方法总是在`main`函数之前调用。\n\n##  (一) 调用规则\n如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：\n\n```objectivec\n// In Parent.m\n+ (void)load {\n    NSLog(@\"Load Class Parent\");\n}\n\n// In Child.m，继承自Parent\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n}\n\n// In Child+load.m，Child类的分类\n+ (void)load {\n    NSLog(@\"Load Class Child+load\");\n}\n\n// 运行结果：\n/*\n    2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n    2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n    2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/\n```\n\n如果一个类没有实现`load`方法，那么就不会调用它父类的`load`方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。\n\n##  (二)执行顺序\n`load`方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的`load`方法进行初始化设置，那么必须确保那个类的`load`方法已经调用了，比如这段代码，打印出的字符串就为`null`：\n\n```objectivec\n// In Child.m\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n\n    Other *other = [Other new];\n    [other originalFunc];\n\n    // 如果不先调用other的load，下面这行代码就无效，打印出null\n    [Other printName];\n}\n\n```\n\n`load`方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：\n![执行顺序](http://oqepgj2jp.bkt.clouddn.com/load%E5%92%8Cinitialize1.jpg)\n\n在`Compile Sources`中，文件的排放顺序就是其装载顺序，自然也就是`load`方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，`Parent`的`load`方法先于`Child`调用，而它的装载顺序其实在`Child`之后。\n\n虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。\n\n\n##  (三) 使用场景\n由于调用`load`方法时的环境很不安全，我们应该尽量减少`load`方法的逻辑。另一个原因是`load`方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在`load`方法中。\n\n一个常见的使用场景是在`load`方法中实现Method Swizzle：\n\n```objectivec\n// In Other.m\n+ (void)load {\n    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));\n    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));\n\n    method_exchangeImplementations(originalFunc, swizzledFunc);\n}\n```\n在`Child`类的`load`方法中，由于还没调用`Other`的`load`方法，所以输出结果是\"Original Output\"，而在main函数中，输出结果自然就变成了\"Swizzled Output\"。\n\n一般来说，除了Method Swizzle，别的逻辑都不应该放在`load`方法中实现。\n\n## 2.initialize\n\n这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。`initialize`方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的 `initialize`方法也不会被调用，这一点有利于节约资源。\n\n\n##  (一) 调用规则\n\n与`load`方法类似的是，在`initialize`方法内部也会调用父类的方法，而且不需要我们显示的写出来。与`load`方法不同之处在于，即使子类没有实现`initialize`方法，也会调用父类的方法，这会导致一个很严重的问题：\n\n```objectivec\n// In Parent.m\n+ (void)initialize {\n    NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n}\n\n// In Child.m\n// 注释掉initialize方法\n\n// In main.m\nChild *child = [Child new];\n```\n\n运行后发现父类的initialize方法竟然调用了两次：\n\n```objectivec\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child\n```\n\n这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的`initialize`方法，然后创建子类时，尽管自己没有实现`initialize`方法，但还是会调用到父类的方法。\n\n虽然`initialize`方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用`initialize`方法的姿势如下：\n\n```objectivec\n// In Parent.m\n+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n    }\n}\n```\n\n加上判断后，就不会因为子类而调用到自己的`initialize`方法了。\n\n##  (二) 使用场景\n\n`initialize`方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如`NSMutableArray`这种类型的实例化依赖于`runtime`的消息发送，所以显然无法在编译器初始化：\n\n```objectivec\n// In Parent.m\nstatic int someNumber = 0;     // int类型可以在编译期赋值\nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n        // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n```\n\n## 总结\n\n`load`和`initialize`方法都会在实例化对象之前调用，以`main`函数为分水岭，前者在`main`函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。\n`load`和`initialize`方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。\n`load`方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。\n`load`和`initialize`方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。\n\n","source":"_posts/OC中的load和initialize方法.md","raw":"---\ntitle: OC中的load和initialize方法\ndate: 2017-06-01 13:58:22\ncategories: \n\t- iOS合集\n---\n## 1.load\n顾名思义，`load`方法在这个文件被程序装载时调用。只要是在`Compile Sources`中出现的文件总是会被装载，这与这个类是否被用到无关，因此`load`方法总是在`main`函数之前调用。\n\n##  (一) 调用规则\n如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：\n\n```objectivec\n// In Parent.m\n+ (void)load {\n    NSLog(@\"Load Class Parent\");\n}\n\n// In Child.m，继承自Parent\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n}\n\n// In Child+load.m，Child类的分类\n+ (void)load {\n    NSLog(@\"Load Class Child+load\");\n}\n\n// 运行结果：\n/*\n    2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n    2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n    2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/\n```\n\n如果一个类没有实现`load`方法，那么就不会调用它父类的`load`方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。\n\n##  (二)执行顺序\n`load`方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的`load`方法进行初始化设置，那么必须确保那个类的`load`方法已经调用了，比如这段代码，打印出的字符串就为`null`：\n\n```objectivec\n// In Child.m\n+ (void)load {\n    NSLog(@\"Load Class Child\");\n\n    Other *other = [Other new];\n    [other originalFunc];\n\n    // 如果不先调用other的load，下面这行代码就无效，打印出null\n    [Other printName];\n}\n\n```\n\n`load`方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：\n![执行顺序](http://oqepgj2jp.bkt.clouddn.com/load%E5%92%8Cinitialize1.jpg)\n\n在`Compile Sources`中，文件的排放顺序就是其装载顺序，自然也就是`load`方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，`Parent`的`load`方法先于`Child`调用，而它的装载顺序其实在`Child`之后。\n\n虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。\n\n\n##  (三) 使用场景\n由于调用`load`方法时的环境很不安全，我们应该尽量减少`load`方法的逻辑。另一个原因是`load`方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在`load`方法中。\n\n一个常见的使用场景是在`load`方法中实现Method Swizzle：\n\n```objectivec\n// In Other.m\n+ (void)load {\n    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));\n    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));\n\n    method_exchangeImplementations(originalFunc, swizzledFunc);\n}\n```\n在`Child`类的`load`方法中，由于还没调用`Other`的`load`方法，所以输出结果是\"Original Output\"，而在main函数中，输出结果自然就变成了\"Swizzled Output\"。\n\n一般来说，除了Method Swizzle，别的逻辑都不应该放在`load`方法中实现。\n\n## 2.initialize\n\n这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。`initialize`方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的 `initialize`方法也不会被调用，这一点有利于节约资源。\n\n\n##  (一) 调用规则\n\n与`load`方法类似的是，在`initialize`方法内部也会调用父类的方法，而且不需要我们显示的写出来。与`load`方法不同之处在于，即使子类没有实现`initialize`方法，也会调用父类的方法，这会导致一个很严重的问题：\n\n```objectivec\n// In Parent.m\n+ (void)initialize {\n    NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n}\n\n// In Child.m\n// 注释掉initialize方法\n\n// In main.m\nChild *child = [Child new];\n```\n\n运行后发现父类的initialize方法竟然调用了两次：\n\n```objectivec\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child\n```\n\n这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的`initialize`方法，然后创建子类时，尽管自己没有实现`initialize`方法，但还是会调用到父类的方法。\n\n虽然`initialize`方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用`initialize`方法的姿势如下：\n\n```objectivec\n// In Parent.m\n+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@\"Initialize Parent, caller Class %@\", [self class]);\n    }\n}\n```\n\n加上判断后，就不会因为子类而调用到自己的`initialize`方法了。\n\n##  (二) 使用场景\n\n`initialize`方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如`NSMutableArray`这种类型的实例化依赖于`runtime`的消息发送，所以显然无法在编译器初始化：\n\n```objectivec\n// In Parent.m\nstatic int someNumber = 0;     // int类型可以在编译期赋值\nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n        // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n```\n\n## 总结\n\n`load`和`initialize`方法都会在实例化对象之前调用，以`main`函数为分水岭，前者在`main`函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。\n`load`和`initialize`方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。\n`load`方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。\n`load`和`initialize`方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。\n\n","slug":"OC中的load和initialize方法","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvl000jznuza2e1nrsk","content":"<h2 id=\"1-load\"><a href=\"#1-load\" class=\"headerlink\" title=\"1.load\"></a>1.load</h2><p>顾名思义，<code>load</code>方法在这个文件被程序装载时调用。只要是在<code>Compile Sources</code>中出现的文件总是会被装载，这与这个类是否被用到无关，因此<code>load</code>方法总是在<code>main</code>函数之前调用。</p>\n<h2 id=\"一-调用规则\"><a href=\"#一-调用规则\" class=\"headerlink\" title=\"(一) 调用规则\"></a>(一) 调用规则</h2><p>如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Parent.m</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>load <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Load Class Parent\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// In Child.m，继承自Parent</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>load <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Load Class Child\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// In Child+load.m，Child类的分类</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>load <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Load Class Child+load\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 运行结果：</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n    2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n    2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n    2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/</span>\n</code></pre>\n<p>如果一个类没有实现<code>load</code>方法，那么就不会调用它父类的<code>load</code>方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。</p>\n<h2 id=\"二-执行顺序\"><a href=\"#二-执行顺序\" class=\"headerlink\" title=\"(二)执行顺序\"></a>(二)执行顺序</h2><p><code>load</code>方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的<code>load</code>方法进行初始化设置，那么必须确保那个类的<code>load</code>方法已经调用了，比如这段代码，打印出的字符串就为<code>null</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Child.m</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>load <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Load Class Child\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Other <span class=\"token operator\">*</span>other <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Other new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>other originalFunc<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果不先调用other的load，下面这行代码就无效，打印出null</span>\n    <span class=\"token punctuation\">[</span>Other printName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>load</code>方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/load%E5%92%8Cinitialize1.jpg\" alt=\"执行顺序\"></p>\n<p>在<code>Compile Sources</code>中，文件的排放顺序就是其装载顺序，自然也就是<code>load</code>方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，<code>Parent</code>的<code>load</code>方法先于<code>Child</code>调用，而它的装载顺序其实在<code>Child</code>之后。</p>\n<p>虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。</p>\n<h2 id=\"三-使用场景\"><a href=\"#三-使用场景\" class=\"headerlink\" title=\"(三) 使用场景\"></a>(三) 使用场景</h2><p>由于调用<code>load</code>方法时的环境很不安全，我们应该尽量减少<code>load</code>方法的逻辑。另一个原因是<code>load</code>方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在<code>load</code>方法中。</p>\n<p>一个常见的使用场景是在<code>load</code>方法中实现Method Swizzle：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Other.m</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>load <span class=\"token punctuation\">{</span>\n    Method originalFunc <span class=\"token operator\">=</span> <span class=\"token function\">class_getInstanceMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>originalFunc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Method swizzledFunc <span class=\"token operator\">=</span> <span class=\"token function\">class_getInstanceMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>swizzledFunc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">method_exchangeImplementations</span><span class=\"token punctuation\">(</span>originalFunc<span class=\"token punctuation\">,</span> swizzledFunc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在<code>Child</code>类的<code>load</code>方法中，由于还没调用<code>Other</code>的<code>load</code>方法，所以输出结果是”Original Output”，而在main函数中，输出结果自然就变成了”Swizzled Output”。</p>\n<p>一般来说，除了Method Swizzle，别的逻辑都不应该放在<code>load</code>方法中实现。</p>\n<h2 id=\"2-initialize\"><a href=\"#2-initialize\" class=\"headerlink\" title=\"2.initialize\"></a>2.initialize</h2><p>这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。<code>initialize</code>方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的 <code>initialize</code>方法也不会被调用，这一点有利于节约资源。</p>\n<h2 id=\"一-调用规则-1\"><a href=\"#一-调用规则-1\" class=\"headerlink\" title=\"(一) 调用规则\"></a>(一) 调用规则</h2><p>与<code>load</code>方法类似的是，在<code>initialize</code>方法内部也会调用父类的方法，而且不需要我们显示的写出来。与<code>load</code>方法不同之处在于，即使子类没有实现<code>initialize</code>方法，也会调用父类的方法，这会导致一个很严重的问题：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Parent.m</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>initialize <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Initialize Parent, caller Class %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// In Child.m</span>\n<span class=\"token comment\" spellcheck=\"true\">// 注释掉initialize方法</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// In main.m</span>\nChild <span class=\"token operator\">*</span>child <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Child new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>运行后发现父类的initialize方法竟然调用了两次：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token number\">2016</span><span class=\"token operator\">-</span><span class=\"token number\">02</span><span class=\"token operator\">-</span><span class=\"token number\">01</span> <span class=\"token number\">22</span><span class=\"token punctuation\">:</span><span class=\"token number\">57</span><span class=\"token punctuation\">:</span><span class=\"token number\">02.985</span> load<span class=\"token punctuation\">[</span><span class=\"token number\">12772</span><span class=\"token punctuation\">:</span><span class=\"token number\">1509345</span><span class=\"token punctuation\">]</span> Initialize Parent<span class=\"token punctuation\">,</span> caller Class Parent\n<span class=\"token number\">2016</span><span class=\"token operator\">-</span><span class=\"token number\">02</span><span class=\"token operator\">-</span><span class=\"token number\">01</span> <span class=\"token number\">22</span><span class=\"token punctuation\">:</span><span class=\"token number\">57</span><span class=\"token punctuation\">:</span><span class=\"token number\">02.985</span> load<span class=\"token punctuation\">[</span><span class=\"token number\">12772</span><span class=\"token punctuation\">:</span><span class=\"token number\">1509345</span><span class=\"token punctuation\">]</span> Initialize Parent<span class=\"token punctuation\">,</span> caller Class Child\n</code></pre>\n<p>这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的<code>initialize</code>方法，然后创建子类时，尽管自己没有实现<code>initialize</code>方法，但还是会调用到父类的方法。</p>\n<p>虽然<code>initialize</code>方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用<code>initialize</code>方法的姿势如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Parent.m</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>initialize <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>Parent class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Initialize Parent, caller Class %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>加上判断后，就不会因为子类而调用到自己的<code>initialize</code>方法了。</p>\n<h2 id=\"二-使用场景\"><a href=\"#二-使用场景\" class=\"headerlink\" title=\"(二) 使用场景\"></a>(二) 使用场景</h2><p><code>initialize</code>方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如<code>NSMutableArray</code>这种类型的实例化依赖于<code>runtime</code>的消息发送，所以显然无法在编译器初始化：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// In Parent.m</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> someNumber <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// int类型可以在编译期赋值</span>\n<span class=\"token keyword\">static</span> NSMutableArray <span class=\"token operator\">*</span>someObjects<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>initialize <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>Parent class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 不方便编译期复制的对象在这里赋值</span>\n        someObjects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableArray alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>load</code>和<code>initialize</code>方法都会在实例化对象之前调用，以<code>main</code>函数为分水岭，前者在<code>main</code>函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。<br><code>load</code>和<code>initialize</code>方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。<br><code>load</code>方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。<br><code>load</code>和<code>initialize</code>方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h2 id=\"1-load\"><a href=\"#1-load\" class=\"headerlink\" title=\"1.load\"></a>1.load</h2><p>顾名思义，<code>load</code>方法在这个文件被程序装载时调用。只要是在<code>Compile Sources</code>中出现的文件总是会被装载，这与这个类是否被用到无关，因此<code>load</code>方法总是在<code>main</code>函数之前调用。</p>\n<h2 id=\"一-调用规则\"><a href=\"#一-调用规则\" class=\"headerlink\" title=\"(一) 调用规则\"></a>(一) 调用规则</h2><p>如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：</p>\n<pre><code class=\"objectivec\">// In Parent.m\n+ (void)load {\n    NSLog(@&quot;Load Class Parent&quot;);\n}\n\n// In Child.m，继承自Parent\n+ (void)load {\n    NSLog(@&quot;Load Class Child&quot;);\n}\n\n// In Child+load.m，Child类的分类\n+ (void)load {\n    NSLog(@&quot;Load Class Child+load&quot;);\n}\n\n// 运行结果：\n/*\n    2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent\n    2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child\n    2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load\n*/\n</code></pre>\n<p>如果一个类没有实现<code>load</code>方法，那么就不会调用它父类的<code>load</code>方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。</p>\n<h2 id=\"二-执行顺序\"><a href=\"#二-执行顺序\" class=\"headerlink\" title=\"(二)执行顺序\"></a>(二)执行顺序</h2><p><code>load</code>方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的<code>load</code>方法进行初始化设置，那么必须确保那个类的<code>load</code>方法已经调用了，比如这段代码，打印出的字符串就为<code>null</code>：</p>\n<pre><code class=\"objectivec\">// In Child.m\n+ (void)load {\n    NSLog(@&quot;Load Class Child&quot;);\n\n    Other *other = [Other new];\n    [other originalFunc];\n\n    // 如果不先调用other的load，下面这行代码就无效，打印出null\n    [Other printName];\n}\n</code></pre>\n<p><code>load</code>方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/load%E5%92%8Cinitialize1.jpg\" alt=\"执行顺序\"></p>\n<p>在<code>Compile Sources</code>中，文件的排放顺序就是其装载顺序，自然也就是<code>load</code>方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，<code>Parent</code>的<code>load</code>方法先于<code>Child</code>调用，而它的装载顺序其实在<code>Child</code>之后。</p>\n<p>虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。</p>\n<h2 id=\"三-使用场景\"><a href=\"#三-使用场景\" class=\"headerlink\" title=\"(三) 使用场景\"></a>(三) 使用场景</h2><p>由于调用<code>load</code>方法时的环境很不安全，我们应该尽量减少<code>load</code>方法的逻辑。另一个原因是<code>load</code>方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在<code>load</code>方法中。</p>\n<p>一个常见的使用场景是在<code>load</code>方法中实现Method Swizzle：</p>\n<pre><code class=\"objectivec\">// In Other.m\n+ (void)load {\n    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));\n    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));\n\n    method_exchangeImplementations(originalFunc, swizzledFunc);\n}\n</code></pre>\n<p>在<code>Child</code>类的<code>load</code>方法中，由于还没调用<code>Other</code>的<code>load</code>方法，所以输出结果是”Original Output”，而在main函数中，输出结果自然就变成了”Swizzled Output”。</p>\n<p>一般来说，除了Method Swizzle，别的逻辑都不应该放在<code>load</code>方法中实现。</p>\n<h2 id=\"2-initialize\"><a href=\"#2-initialize\" class=\"headerlink\" title=\"2.initialize\"></a>2.initialize</h2><p>这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。<code>initialize</code>方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的 <code>initialize</code>方法也不会被调用，这一点有利于节约资源。</p>\n<h2 id=\"一-调用规则-1\"><a href=\"#一-调用规则-1\" class=\"headerlink\" title=\"(一) 调用规则\"></a>(一) 调用规则</h2><p>与<code>load</code>方法类似的是，在<code>initialize</code>方法内部也会调用父类的方法，而且不需要我们显示的写出来。与<code>load</code>方法不同之处在于，即使子类没有实现<code>initialize</code>方法，也会调用父类的方法，这会导致一个很严重的问题：</p>\n<pre><code class=\"objectivec\">// In Parent.m\n+ (void)initialize {\n    NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);\n}\n\n// In Child.m\n// 注释掉initialize方法\n\n// In main.m\nChild *child = [Child new];\n</code></pre>\n<p>运行后发现父类的initialize方法竟然调用了两次：</p>\n<pre><code class=\"objectivec\">2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent\n2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child\n</code></pre>\n<p>这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的<code>initialize</code>方法，然后创建子类时，尽管自己没有实现<code>initialize</code>方法，但还是会调用到父类的方法。</p>\n<p>虽然<code>initialize</code>方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用<code>initialize</code>方法的姿势如下：</p>\n<pre><code class=\"objectivec\">// In Parent.m\n+ (void)initialize {\n    if (self == [Parent class]) {\n        NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);\n    }\n}\n</code></pre>\n<p>加上判断后，就不会因为子类而调用到自己的<code>initialize</code>方法了。</p>\n<h2 id=\"二-使用场景\"><a href=\"#二-使用场景\" class=\"headerlink\" title=\"(二) 使用场景\"></a>(二) 使用场景</h2><p><code>initialize</code>方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如<code>NSMutableArray</code>这种类型的实例化依赖于<code>runtime</code>的消息发送，所以显然无法在编译器初始化：</p>\n<pre><code class=\"objectivec\">// In Parent.m\nstatic int someNumber = 0;     // int类型可以在编译期赋值\nstatic NSMutableArray *someObjects;\n\n+ (void)initialize {\n    if (self == [Parent class]) {\n        // 不方便编译期复制的对象在这里赋值\n        someObjects = [[NSMutableArray alloc] init];\n    }\n}\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>load</code>和<code>initialize</code>方法都会在实例化对象之前调用，以<code>main</code>函数为分水岭，前者在<code>main</code>函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。<br><code>load</code>和<code>initialize</code>方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。<br><code>load</code>方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。<br><code>load</code>和<code>initialize</code>方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</p>\n"},{"title":"HTTPS小解析","date":"2017-06-17T14:59:42.000Z","_content":"####  一、HTTPS介绍\n\n超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。\n\nHTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。\n\nhttp协议直接放置在TCP协议之上，而HTTPS提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。所以严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。\n\n下面是一个简单的HTTPS协议栈的图：\n![](http://oqepgj2jp.bkt.clouddn.com/https1.png)\n\n---\n\n####  二、HTTPS流程步骤\n\n上面已经说过HTTPS主要是加了一层SSL/TLS加密，那么具体是如何进行加密，解密，验证的，且看下图：\n![](http://oqepgj2jp.bkt.clouddn.com/https2.png)\n\n\n###### 1. 客户端发起HTTPS请求\n这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。\n\n###### 2. 服务端的配置\n采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。\n\n###### 3. 传送证书\n这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。\n\n###### 4. 客户端解析证书\n这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。\n\n###### 5. 传送加密信息\n这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。\n\n###### 6. 服务端解密信息\n服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。\n\n###### 7. 传输加密后的信息\n这部分信息是服务段用私钥加密后的信息，可以在客户端被还原\n\n###### 8. 客户端解密信息\n客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。\n\n---\n\n####  三、SSL/TLS概念\n\nSSL/TLS是加密通信协议，SSL由NetScape在1994年设计，1999年互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。现在主流的浏览器等都支持TLS1.2版本，如iOS9中新增App Transport Security（简称ATS）特性，强制http转向https，其中加密通信协议就需要TLS1.2及以上版本。\n\nSSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\nSSL/TLS协议的基本过程是这样的：\n\n```\n（1） 客户端向服务器端索要并验证公钥。\n（2） 双方协商生成\"对话密钥\"。\n（3） 双方采用\"对话密钥\"进行加密通信。\n```\n所以说SSL/TLS协议主要是包含非对称加密（公钥加密）和对称加密，用非对称加密来得到对称加密的\"对话秘钥\"，然后用对称加密来进行加密通信。\n\n\n####  四、两个问题\n\n- 如何保证公钥不被篡改？\n\n> 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。那如何保证证书是可信的呢？证书由CA机构进行颁发，而游览器内置了这些CA机构的根证书，只要由这些CA机构办法的数字证书即是可信的。\n\n- 为什么不直接使用公钥加密，还要加上个对称加密？\n\n> 公钥加密是非对称加密，加密计算量大，而对称加密运算速度非常快。所以这里只有第一次握手时进行公钥加密来得到对称加密的\"对话密钥\"，之后的通信就使用对称加密来进行通信了。\n\n####  五、加密算法\n\n- 对称密码算法\n\n> 是指加密和解密使用相同的密钥，典型的有DES、RC5、IDEA（分组加密），RC4（序列加密）；\n\n- 非对称密码算法\n\n> 又称为公钥加密算法，是指加密和解密使用不同的密钥（公开的公钥用于加密，私有的私钥用于解密）。比如A发送，B接收，A想确保消息只有B看到，需要B生成一对公私钥，并拿到B的公钥。于是A用这个公钥加密消息，B收到密文后用自己的与之匹配的私钥解密即可。反过来也可以用私钥加密公钥解密。也就是说对于给定的公钥有且只有与之匹配的私钥可以解密，对于给定的私钥，有且只有与之匹配的公钥可以解密。典型的算法有RSA，DSA，DH；\n\n- 散列算法\n\n> 散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。因此，散列变换通常用于验证原文是否被篡改。典型的算法有：MD5，SHA，Base64，CRC等。\n\n---\n\n####  六、关于CA及数字证书\n\n- 什么是CA\n\nCA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构。\n\nCA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理。\n\nCA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。\n如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。\n\n如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。\n\n- 证书的内容\n\n数字证书的格式遵循X.509标准，X.509是由国际电信联盟（ITU-T）制定的数字证书标准，规范了公开密钥认证、证书吊销列表、授权证书、证书路径验证算法等。\n\n证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。\n\n下图就表示一个数字证书包含的内容：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https3.png)\n\n> 我们这里能看到颁发机构签名是由申请者信息经过哈希算法得到hash值，然后再用机构的私钥进行加密。所以这个签名只有办法机构的公钥才能解密，而一般权威CA机构的根证书（含公钥）都内置在浏览器中，所以客户端接收到这个数字证书后，先把申请者信息用同样的哈希算法得到hash值h1，然后用公钥进行办法机构签名解密得到hash值h2，如果h1==h2，则表示证书是有效的。\n\n下图就是Charles的根证书例子：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https4.png)\n\n####  七、编码格式\n\n同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式。\n\n**PEM** - Privacy Enhanced Mail,打开看文本格式,以\"-----BEGIN...\"开头, \"-----END...\"结尾,内容是BASE64编码.\n查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout\nApache和*NIX服务器偏向于使用这种编码格式.\n\n**DER** - Distinguished Encoding Rules,打开看是二进制格式,不可读.\n查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout\nJava和Windows服务器偏向于使用这种编码格式.\n\n####  八、相关的文件扩展名\n\n这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫\"PEM\"或者\"DER\",常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式。\n\n**CRT** - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.\n\n**CER** - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.\n\n**KEY** - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER。\n查看KEY的办法:`openssl rsa -in mykey.key -text -noout`\n如果是DER格式的话:`openssl rsa -in mykey.key -text -noout -inform der`\n\n**CSR** - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。\n查看的办法:`openssl req -noout -text -in my.csr`\n如果是DER格式的话:`openssl req -noout -text -in my.csr -inform der`\n\n**PFX/P12** - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个\"提取密码\",你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？\n`openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes`\n这个时候会提示你输入提取代码. for-iis.pem就是可读的文本。\n生成pfx的命令类似这样:`openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out` `certificate.pfx -certfile CACert.crt`\n\n其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.\n\n**JKS** - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫\"keytool\"的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了。\n\n####  九、证书编码的转换\n\n- .crt转.der方法\n\n`openssl x509 -in cert.crt -out cert.der -outform DER`\n\n- .crt转.cer方法\n\n`openssl x509 -in cert.crt -out cert.cer -outform DER`\n\n- .crt转.pem方法\n\n`openssl x509 -in cert.crt -out cert.pem -outform PEM`\n\n\n####  十、生成自签名证书的步骤\n\n###### 建立CA\n\n- 在任意目录建立文件夹，文件夹名称任意\n\n```\nmkdir ca\n```\n\n- 进入到新建立的文件夹ca\n\n```\nd ca\n```\n\n- 生成CA私钥\n\n```\nopenssl genrsa -out ca.key 2048\n```\n\n- 用CA私钥生成CA的证书\n\n```\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \n\"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng\"\n```\n\n- 建立CA相应目录\n\n```\nmkdir demoCA\ncd demoCA/\n\nmkdir newcerts\n\ntouch index.txt\n\necho '01' > serial\n```\n\n###### 生成server端证书\n\n- 进入ca文件夹\n\n```\ncd ca\n```\n\n\n- 生成server私钥\n\n```\nopenssl genrsa -out server.key 2048\n```\n\n- 使用server私钥生成server端证书请求文件\n\n```\nopenssl req -new -key server.key -out server.csr -subj \"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=dasheng/CN=dasheng\"\n```\n\n- 使用server证书请求文件通过CA生成自签名证书\n\n```\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key\n```\n\n- 验证server证书\n\n```\nopenssl verify -CAfile ca.crt server.crt\n```\n\n###### 测试\n\n- 使用server证书测试单向认证\n\n- 打开窗口1启动server\n\n```\nopenssl s_server -accept 10001 -key server.key -cert server.crt\n```\n\n- 打开窗口2启动客户端\n\n```\nopenssl s_client -connect localhost:10001\n```\n\n- 连接成功后在任意一个窗口输入字符串会传输到另外一个窗口回显。\n\n###### 脚本\n[快速创建证书的脚本](http://ofcckdrlc.bkt.clouddn.com/generate_certificate.sh)\n使用（host表示证书用于的域名，cerFile表示证书保存的目录）：\n\n```\nsh ./generate_certificate.sh host cerFile\n```\n\n####  十一、信任自签名证书\n\n###### 查看证书链\n\nChrome57及后续版本Chrome浏览器用户如要查看SSL证书信息只能通过开发者工具（右键->检查），选择安全标签（Security）进行查看了。然后点击View certificate查看证书链，如下图为查看www.google.com的证书链：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https5.png)\n\n![](http://oqepgj2jp.bkt.clouddn.com/https6.png)\n\n###### 信任证书\n\n在MAC上直接双击证书，然后在钥匙串里就能看到这个证书了，我们能看到证书上会显示此证书是由不被信任的签发者签发的或此根证书不被信任。然后我们再在钥匙串中双击证书->信任->使用此证书时：始终信任。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https7.png)\n\n这里我们可以信任两种证书：CA根证书和CA签名过的数字证书。两种证书在钥匙串中显示的颜色是不一样的。\n\n下图就是自己创建的两种证书：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https8.png)\n\n![](http://oqepgj2jp.bkt.clouddn.com/https9.png)\n\n我们信任两种证书都可以使请求变成安全的请求，在浏览器中输入的时候就不会有不安全的提示了。这里说一下为什么两种证书都可以。\n\n首先说CA根证书，这种就是我们正常的流程，CA根证书用公钥解密数字证书的签名得到hash值，然后根据hash值相等判断证书有效。\n而不信任根证书只信任数字证书，就很容易理解了，他们本来就是同一张证书，也不用通过加密解密什么的来判断了。\n\n\n####  十二、Chrome信任根证书后提示链接不安全\n\n这里我信任根证书之后还是提示链接不安全：`ERR_CERT_WEAK_SIGNATURE_ALGORITHM`。而信任数字证书则没问题。发生这种情况的原因是`Chrome 57`版本以后是不支持SHA-1算出的hash值的证书签名的，而我们上面生成的证书默认为SHA-1，这里只要改为SHA-256就可以了。\n\n```\n//用CA私钥生成CA的证书\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng\" -sha256\n\n//使用server证书请求文件通过CA生成自签名证书\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -sha256\n```\n\n####  十三、获取证书小技巧\n\n有时候我们没有这个网站的证书，那要如何得到呢？\n\n###### 1、使用openssl能直接得到这个证书:\n\n```\nopenssl s_client -connect 172.16.10.244:8000 </dev/null 2>/dev/null | openssl x509 -outform DER > https.cer\n```\n\n###### 2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https10.png)\n\n---\n\n####  十四、iOS中使用自签名证书\n\niOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。一般如果我们HTTPS服务使用的证书是CA权威机构颁发的话，客户端不用修改任何代码，因为iOS系统已经内置了这些权威机构的根证书。但是如果是自签名的证书的话就需要修改代码来内部信任这部分证书了。\n\n###### AFNetworking使用自签名证书\n\nAFNetWorking封装了如何使用自签名证书，简单的使用方式如下。\n\n```objectivec\n//先导入证书，找到证书的路径\nNSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"cert\" ofType:@\"der\"];\nNSData *certData = [NSData dataWithContentsOfFile:cerPath];\nNSSet * certSet = [[NSSet alloc] initWithObjects:certData, nil];\n\n//AFSSLPinningModeNone 这个模式表示不做 SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。\n\n//AFSSLPinningModeCertificate 这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。\n\n//AFSSLPinningModePublicKey 这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。\n\nAFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];\n// 是否允许,NO-- 不允许无效的证书\n[securityPolicy setAllowInvalidCertificates:YES];\n// 设置证书\n[securityPolicy setPinnedCertificates:certSet];\n//是否验证域名信息\nsecurityPolicy.validatesDomainName = NO;\n\n\nAFHTTPSessionManager *manager = [[AFHTTPSessionManager manager] initWithBaseURL:[NSURL URLWithString:@\"https://192.168.3.13:8000\"]];\nmanager.securityPolicy = securityPolicy;\nmanager.responseSerializer = [AFHTTPResponseSerializer serializer];\n[manager GET:@\"/getInfo\" parameters:@{@\"t\":@\"1490927497.569\"} progress:^(NSProgress * progress){\n} success:^(NSURLSessionDataTask *task, id responseObject) {\n    NSArray * array = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableLeaves error:nil];\n    NSLog(@\"OK === %@\",array);\n} failure:^(NSURLSessionDataTask *task, NSError *error) {\n    NSLog(@\"error ==%@\",error.description);\n}];\n```\n\n###### 证书需要满足的条件\n\n这里的证书使用CA根证书或CA签名的数字证书都可以。\n\n密钥交换算法有`RSA`和`ECDHE`，RSA 历史悠久，支持度好，但不支持 PFS（Perfect Forward Secrecy）；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，支持 PFS。\n\niOS支持的秘钥交换算法为：至少**2048位的 RSA 密钥或至少256位的 ECC 密钥**\n\n服务器证书的哈希算法必须为 SHA-2，其摘要长度至少位256位。\n\n证书格式为.der，很多网上的教程都写的是.cer，应该是使用的旧版AFNetWorking，最新版的不支持.cer，需要使用.der格式。\n\n---\n\n####  十五、中间人攻击\n\n###### 概念\n\n关于Https最常讲到的就是中间人攻击，即所谓的Man-in-the-middle attack(MITM)。也就是攻击者插入原先攻击的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改。\n\n其实http的中间人攻击是最简单的，因为http都是通过明文传输，而且没有任何认证之类的东西。我们常常用的Charles抓包就是一个最简单的中间人攻击。\n\n###### 对HTTPS进行中间人攻击\n\n我们用Charles进行HTTPS的抓包的时候会发现抓到的包都是加过密的无法查看，那是不是就意味着无法抓取HTTPS的包了呢？其实也是可以的，通过伪造证书，并且客户端又安装了Charles根证书，就可以抓取到HTTPS的包并解密了。\n\n具体的步骤是这样的，手机安装Charles根证书，手机使用Charles的代理，所有请求都经过Charles中间人。Charles劫持到请求，替换服务端的证书为自己的伪证书，然后发送给客户端，客户端使用Charles根证书来验证这个伪证书，验证通过得到公钥，然后用公钥加密对话秘钥发送回Charles中间人，Charles中间人私用私钥解密得到对话秘钥并保存，然后再把对话秘钥用服务端的公钥加密返回给服务端，这样就表示两端握手成功，可以进行通信了。而且中间人也获得了之后的对话秘钥，可以解密之后的对话信息。\n\n###### Charles实现HTTPS抓包\n\n这里基本的HTTP抓包的设置就不讲了，下面是基于实现基本的HTTP抓包的基础上来实现HTTPS的抓包解密。\n\n- 安装Charles CA根证书\n点击`Help->SSL Proxying->Install Charles Root Certification ...`，会弹出如下提示，链接代理，手机浏览器输入`chls.pro/ssl`，就可以安装根证书了。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https11.png)\n\n- 设置SSL代理\n点击`Proxy->SSL Proxying Setting`，勾选`Enable SSL Proxying`，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https12.png)\n\n或者在对应的请求上右键选择`Enable SSL Proxying`，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https13.png)\n\n做完上述步骤后重新请求就能得到解密后的信息了。抓取PC端的HTTPS包也类似，在`Help->SSL Proxying`中下载证书，双击安装证书，并选择始终信任即可。\n\n---\n\n#### 参考\n[超文本传输安全协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE)\n[图解HTTPS](http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html)\n[HTTPS从原理到应用](http://www.jianshu.com/p/e767a4e9252e)\n[那些证书相关的玩意儿](http://www.cnblogs.com/guogangj/p/4118605.html)\n[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n[SSL/TLS协议及Openssl工具的实现](http://www.jianshu.com/p/da65e5cd552e)\n[openssl自签名证书生成与单双向验证](http://blog.csdn.net/gx_1983/article/details/47866537)\n[iOS 10 适配 ATS](http://www.jianshu.com/p/36ddc5b009a7)\n[iOS安全系列之一：HTTPS](http://oncenote.com/2014/10/21/Security-1-HTTPS/)\n[iOS安全系列之二：HTTPS进阶](http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm)\n\n\n\n","source":"_posts/HTTPS小解析.md","raw":"---\ntitle: HTTPS小解析\ndate: 2017-06-17 22:59:42\ncategories: \n\t- iOS合集\n---\n####  一、HTTPS介绍\n\n超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。\n\nHTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。\n\nhttp协议直接放置在TCP协议之上，而HTTPS提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。所以严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。\n\n下面是一个简单的HTTPS协议栈的图：\n![](http://oqepgj2jp.bkt.clouddn.com/https1.png)\n\n---\n\n####  二、HTTPS流程步骤\n\n上面已经说过HTTPS主要是加了一层SSL/TLS加密，那么具体是如何进行加密，解密，验证的，且看下图：\n![](http://oqepgj2jp.bkt.clouddn.com/https2.png)\n\n\n###### 1. 客户端发起HTTPS请求\n这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。\n\n###### 2. 服务端的配置\n采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。\n\n###### 3. 传送证书\n这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。\n\n###### 4. 客户端解析证书\n这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。\n\n###### 5. 传送加密信息\n这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。\n\n###### 6. 服务端解密信息\n服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。\n\n###### 7. 传输加密后的信息\n这部分信息是服务段用私钥加密后的信息，可以在客户端被还原\n\n###### 8. 客户端解密信息\n客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。\n\n---\n\n####  三、SSL/TLS概念\n\nSSL/TLS是加密通信协议，SSL由NetScape在1994年设计，1999年互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。现在主流的浏览器等都支持TLS1.2版本，如iOS9中新增App Transport Security（简称ATS）特性，强制http转向https，其中加密通信协议就需要TLS1.2及以上版本。\n\nSSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\nSSL/TLS协议的基本过程是这样的：\n\n```\n（1） 客户端向服务器端索要并验证公钥。\n（2） 双方协商生成\"对话密钥\"。\n（3） 双方采用\"对话密钥\"进行加密通信。\n```\n所以说SSL/TLS协议主要是包含非对称加密（公钥加密）和对称加密，用非对称加密来得到对称加密的\"对话秘钥\"，然后用对称加密来进行加密通信。\n\n\n####  四、两个问题\n\n- 如何保证公钥不被篡改？\n\n> 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。那如何保证证书是可信的呢？证书由CA机构进行颁发，而游览器内置了这些CA机构的根证书，只要由这些CA机构办法的数字证书即是可信的。\n\n- 为什么不直接使用公钥加密，还要加上个对称加密？\n\n> 公钥加密是非对称加密，加密计算量大，而对称加密运算速度非常快。所以这里只有第一次握手时进行公钥加密来得到对称加密的\"对话密钥\"，之后的通信就使用对称加密来进行通信了。\n\n####  五、加密算法\n\n- 对称密码算法\n\n> 是指加密和解密使用相同的密钥，典型的有DES、RC5、IDEA（分组加密），RC4（序列加密）；\n\n- 非对称密码算法\n\n> 又称为公钥加密算法，是指加密和解密使用不同的密钥（公开的公钥用于加密，私有的私钥用于解密）。比如A发送，B接收，A想确保消息只有B看到，需要B生成一对公私钥，并拿到B的公钥。于是A用这个公钥加密消息，B收到密文后用自己的与之匹配的私钥解密即可。反过来也可以用私钥加密公钥解密。也就是说对于给定的公钥有且只有与之匹配的私钥可以解密，对于给定的私钥，有且只有与之匹配的公钥可以解密。典型的算法有RSA，DSA，DH；\n\n- 散列算法\n\n> 散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。因此，散列变换通常用于验证原文是否被篡改。典型的算法有：MD5，SHA，Base64，CRC等。\n\n---\n\n####  六、关于CA及数字证书\n\n- 什么是CA\n\nCA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构。\n\nCA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理。\n\nCA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。\n如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。\n\n如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。\n\n- 证书的内容\n\n数字证书的格式遵循X.509标准，X.509是由国际电信联盟（ITU-T）制定的数字证书标准，规范了公开密钥认证、证书吊销列表、授权证书、证书路径验证算法等。\n\n证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。\n\n下图就表示一个数字证书包含的内容：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https3.png)\n\n> 我们这里能看到颁发机构签名是由申请者信息经过哈希算法得到hash值，然后再用机构的私钥进行加密。所以这个签名只有办法机构的公钥才能解密，而一般权威CA机构的根证书（含公钥）都内置在浏览器中，所以客户端接收到这个数字证书后，先把申请者信息用同样的哈希算法得到hash值h1，然后用公钥进行办法机构签名解密得到hash值h2，如果h1==h2，则表示证书是有效的。\n\n下图就是Charles的根证书例子：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https4.png)\n\n####  七、编码格式\n\n同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式。\n\n**PEM** - Privacy Enhanced Mail,打开看文本格式,以\"-----BEGIN...\"开头, \"-----END...\"结尾,内容是BASE64编码.\n查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout\nApache和*NIX服务器偏向于使用这种编码格式.\n\n**DER** - Distinguished Encoding Rules,打开看是二进制格式,不可读.\n查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout\nJava和Windows服务器偏向于使用这种编码格式.\n\n####  八、相关的文件扩展名\n\n这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫\"PEM\"或者\"DER\",常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式。\n\n**CRT** - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.\n\n**CER** - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.\n\n**KEY** - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER。\n查看KEY的办法:`openssl rsa -in mykey.key -text -noout`\n如果是DER格式的话:`openssl rsa -in mykey.key -text -noout -inform der`\n\n**CSR** - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。\n查看的办法:`openssl req -noout -text -in my.csr`\n如果是DER格式的话:`openssl req -noout -text -in my.csr -inform der`\n\n**PFX/P12** - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个\"提取密码\",你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？\n`openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes`\n这个时候会提示你输入提取代码. for-iis.pem就是可读的文本。\n生成pfx的命令类似这样:`openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out` `certificate.pfx -certfile CACert.crt`\n\n其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.\n\n**JKS** - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫\"keytool\"的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了。\n\n####  九、证书编码的转换\n\n- .crt转.der方法\n\n`openssl x509 -in cert.crt -out cert.der -outform DER`\n\n- .crt转.cer方法\n\n`openssl x509 -in cert.crt -out cert.cer -outform DER`\n\n- .crt转.pem方法\n\n`openssl x509 -in cert.crt -out cert.pem -outform PEM`\n\n\n####  十、生成自签名证书的步骤\n\n###### 建立CA\n\n- 在任意目录建立文件夹，文件夹名称任意\n\n```\nmkdir ca\n```\n\n- 进入到新建立的文件夹ca\n\n```\nd ca\n```\n\n- 生成CA私钥\n\n```\nopenssl genrsa -out ca.key 2048\n```\n\n- 用CA私钥生成CA的证书\n\n```\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \n\"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng\"\n```\n\n- 建立CA相应目录\n\n```\nmkdir demoCA\ncd demoCA/\n\nmkdir newcerts\n\ntouch index.txt\n\necho '01' > serial\n```\n\n###### 生成server端证书\n\n- 进入ca文件夹\n\n```\ncd ca\n```\n\n\n- 生成server私钥\n\n```\nopenssl genrsa -out server.key 2048\n```\n\n- 使用server私钥生成server端证书请求文件\n\n```\nopenssl req -new -key server.key -out server.csr -subj \"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=dasheng/CN=dasheng\"\n```\n\n- 使用server证书请求文件通过CA生成自签名证书\n\n```\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key\n```\n\n- 验证server证书\n\n```\nopenssl verify -CAfile ca.crt server.crt\n```\n\n###### 测试\n\n- 使用server证书测试单向认证\n\n- 打开窗口1启动server\n\n```\nopenssl s_server -accept 10001 -key server.key -cert server.crt\n```\n\n- 打开窗口2启动客户端\n\n```\nopenssl s_client -connect localhost:10001\n```\n\n- 连接成功后在任意一个窗口输入字符串会传输到另外一个窗口回显。\n\n###### 脚本\n[快速创建证书的脚本](http://ofcckdrlc.bkt.clouddn.com/generate_certificate.sh)\n使用（host表示证书用于的域名，cerFile表示证书保存的目录）：\n\n```\nsh ./generate_certificate.sh host cerFile\n```\n\n####  十一、信任自签名证书\n\n###### 查看证书链\n\nChrome57及后续版本Chrome浏览器用户如要查看SSL证书信息只能通过开发者工具（右键->检查），选择安全标签（Security）进行查看了。然后点击View certificate查看证书链，如下图为查看www.google.com的证书链：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https5.png)\n\n![](http://oqepgj2jp.bkt.clouddn.com/https6.png)\n\n###### 信任证书\n\n在MAC上直接双击证书，然后在钥匙串里就能看到这个证书了，我们能看到证书上会显示此证书是由不被信任的签发者签发的或此根证书不被信任。然后我们再在钥匙串中双击证书->信任->使用此证书时：始终信任。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https7.png)\n\n这里我们可以信任两种证书：CA根证书和CA签名过的数字证书。两种证书在钥匙串中显示的颜色是不一样的。\n\n下图就是自己创建的两种证书：\n\n![](http://oqepgj2jp.bkt.clouddn.com/https8.png)\n\n![](http://oqepgj2jp.bkt.clouddn.com/https9.png)\n\n我们信任两种证书都可以使请求变成安全的请求，在浏览器中输入的时候就不会有不安全的提示了。这里说一下为什么两种证书都可以。\n\n首先说CA根证书，这种就是我们正常的流程，CA根证书用公钥解密数字证书的签名得到hash值，然后根据hash值相等判断证书有效。\n而不信任根证书只信任数字证书，就很容易理解了，他们本来就是同一张证书，也不用通过加密解密什么的来判断了。\n\n\n####  十二、Chrome信任根证书后提示链接不安全\n\n这里我信任根证书之后还是提示链接不安全：`ERR_CERT_WEAK_SIGNATURE_ALGORITHM`。而信任数字证书则没问题。发生这种情况的原因是`Chrome 57`版本以后是不支持SHA-1算出的hash值的证书签名的，而我们上面生成的证书默认为SHA-1，这里只要改为SHA-256就可以了。\n\n```\n//用CA私钥生成CA的证书\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \"/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng\" -sha256\n\n//使用server证书请求文件通过CA生成自签名证书\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -sha256\n```\n\n####  十三、获取证书小技巧\n\n有时候我们没有这个网站的证书，那要如何得到呢？\n\n###### 1、使用openssl能直接得到这个证书:\n\n```\nopenssl s_client -connect 172.16.10.244:8000 </dev/null 2>/dev/null | openssl x509 -outform DER > https.cer\n```\n\n###### 2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https10.png)\n\n---\n\n####  十四、iOS中使用自签名证书\n\niOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。一般如果我们HTTPS服务使用的证书是CA权威机构颁发的话，客户端不用修改任何代码，因为iOS系统已经内置了这些权威机构的根证书。但是如果是自签名的证书的话就需要修改代码来内部信任这部分证书了。\n\n###### AFNetworking使用自签名证书\n\nAFNetWorking封装了如何使用自签名证书，简单的使用方式如下。\n\n```objectivec\n//先导入证书，找到证书的路径\nNSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"cert\" ofType:@\"der\"];\nNSData *certData = [NSData dataWithContentsOfFile:cerPath];\nNSSet * certSet = [[NSSet alloc] initWithObjects:certData, nil];\n\n//AFSSLPinningModeNone 这个模式表示不做 SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。\n\n//AFSSLPinningModeCertificate 这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。\n\n//AFSSLPinningModePublicKey 这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。\n\nAFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];\n// 是否允许,NO-- 不允许无效的证书\n[securityPolicy setAllowInvalidCertificates:YES];\n// 设置证书\n[securityPolicy setPinnedCertificates:certSet];\n//是否验证域名信息\nsecurityPolicy.validatesDomainName = NO;\n\n\nAFHTTPSessionManager *manager = [[AFHTTPSessionManager manager] initWithBaseURL:[NSURL URLWithString:@\"https://192.168.3.13:8000\"]];\nmanager.securityPolicy = securityPolicy;\nmanager.responseSerializer = [AFHTTPResponseSerializer serializer];\n[manager GET:@\"/getInfo\" parameters:@{@\"t\":@\"1490927497.569\"} progress:^(NSProgress * progress){\n} success:^(NSURLSessionDataTask *task, id responseObject) {\n    NSArray * array = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableLeaves error:nil];\n    NSLog(@\"OK === %@\",array);\n} failure:^(NSURLSessionDataTask *task, NSError *error) {\n    NSLog(@\"error ==%@\",error.description);\n}];\n```\n\n###### 证书需要满足的条件\n\n这里的证书使用CA根证书或CA签名的数字证书都可以。\n\n密钥交换算法有`RSA`和`ECDHE`，RSA 历史悠久，支持度好，但不支持 PFS（Perfect Forward Secrecy）；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，支持 PFS。\n\niOS支持的秘钥交换算法为：至少**2048位的 RSA 密钥或至少256位的 ECC 密钥**\n\n服务器证书的哈希算法必须为 SHA-2，其摘要长度至少位256位。\n\n证书格式为.der，很多网上的教程都写的是.cer，应该是使用的旧版AFNetWorking，最新版的不支持.cer，需要使用.der格式。\n\n---\n\n####  十五、中间人攻击\n\n###### 概念\n\n关于Https最常讲到的就是中间人攻击，即所谓的Man-in-the-middle attack(MITM)。也就是攻击者插入原先攻击的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改。\n\n其实http的中间人攻击是最简单的，因为http都是通过明文传输，而且没有任何认证之类的东西。我们常常用的Charles抓包就是一个最简单的中间人攻击。\n\n###### 对HTTPS进行中间人攻击\n\n我们用Charles进行HTTPS的抓包的时候会发现抓到的包都是加过密的无法查看，那是不是就意味着无法抓取HTTPS的包了呢？其实也是可以的，通过伪造证书，并且客户端又安装了Charles根证书，就可以抓取到HTTPS的包并解密了。\n\n具体的步骤是这样的，手机安装Charles根证书，手机使用Charles的代理，所有请求都经过Charles中间人。Charles劫持到请求，替换服务端的证书为自己的伪证书，然后发送给客户端，客户端使用Charles根证书来验证这个伪证书，验证通过得到公钥，然后用公钥加密对话秘钥发送回Charles中间人，Charles中间人私用私钥解密得到对话秘钥并保存，然后再把对话秘钥用服务端的公钥加密返回给服务端，这样就表示两端握手成功，可以进行通信了。而且中间人也获得了之后的对话秘钥，可以解密之后的对话信息。\n\n###### Charles实现HTTPS抓包\n\n这里基本的HTTP抓包的设置就不讲了，下面是基于实现基本的HTTP抓包的基础上来实现HTTPS的抓包解密。\n\n- 安装Charles CA根证书\n点击`Help->SSL Proxying->Install Charles Root Certification ...`，会弹出如下提示，链接代理，手机浏览器输入`chls.pro/ssl`，就可以安装根证书了。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https11.png)\n\n- 设置SSL代理\n点击`Proxy->SSL Proxying Setting`，勾选`Enable SSL Proxying`，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https12.png)\n\n或者在对应的请求上右键选择`Enable SSL Proxying`，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。\n\n![](http://oqepgj2jp.bkt.clouddn.com/https13.png)\n\n做完上述步骤后重新请求就能得到解密后的信息了。抓取PC端的HTTPS包也类似，在`Help->SSL Proxying`中下载证书，双击安装证书，并选择始终信任即可。\n\n---\n\n#### 参考\n[超文本传输安全协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE)\n[图解HTTPS](http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html)\n[HTTPS从原理到应用](http://www.jianshu.com/p/e767a4e9252e)\n[那些证书相关的玩意儿](http://www.cnblogs.com/guogangj/p/4118605.html)\n[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n[SSL/TLS协议及Openssl工具的实现](http://www.jianshu.com/p/da65e5cd552e)\n[openssl自签名证书生成与单双向验证](http://blog.csdn.net/gx_1983/article/details/47866537)\n[iOS 10 适配 ATS](http://www.jianshu.com/p/36ddc5b009a7)\n[iOS安全系列之一：HTTPS](http://oncenote.com/2014/10/21/Security-1-HTTPS/)\n[iOS安全系列之二：HTTPS进阶](http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm)\n\n\n\n","slug":"HTTPS小解析","published":1,"updated":"2017-06-17T15:00:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvn000mznuzfewxmqyz","content":"<h4 id=\"一、HTTPS介绍\"><a href=\"#一、HTTPS介绍\" class=\"headerlink\" title=\"一、HTTPS介绍\"></a>一、HTTPS介绍</h4><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>\n<p>HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。</p>\n<p>http协议直接放置在TCP协议之上，而HTTPS提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。所以严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。</p>\n<p>下面是一个简单的HTTPS协议栈的图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/https1.png\" alt=\"\"></p>\n<hr>\n<h4 id=\"二、HTTPS流程步骤\"><a href=\"#二、HTTPS流程步骤\" class=\"headerlink\" title=\"二、HTTPS流程步骤\"></a>二、HTTPS流程步骤</h4><p>上面已经说过HTTPS主要是加了一层SSL/TLS加密，那么具体是如何进行加密，解密，验证的，且看下图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/https2.png\" alt=\"\"></p>\n<h6 id=\"1-客户端发起HTTPS请求\"><a href=\"#1-客户端发起HTTPS请求\" class=\"headerlink\" title=\"1. 客户端发起HTTPS请求\"></a>1. 客户端发起HTTPS请求</h6><p>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>\n<h6 id=\"2-服务端的配置\"><a href=\"#2-服务端的配置\" class=\"headerlink\" title=\"2. 服务端的配置\"></a>2. 服务端的配置</h6><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>\n<h6 id=\"3-传送证书\"><a href=\"#3-传送证书\" class=\"headerlink\" title=\"3. 传送证书\"></a>3. 传送证书</h6><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>\n<h6 id=\"4-客户端解析证书\"><a href=\"#4-客户端解析证书\" class=\"headerlink\" title=\"4. 客户端解析证书\"></a>4. 客户端解析证书</h6><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>\n<h6 id=\"5-传送加密信息\"><a href=\"#5-传送加密信息\" class=\"headerlink\" title=\"5. 传送加密信息\"></a>5. 传送加密信息</h6><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>\n<h6 id=\"6-服务端解密信息\"><a href=\"#6-服务端解密信息\" class=\"headerlink\" title=\"6. 服务端解密信息\"></a>6. 服务端解密信息</h6><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>\n<h6 id=\"7-传输加密后的信息\"><a href=\"#7-传输加密后的信息\" class=\"headerlink\" title=\"7. 传输加密后的信息\"></a>7. 传输加密后的信息</h6><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</p>\n<h6 id=\"8-客户端解密信息\"><a href=\"#8-客户端解密信息\" class=\"headerlink\" title=\"8. 客户端解密信息\"></a>8. 客户端解密信息</h6><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>\n<hr>\n<h4 id=\"三、SSL-TLS概念\"><a href=\"#三、SSL-TLS概念\" class=\"headerlink\" title=\"三、SSL/TLS概念\"></a>三、SSL/TLS概念</h4><p>SSL/TLS是加密通信协议，SSL由NetScape在1994年设计，1999年互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。现在主流的浏览器等都支持TLS1.2版本，如iOS9中新增App Transport Security（简称ATS）特性，强制http转向https，其中加密通信协议就需要TLS1.2及以上版本。</p>\n<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>\n<p>SSL/TLS协议的基本过程是这样的：</p>\n<pre><code>（1） 客户端向服务器端索要并验证公钥。\n（2） 双方协商生成&quot;对话密钥&quot;。\n（3） 双方采用&quot;对话密钥&quot;进行加密通信。\n</code></pre><p>所以说SSL/TLS协议主要是包含非对称加密（公钥加密）和对称加密，用非对称加密来得到对称加密的”对话秘钥”，然后用对称加密来进行加密通信。</p>\n<h4 id=\"四、两个问题\"><a href=\"#四、两个问题\" class=\"headerlink\" title=\"四、两个问题\"></a>四、两个问题</h4><ul>\n<li>如何保证公钥不被篡改？</li>\n</ul>\n<blockquote>\n<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。那如何保证证书是可信的呢？证书由CA机构进行颁发，而游览器内置了这些CA机构的根证书，只要由这些CA机构办法的数字证书即是可信的。</p>\n</blockquote>\n<ul>\n<li>为什么不直接使用公钥加密，还要加上个对称加密？</li>\n</ul>\n<blockquote>\n<p>公钥加密是非对称加密，加密计算量大，而对称加密运算速度非常快。所以这里只有第一次握手时进行公钥加密来得到对称加密的”对话密钥”，之后的通信就使用对称加密来进行通信了。</p>\n</blockquote>\n<h4 id=\"五、加密算法\"><a href=\"#五、加密算法\" class=\"headerlink\" title=\"五、加密算法\"></a>五、加密算法</h4><ul>\n<li>对称密码算法</li>\n</ul>\n<blockquote>\n<p>是指加密和解密使用相同的密钥，典型的有DES、RC5、IDEA（分组加密），RC4（序列加密）；</p>\n</blockquote>\n<ul>\n<li>非对称密码算法</li>\n</ul>\n<blockquote>\n<p>又称为公钥加密算法，是指加密和解密使用不同的密钥（公开的公钥用于加密，私有的私钥用于解密）。比如A发送，B接收，A想确保消息只有B看到，需要B生成一对公私钥，并拿到B的公钥。于是A用这个公钥加密消息，B收到密文后用自己的与之匹配的私钥解密即可。反过来也可以用私钥加密公钥解密。也就是说对于给定的公钥有且只有与之匹配的私钥可以解密，对于给定的私钥，有且只有与之匹配的公钥可以解密。典型的算法有RSA，DSA，DH；</p>\n</blockquote>\n<ul>\n<li>散列算法</li>\n</ul>\n<blockquote>\n<p>散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。因此，散列变换通常用于验证原文是否被篡改。典型的算法有：MD5，SHA，Base64，CRC等。</p>\n</blockquote>\n<hr>\n<h4 id=\"六、关于CA及数字证书\"><a href=\"#六、关于CA及数字证书\" class=\"headerlink\" title=\"六、关于CA及数字证书\"></a>六、关于CA及数字证书</h4><ul>\n<li>什么是CA</li>\n</ul>\n<p>CA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构。</p>\n<p>CA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理。</p>\n<p>CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。<br>如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。</p>\n<p>如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</p>\n<ul>\n<li>证书的内容</li>\n</ul>\n<p>数字证书的格式遵循X.509标准，X.509是由国际电信联盟（ITU-T）制定的数字证书标准，规范了公开密钥认证、证书吊销列表、授权证书、证书路径验证算法等。</p>\n<p>证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。</p>\n<p>下图就表示一个数字证书包含的内容：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https3.png\" alt=\"\"></p>\n<blockquote>\n<p>我们这里能看到颁发机构签名是由申请者信息经过哈希算法得到hash值，然后再用机构的私钥进行加密。所以这个签名只有办法机构的公钥才能解密，而一般权威CA机构的根证书（含公钥）都内置在浏览器中，所以客户端接收到这个数字证书后，先把申请者信息用同样的哈希算法得到hash值h1，然后用公钥进行办法机构签名解密得到hash值h2，如果h1==h2，则表示证书是有效的。</p>\n</blockquote>\n<p>下图就是Charles的根证书例子：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https4.png\" alt=\"\"></p>\n<h4 id=\"七、编码格式\"><a href=\"#七、编码格式\" class=\"headerlink\" title=\"七、编码格式\"></a>七、编码格式</h4><p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式。</p>\n<p><strong>PEM</strong> - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p>\n<p><strong>DER</strong> - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p>\n<h4 id=\"八、相关的文件扩展名\"><a href=\"#八、相关的文件扩展名\" class=\"headerlink\" title=\"八、相关的文件扩展名\"></a>八、相关的文件扩展名</h4><p>这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式。</p>\n<p><strong>CRT</strong> - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.</p>\n<p><strong>CER</strong> - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</p>\n<p><strong>KEY</strong> - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER。<br>查看KEY的办法:<code>openssl rsa -in mykey.key -text -noout</code><br>如果是DER格式的话:<code>openssl rsa -in mykey.key -text -noout -inform der</code></p>\n<p><strong>CSR</strong> - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。<br>查看的办法:<code>openssl req -noout -text -in my.csr</code><br>如果是DER格式的话:<code>openssl req -noout -text -in my.csr -inform der</code></p>\n<p><strong>PFX/P12</strong> - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br><code>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</code><br>这个时候会提示你输入提取代码. for-iis.pem就是可读的文本。<br>生成pfx的命令类似这样:<code>openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out</code> <code>certificate.pfx -certfile CACert.crt</code></p>\n<p>其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</p>\n<p><strong>JKS</strong> - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了。</p>\n<h4 id=\"九、证书编码的转换\"><a href=\"#九、证书编码的转换\" class=\"headerlink\" title=\"九、证书编码的转换\"></a>九、证书编码的转换</h4><ul>\n<li>.crt转.der方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.der -outform DER</code></p>\n<ul>\n<li>.crt转.cer方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.cer -outform DER</code></p>\n<ul>\n<li>.crt转.pem方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.pem -outform PEM</code></p>\n<h4 id=\"十、生成自签名证书的步骤\"><a href=\"#十、生成自签名证书的步骤\" class=\"headerlink\" title=\"十、生成自签名证书的步骤\"></a>十、生成自签名证书的步骤</h4><h6 id=\"建立CA\"><a href=\"#建立CA\" class=\"headerlink\" title=\"建立CA\"></a>建立CA</h6><ul>\n<li>在任意目录建立文件夹，文件夹名称任意</li>\n</ul>\n<pre><code>mkdir ca\n</code></pre><ul>\n<li>进入到新建立的文件夹ca</li>\n</ul>\n<pre><code>d ca\n</code></pre><ul>\n<li>生成CA私钥</li>\n</ul>\n<pre><code>openssl genrsa -out ca.key 2048\n</code></pre><ul>\n<li>用CA私钥生成CA的证书</li>\n</ul>\n<pre><code>openssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \n&quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng&quot;\n</code></pre><ul>\n<li>建立CA相应目录</li>\n</ul>\n<pre><code>mkdir demoCA\ncd demoCA/\n\nmkdir newcerts\n\ntouch index.txt\n\necho &#39;01&#39; &gt; serial\n</code></pre><h6 id=\"生成server端证书\"><a href=\"#生成server端证书\" class=\"headerlink\" title=\"生成server端证书\"></a>生成server端证书</h6><ul>\n<li>进入ca文件夹</li>\n</ul>\n<pre><code>cd ca\n</code></pre><ul>\n<li>生成server私钥</li>\n</ul>\n<pre><code>openssl genrsa -out server.key 2048\n</code></pre><ul>\n<li>使用server私钥生成server端证书请求文件</li>\n</ul>\n<pre><code>openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=dasheng/CN=dasheng&quot;\n</code></pre><ul>\n<li>使用server证书请求文件通过CA生成自签名证书</li>\n</ul>\n<pre><code>openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key\n</code></pre><ul>\n<li>验证server证书</li>\n</ul>\n<pre><code>openssl verify -CAfile ca.crt server.crt\n</code></pre><h6 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h6><ul>\n<li><p>使用server证书测试单向认证</p>\n</li>\n<li><p>打开窗口1启动server</p>\n</li>\n</ul>\n<pre><code>openssl s_server -accept 10001 -key server.key -cert server.crt\n</code></pre><ul>\n<li>打开窗口2启动客户端</li>\n</ul>\n<pre><code>openssl s_client -connect localhost:10001\n</code></pre><ul>\n<li>连接成功后在任意一个窗口输入字符串会传输到另外一个窗口回显。</li>\n</ul>\n<h6 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h6><p><a href=\"http://ofcckdrlc.bkt.clouddn.com/generate_certificate.sh\" target=\"_blank\" rel=\"external\">快速创建证书的脚本</a><br>使用（host表示证书用于的域名，cerFile表示证书保存的目录）：</p>\n<pre><code>sh ./generate_certificate.sh host cerFile\n</code></pre><h4 id=\"十一、信任自签名证书\"><a href=\"#十一、信任自签名证书\" class=\"headerlink\" title=\"十一、信任自签名证书\"></a>十一、信任自签名证书</h4><h6 id=\"查看证书链\"><a href=\"#查看证书链\" class=\"headerlink\" title=\"查看证书链\"></a>查看证书链</h6><p>Chrome57及后续版本Chrome浏览器用户如要查看SSL证书信息只能通过开发者工具（右键-&gt;检查），选择安全标签（Security）进行查看了。然后点击View certificate查看证书链，如下图为查看www.google.com的证书链：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https5.png\" alt=\"\"></p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https6.png\" alt=\"\"></p>\n<h6 id=\"信任证书\"><a href=\"#信任证书\" class=\"headerlink\" title=\"信任证书\"></a>信任证书</h6><p>在MAC上直接双击证书，然后在钥匙串里就能看到这个证书了，我们能看到证书上会显示此证书是由不被信任的签发者签发的或此根证书不被信任。然后我们再在钥匙串中双击证书-&gt;信任-&gt;使用此证书时：始终信任。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https7.png\" alt=\"\"></p>\n<p>这里我们可以信任两种证书：CA根证书和CA签名过的数字证书。两种证书在钥匙串中显示的颜色是不一样的。</p>\n<p>下图就是自己创建的两种证书：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https8.png\" alt=\"\"></p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https9.png\" alt=\"\"></p>\n<p>我们信任两种证书都可以使请求变成安全的请求，在浏览器中输入的时候就不会有不安全的提示了。这里说一下为什么两种证书都可以。</p>\n<p>首先说CA根证书，这种就是我们正常的流程，CA根证书用公钥解密数字证书的签名得到hash值，然后根据hash值相等判断证书有效。<br>而不信任根证书只信任数字证书，就很容易理解了，他们本来就是同一张证书，也不用通过加密解密什么的来判断了。</p>\n<h4 id=\"十二、Chrome信任根证书后提示链接不安全\"><a href=\"#十二、Chrome信任根证书后提示链接不安全\" class=\"headerlink\" title=\"十二、Chrome信任根证书后提示链接不安全\"></a>十二、Chrome信任根证书后提示链接不安全</h4><p>这里我信任根证书之后还是提示链接不安全：<code>ERR_CERT_WEAK_SIGNATURE_ALGORITHM</code>。而信任数字证书则没问题。发生这种情况的原因是<code>Chrome 57</code>版本以后是不支持SHA-1算出的hash值的证书签名的，而我们上面生成的证书默认为SHA-1，这里只要改为SHA-256就可以了。</p>\n<pre><code>//用CA私钥生成CA的证书\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj &quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng&quot; -sha256\n\n//使用server证书请求文件通过CA生成自签名证书\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -sha256\n</code></pre><h4 id=\"十三、获取证书小技巧\"><a href=\"#十三、获取证书小技巧\" class=\"headerlink\" title=\"十三、获取证书小技巧\"></a>十三、获取证书小技巧</h4><p>有时候我们没有这个网站的证书，那要如何得到呢？</p>\n<h6 id=\"1、使用openssl能直接得到这个证书\"><a href=\"#1、使用openssl能直接得到这个证书\" class=\"headerlink\" title=\"1、使用openssl能直接得到这个证书:\"></a>1、使用openssl能直接得到这个证书:</h6><pre><code>openssl s_client -connect 172.16.10.244:8000 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer\n</code></pre><h6 id=\"2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\"><a href=\"#2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\" class=\"headerlink\" title=\"2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\"></a>2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。</h6><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https10.png\" alt=\"\"></p>\n<hr>\n<h4 id=\"十四、iOS中使用自签名证书\"><a href=\"#十四、iOS中使用自签名证书\" class=\"headerlink\" title=\"十四、iOS中使用自签名证书\"></a>十四、iOS中使用自签名证书</h4><p>iOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。一般如果我们HTTPS服务使用的证书是CA权威机构颁发的话，客户端不用修改任何代码，因为iOS系统已经内置了这些权威机构的根证书。但是如果是自签名的证书的话就需要修改代码来内部信任这部分证书了。</p>\n<h6 id=\"AFNetworking使用自签名证书\"><a href=\"#AFNetworking使用自签名证书\" class=\"headerlink\" title=\"AFNetworking使用自签名证书\"></a>AFNetworking使用自签名证书</h6><p>AFNetWorking封装了如何使用自签名证书，简单的使用方式如下。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//先导入证书，找到证书的路径</span>\nNSString <span class=\"token operator\">*</span>cerPath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span><span class=\"token string\">@\"cert\"</span> ofType<span class=\"token punctuation\">:</span><span class=\"token string\">@\"der\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSData <span class=\"token operator\">*</span>certData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithContentsOfFile<span class=\"token punctuation\">:</span>cerPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSSet <span class=\"token operator\">*</span> certSet <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSSet alloc<span class=\"token punctuation\">]</span> initWithObjects<span class=\"token punctuation\">:</span>certData<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//AFSSLPinningModeNone 这个模式表示不做 SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//AFSSLPinningModeCertificate 这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//AFSSLPinningModePublicKey 这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span>\n\nAFSecurityPolicy <span class=\"token operator\">*</span>securityPolicy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AFSecurityPolicy policyWithPinningMode<span class=\"token punctuation\">:</span>AFSSLPinningModeNone<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 是否允许,NO-- 不允许无效的证书</span>\n<span class=\"token punctuation\">[</span>securityPolicy setAllowInvalidCertificates<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 设置证书</span>\n<span class=\"token punctuation\">[</span>securityPolicy setPinnedCertificates<span class=\"token punctuation\">:</span>certSet<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//是否验证域名信息</span>\nsecurityPolicy<span class=\"token punctuation\">.</span>validatesDomainName <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n\n\nAFHTTPSessionManager <span class=\"token operator\">*</span>manager <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AFHTTPSessionManager manager<span class=\"token punctuation\">]</span> initWithBaseURL<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSURL URLWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"https://192.168.3.13:8000\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmanager<span class=\"token punctuation\">.</span>securityPolicy <span class=\"token operator\">=</span> securityPolicy<span class=\"token punctuation\">;</span>\nmanager<span class=\"token punctuation\">.</span>responseSerializer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AFHTTPResponseSerializer serializer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>manager GET<span class=\"token punctuation\">:</span><span class=\"token string\">@\"/getInfo\"</span> parameters<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token string\">@\"t\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">@\"1490927497.569\"</span><span class=\"token punctuation\">}</span> progress<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>NSProgress <span class=\"token operator\">*</span> progress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span> success<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>NSURLSessionDataTask <span class=\"token operator\">*</span>task<span class=\"token punctuation\">,</span> id responseObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    NSArray <span class=\"token operator\">*</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSJSONSerialization JSONObjectWithData<span class=\"token punctuation\">:</span>responseObject options<span class=\"token punctuation\">:</span>NSJSONReadingMutableLeaves error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"OK === %@\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> failure<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>NSURLSessionDataTask <span class=\"token operator\">*</span>task<span class=\"token punctuation\">,</span> NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"error ==%@\"</span><span class=\"token punctuation\">,</span>error<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h6 id=\"证书需要满足的条件\"><a href=\"#证书需要满足的条件\" class=\"headerlink\" title=\"证书需要满足的条件\"></a>证书需要满足的条件</h6><p>这里的证书使用CA根证书或CA签名的数字证书都可以。</p>\n<p>密钥交换算法有<code>RSA</code>和<code>ECDHE</code>，RSA 历史悠久，支持度好，但不支持 PFS（Perfect Forward Secrecy）；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，支持 PFS。</p>\n<p>iOS支持的秘钥交换算法为：至少<strong>2048位的 RSA 密钥或至少256位的 ECC 密钥</strong></p>\n<p>服务器证书的哈希算法必须为 SHA-2，其摘要长度至少位256位。</p>\n<p>证书格式为.der，很多网上的教程都写的是.cer，应该是使用的旧版AFNetWorking，最新版的不支持.cer，需要使用.der格式。</p>\n<hr>\n<h4 id=\"十五、中间人攻击\"><a href=\"#十五、中间人攻击\" class=\"headerlink\" title=\"十五、中间人攻击\"></a>十五、中间人攻击</h4><h6 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h6><p>关于Https最常讲到的就是中间人攻击，即所谓的Man-in-the-middle attack(MITM)。也就是攻击者插入原先攻击的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改。</p>\n<p>其实http的中间人攻击是最简单的，因为http都是通过明文传输，而且没有任何认证之类的东西。我们常常用的Charles抓包就是一个最简单的中间人攻击。</p>\n<h6 id=\"对HTTPS进行中间人攻击\"><a href=\"#对HTTPS进行中间人攻击\" class=\"headerlink\" title=\"对HTTPS进行中间人攻击\"></a>对HTTPS进行中间人攻击</h6><p>我们用Charles进行HTTPS的抓包的时候会发现抓到的包都是加过密的无法查看，那是不是就意味着无法抓取HTTPS的包了呢？其实也是可以的，通过伪造证书，并且客户端又安装了Charles根证书，就可以抓取到HTTPS的包并解密了。</p>\n<p>具体的步骤是这样的，手机安装Charles根证书，手机使用Charles的代理，所有请求都经过Charles中间人。Charles劫持到请求，替换服务端的证书为自己的伪证书，然后发送给客户端，客户端使用Charles根证书来验证这个伪证书，验证通过得到公钥，然后用公钥加密对话秘钥发送回Charles中间人，Charles中间人私用私钥解密得到对话秘钥并保存，然后再把对话秘钥用服务端的公钥加密返回给服务端，这样就表示两端握手成功，可以进行通信了。而且中间人也获得了之后的对话秘钥，可以解密之后的对话信息。</p>\n<h6 id=\"Charles实现HTTPS抓包\"><a href=\"#Charles实现HTTPS抓包\" class=\"headerlink\" title=\"Charles实现HTTPS抓包\"></a>Charles实现HTTPS抓包</h6><p>这里基本的HTTP抓包的设置就不讲了，下面是基于实现基本的HTTP抓包的基础上来实现HTTPS的抓包解密。</p>\n<ul>\n<li>安装Charles CA根证书<br>点击<code>Help-&gt;SSL Proxying-&gt;Install Charles Root Certification ...</code>，会弹出如下提示，链接代理，手机浏览器输入<code>chls.pro/ssl</code>，就可以安装根证书了。</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https11.png\" alt=\"\"></p>\n<ul>\n<li>设置SSL代理<br>点击<code>Proxy-&gt;SSL Proxying Setting</code>，勾选<code>Enable SSL Proxying</code>，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https12.png\" alt=\"\"></p>\n<p>或者在对应的请求上右键选择<code>Enable SSL Proxying</code>，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https13.png\" alt=\"\"></p>\n<p>做完上述步骤后重新请求就能得到解密后的信息了。抓取PC端的HTTPS包也类似，在<code>Help-&gt;SSL Proxying</code>中下载证书，双击安装证书，并选择始终信任即可。</p>\n<hr>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"external\">超文本传输安全协议</a><br><a href=\"http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html\" target=\"_blank\" rel=\"external\">图解HTTPS</a><br><a href=\"http://www.jianshu.com/p/e767a4e9252e\" target=\"_blank\" rel=\"external\">HTTPS从原理到应用</a><br><a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\" target=\"_blank\" rel=\"external\">那些证书相关的玩意儿</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"external\">SSL/TLS协议运行机制的概述</a><br><a href=\"http://www.jianshu.com/p/da65e5cd552e\" target=\"_blank\" rel=\"external\">SSL/TLS协议及Openssl工具的实现</a><br><a href=\"http://blog.csdn.net/gx_1983/article/details/47866537\" target=\"_blank\" rel=\"external\">openssl自签名证书生成与单双向验证</a><br><a href=\"http://www.jianshu.com/p/36ddc5b009a7\" target=\"_blank\" rel=\"external\">iOS 10 适配 ATS</a><br><a href=\"http://oncenote.com/2014/10/21/Security-1-HTTPS/\" target=\"_blank\" rel=\"external\">iOS安全系列之一：HTTPS</a><br><a href=\"http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm\" target=\"_blank\" rel=\"external\">iOS安全系列之二：HTTPS进阶</a></p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"一、HTTPS介绍\"><a href=\"#一、HTTPS介绍\" class=\"headerlink\" title=\"一、HTTPS介绍\"></a>一、HTTPS介绍</h4><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>\n<p>HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。</p>\n<p>http协议直接放置在TCP协议之上，而HTTPS提出在http和TCP中间加上一层加密层。从发送端看，这一层负责把http的内容加密后送到下层的TCP，从接收方看，这一层负责将TCP送来的数据解密还原成http的内容。所以严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。</p>\n<p>下面是一个简单的HTTPS协议栈的图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/https1.png\" alt=\"\"></p>\n<hr>\n<h4 id=\"二、HTTPS流程步骤\"><a href=\"#二、HTTPS流程步骤\" class=\"headerlink\" title=\"二、HTTPS流程步骤\"></a>二、HTTPS流程步骤</h4><p>上面已经说过HTTPS主要是加了一层SSL/TLS加密，那么具体是如何进行加密，解密，验证的，且看下图：<br><img src=\"http://oqepgj2jp.bkt.clouddn.com/https2.png\" alt=\"\"></p>\n<h6 id=\"1-客户端发起HTTPS请求\"><a href=\"#1-客户端发起HTTPS请求\" class=\"headerlink\" title=\"1. 客户端发起HTTPS请求\"></a>1. 客户端发起HTTPS请求</h6><p>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>\n<h6 id=\"2-服务端的配置\"><a href=\"#2-服务端的配置\" class=\"headerlink\" title=\"2. 服务端的配置\"></a>2. 服务端的配置</h6><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>\n<h6 id=\"3-传送证书\"><a href=\"#3-传送证书\" class=\"headerlink\" title=\"3. 传送证书\"></a>3. 传送证书</h6><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>\n<h6 id=\"4-客户端解析证书\"><a href=\"#4-客户端解析证书\" class=\"headerlink\" title=\"4. 客户端解析证书\"></a>4. 客户端解析证书</h6><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>\n<h6 id=\"5-传送加密信息\"><a href=\"#5-传送加密信息\" class=\"headerlink\" title=\"5. 传送加密信息\"></a>5. 传送加密信息</h6><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>\n<h6 id=\"6-服务端解密信息\"><a href=\"#6-服务端解密信息\" class=\"headerlink\" title=\"6. 服务端解密信息\"></a>6. 服务端解密信息</h6><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>\n<h6 id=\"7-传输加密后的信息\"><a href=\"#7-传输加密后的信息\" class=\"headerlink\" title=\"7. 传输加密后的信息\"></a>7. 传输加密后的信息</h6><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</p>\n<h6 id=\"8-客户端解密信息\"><a href=\"#8-客户端解密信息\" class=\"headerlink\" title=\"8. 客户端解密信息\"></a>8. 客户端解密信息</h6><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>\n<hr>\n<h4 id=\"三、SSL-TLS概念\"><a href=\"#三、SSL-TLS概念\" class=\"headerlink\" title=\"三、SSL/TLS概念\"></a>三、SSL/TLS概念</h4><p>SSL/TLS是加密通信协议，SSL由NetScape在1994年设计，1999年互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。现在主流的浏览器等都支持TLS1.2版本，如iOS9中新增App Transport Security（简称ATS）特性，强制http转向https，其中加密通信协议就需要TLS1.2及以上版本。</p>\n<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>\n<p>SSL/TLS协议的基本过程是这样的：</p>\n<pre><code>（1） 客户端向服务器端索要并验证公钥。\n（2） 双方协商生成&quot;对话密钥&quot;。\n（3） 双方采用&quot;对话密钥&quot;进行加密通信。\n</code></pre><p>所以说SSL/TLS协议主要是包含非对称加密（公钥加密）和对称加密，用非对称加密来得到对称加密的”对话秘钥”，然后用对称加密来进行加密通信。</p>\n<h4 id=\"四、两个问题\"><a href=\"#四、两个问题\" class=\"headerlink\" title=\"四、两个问题\"></a>四、两个问题</h4><ul>\n<li>如何保证公钥不被篡改？</li>\n</ul>\n<blockquote>\n<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。那如何保证证书是可信的呢？证书由CA机构进行颁发，而游览器内置了这些CA机构的根证书，只要由这些CA机构办法的数字证书即是可信的。</p>\n</blockquote>\n<ul>\n<li>为什么不直接使用公钥加密，还要加上个对称加密？</li>\n</ul>\n<blockquote>\n<p>公钥加密是非对称加密，加密计算量大，而对称加密运算速度非常快。所以这里只有第一次握手时进行公钥加密来得到对称加密的”对话密钥”，之后的通信就使用对称加密来进行通信了。</p>\n</blockquote>\n<h4 id=\"五、加密算法\"><a href=\"#五、加密算法\" class=\"headerlink\" title=\"五、加密算法\"></a>五、加密算法</h4><ul>\n<li>对称密码算法</li>\n</ul>\n<blockquote>\n<p>是指加密和解密使用相同的密钥，典型的有DES、RC5、IDEA（分组加密），RC4（序列加密）；</p>\n</blockquote>\n<ul>\n<li>非对称密码算法</li>\n</ul>\n<blockquote>\n<p>又称为公钥加密算法，是指加密和解密使用不同的密钥（公开的公钥用于加密，私有的私钥用于解密）。比如A发送，B接收，A想确保消息只有B看到，需要B生成一对公私钥，并拿到B的公钥。于是A用这个公钥加密消息，B收到密文后用自己的与之匹配的私钥解密即可。反过来也可以用私钥加密公钥解密。也就是说对于给定的公钥有且只有与之匹配的私钥可以解密，对于给定的私钥，有且只有与之匹配的公钥可以解密。典型的算法有RSA，DSA，DH；</p>\n</blockquote>\n<ul>\n<li>散列算法</li>\n</ul>\n<blockquote>\n<p>散列变换是指把文件内容通过某种公开的算法，变成固定长度的值（散列值），这个过程可以使用密钥也可以不使用。这种散列变换是不可逆的，也就是说不能从散列值变成原文。因此，散列变换通常用于验证原文是否被篡改。典型的算法有：MD5，SHA，Base64，CRC等。</p>\n</blockquote>\n<hr>\n<h4 id=\"六、关于CA及数字证书\"><a href=\"#六、关于CA及数字证书\" class=\"headerlink\" title=\"六、关于CA及数字证书\"></a>六、关于CA及数字证书</h4><ul>\n<li>什么是CA</li>\n</ul>\n<p>CA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构。</p>\n<p>CA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理。</p>\n<p>CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。<br>如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。</p>\n<p>如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。</p>\n<ul>\n<li>证书的内容</li>\n</ul>\n<p>数字证书的格式遵循X.509标准，X.509是由国际电信联盟（ITU-T）制定的数字证书标准，规范了公开密钥认证、证书吊销列表、授权证书、证书路径验证算法等。</p>\n<p>证书的内容包括：电子签证机关的信息、公钥用户信息、公钥、权威机构的签字和有效期等等。</p>\n<p>下图就表示一个数字证书包含的内容：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https3.png\" alt=\"\"></p>\n<blockquote>\n<p>我们这里能看到颁发机构签名是由申请者信息经过哈希算法得到hash值，然后再用机构的私钥进行加密。所以这个签名只有办法机构的公钥才能解密，而一般权威CA机构的根证书（含公钥）都内置在浏览器中，所以客户端接收到这个数字证书后，先把申请者信息用同样的哈希算法得到hash值h1，然后用公钥进行办法机构签名解密得到hash值h2，如果h1==h2，则表示证书是有效的。</p>\n</blockquote>\n<p>下图就是Charles的根证书例子：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https4.png\" alt=\"\"></p>\n<h4 id=\"七、编码格式\"><a href=\"#七、编码格式\" class=\"headerlink\" title=\"七、编码格式\"></a>七、编码格式</h4><p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式。</p>\n<p><strong>PEM</strong> - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p>\n<p><strong>DER</strong> - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p>\n<h4 id=\"八、相关的文件扩展名\"><a href=\"#八、相关的文件扩展名\" class=\"headerlink\" title=\"八、相关的文件扩展名\"></a>八、相关的文件扩展名</h4><p>这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式。</p>\n<p><strong>CRT</strong> - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.</p>\n<p><strong>CER</strong> - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</p>\n<p><strong>KEY</strong> - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER。<br>查看KEY的办法:<code>openssl rsa -in mykey.key -text -noout</code><br>如果是DER格式的话:<code>openssl rsa -in mykey.key -text -noout -inform der</code></p>\n<p><strong>CSR</strong> - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。<br>查看的办法:<code>openssl req -noout -text -in my.csr</code><br>如果是DER格式的话:<code>openssl req -noout -text -in my.csr -inform der</code></p>\n<p><strong>PFX/P12</strong> - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br><code>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</code><br>这个时候会提示你输入提取代码. for-iis.pem就是可读的文本。<br>生成pfx的命令类似这样:<code>openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out</code> <code>certificate.pfx -certfile CACert.crt</code></p>\n<p>其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</p>\n<p><strong>JKS</strong> - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了。</p>\n<h4 id=\"九、证书编码的转换\"><a href=\"#九、证书编码的转换\" class=\"headerlink\" title=\"九、证书编码的转换\"></a>九、证书编码的转换</h4><ul>\n<li>.crt转.der方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.der -outform DER</code></p>\n<ul>\n<li>.crt转.cer方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.cer -outform DER</code></p>\n<ul>\n<li>.crt转.pem方法</li>\n</ul>\n<p><code>openssl x509 -in cert.crt -out cert.pem -outform PEM</code></p>\n<h4 id=\"十、生成自签名证书的步骤\"><a href=\"#十、生成自签名证书的步骤\" class=\"headerlink\" title=\"十、生成自签名证书的步骤\"></a>十、生成自签名证书的步骤</h4><h6 id=\"建立CA\"><a href=\"#建立CA\" class=\"headerlink\" title=\"建立CA\"></a>建立CA</h6><ul>\n<li>在任意目录建立文件夹，文件夹名称任意</li>\n</ul>\n<pre><code>mkdir ca\n</code></pre><ul>\n<li>进入到新建立的文件夹ca</li>\n</ul>\n<pre><code>d ca\n</code></pre><ul>\n<li>生成CA私钥</li>\n</ul>\n<pre><code>openssl genrsa -out ca.key 2048\n</code></pre><ul>\n<li>用CA私钥生成CA的证书</li>\n</ul>\n<pre><code>openssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj \n&quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng&quot;\n</code></pre><ul>\n<li>建立CA相应目录</li>\n</ul>\n<pre><code>mkdir demoCA\ncd demoCA/\n\nmkdir newcerts\n\ntouch index.txt\n\necho &#39;01&#39; &gt; serial\n</code></pre><h6 id=\"生成server端证书\"><a href=\"#生成server端证书\" class=\"headerlink\" title=\"生成server端证书\"></a>生成server端证书</h6><ul>\n<li>进入ca文件夹</li>\n</ul>\n<pre><code>cd ca\n</code></pre><ul>\n<li>生成server私钥</li>\n</ul>\n<pre><code>openssl genrsa -out server.key 2048\n</code></pre><ul>\n<li>使用server私钥生成server端证书请求文件</li>\n</ul>\n<pre><code>openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=dasheng/CN=dasheng&quot;\n</code></pre><ul>\n<li>使用server证书请求文件通过CA生成自签名证书</li>\n</ul>\n<pre><code>openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key\n</code></pre><ul>\n<li>验证server证书</li>\n</ul>\n<pre><code>openssl verify -CAfile ca.crt server.crt\n</code></pre><h6 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h6><ul>\n<li><p>使用server证书测试单向认证</p>\n</li>\n<li><p>打开窗口1启动server</p>\n</li>\n</ul>\n<pre><code>openssl s_server -accept 10001 -key server.key -cert server.crt\n</code></pre><ul>\n<li>打开窗口2启动客户端</li>\n</ul>\n<pre><code>openssl s_client -connect localhost:10001\n</code></pre><ul>\n<li>连接成功后在任意一个窗口输入字符串会传输到另外一个窗口回显。</li>\n</ul>\n<h6 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h6><p><a href=\"http://ofcckdrlc.bkt.clouddn.com/generate_certificate.sh\" target=\"_blank\" rel=\"external\">快速创建证书的脚本</a><br>使用（host表示证书用于的域名，cerFile表示证书保存的目录）：</p>\n<pre><code>sh ./generate_certificate.sh host cerFile\n</code></pre><h4 id=\"十一、信任自签名证书\"><a href=\"#十一、信任自签名证书\" class=\"headerlink\" title=\"十一、信任自签名证书\"></a>十一、信任自签名证书</h4><h6 id=\"查看证书链\"><a href=\"#查看证书链\" class=\"headerlink\" title=\"查看证书链\"></a>查看证书链</h6><p>Chrome57及后续版本Chrome浏览器用户如要查看SSL证书信息只能通过开发者工具（右键-&gt;检查），选择安全标签（Security）进行查看了。然后点击View certificate查看证书链，如下图为查看www.google.com的证书链：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https5.png\" alt=\"\"></p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https6.png\" alt=\"\"></p>\n<h6 id=\"信任证书\"><a href=\"#信任证书\" class=\"headerlink\" title=\"信任证书\"></a>信任证书</h6><p>在MAC上直接双击证书，然后在钥匙串里就能看到这个证书了，我们能看到证书上会显示此证书是由不被信任的签发者签发的或此根证书不被信任。然后我们再在钥匙串中双击证书-&gt;信任-&gt;使用此证书时：始终信任。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https7.png\" alt=\"\"></p>\n<p>这里我们可以信任两种证书：CA根证书和CA签名过的数字证书。两种证书在钥匙串中显示的颜色是不一样的。</p>\n<p>下图就是自己创建的两种证书：</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https8.png\" alt=\"\"></p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https9.png\" alt=\"\"></p>\n<p>我们信任两种证书都可以使请求变成安全的请求，在浏览器中输入的时候就不会有不安全的提示了。这里说一下为什么两种证书都可以。</p>\n<p>首先说CA根证书，这种就是我们正常的流程，CA根证书用公钥解密数字证书的签名得到hash值，然后根据hash值相等判断证书有效。<br>而不信任根证书只信任数字证书，就很容易理解了，他们本来就是同一张证书，也不用通过加密解密什么的来判断了。</p>\n<h4 id=\"十二、Chrome信任根证书后提示链接不安全\"><a href=\"#十二、Chrome信任根证书后提示链接不安全\" class=\"headerlink\" title=\"十二、Chrome信任根证书后提示链接不安全\"></a>十二、Chrome信任根证书后提示链接不安全</h4><p>这里我信任根证书之后还是提示链接不安全：<code>ERR_CERT_WEAK_SIGNATURE_ALGORITHM</code>。而信任数字证书则没问题。发生这种情况的原因是<code>Chrome 57</code>版本以后是不支持SHA-1算出的hash值的证书签名的，而我们上面生成的证书默认为SHA-1，这里只要改为SHA-256就可以了。</p>\n<pre><code>//用CA私钥生成CA的证书\nopenssl req -new -x509 -days 36500 -key ca.key -out ca.crt -subj &quot;/C=CN/ST=Hangzhou/L=Hangzhou/O=Teamsun/OU=Dasheng&quot; -sha256\n\n//使用server证书请求文件通过CA生成自签名证书\nopenssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -sha256\n</code></pre><h4 id=\"十三、获取证书小技巧\"><a href=\"#十三、获取证书小技巧\" class=\"headerlink\" title=\"十三、获取证书小技巧\"></a>十三、获取证书小技巧</h4><p>有时候我们没有这个网站的证书，那要如何得到呢？</p>\n<h6 id=\"1、使用openssl能直接得到这个证书\"><a href=\"#1、使用openssl能直接得到这个证书\" class=\"headerlink\" title=\"1、使用openssl能直接得到这个证书:\"></a>1、使用openssl能直接得到这个证书:</h6><pre><code>openssl s_client -connect 172.16.10.244:8000 &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer\n</code></pre><h6 id=\"2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\"><a href=\"#2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\" class=\"headerlink\" title=\"2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。\"></a>2、直接Safari输入网站，如果是不安全的，会显示下图，然后点击显示证书，勾选连接时始终信任，点击继续证书就添加到钥匙串中了。</h6><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https10.png\" alt=\"\"></p>\n<hr>\n<h4 id=\"十四、iOS中使用自签名证书\"><a href=\"#十四、iOS中使用自签名证书\" class=\"headerlink\" title=\"十四、iOS中使用自签名证书\"></a>十四、iOS中使用自签名证书</h4><p>iOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。一般如果我们HTTPS服务使用的证书是CA权威机构颁发的话，客户端不用修改任何代码，因为iOS系统已经内置了这些权威机构的根证书。但是如果是自签名的证书的话就需要修改代码来内部信任这部分证书了。</p>\n<h6 id=\"AFNetworking使用自签名证书\"><a href=\"#AFNetworking使用自签名证书\" class=\"headerlink\" title=\"AFNetworking使用自签名证书\"></a>AFNetworking使用自签名证书</h6><p>AFNetWorking封装了如何使用自签名证书，简单的使用方式如下。</p>\n<pre><code class=\"objectivec\">//先导入证书，找到证书的路径\nNSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;cert&quot; ofType:@&quot;der&quot;];\nNSData *certData = [NSData dataWithContentsOfFile:cerPath];\nNSSet * certSet = [[NSSet alloc] initWithObjects:certData, nil];\n\n//AFSSLPinningModeNone 这个模式表示不做 SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。\n\n//AFSSLPinningModeCertificate 这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。\n\n//AFSSLPinningModePublicKey 这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。\n\nAFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];\n// 是否允许,NO-- 不允许无效的证书\n[securityPolicy setAllowInvalidCertificates:YES];\n// 设置证书\n[securityPolicy setPinnedCertificates:certSet];\n//是否验证域名信息\nsecurityPolicy.validatesDomainName = NO;\n\n\nAFHTTPSessionManager *manager = [[AFHTTPSessionManager manager] initWithBaseURL:[NSURL URLWithString:@&quot;https://192.168.3.13:8000&quot;]];\nmanager.securityPolicy = securityPolicy;\nmanager.responseSerializer = [AFHTTPResponseSerializer serializer];\n[manager GET:@&quot;/getInfo&quot; parameters:@{@&quot;t&quot;:@&quot;1490927497.569&quot;} progress:^(NSProgress * progress){\n} success:^(NSURLSessionDataTask *task, id responseObject) {\n    NSArray * array = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableLeaves error:nil];\n    NSLog(@&quot;OK === %@&quot;,array);\n} failure:^(NSURLSessionDataTask *task, NSError *error) {\n    NSLog(@&quot;error ==%@&quot;,error.description);\n}];\n</code></pre>\n<h6 id=\"证书需要满足的条件\"><a href=\"#证书需要满足的条件\" class=\"headerlink\" title=\"证书需要满足的条件\"></a>证书需要满足的条件</h6><p>这里的证书使用CA根证书或CA签名的数字证书都可以。</p>\n<p>密钥交换算法有<code>RSA</code>和<code>ECDHE</code>，RSA 历史悠久，支持度好，但不支持 PFS（Perfect Forward Secrecy）；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，支持 PFS。</p>\n<p>iOS支持的秘钥交换算法为：至少<strong>2048位的 RSA 密钥或至少256位的 ECC 密钥</strong></p>\n<p>服务器证书的哈希算法必须为 SHA-2，其摘要长度至少位256位。</p>\n<p>证书格式为.der，很多网上的教程都写的是.cer，应该是使用的旧版AFNetWorking，最新版的不支持.cer，需要使用.der格式。</p>\n<hr>\n<h4 id=\"十五、中间人攻击\"><a href=\"#十五、中间人攻击\" class=\"headerlink\" title=\"十五、中间人攻击\"></a>十五、中间人攻击</h4><h6 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h6><p>关于Https最常讲到的就是中间人攻击，即所谓的Man-in-the-middle attack(MITM)。也就是攻击者插入原先攻击的双方，让双方以为还在直接跟对方通讯，但实际上双方的通信对方已变成了中间人，信息已经是被中间人获取或篡改。</p>\n<p>其实http的中间人攻击是最简单的，因为http都是通过明文传输，而且没有任何认证之类的东西。我们常常用的Charles抓包就是一个最简单的中间人攻击。</p>\n<h6 id=\"对HTTPS进行中间人攻击\"><a href=\"#对HTTPS进行中间人攻击\" class=\"headerlink\" title=\"对HTTPS进行中间人攻击\"></a>对HTTPS进行中间人攻击</h6><p>我们用Charles进行HTTPS的抓包的时候会发现抓到的包都是加过密的无法查看，那是不是就意味着无法抓取HTTPS的包了呢？其实也是可以的，通过伪造证书，并且客户端又安装了Charles根证书，就可以抓取到HTTPS的包并解密了。</p>\n<p>具体的步骤是这样的，手机安装Charles根证书，手机使用Charles的代理，所有请求都经过Charles中间人。Charles劫持到请求，替换服务端的证书为自己的伪证书，然后发送给客户端，客户端使用Charles根证书来验证这个伪证书，验证通过得到公钥，然后用公钥加密对话秘钥发送回Charles中间人，Charles中间人私用私钥解密得到对话秘钥并保存，然后再把对话秘钥用服务端的公钥加密返回给服务端，这样就表示两端握手成功，可以进行通信了。而且中间人也获得了之后的对话秘钥，可以解密之后的对话信息。</p>\n<h6 id=\"Charles实现HTTPS抓包\"><a href=\"#Charles实现HTTPS抓包\" class=\"headerlink\" title=\"Charles实现HTTPS抓包\"></a>Charles实现HTTPS抓包</h6><p>这里基本的HTTP抓包的设置就不讲了，下面是基于实现基本的HTTP抓包的基础上来实现HTTPS的抓包解密。</p>\n<ul>\n<li>安装Charles CA根证书<br>点击<code>Help-&gt;SSL Proxying-&gt;Install Charles Root Certification ...</code>，会弹出如下提示，链接代理，手机浏览器输入<code>chls.pro/ssl</code>，就可以安装根证书了。</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https11.png\" alt=\"\"></p>\n<ul>\n<li>设置SSL代理<br>点击<code>Proxy-&gt;SSL Proxying Setting</code>，勾选<code>Enable SSL Proxying</code>，然后点击Add输入要SSL代理的请求Host和Port，可以使用通配符来表示某一类请求。</li>\n</ul>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https12.png\" alt=\"\"></p>\n<p>或者在对应的请求上右键选择<code>Enable SSL Proxying</code>，就会把这一个请求加入到上面的SSL代理列表中（类似于点击Add的效果）。</p>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/https13.png\" alt=\"\"></p>\n<p>做完上述步骤后重新请求就能得到解密后的信息了。抓取PC端的HTTPS包也类似，在<code>Help-&gt;SSL Proxying</code>中下载证书，双击安装证书，并选择始终信任即可。</p>\n<hr>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"external\">超文本传输安全协议</a><br><a href=\"http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html\" target=\"_blank\" rel=\"external\">图解HTTPS</a><br><a href=\"http://www.jianshu.com/p/e767a4e9252e\" target=\"_blank\" rel=\"external\">HTTPS从原理到应用</a><br><a href=\"http://www.cnblogs.com/guogangj/p/4118605.html\" target=\"_blank\" rel=\"external\">那些证书相关的玩意儿</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\" target=\"_blank\" rel=\"external\">SSL/TLS协议运行机制的概述</a><br><a href=\"http://www.jianshu.com/p/da65e5cd552e\" target=\"_blank\" rel=\"external\">SSL/TLS协议及Openssl工具的实现</a><br><a href=\"http://blog.csdn.net/gx_1983/article/details/47866537\" target=\"_blank\" rel=\"external\">openssl自签名证书生成与单双向验证</a><br><a href=\"http://www.jianshu.com/p/36ddc5b009a7\" target=\"_blank\" rel=\"external\">iOS 10 适配 ATS</a><br><a href=\"http://oncenote.com/2014/10/21/Security-1-HTTPS/\" target=\"_blank\" rel=\"external\">iOS安全系列之一：HTTPS</a><br><a href=\"http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm\" target=\"_blank\" rel=\"external\">iOS安全系列之二：HTTPS进阶</a></p>\n"},{"title":"AVAudioFoundation(5)：音视频导出","date":"2017-07-05T01:21:54.000Z","_content":"本文转自：[AVAudioFoundation(5)：音视频导出 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n要读写音视频数据资源 `asset`，我们需要用到 `AVFoundation` 提供的文件导出 `API`。`AVAssetExportSession` 提供了比较简单的 API 来满足基本的导出需求，比如修改文件类型、剪辑资源长度。如果要满足更加深度的导出需求，我们则需要用到 `AVAssetReader` 和 `AVAssetWriter`。\n\n当我们需要去操作 `asset` 的内容时，我们可以用 `AVAssetReader`，比如读取 `asset` 中的音频轨道来展示波形等等。当我们想用一些音频采样或静态图片去生成 `asset` 时，我们可以使用 `AVAssetWriter`。\n\n需要注意的是 `AVAssetReader` 不适用于做实时处理。`AVAssetReader` 没法用来处理 HLS 之类的实时数据流。但是 `AVAssetWriter` 是可以用来处理实时数据源的，比如 `AVCaptureOutput`，当需要处理实时数据源时，需要设置 `expectsMediaDataInRealTime` 属性为 `YES`。如果对非实时数据源设置该属性为 `YES`，那么可能会造成你导出的文件有问题。\n\n#### 读取 Asset\n\n每一个 `AVAssetReader` 一次只能与一个 `asset` 关联，但是这个 `asset` 可以包含多个轨道。由于这个原因通常我们需要为 `AVAssetReader` 指定一个 `AVAssetReaderOutput` 的具体子类来具体操作 `asset` 的读取，比如：\n\n- `AVAssetReaderTrackOutput`\n- `AVAssetReaderAudioMixOutput`\n- `AVAssetReaderVideoCompositionOutput`\n\n##### 创建 Asset Reader\n\n初始化 `AVAssetReader` 时需要传入相应读取的 `asset`。\n\n```objectivec\nNSError *outError;\nAVAsset *someAsset = <#AVAsset that you want to read#>;\nAVAssetReader *assetReader = [AVAssetReader assetReaderWithAsset:someAsset error:&outError];\nBOOL success = (assetReader != nil);\n```\n\n需要注意的是要检查创建的 `asset reader` 是否为空。初始化失败时，可以查看具体的 `error` 信息。\n\n##### 创建 Asset Reader Outputs\n\n在完成创建 `asset reader` 后，创建至少一个 `output` 对象来接收读取的媒体数据。当创建 `output` 对象时，要记得设置 `alwaysCopiesSampleData` 属性为 `NO`，这样你会获得性能上的提升。在本章中的示例代码中，这个属性都应该被设置为 NO。\n\n如果我们想从媒体资源中读取一个或多个轨道，并且可能会转换数据的格式，那么可以使用 `AVAssetReaderTrackOutput` 类，为每个 `AVAssetTrack` 轨道使用一个 `track output` 对象。\n\n下面的示例展示了使用 `asset reader` 来把一个 `audio track` 压缩为线性的 `PCM`：\n\n```objecivec\nAVAsset *localAsset = assetReader.asset;\n// Get the audio track to read.\nAVAssetTrack *audioTrack = [[localAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];\n// Decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the output with the audio track and decompression settings.\nAVAssetReaderOutput *trackOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:trackOutput]) {\n    [assetReader addOutput:trackOutput];\n}\n```\n\n如果想从一个指定的 `asset track` 按它原本存储的格式读取媒体数据，设置 `outputSettings` 为 `nil` 即可。\n\n当想要读取用 `AVAudioMix` 或 `AVVideoComposition` 混音或编辑过的媒体数据时，需要对应的使用 `AVAssetReaderAudioMixOutput` 和 `AVAssetReaderVideoCompositionOutput`。一般，当我们从一个 `AVComposition` 读取媒体资源时，我们需要用到这些 `output` 类。\n\n使用一个单独的 `audio mix output` 我们就可以读取 `AVAudioMix` 混合过的 `asset` 中的多个音频轨道。为了指明这些音频轨道是如何混合的，我们需要在 `AVAssetReaderAudioMixOutput` 对象初始化完成后将对应的 `AVAudioMix` 对象设置给它的 `audioMix` 属性。\n\n下面的代码展示了如何基于一个 `asset` 来创建我们的 `audio mix output` 对象去处理所有的音频轨道，然后压缩这些音频轨道为线性 `PCM` 数据，并为 `output` 对象设置 `audioMix` 属性。\n\n```objectivec\nAVAudioMix *audioMix = <#An AVAudioMix that specifies how the audio tracks from the AVAsset are mixed#>;\n// Assumes that assetReader was initialized with an AVComposition object.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the audio tracks to read.\nNSArray *audioTracks = [composition tracksWithMediaType:AVMediaTypeAudio];\n// Get the decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the audio mix output with the audio tracks and decompression setttings.\nAVAssetReaderOutput *audioMixOutput = [AVAssetReaderAudioMixOutput assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];\n// Associate the audio mix used to mix the audio tracks being read with the output.\naudioMixOutput.audioMix = audioMix;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:audioMixOutput]) {\n    [assetReader addOutput:audioMixOutput];\n}\n```\n\n如果想要 `asset reader` 返回无压缩格式，那么就把 `audioSettings` 参数传为 `nil`。对于使用 `AVAssetReaderVideoCompositionOutput` 时，也是同样的道理。\n\n我们使用 `video composition output` 的方式跟上面类似。下面的代码展示了，如果读取多个视频轨道的媒体数据并将他们压缩为 `ARGB` 格式。\n\n```objectivec\nAVVideoComposition *videoComposition = <#An AVVideoComposition that specifies how the video tracks from the AVAsset are composited#>;\n// Assumes assetReader was initialized with an AVComposition.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the video tracks to read.\nNSArray *videoTracks = [composition tracksWithMediaType:AVMediaTypeVideo];\n// Decompression settings for ARGB.\nNSDictionary *decompressionVideoSettings = @{(id) kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (id) kCVPixelBufferIOSurfacePropertiesKey: [NSDictionary dictionary]};\n// Create the video composition output with the video tracks and decompression setttings.\nAVAssetReaderOutput *videoCompositionOutput = [AVAssetReaderVideoCompositionOutput assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];\n// Associate the video composition used to composite the video tracks being read with the output.\nvideoCompositionOutput.videoComposition = videoComposition;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:videoCompositionOutput]) {\n    [assetReader addOutput:videoCompositionOutput];\n}\n```\n\n##### 读取 Asset 的媒体数据\n\nTo start reading after setting up all of the outputs you need, call the startReading method on your asset reader. Next, retrieve the media data individually from each output using the copyNextSampleBuffer method. To start up an asset reader with a single output and read all of its media samples, do the following:\n\n在 `output` 对象创建完成后，接着就要开始读取数据了，这时候我们需要调用 `asset reader` 的 `startReading` 接口。接着，使用 `copyNextSampleBuffer` 接口来从各个 `output` 来获取媒体数据。\n\n下面的代码展示了 `asset reader` 如何用一个 `output` 对象从 `asset` 中读取所有的媒体数据：\n\n```objectivec\n// Start the asset reader up.\n[self.assetReader startReading];\nBOOL done = NO;\nwhile (!done) {\n    // Copy the next sample buffer from the reader output.\n    CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n    if (sampleBuffer) {\n        // Do something with sampleBuffer here.\n        CFRelease(sampleBuffer);\n        sampleBuffer = NULL;\n    } else {\n        // Find out why the asset reader output couldn't copy another sample buffer.\n        if (self.assetReader.status == AVAssetReaderStatusFailed) {\n            NSError *failureError = self.assetReader.error;\n            // Handle the error here.\n        } else {\n            // The asset reader output has read all of its samples.\n            done = YES;\n        } \n    }\n}\n```\n\n#### 写入 Asset\n\n`AVAssetWriter` 类可以将媒体数据从多个源写入指定文件格式的单个文件。我们也不需要将 `asset writer` 对象与特定 `asset` 相关联，但必须为要创建的每个输出文件使用单独的 `asset writer`。由于 `asset writer` 可以从多个来源写出媒体数据，因此我们必须为每个要被写入到输出文件的轨道创建一个 `AVAssetWriterInput` 对象。每个 `AVAssetWriterInput` 对象都期望以 `CMSampleBufferRef` 对象的形式接收数据，但是如果要将 `CVPixelBufferRef` 对象附加到 `asset writer`，可以使用 `AVAssetWriterInputPixelBufferAdaptor` 类。\n\n\n##### 创建 Asset Writer\n\n为了创建 `asset writer`，我们需要指定输出文件的 URL 和所需的文件类型。以下代码展示了如何初始化 `asset writer` 来创建 `QuickTime` 格式的视频：\n\n```objectivec\nNSError *outError;\nNSURL *outputURL = <#NSURL object representing the URL where you want to save the video#>;\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:&outError];\nBOOL success = (assetWriter != nil);\n```\n\n##### 创建 Asset Writer Inputs\n\n想要用 `asset writer` 来写媒体数据，必须至少设置一个 `asset writer input`。例如，如果数据源已经使用 `CMSampleBufferRef` 类来表示，那么使用 `AVAssetWriterInput` 类即可。\n\n下面的代码展示了如何设置将音频媒体数据压缩为 `128 kbps AAC` 并将其连接到 `asset writer` 的 `input`：\n\n```objectivec\n// Configure the channel layout as stereo.\nAudioChannelLayout stereoChannelLayout = {\n    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n    .mChannelBitmap = 0,\n    .mNumberChannelDescriptions = 0\n};\n\n// Convert the channel layout object to an NSData object.\nNSData *channelLayoutAsData = [NSData dataWithBytes:&stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n\n// Get the compression settings for 128 kbps AAC.\nNSDictionary *compressionAudioSettings = @{\n    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n    AVChannelLayoutKey    : channelLayoutAsData,\n    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n};\n\n// Create the asset writer input with the compression settings and specify the media type as audio.\nAVAssetWriterInput *assetWriterInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:compressionAudioSettings];\n// Add the input to the writer if possible.\nif ([assetWriter canAddInput:assetWriterInput]) {\n    [assetWriter addInput:assetWriterInput];\n}\n```\n\n需要注意的是，如果要以原本存储的格式来写入媒体数据，可以在 `outputSettings` 参数中传 `nil`。只有`asset writer` 使用 `AVFileTypeQuickTimeMovie` 的 `fileType` 进行初始化时，才能传 `nil`。\n\n您的 `asset writer input` 可以通过设置 `metadata` 和 `transform` 属性来包含一些元数据或为特定的轨道指定不同的变换。对于数据源是视频轨道的 `asset writer input`，您可以通过执行以下操作来将视频的原始变换保存在输出文件中：\n\n```objectivec\nAVAsset *videoAsset = <#AVAsset with at least one video track#>;\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nassetWriterInput.transform = videoAssetTrack.preferredTransform;\n```\n\n需要注意的是 `metadata` 和 `transform` 这两个属性需要在开始写之前设定才会生效。\n\n将媒体数据写入输出文件时，有时我们可能需要分配像素数据缓冲区。这时可以使用 `AVAssetWriterInputPixelBufferAdaptor` 类。为了最大的效率，不要使用单独的池分配的像素缓冲区，而是使用像素缓冲适配器提供的像素缓冲池。以下代码创建一个在 `RGB` 域中工作的像素缓冲区对象，它将使用 `CGImage` 对象来创建其像素缓冲区：\n\n```objectivec\nNSDictionary *pixelBufferAttributes = @{\n     kCVPixelBufferCGImageCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferCGBitmapContextCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithInt:kCVPixelFormatType_32ARGB]\n};\nAVAssetWriterInputPixelBufferAdaptor *inputPixelBufferAdaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:self.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];\n```\n\n需要注意的是，所有 `AVAssetWriterInputPixelBufferAdaptor` 对象必须连接到单个 `asset writer input`。`Asset writer input` 必须接受 `AVMediaTypeVideo` 类型的媒体数据。\n\n##### 写媒体数据\n\n配置 `asset writer` 所需的所有输入后，即可开始写媒体数据。与 `asset reader` 一样，通过调用 `startWriting` 方法启动写入过程。然后，需要通过调用 `startSessionAtSourceTime:` 方法启动写入会话。`Asset writer` 完成的所有写入都必须在这些会话之一内进行，每个会话的时间范围不超出源中包含的媒体数据的时间范围。\n\n下面的代码展示了当我们的数据源是一个 `asset reader`，它提供从 `AVAsset` 对象读取的媒体数据，并且不希望包含资产前半部分的媒体数据：\n\n```objectivec\nCMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);\n[self.assetWriter startSessionAtSourceTime:halfAssetDuration];\n//Implementation continues.\n```\n\n通常，要结束写入会话，您必须调用 `endSessionAtSourceTime:` 方法。但是，如果写入会话直到文件的末尾，则可以通过调用 `finishWriting` 方法来结束。\n\n下面代码展示了使用单个 `input` 启动 `asset writer` 并写入其所有媒体数据：\n\n```objectivec\n// Prepare the asset writer for writing.\n[self.assetWriter startWriting];\n// Start a sample-writing session.\n[self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the next sample buffer.\n        CMSampleBufferRef nextSampleBuffer = [self copyNextSampleBufferToWrite];\n        if (nextSampleBuffer) {\n            // If it exists, append the next sample buffer to the output file.\n            [self.assetWriterInput appendSampleBuffer:nextSampleBuffer];\n            CFRelease(nextSampleBuffer);\n            nextSampleBuffer = nil;\n        } else {\n            // Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.\n            [self.assetWriterInput markAsFinished];\n            break;\n        }\n    }\n}];\n```\n上面代码中的 `copyNextSampleBufferToWrite` 方法只是一个占位方法。在这个方法里需要实现一些逻辑来返回将要写入的媒体数据，用 `CMSampleBufferRef` 对象表示，这里的 `sample buffer` 就可以用 `asset reader input` 作为数据来源。\n\n#### 重编码 Asset\n\n您可以一起使用 `asset reader` 和 `asset writer` 对象将 `asset` 从一种格式转换为另一种。使用这些对象，我们对转换的控制比 `AVAssetExportSession` 要多得多。比如，我们可以选择哪些轨道要写入到输出文件中；指定输出格式；在转换过程中修改 `asset`。此过程的第一步只是根据需要设置 `asset reader outputs` 和 `asset writer inputs`。在 `asset reader` 完全配置后，可以分别调用 `startReading` 和 `startWriting` 方法来启动。\n\n以下代码展示了如何使用单个 `asset writer input` 来写入由单个 `asset reader output` 提供的媒体数据：\n\n```objectivec\nNSString *serializationQueueDescription = [NSString stringWithFormat:@\"%@ serialization queue\", self];\n\n// Create a serialization queue for reading and writing.\ndispatch_queue_t serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\n\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the asset reader output's next sample buffer.\n        CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n        if (sampleBuffer != NULL) {\n            // If it exists, append this sample buffer to the output file.\n            BOOL success = [self.assetWriterInput appendSampleBuffer:sampleBuffer];\n            CFRelease(sampleBuffer);\n            sampleBuffer = NULL;\n            // Check for errors that may have occurred when appending the new sample buffer.\n            if (!success && self.assetWriter.status == AVAssetWriterStatusFailed) {\n                NSError *failureError = self.assetWriter.error;\n                //Handle the error.\n            }\n        } else {\n            // If the next sample buffer doesn't exist, find out why the asset reader output couldn't vend another one.\n            if (self.assetReader.status == AVAssetReaderStatusFailed) {\n                NSError *failureError = self.assetReader.error;\n                //Handle the error here.\n            } else {\n                // The asset reader output must have vended all of its samples. Mark the input as finished.\n                [self.assetWriterInput markAsFinished];\n                break;\n            }\n        }\n    }\n}];\n```\n\n#### 一个完整示例\n\n下面的代码展示了如何使用 `asset reader` 和 `asset writer` 将资产的第一个视频轨道和音频轨重新编码到新的文件中。其中主要包括下面这些步骤：\n\n- 使用序列化队列来处理读和写视听数据。\n- 初始化 `asset reader` 并配置两个 `output`，一个用于音频，另一个用于视频。\n- 初始化 `asset writer` 并配置两个 `input`，一个用于音频，另一个用于视频。\n- 使用 `asset reader` 通过两种不同的输出/输入组合异步地向 `asset writer` 提供媒体数据。\n- 使用 `dispatch group` 来完成重编码的异步调度。\n- 允许用户在编码开始后取消该操作。\n下面是初始化的代码：\n\n```objectivec\n// 初始化过程：\nNSString *serializationQueueDescription = [NSString stringWithFormat:@\"%@ serialization queue\", self];\n\n// Create the main serialization queue.\nself.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\nNSString *rwAudioSerializationQueueDescription = [NSString stringWithFormat:@\"%@ rw audio serialization queue\", self];\n\n// Create the serialization queue to use for reading and writing the audio data.\nself.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], NULL);\nNSString *rwVideoSerializationQueueDescription = [NSString stringWithFormat:@\"%@ rw video serialization queue\", self];\n\n// Create the serialization queue to use for reading and writing the video data.\nself.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], NULL);\n\n\n// 加载资源：\nself.asset = <#AVAsset that you want to reencode#>;\nself.cancelled = NO;\nself.outputURL = <#NSURL representing desired output URL for file generated by asset writer#>;\n// Asynchronously load the tracks of the asset you want to read.\n[self.asset loadValuesAsynchronouslyForKeys:@[@\"tracks\"] completionHandler:^{\n    // Once the tracks have finished loading, dispatch the work to the main serialization queue.\n    dispatch_async(self.mainSerializationQueue, ^{\n        // Due to asynchronous nature, check to see if user has already cancelled.\n        if (self.cancelled) {\n            return;\n        }\n        BOOL success = YES;\n        NSError *localError = nil;\n        // Check for success of loading the assets tracks.\n        success = ([self.asset statusOfValueForKey:@\"tracks\" error:&localError] == AVKeyValueStatusLoaded);\n        if (success) {\n            // If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.\n            NSFileManager *fm = [NSFileManager defaultManager];\n            NSString *localOutputPath = [self.outputURL path];\n            if ([fm fileExistsAtPath:localOutputPath]) {\n                success = [fm removeItemAtPath:localOutputPath error:&localError];\n            }\n        }\n        if (success) {\n            success = [self setupAssetReaderAndAssetWriter:&localError];\n        }\n        if (success) {\n            success = [self startAssetReaderAndWriter:&localError];\n        }\n        if (!success) {\n            [self readingAndWritingDidFinishSuccessfully:success withError:localError];\n        }\n    });\n}];\n```\n\n下面是初始化 asset reader 和 writer 的代码：\n\n```objectivec\n- (BOOL)setupAssetReaderAndAssetWriter:(NSError **)outError {\n     // Create and initialize the asset reader.\n     self.assetReader = [[AVAssetReader alloc] initWithAsset:self.asset error:outError];\n     BOOL success = (self.assetReader != nil);\n     if (success) {\n          // If the asset reader was successfully initialized, do the same for the asset writer.\n          self.assetWriter = [[AVAssetWriter alloc] initWithURL:self.outputURL fileType:AVFileTypeQuickTimeMovie error:outError];\n          success = (self.assetWriter != nil);\n     }\n\n     if (success) {\n          // If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.\n          AVAssetTrack *assetAudioTrack = nil, *assetVideoTrack = nil;\n          NSArray *audioTracks = [self.asset tracksWithMediaType:AVMediaTypeAudio];\n          if ([audioTracks count] > 0) {\n               assetAudioTrack = [audioTracks objectAtIndex:0];\n          }\n          NSArray *videoTracks = [self.asset tracksWithMediaType:AVMediaTypeVideo];\n          if ([videoTracks count] > 0) {\n               assetVideoTrack = [videoTracks objectAtIndex:0];\n          }\n\n          if (assetAudioTrack) {\n               // If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.\n               NSDictionary *decompressionAudioSettings = @{ AVFormatIDKey : [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM] };\n               self.assetReaderAudioOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];\n               [self.assetReader addOutput:self.assetReaderAudioOutput];\n               // Then, set the compression settings to 128kbps AAC and create the asset writer input.\n               AudioChannelLayout stereoChannelLayout = {\n                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n                    .mChannelBitmap = 0,\n                    .mNumberChannelDescriptions = 0\n               };\n               NSData *channelLayoutAsData = [NSData dataWithBytes:&stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n               NSDictionary *compressionAudioSettings = @{\n                    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n                    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n                    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n                    AVChannelLayoutKey    : channelLayoutAsData,\n                    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n               };\n               self.assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];\n               [self.assetWriter addInput:self.assetWriterAudioInput];\n          }\n\n          if (assetVideoTrack) {\n               // If there is a video track to read, set the decompression settings for YUV and create the asset reader output.\n               NSDictionary *decompressionVideoSettings = @{\n                    (id)kCVPixelBufferPixelFormatTypeKey     : [NSNumber numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],\n                    (id)kCVPixelBufferIOSurfacePropertiesKey : [NSDictionary dictionary]\n               };\n               self.assetReaderVideoOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];\n               [self.assetReader addOutput:self.assetReaderVideoOutput];\n               CMFormatDescriptionRef formatDescription = NULL;\n               // Grab the video format descriptions from the video track and grab the first one if it exists.\n               NSArray *videoFormatDescriptions = [assetVideoTrack formatDescriptions];\n               if ([videoFormatDescriptions count] > 0) {\n                    formatDescription = (__bridge CMFormatDescriptionRef)[formatDescriptions objectAtIndex:0];\n               }\n               CGSize trackDimensions = {\n                    .width = 0.0,\n                    .height = 0.0,\n               };\n               // If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.\n               if (formatDescription) {\n                    trackDimensions = CMVideoFormatDescriptionGetPresentationDimensions(formatDescription, false, false);\n               } else {\n                    trackDimensions = [assetVideoTrack naturalSize];\n               }\n               NSDictionary *compressionSettings = nil;\n               // If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.\n               if (formatDescription) {\n                    NSDictionary *cleanAperture = nil;\n                    NSDictionary *pixelAspectRatio = nil;\n                    CFDictionaryRef cleanApertureFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_CleanAperture);\n                    if (cleanApertureFromCMFormatDescription) {\n                         cleanAperture = @{\n                              AVVideoCleanApertureWidthKey            : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),\n                              AVVideoCleanApertureHeightKey           : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),\n                              AVVideoCleanApertureHorizontalOffsetKey : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),\n                              AVVideoCleanApertureVerticalOffsetKey   : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)\n                         };\n                    }\n                    CFDictionaryRef pixelAspectRatioFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);\n                    if (pixelAspectRatioFromCMFormatDescription) {\n                         pixelAspectRatio = @{\n                              AVVideoPixelAspectRatioHorizontalSpacingKey : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),\n                              AVVideoPixelAspectRatioVerticalSpacingKey   : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)\n                         };\n                    }\n                    // Add whichever settings we could grab from the format description to the compression settings dictionary.\n                    if (cleanAperture || pixelAspectRatio) {\n                         NSMutableDictionary *mutableCompressionSettings = [NSMutableDictionary dictionary];\n                         if (cleanAperture) {\n                              [mutableCompressionSettings setObject:cleanAperture forKey:AVVideoCleanApertureKey];\n                         }\n                         if (pixelAspectRatio) {\n                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:AVVideoPixelAspectRatioKey];\n                         }\n                         compressionSettings = mutableCompressionSettings;\n                    }\n               }\n               // Create the video settings dictionary for H.264.\n               NSMutableDictionary *videoSettings = (NSMutableDictionary *) @{\n                    AVVideoCodecKey  : AVVideoCodecH264,\n                    AVVideoWidthKey  : [NSNumber numberWithDouble:trackDimensions.width],\n                    AVVideoHeightKey : [NSNumber numberWithDouble:trackDimensions.height]\n               };\n               // Put the compression settings into the video settings dictionary if we were able to grab them.\n               if (compressionSettings) {\n                    [videoSettings setObject:compressionSettings forKey:AVVideoCompressionPropertiesKey];\n               }\n               // Create the asset writer input and add it to the asset writer.\n               self.assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];\n               [self.assetWriter addInput:self.assetWriterVideoInput];\n          }\n     }\n     return success;\n}\n```\n\n下面是重新编码 asset 的代码：\n\n```objectivec\n- (BOOL)startAssetReaderAndWriter:(NSError **)outError {\n     BOOL success = YES;\n     // Attempt to start the asset reader.\n     success = [self.assetReader startReading];\n     if (!success) {\n          *outError = [self.assetReader error];\n     }\n     if (success) {\n          // If the reader started successfully, attempt to start the asset writer.\n          success = [self.assetWriter startWriting];\n          if (!success) {\n               *outError = [self.assetWriter error];\n          }\n     }\n\n     if (success) {\n          // If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.\n          self.dispatchGroup = dispatch_group_create();\n          [self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n          self.audioFinished = NO;\n          self.videoFinished = NO;\n\n          if (self.assetWriterAudioInput) {\n               // If there is audio to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.\n               [self.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:self.rwAudioSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.audioFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn't complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterAudioInput isReadyForMoreMediaData] && !completedOrFailed) {\n                         // Get the next audio sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderAudioOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterAudioInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the audio work has finished).\n                         BOOL oldFinished = self.audioFinished;\n                         self.audioFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterAudioInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n\n          if (self.assetWriterVideoInput) {\n               // If we had video to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.\n               [self.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:self.rwVideoSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.videoFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn't complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterVideoInput isReadyForMoreMediaData] && !completedOrFailed) {\n                         // Get the next video sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderVideoOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterVideoInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the video work has finished).\n                         BOOL oldFinished = self.videoFinished;\n                         self.videoFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterVideoInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n          // Set up the notification that the dispatch group will send when the audio and video work have both finished.\n          dispatch_group_notify(self.dispatchGroup, self.mainSerializationQueue, ^{\n               BOOL finalSuccess = YES;\n               NSError *finalError = nil;\n               // Check to see if the work has finished due to cancellation.\n               if (self.cancelled) {\n                    // If so, cancel the reader and writer.\n                    [self.assetReader cancelReading];\n                    [self.assetWriter cancelWriting];\n               } else {\n                    // If cancellation didn't occur, first make sure that the asset reader didn't fail.\n                    if ([self.assetReader status] == AVAssetReaderStatusFailed) {\n                         finalSuccess = NO;\n                         finalError = [self.assetReader error];\n                    }\n                    // If the asset reader didn't fail, attempt to stop the asset writer and check for any errors.\n                    if (finalSuccess) {\n                         finalSuccess = [self.assetWriter finishWriting];\n                         if (!finalSuccess) {\n                              finalError = [self.assetWriter error];\n                         }\n                    }\n               }\n               // Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.\n               [self readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];\n          });\n     }\n     // Return success here to indicate whether the asset reader and writer were started successfully.\n     return success;\n}\n```\n\n处理完成的代码：\n\n```objectivec\n- (void)readingAndWritingDidFinishSuccessfully:(BOOL)success withError:(NSError *)error {\n     if (!success) {\n          // If the reencoding process failed, we need to cancel the asset reader and writer.\n          [self.assetReader cancelReading];\n          [self.assetWriter cancelWriting];\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to failure.\n          });\n     } else {\n          // Reencoding was successful, reset booleans.\n          self.cancelled = NO;\n          self.videoFinished = NO;\n          self.audioFinished = NO;\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to success.\n          });\n     }\n}\n```\n处理取消的代码：\n\n```objectivec\n- (void)cancel\n{\n     // Handle cancellation asynchronously, but serialize it with the main queue.\n     dispatch_async(self.mainSerializationQueue, ^{\n          // If we had audio data to reencode, we need to cancel the audio work.\n          if (self.assetWriterAudioInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the audio queue.\n               dispatch_async(self.rwAudioSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.\n                    BOOL oldFinished = self.audioFinished;\n                    self.audioFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterAudioInput markAsFinished];\n                    }\n                    // Leave the dispatch group since the audio work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n\n          if (self.assetWriterVideoInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the video queue.\n               dispatch_async(self.rwVideoSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.\n                    BOOL oldFinished = self.videoFinished;\n                    self.videoFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterVideoInput markAsFinished];\n                    }\n                    // Leave the dispatch group, since the video work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n          // Set the cancelled Boolean property to YES to cancel any work on the main queue as well.\n          self.cancelled = YES;\n     });\n}\n```\n\n#### Asset Output 设置助手\n\n`AVOutputSettingsAssistant` 类有助于为 `asset reader` 或 `writer` 创建输出设置字典。这使得设置更简单，特别是对于具有多个特定预设的高帧率 `H264` 电影。\n\n下面的示例是如何使用 `output settings assistant`：\n\n```objectivec\nAVOutputSettingsAssistant *outputSettingsAssistant = [AVOutputSettingsAssistant outputSettingsAssistantWithPreset:<#some preset#>];\nCMFormatDescriptionRef audioFormat = [self getAudioFormat];\n\nif (audioFormat != NULL) {\n    [outputSettingsAssistant setSourceAudioFormat:(CMAudioFormatDescriptionRef)audioFormat];\n}\n\nCMFormatDescriptionRef videoFormat = [self getVideoFormat];\n\nif (videoFormat != NULL) {\n    [outputSettingsAssistant setSourceVideoFormat:(CMVideoFormatDescriptionRef)videoFormat];\n}\n\nCMTime assetMinVideoFrameDuration = [self getMinFrameDuration];\nCMTime averageFrameDuration = [self getAvgFrameDuration]\n\n[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];\n[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];\n\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:<#some URL#> fileType:[outputSettingsAssistant outputFileType] error:NULL];\nAVAssetWriterInput *audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];\nAVAssetWriterInput *videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];\n```\n\n","source":"_posts/AVAudioFoundation-5-：音视频导出.md","raw":"---\ntitle: AVAudioFoundation(5)：音视频导出\ndate: 2017-07-05 09:21:54\ncategories: \n\t- iOS合集\n---\n本文转自：[AVAudioFoundation(5)：音视频导出 | www.samirchen.com](http://www.samirchen.com/ios-av-asset)\n本文主要内容来自 [AVFoundation Programming Guide](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html)。\n\n要读写音视频数据资源 `asset`，我们需要用到 `AVFoundation` 提供的文件导出 `API`。`AVAssetExportSession` 提供了比较简单的 API 来满足基本的导出需求，比如修改文件类型、剪辑资源长度。如果要满足更加深度的导出需求，我们则需要用到 `AVAssetReader` 和 `AVAssetWriter`。\n\n当我们需要去操作 `asset` 的内容时，我们可以用 `AVAssetReader`，比如读取 `asset` 中的音频轨道来展示波形等等。当我们想用一些音频采样或静态图片去生成 `asset` 时，我们可以使用 `AVAssetWriter`。\n\n需要注意的是 `AVAssetReader` 不适用于做实时处理。`AVAssetReader` 没法用来处理 HLS 之类的实时数据流。但是 `AVAssetWriter` 是可以用来处理实时数据源的，比如 `AVCaptureOutput`，当需要处理实时数据源时，需要设置 `expectsMediaDataInRealTime` 属性为 `YES`。如果对非实时数据源设置该属性为 `YES`，那么可能会造成你导出的文件有问题。\n\n#### 读取 Asset\n\n每一个 `AVAssetReader` 一次只能与一个 `asset` 关联，但是这个 `asset` 可以包含多个轨道。由于这个原因通常我们需要为 `AVAssetReader` 指定一个 `AVAssetReaderOutput` 的具体子类来具体操作 `asset` 的读取，比如：\n\n- `AVAssetReaderTrackOutput`\n- `AVAssetReaderAudioMixOutput`\n- `AVAssetReaderVideoCompositionOutput`\n\n##### 创建 Asset Reader\n\n初始化 `AVAssetReader` 时需要传入相应读取的 `asset`。\n\n```objectivec\nNSError *outError;\nAVAsset *someAsset = <#AVAsset that you want to read#>;\nAVAssetReader *assetReader = [AVAssetReader assetReaderWithAsset:someAsset error:&outError];\nBOOL success = (assetReader != nil);\n```\n\n需要注意的是要检查创建的 `asset reader` 是否为空。初始化失败时，可以查看具体的 `error` 信息。\n\n##### 创建 Asset Reader Outputs\n\n在完成创建 `asset reader` 后，创建至少一个 `output` 对象来接收读取的媒体数据。当创建 `output` 对象时，要记得设置 `alwaysCopiesSampleData` 属性为 `NO`，这样你会获得性能上的提升。在本章中的示例代码中，这个属性都应该被设置为 NO。\n\n如果我们想从媒体资源中读取一个或多个轨道，并且可能会转换数据的格式，那么可以使用 `AVAssetReaderTrackOutput` 类，为每个 `AVAssetTrack` 轨道使用一个 `track output` 对象。\n\n下面的示例展示了使用 `asset reader` 来把一个 `audio track` 压缩为线性的 `PCM`：\n\n```objecivec\nAVAsset *localAsset = assetReader.asset;\n// Get the audio track to read.\nAVAssetTrack *audioTrack = [[localAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];\n// Decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the output with the audio track and decompression settings.\nAVAssetReaderOutput *trackOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:trackOutput]) {\n    [assetReader addOutput:trackOutput];\n}\n```\n\n如果想从一个指定的 `asset track` 按它原本存储的格式读取媒体数据，设置 `outputSettings` 为 `nil` 即可。\n\n当想要读取用 `AVAudioMix` 或 `AVVideoComposition` 混音或编辑过的媒体数据时，需要对应的使用 `AVAssetReaderAudioMixOutput` 和 `AVAssetReaderVideoCompositionOutput`。一般，当我们从一个 `AVComposition` 读取媒体资源时，我们需要用到这些 `output` 类。\n\n使用一个单独的 `audio mix output` 我们就可以读取 `AVAudioMix` 混合过的 `asset` 中的多个音频轨道。为了指明这些音频轨道是如何混合的，我们需要在 `AVAssetReaderAudioMixOutput` 对象初始化完成后将对应的 `AVAudioMix` 对象设置给它的 `audioMix` 属性。\n\n下面的代码展示了如何基于一个 `asset` 来创建我们的 `audio mix output` 对象去处理所有的音频轨道，然后压缩这些音频轨道为线性 `PCM` 数据，并为 `output` 对象设置 `audioMix` 属性。\n\n```objectivec\nAVAudioMix *audioMix = <#An AVAudioMix that specifies how the audio tracks from the AVAsset are mixed#>;\n// Assumes that assetReader was initialized with an AVComposition object.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the audio tracks to read.\nNSArray *audioTracks = [composition tracksWithMediaType:AVMediaTypeAudio];\n// Get the decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the audio mix output with the audio tracks and decompression setttings.\nAVAssetReaderOutput *audioMixOutput = [AVAssetReaderAudioMixOutput assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];\n// Associate the audio mix used to mix the audio tracks being read with the output.\naudioMixOutput.audioMix = audioMix;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:audioMixOutput]) {\n    [assetReader addOutput:audioMixOutput];\n}\n```\n\n如果想要 `asset reader` 返回无压缩格式，那么就把 `audioSettings` 参数传为 `nil`。对于使用 `AVAssetReaderVideoCompositionOutput` 时，也是同样的道理。\n\n我们使用 `video composition output` 的方式跟上面类似。下面的代码展示了，如果读取多个视频轨道的媒体数据并将他们压缩为 `ARGB` 格式。\n\n```objectivec\nAVVideoComposition *videoComposition = <#An AVVideoComposition that specifies how the video tracks from the AVAsset are composited#>;\n// Assumes assetReader was initialized with an AVComposition.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the video tracks to read.\nNSArray *videoTracks = [composition tracksWithMediaType:AVMediaTypeVideo];\n// Decompression settings for ARGB.\nNSDictionary *decompressionVideoSettings = @{(id) kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (id) kCVPixelBufferIOSurfacePropertiesKey: [NSDictionary dictionary]};\n// Create the video composition output with the video tracks and decompression setttings.\nAVAssetReaderOutput *videoCompositionOutput = [AVAssetReaderVideoCompositionOutput assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];\n// Associate the video composition used to composite the video tracks being read with the output.\nvideoCompositionOutput.videoComposition = videoComposition;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:videoCompositionOutput]) {\n    [assetReader addOutput:videoCompositionOutput];\n}\n```\n\n##### 读取 Asset 的媒体数据\n\nTo start reading after setting up all of the outputs you need, call the startReading method on your asset reader. Next, retrieve the media data individually from each output using the copyNextSampleBuffer method. To start up an asset reader with a single output and read all of its media samples, do the following:\n\n在 `output` 对象创建完成后，接着就要开始读取数据了，这时候我们需要调用 `asset reader` 的 `startReading` 接口。接着，使用 `copyNextSampleBuffer` 接口来从各个 `output` 来获取媒体数据。\n\n下面的代码展示了 `asset reader` 如何用一个 `output` 对象从 `asset` 中读取所有的媒体数据：\n\n```objectivec\n// Start the asset reader up.\n[self.assetReader startReading];\nBOOL done = NO;\nwhile (!done) {\n    // Copy the next sample buffer from the reader output.\n    CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n    if (sampleBuffer) {\n        // Do something with sampleBuffer here.\n        CFRelease(sampleBuffer);\n        sampleBuffer = NULL;\n    } else {\n        // Find out why the asset reader output couldn't copy another sample buffer.\n        if (self.assetReader.status == AVAssetReaderStatusFailed) {\n            NSError *failureError = self.assetReader.error;\n            // Handle the error here.\n        } else {\n            // The asset reader output has read all of its samples.\n            done = YES;\n        } \n    }\n}\n```\n\n#### 写入 Asset\n\n`AVAssetWriter` 类可以将媒体数据从多个源写入指定文件格式的单个文件。我们也不需要将 `asset writer` 对象与特定 `asset` 相关联，但必须为要创建的每个输出文件使用单独的 `asset writer`。由于 `asset writer` 可以从多个来源写出媒体数据，因此我们必须为每个要被写入到输出文件的轨道创建一个 `AVAssetWriterInput` 对象。每个 `AVAssetWriterInput` 对象都期望以 `CMSampleBufferRef` 对象的形式接收数据，但是如果要将 `CVPixelBufferRef` 对象附加到 `asset writer`，可以使用 `AVAssetWriterInputPixelBufferAdaptor` 类。\n\n\n##### 创建 Asset Writer\n\n为了创建 `asset writer`，我们需要指定输出文件的 URL 和所需的文件类型。以下代码展示了如何初始化 `asset writer` 来创建 `QuickTime` 格式的视频：\n\n```objectivec\nNSError *outError;\nNSURL *outputURL = <#NSURL object representing the URL where you want to save the video#>;\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:&outError];\nBOOL success = (assetWriter != nil);\n```\n\n##### 创建 Asset Writer Inputs\n\n想要用 `asset writer` 来写媒体数据，必须至少设置一个 `asset writer input`。例如，如果数据源已经使用 `CMSampleBufferRef` 类来表示，那么使用 `AVAssetWriterInput` 类即可。\n\n下面的代码展示了如何设置将音频媒体数据压缩为 `128 kbps AAC` 并将其连接到 `asset writer` 的 `input`：\n\n```objectivec\n// Configure the channel layout as stereo.\nAudioChannelLayout stereoChannelLayout = {\n    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n    .mChannelBitmap = 0,\n    .mNumberChannelDescriptions = 0\n};\n\n// Convert the channel layout object to an NSData object.\nNSData *channelLayoutAsData = [NSData dataWithBytes:&stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n\n// Get the compression settings for 128 kbps AAC.\nNSDictionary *compressionAudioSettings = @{\n    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n    AVChannelLayoutKey    : channelLayoutAsData,\n    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n};\n\n// Create the asset writer input with the compression settings and specify the media type as audio.\nAVAssetWriterInput *assetWriterInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:compressionAudioSettings];\n// Add the input to the writer if possible.\nif ([assetWriter canAddInput:assetWriterInput]) {\n    [assetWriter addInput:assetWriterInput];\n}\n```\n\n需要注意的是，如果要以原本存储的格式来写入媒体数据，可以在 `outputSettings` 参数中传 `nil`。只有`asset writer` 使用 `AVFileTypeQuickTimeMovie` 的 `fileType` 进行初始化时，才能传 `nil`。\n\n您的 `asset writer input` 可以通过设置 `metadata` 和 `transform` 属性来包含一些元数据或为特定的轨道指定不同的变换。对于数据源是视频轨道的 `asset writer input`，您可以通过执行以下操作来将视频的原始变换保存在输出文件中：\n\n```objectivec\nAVAsset *videoAsset = <#AVAsset with at least one video track#>;\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nassetWriterInput.transform = videoAssetTrack.preferredTransform;\n```\n\n需要注意的是 `metadata` 和 `transform` 这两个属性需要在开始写之前设定才会生效。\n\n将媒体数据写入输出文件时，有时我们可能需要分配像素数据缓冲区。这时可以使用 `AVAssetWriterInputPixelBufferAdaptor` 类。为了最大的效率，不要使用单独的池分配的像素缓冲区，而是使用像素缓冲适配器提供的像素缓冲池。以下代码创建一个在 `RGB` 域中工作的像素缓冲区对象，它将使用 `CGImage` 对象来创建其像素缓冲区：\n\n```objectivec\nNSDictionary *pixelBufferAttributes = @{\n     kCVPixelBufferCGImageCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferCGBitmapContextCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithInt:kCVPixelFormatType_32ARGB]\n};\nAVAssetWriterInputPixelBufferAdaptor *inputPixelBufferAdaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:self.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];\n```\n\n需要注意的是，所有 `AVAssetWriterInputPixelBufferAdaptor` 对象必须连接到单个 `asset writer input`。`Asset writer input` 必须接受 `AVMediaTypeVideo` 类型的媒体数据。\n\n##### 写媒体数据\n\n配置 `asset writer` 所需的所有输入后，即可开始写媒体数据。与 `asset reader` 一样，通过调用 `startWriting` 方法启动写入过程。然后，需要通过调用 `startSessionAtSourceTime:` 方法启动写入会话。`Asset writer` 完成的所有写入都必须在这些会话之一内进行，每个会话的时间范围不超出源中包含的媒体数据的时间范围。\n\n下面的代码展示了当我们的数据源是一个 `asset reader`，它提供从 `AVAsset` 对象读取的媒体数据，并且不希望包含资产前半部分的媒体数据：\n\n```objectivec\nCMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);\n[self.assetWriter startSessionAtSourceTime:halfAssetDuration];\n//Implementation continues.\n```\n\n通常，要结束写入会话，您必须调用 `endSessionAtSourceTime:` 方法。但是，如果写入会话直到文件的末尾，则可以通过调用 `finishWriting` 方法来结束。\n\n下面代码展示了使用单个 `input` 启动 `asset writer` 并写入其所有媒体数据：\n\n```objectivec\n// Prepare the asset writer for writing.\n[self.assetWriter startWriting];\n// Start a sample-writing session.\n[self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the next sample buffer.\n        CMSampleBufferRef nextSampleBuffer = [self copyNextSampleBufferToWrite];\n        if (nextSampleBuffer) {\n            // If it exists, append the next sample buffer to the output file.\n            [self.assetWriterInput appendSampleBuffer:nextSampleBuffer];\n            CFRelease(nextSampleBuffer);\n            nextSampleBuffer = nil;\n        } else {\n            // Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.\n            [self.assetWriterInput markAsFinished];\n            break;\n        }\n    }\n}];\n```\n上面代码中的 `copyNextSampleBufferToWrite` 方法只是一个占位方法。在这个方法里需要实现一些逻辑来返回将要写入的媒体数据，用 `CMSampleBufferRef` 对象表示，这里的 `sample buffer` 就可以用 `asset reader input` 作为数据来源。\n\n#### 重编码 Asset\n\n您可以一起使用 `asset reader` 和 `asset writer` 对象将 `asset` 从一种格式转换为另一种。使用这些对象，我们对转换的控制比 `AVAssetExportSession` 要多得多。比如，我们可以选择哪些轨道要写入到输出文件中；指定输出格式；在转换过程中修改 `asset`。此过程的第一步只是根据需要设置 `asset reader outputs` 和 `asset writer inputs`。在 `asset reader` 完全配置后，可以分别调用 `startReading` 和 `startWriting` 方法来启动。\n\n以下代码展示了如何使用单个 `asset writer input` 来写入由单个 `asset reader output` 提供的媒体数据：\n\n```objectivec\nNSString *serializationQueueDescription = [NSString stringWithFormat:@\"%@ serialization queue\", self];\n\n// Create a serialization queue for reading and writing.\ndispatch_queue_t serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\n\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the asset reader output's next sample buffer.\n        CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n        if (sampleBuffer != NULL) {\n            // If it exists, append this sample buffer to the output file.\n            BOOL success = [self.assetWriterInput appendSampleBuffer:sampleBuffer];\n            CFRelease(sampleBuffer);\n            sampleBuffer = NULL;\n            // Check for errors that may have occurred when appending the new sample buffer.\n            if (!success && self.assetWriter.status == AVAssetWriterStatusFailed) {\n                NSError *failureError = self.assetWriter.error;\n                //Handle the error.\n            }\n        } else {\n            // If the next sample buffer doesn't exist, find out why the asset reader output couldn't vend another one.\n            if (self.assetReader.status == AVAssetReaderStatusFailed) {\n                NSError *failureError = self.assetReader.error;\n                //Handle the error here.\n            } else {\n                // The asset reader output must have vended all of its samples. Mark the input as finished.\n                [self.assetWriterInput markAsFinished];\n                break;\n            }\n        }\n    }\n}];\n```\n\n#### 一个完整示例\n\n下面的代码展示了如何使用 `asset reader` 和 `asset writer` 将资产的第一个视频轨道和音频轨重新编码到新的文件中。其中主要包括下面这些步骤：\n\n- 使用序列化队列来处理读和写视听数据。\n- 初始化 `asset reader` 并配置两个 `output`，一个用于音频，另一个用于视频。\n- 初始化 `asset writer` 并配置两个 `input`，一个用于音频，另一个用于视频。\n- 使用 `asset reader` 通过两种不同的输出/输入组合异步地向 `asset writer` 提供媒体数据。\n- 使用 `dispatch group` 来完成重编码的异步调度。\n- 允许用户在编码开始后取消该操作。\n下面是初始化的代码：\n\n```objectivec\n// 初始化过程：\nNSString *serializationQueueDescription = [NSString stringWithFormat:@\"%@ serialization queue\", self];\n\n// Create the main serialization queue.\nself.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\nNSString *rwAudioSerializationQueueDescription = [NSString stringWithFormat:@\"%@ rw audio serialization queue\", self];\n\n// Create the serialization queue to use for reading and writing the audio data.\nself.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], NULL);\nNSString *rwVideoSerializationQueueDescription = [NSString stringWithFormat:@\"%@ rw video serialization queue\", self];\n\n// Create the serialization queue to use for reading and writing the video data.\nself.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], NULL);\n\n\n// 加载资源：\nself.asset = <#AVAsset that you want to reencode#>;\nself.cancelled = NO;\nself.outputURL = <#NSURL representing desired output URL for file generated by asset writer#>;\n// Asynchronously load the tracks of the asset you want to read.\n[self.asset loadValuesAsynchronouslyForKeys:@[@\"tracks\"] completionHandler:^{\n    // Once the tracks have finished loading, dispatch the work to the main serialization queue.\n    dispatch_async(self.mainSerializationQueue, ^{\n        // Due to asynchronous nature, check to see if user has already cancelled.\n        if (self.cancelled) {\n            return;\n        }\n        BOOL success = YES;\n        NSError *localError = nil;\n        // Check for success of loading the assets tracks.\n        success = ([self.asset statusOfValueForKey:@\"tracks\" error:&localError] == AVKeyValueStatusLoaded);\n        if (success) {\n            // If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.\n            NSFileManager *fm = [NSFileManager defaultManager];\n            NSString *localOutputPath = [self.outputURL path];\n            if ([fm fileExistsAtPath:localOutputPath]) {\n                success = [fm removeItemAtPath:localOutputPath error:&localError];\n            }\n        }\n        if (success) {\n            success = [self setupAssetReaderAndAssetWriter:&localError];\n        }\n        if (success) {\n            success = [self startAssetReaderAndWriter:&localError];\n        }\n        if (!success) {\n            [self readingAndWritingDidFinishSuccessfully:success withError:localError];\n        }\n    });\n}];\n```\n\n下面是初始化 asset reader 和 writer 的代码：\n\n```objectivec\n- (BOOL)setupAssetReaderAndAssetWriter:(NSError **)outError {\n     // Create and initialize the asset reader.\n     self.assetReader = [[AVAssetReader alloc] initWithAsset:self.asset error:outError];\n     BOOL success = (self.assetReader != nil);\n     if (success) {\n          // If the asset reader was successfully initialized, do the same for the asset writer.\n          self.assetWriter = [[AVAssetWriter alloc] initWithURL:self.outputURL fileType:AVFileTypeQuickTimeMovie error:outError];\n          success = (self.assetWriter != nil);\n     }\n\n     if (success) {\n          // If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.\n          AVAssetTrack *assetAudioTrack = nil, *assetVideoTrack = nil;\n          NSArray *audioTracks = [self.asset tracksWithMediaType:AVMediaTypeAudio];\n          if ([audioTracks count] > 0) {\n               assetAudioTrack = [audioTracks objectAtIndex:0];\n          }\n          NSArray *videoTracks = [self.asset tracksWithMediaType:AVMediaTypeVideo];\n          if ([videoTracks count] > 0) {\n               assetVideoTrack = [videoTracks objectAtIndex:0];\n          }\n\n          if (assetAudioTrack) {\n               // If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.\n               NSDictionary *decompressionAudioSettings = @{ AVFormatIDKey : [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM] };\n               self.assetReaderAudioOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];\n               [self.assetReader addOutput:self.assetReaderAudioOutput];\n               // Then, set the compression settings to 128kbps AAC and create the asset writer input.\n               AudioChannelLayout stereoChannelLayout = {\n                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n                    .mChannelBitmap = 0,\n                    .mNumberChannelDescriptions = 0\n               };\n               NSData *channelLayoutAsData = [NSData dataWithBytes:&stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n               NSDictionary *compressionAudioSettings = @{\n                    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n                    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n                    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n                    AVChannelLayoutKey    : channelLayoutAsData,\n                    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n               };\n               self.assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];\n               [self.assetWriter addInput:self.assetWriterAudioInput];\n          }\n\n          if (assetVideoTrack) {\n               // If there is a video track to read, set the decompression settings for YUV and create the asset reader output.\n               NSDictionary *decompressionVideoSettings = @{\n                    (id)kCVPixelBufferPixelFormatTypeKey     : [NSNumber numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],\n                    (id)kCVPixelBufferIOSurfacePropertiesKey : [NSDictionary dictionary]\n               };\n               self.assetReaderVideoOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];\n               [self.assetReader addOutput:self.assetReaderVideoOutput];\n               CMFormatDescriptionRef formatDescription = NULL;\n               // Grab the video format descriptions from the video track and grab the first one if it exists.\n               NSArray *videoFormatDescriptions = [assetVideoTrack formatDescriptions];\n               if ([videoFormatDescriptions count] > 0) {\n                    formatDescription = (__bridge CMFormatDescriptionRef)[formatDescriptions objectAtIndex:0];\n               }\n               CGSize trackDimensions = {\n                    .width = 0.0,\n                    .height = 0.0,\n               };\n               // If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.\n               if (formatDescription) {\n                    trackDimensions = CMVideoFormatDescriptionGetPresentationDimensions(formatDescription, false, false);\n               } else {\n                    trackDimensions = [assetVideoTrack naturalSize];\n               }\n               NSDictionary *compressionSettings = nil;\n               // If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.\n               if (formatDescription) {\n                    NSDictionary *cleanAperture = nil;\n                    NSDictionary *pixelAspectRatio = nil;\n                    CFDictionaryRef cleanApertureFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_CleanAperture);\n                    if (cleanApertureFromCMFormatDescription) {\n                         cleanAperture = @{\n                              AVVideoCleanApertureWidthKey            : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),\n                              AVVideoCleanApertureHeightKey           : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),\n                              AVVideoCleanApertureHorizontalOffsetKey : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),\n                              AVVideoCleanApertureVerticalOffsetKey   : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)\n                         };\n                    }\n                    CFDictionaryRef pixelAspectRatioFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);\n                    if (pixelAspectRatioFromCMFormatDescription) {\n                         pixelAspectRatio = @{\n                              AVVideoPixelAspectRatioHorizontalSpacingKey : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),\n                              AVVideoPixelAspectRatioVerticalSpacingKey   : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)\n                         };\n                    }\n                    // Add whichever settings we could grab from the format description to the compression settings dictionary.\n                    if (cleanAperture || pixelAspectRatio) {\n                         NSMutableDictionary *mutableCompressionSettings = [NSMutableDictionary dictionary];\n                         if (cleanAperture) {\n                              [mutableCompressionSettings setObject:cleanAperture forKey:AVVideoCleanApertureKey];\n                         }\n                         if (pixelAspectRatio) {\n                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:AVVideoPixelAspectRatioKey];\n                         }\n                         compressionSettings = mutableCompressionSettings;\n                    }\n               }\n               // Create the video settings dictionary for H.264.\n               NSMutableDictionary *videoSettings = (NSMutableDictionary *) @{\n                    AVVideoCodecKey  : AVVideoCodecH264,\n                    AVVideoWidthKey  : [NSNumber numberWithDouble:trackDimensions.width],\n                    AVVideoHeightKey : [NSNumber numberWithDouble:trackDimensions.height]\n               };\n               // Put the compression settings into the video settings dictionary if we were able to grab them.\n               if (compressionSettings) {\n                    [videoSettings setObject:compressionSettings forKey:AVVideoCompressionPropertiesKey];\n               }\n               // Create the asset writer input and add it to the asset writer.\n               self.assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];\n               [self.assetWriter addInput:self.assetWriterVideoInput];\n          }\n     }\n     return success;\n}\n```\n\n下面是重新编码 asset 的代码：\n\n```objectivec\n- (BOOL)startAssetReaderAndWriter:(NSError **)outError {\n     BOOL success = YES;\n     // Attempt to start the asset reader.\n     success = [self.assetReader startReading];\n     if (!success) {\n          *outError = [self.assetReader error];\n     }\n     if (success) {\n          // If the reader started successfully, attempt to start the asset writer.\n          success = [self.assetWriter startWriting];\n          if (!success) {\n               *outError = [self.assetWriter error];\n          }\n     }\n\n     if (success) {\n          // If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.\n          self.dispatchGroup = dispatch_group_create();\n          [self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n          self.audioFinished = NO;\n          self.videoFinished = NO;\n\n          if (self.assetWriterAudioInput) {\n               // If there is audio to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.\n               [self.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:self.rwAudioSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.audioFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn't complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterAudioInput isReadyForMoreMediaData] && !completedOrFailed) {\n                         // Get the next audio sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderAudioOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterAudioInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the audio work has finished).\n                         BOOL oldFinished = self.audioFinished;\n                         self.audioFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterAudioInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n\n          if (self.assetWriterVideoInput) {\n               // If we had video to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.\n               [self.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:self.rwVideoSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.videoFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn't complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterVideoInput isReadyForMoreMediaData] && !completedOrFailed) {\n                         // Get the next video sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderVideoOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterVideoInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the video work has finished).\n                         BOOL oldFinished = self.videoFinished;\n                         self.videoFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterVideoInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n          // Set up the notification that the dispatch group will send when the audio and video work have both finished.\n          dispatch_group_notify(self.dispatchGroup, self.mainSerializationQueue, ^{\n               BOOL finalSuccess = YES;\n               NSError *finalError = nil;\n               // Check to see if the work has finished due to cancellation.\n               if (self.cancelled) {\n                    // If so, cancel the reader and writer.\n                    [self.assetReader cancelReading];\n                    [self.assetWriter cancelWriting];\n               } else {\n                    // If cancellation didn't occur, first make sure that the asset reader didn't fail.\n                    if ([self.assetReader status] == AVAssetReaderStatusFailed) {\n                         finalSuccess = NO;\n                         finalError = [self.assetReader error];\n                    }\n                    // If the asset reader didn't fail, attempt to stop the asset writer and check for any errors.\n                    if (finalSuccess) {\n                         finalSuccess = [self.assetWriter finishWriting];\n                         if (!finalSuccess) {\n                              finalError = [self.assetWriter error];\n                         }\n                    }\n               }\n               // Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.\n               [self readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];\n          });\n     }\n     // Return success here to indicate whether the asset reader and writer were started successfully.\n     return success;\n}\n```\n\n处理完成的代码：\n\n```objectivec\n- (void)readingAndWritingDidFinishSuccessfully:(BOOL)success withError:(NSError *)error {\n     if (!success) {\n          // If the reencoding process failed, we need to cancel the asset reader and writer.\n          [self.assetReader cancelReading];\n          [self.assetWriter cancelWriting];\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to failure.\n          });\n     } else {\n          // Reencoding was successful, reset booleans.\n          self.cancelled = NO;\n          self.videoFinished = NO;\n          self.audioFinished = NO;\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to success.\n          });\n     }\n}\n```\n处理取消的代码：\n\n```objectivec\n- (void)cancel\n{\n     // Handle cancellation asynchronously, but serialize it with the main queue.\n     dispatch_async(self.mainSerializationQueue, ^{\n          // If we had audio data to reencode, we need to cancel the audio work.\n          if (self.assetWriterAudioInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the audio queue.\n               dispatch_async(self.rwAudioSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.\n                    BOOL oldFinished = self.audioFinished;\n                    self.audioFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterAudioInput markAsFinished];\n                    }\n                    // Leave the dispatch group since the audio work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n\n          if (self.assetWriterVideoInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the video queue.\n               dispatch_async(self.rwVideoSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.\n                    BOOL oldFinished = self.videoFinished;\n                    self.videoFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterVideoInput markAsFinished];\n                    }\n                    // Leave the dispatch group, since the video work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n          // Set the cancelled Boolean property to YES to cancel any work on the main queue as well.\n          self.cancelled = YES;\n     });\n}\n```\n\n#### Asset Output 设置助手\n\n`AVOutputSettingsAssistant` 类有助于为 `asset reader` 或 `writer` 创建输出设置字典。这使得设置更简单，特别是对于具有多个特定预设的高帧率 `H264` 电影。\n\n下面的示例是如何使用 `output settings assistant`：\n\n```objectivec\nAVOutputSettingsAssistant *outputSettingsAssistant = [AVOutputSettingsAssistant outputSettingsAssistantWithPreset:<#some preset#>];\nCMFormatDescriptionRef audioFormat = [self getAudioFormat];\n\nif (audioFormat != NULL) {\n    [outputSettingsAssistant setSourceAudioFormat:(CMAudioFormatDescriptionRef)audioFormat];\n}\n\nCMFormatDescriptionRef videoFormat = [self getVideoFormat];\n\nif (videoFormat != NULL) {\n    [outputSettingsAssistant setSourceVideoFormat:(CMVideoFormatDescriptionRef)videoFormat];\n}\n\nCMTime assetMinVideoFrameDuration = [self getMinFrameDuration];\nCMTime averageFrameDuration = [self getAvgFrameDuration]\n\n[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];\n[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];\n\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:<#some URL#> fileType:[outputSettingsAssistant outputFileType] error:NULL];\nAVAssetWriterInput *audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];\nAVAssetWriterInput *videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];\n```\n\n","slug":"AVAudioFoundation-5-：音视频导出","published":1,"updated":"2017-07-07T11:15:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvp000oznuzqnfmzfl3","content":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(5)：音视频导出 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>要读写音视频数据资源 <code>asset</code>，我们需要用到 <code>AVFoundation</code> 提供的文件导出 <code>API</code>。<code>AVAssetExportSession</code> 提供了比较简单的 API 来满足基本的导出需求，比如修改文件类型、剪辑资源长度。如果要满足更加深度的导出需求，我们则需要用到 <code>AVAssetReader</code> 和 <code>AVAssetWriter</code>。</p>\n<p>当我们需要去操作 <code>asset</code> 的内容时，我们可以用 <code>AVAssetReader</code>，比如读取 <code>asset</code> 中的音频轨道来展示波形等等。当我们想用一些音频采样或静态图片去生成 <code>asset</code> 时，我们可以使用 <code>AVAssetWriter</code>。</p>\n<p>需要注意的是 <code>AVAssetReader</code> 不适用于做实时处理。<code>AVAssetReader</code> 没法用来处理 HLS 之类的实时数据流。但是 <code>AVAssetWriter</code> 是可以用来处理实时数据源的，比如 <code>AVCaptureOutput</code>，当需要处理实时数据源时，需要设置 <code>expectsMediaDataInRealTime</code> 属性为 <code>YES</code>。如果对非实时数据源设置该属性为 <code>YES</code>，那么可能会造成你导出的文件有问题。</p>\n<h4 id=\"读取-Asset\"><a href=\"#读取-Asset\" class=\"headerlink\" title=\"读取 Asset\"></a>读取 Asset</h4><p>每一个 <code>AVAssetReader</code> 一次只能与一个 <code>asset</code> 关联，但是这个 <code>asset</code> 可以包含多个轨道。由于这个原因通常我们需要为 <code>AVAssetReader</code> 指定一个 <code>AVAssetReaderOutput</code> 的具体子类来具体操作 <code>asset</code> 的读取，比如：</p>\n<ul>\n<li><code>AVAssetReaderTrackOutput</code></li>\n<li><code>AVAssetReaderAudioMixOutput</code></li>\n<li><code>AVAssetReaderVideoCompositionOutput</code></li>\n</ul>\n<h5 id=\"创建-Asset-Reader\"><a href=\"#创建-Asset-Reader\" class=\"headerlink\" title=\"创建 Asset Reader\"></a>创建 Asset Reader</h5><p>初始化 <code>AVAssetReader</code> 时需要传入相应读取的 <code>asset</code>。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSError <span class=\"token operator\">*</span>outError<span class=\"token punctuation\">;</span>\nAVAsset <span class=\"token operator\">*</span>someAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAsset that you want to read#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAssetReader <span class=\"token operator\">*</span>assetReader <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetReader assetReaderWithAsset<span class=\"token punctuation\">:</span>someAsset error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>outError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nBOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>assetReader <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>需要注意的是要检查创建的 <code>asset reader</code> 是否为空。初始化失败时，可以查看具体的 <code>error</code> 信息。</p>\n<h5 id=\"创建-Asset-Reader-Outputs\"><a href=\"#创建-Asset-Reader-Outputs\" class=\"headerlink\" title=\"创建 Asset Reader Outputs\"></a>创建 Asset Reader Outputs</h5><p>在完成创建 <code>asset reader</code> 后，创建至少一个 <code>output</code> 对象来接收读取的媒体数据。当创建 <code>output</code> 对象时，要记得设置 <code>alwaysCopiesSampleData</code> 属性为 <code>NO</code>，这样你会获得性能上的提升。在本章中的示例代码中，这个属性都应该被设置为 NO。</p>\n<p>如果我们想从媒体资源中读取一个或多个轨道，并且可能会转换数据的格式，那么可以使用 <code>AVAssetReaderTrackOutput</code> 类，为每个 <code>AVAssetTrack</code> 轨道使用一个 <code>track output</code> 对象。</p>\n<p>下面的示例展示了使用 <code>asset reader</code> 来把一个 <code>audio track</code> 压缩为线性的 <code>PCM</code>：</p>\n<pre class=\" language-objecivec\"><code class=\"language-objecivec\">AVAsset *localAsset = assetReader.asset;\n// Get the audio track to read.\nAVAssetTrack *audioTrack = [[localAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];\n// Decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the output with the audio track and decompression settings.\nAVAssetReaderOutput *trackOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:trackOutput]) {\n    [assetReader addOutput:trackOutput];\n}\n</code></pre>\n<p>如果想从一个指定的 <code>asset track</code> 按它原本存储的格式读取媒体数据，设置 <code>outputSettings</code> 为 <code>nil</code> 即可。</p>\n<p>当想要读取用 <code>AVAudioMix</code> 或 <code>AVVideoComposition</code> 混音或编辑过的媒体数据时，需要对应的使用 <code>AVAssetReaderAudioMixOutput</code> 和 <code>AVAssetReaderVideoCompositionOutput</code>。一般，当我们从一个 <code>AVComposition</code> 读取媒体资源时，我们需要用到这些 <code>output</code> 类。</p>\n<p>使用一个单独的 <code>audio mix output</code> 我们就可以读取 <code>AVAudioMix</code> 混合过的 <code>asset</code> 中的多个音频轨道。为了指明这些音频轨道是如何混合的，我们需要在 <code>AVAssetReaderAudioMixOutput</code> 对象初始化完成后将对应的 <code>AVAudioMix</code> 对象设置给它的 <code>audioMix</code> 属性。</p>\n<p>下面的代码展示了如何基于一个 <code>asset</code> 来创建我们的 <code>audio mix output</code> 对象去处理所有的音频轨道，然后压缩这些音频轨道为线性 <code>PCM</code> 数据，并为 <code>output</code> 对象设置 <code>audioMix</code> 属性。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAudioMix <span class=\"token operator\">*</span>audioMix <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An AVAudioMix that specifies how the audio tracks from the AVAsset are mixed#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Assumes that assetReader was initialized with an AVComposition object.</span>\nAVComposition <span class=\"token operator\">*</span>composition <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>AVComposition <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> assetReader<span class=\"token punctuation\">.</span>asset<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Get the audio tracks to read.</span>\nNSArray <span class=\"token operator\">*</span>audioTracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>composition tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Get the decompression settings for Linear PCM.</span>\nNSDictionary <span class=\"token operator\">*</span>decompressionAudioSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>AVFormatIDKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kAudioFormatLinearPCM<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the audio mix output with the audio tracks and decompression setttings.</span>\nAVAssetReaderOutput <span class=\"token operator\">*</span>audioMixOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetReaderAudioMixOutput assetReaderAudioMixOutputWithAudioTracks<span class=\"token punctuation\">:</span>audioTracks audioSettings<span class=\"token punctuation\">:</span>decompressionAudioSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Associate the audio mix used to mix the audio tracks being read with the output.</span>\naudioMixOutput<span class=\"token punctuation\">.</span>audioMix <span class=\"token operator\">=</span> audioMix<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add the output to the reader if possible.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>assetReader canAddOutput<span class=\"token punctuation\">:</span>audioMixOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>assetReader addOutput<span class=\"token punctuation\">:</span>audioMixOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果想要 <code>asset reader</code> 返回无压缩格式，那么就把 <code>audioSettings</code> 参数传为 <code>nil</code>。对于使用 <code>AVAssetReaderVideoCompositionOutput</code> 时，也是同样的道理。</p>\n<p>我们使用 <code>video composition output</code> 的方式跟上面类似。下面的代码展示了，如果读取多个视频轨道的媒体数据并将他们压缩为 <code>ARGB</code> 格式。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVVideoComposition <span class=\"token operator\">*</span>videoComposition <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#An AVVideoComposition that specifies how the video tracks from the AVAsset are composited#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Assumes assetReader was initialized with an AVComposition.</span>\nAVComposition <span class=\"token operator\">*</span>composition <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>AVComposition <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> assetReader<span class=\"token punctuation\">.</span>asset<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Get the video tracks to read.</span>\nNSArray <span class=\"token operator\">*</span>videoTracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>composition tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Decompression settings for ARGB.</span>\nNSDictionary <span class=\"token operator\">*</span>decompressionVideoSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> kCVPixelBufferPixelFormatTypeKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kCVPixelFormatType_32ARGB<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> kCVPixelBufferIOSurfacePropertiesKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Create the video composition output with the video tracks and decompression setttings.</span>\nAVAssetReaderOutput <span class=\"token operator\">*</span>videoCompositionOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetReaderVideoCompositionOutput assetReaderVideoCompositionOutputWithVideoTracks<span class=\"token punctuation\">:</span>videoTracks videoSettings<span class=\"token punctuation\">:</span>decompressionVideoSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Associate the video composition used to composite the video tracks being read with the output.</span>\nvideoCompositionOutput<span class=\"token punctuation\">.</span>videoComposition <span class=\"token operator\">=</span> videoComposition<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add the output to the reader if possible.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>assetReader canAddOutput<span class=\"token punctuation\">:</span>videoCompositionOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>assetReader addOutput<span class=\"token punctuation\">:</span>videoCompositionOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h5 id=\"读取-Asset-的媒体数据\"><a href=\"#读取-Asset-的媒体数据\" class=\"headerlink\" title=\"读取 Asset 的媒体数据\"></a>读取 Asset 的媒体数据</h5><p>To start reading after setting up all of the outputs you need, call the startReading method on your asset reader. Next, retrieve the media data individually from each output using the copyNextSampleBuffer method. To start up an asset reader with a single output and read all of its media samples, do the following:</p>\n<p>在 <code>output</code> 对象创建完成后，接着就要开始读取数据了，这时候我们需要调用 <code>asset reader</code> 的 <code>startReading</code> 接口。接着，使用 <code>copyNextSampleBuffer</code> 接口来从各个 <code>output</code> 来获取媒体数据。</p>\n<p>下面的代码展示了 <code>asset reader</code> 如何用一个 <code>output</code> 对象从 <code>asset</code> 中读取所有的媒体数据：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Start the asset reader up.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader startReading<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nBOOL done <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Copy the next sample buffer from the reader output.</span>\n    CMSampleBufferRef sampleBuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderOutput copyNextSampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Do something with sampleBuffer here.</span>\n        <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sampleBuffer <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Find out why the asset reader output couldn't copy another sample buffer.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> AVAssetReaderStatusFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSError <span class=\"token operator\">*</span>failureError <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Handle the error here.</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// The asset reader output has read all of its samples.</span>\n            done <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"写入-Asset\"><a href=\"#写入-Asset\" class=\"headerlink\" title=\"写入 Asset\"></a>写入 Asset</h4><p><code>AVAssetWriter</code> 类可以将媒体数据从多个源写入指定文件格式的单个文件。我们也不需要将 <code>asset writer</code> 对象与特定 <code>asset</code> 相关联，但必须为要创建的每个输出文件使用单独的 <code>asset writer</code>。由于 <code>asset writer</code> 可以从多个来源写出媒体数据，因此我们必须为每个要被写入到输出文件的轨道创建一个 <code>AVAssetWriterInput</code> 对象。每个 <code>AVAssetWriterInput</code> 对象都期望以 <code>CMSampleBufferRef</code> 对象的形式接收数据，但是如果要将 <code>CVPixelBufferRef</code> 对象附加到 <code>asset writer</code>，可以使用 <code>AVAssetWriterInputPixelBufferAdaptor</code> 类。</p>\n<h5 id=\"创建-Asset-Writer\"><a href=\"#创建-Asset-Writer\" class=\"headerlink\" title=\"创建 Asset Writer\"></a>创建 Asset Writer</h5><p>为了创建 <code>asset writer</code>，我们需要指定输出文件的 URL 和所需的文件类型。以下代码展示了如何初始化 <code>asset writer</code> 来创建 <code>QuickTime</code> 格式的视频：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSError <span class=\"token operator\">*</span>outError<span class=\"token punctuation\">;</span>\nNSURL <span class=\"token operator\">*</span>outputURL <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#NSURL object representing the URL where you want to save the video#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAssetWriter <span class=\"token operator\">*</span>assetWriter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriter assetWriterWithURL<span class=\"token punctuation\">:</span>outputURL fileType<span class=\"token punctuation\">:</span>AVFileTypeQuickTimeMovie error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>outError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nBOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>assetWriter <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h5 id=\"创建-Asset-Writer-Inputs\"><a href=\"#创建-Asset-Writer-Inputs\" class=\"headerlink\" title=\"创建 Asset Writer Inputs\"></a>创建 Asset Writer Inputs</h5><p>想要用 <code>asset writer</code> 来写媒体数据，必须至少设置一个 <code>asset writer input</code>。例如，如果数据源已经使用 <code>CMSampleBufferRef</code> 类来表示，那么使用 <code>AVAssetWriterInput</code> 类即可。</p>\n<p>下面的代码展示了如何设置将音频媒体数据压缩为 <code>128 kbps AAC</code> 并将其连接到 <code>asset writer</code> 的 <code>input</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Configure the channel layout as stereo.</span>\nAudioChannelLayout stereoChannelLayout <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span>mChannelLayoutTag <span class=\"token operator\">=</span> kAudioChannelLayoutTag_Stereo<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>mChannelBitmap <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>mNumberChannelDescriptions <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Convert the channel layout object to an NSData object.</span>\nNSData <span class=\"token operator\">*</span>channelLayoutAsData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithBytes<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>stereoChannelLayout length<span class=\"token punctuation\">:</span><span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>AudioChannelLayout<span class=\"token punctuation\">,</span> mChannelDescriptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Get the compression settings for 128 kbps AAC.</span>\nNSDictionary <span class=\"token operator\">*</span>compressionAudioSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n    AVFormatIDKey         <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kAudioFormatMPEG4AAC<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    AVEncoderBitRateKey   <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInteger<span class=\"token punctuation\">:</span><span class=\"token number\">128000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    AVSampleRateKey       <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInteger<span class=\"token punctuation\">:</span><span class=\"token number\">44100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    AVChannelLayoutKey    <span class=\"token punctuation\">:</span> channelLayoutAsData<span class=\"token punctuation\">,</span>\n    AVNumberOfChannelsKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInteger<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create the asset writer input with the compression settings and specify the media type as audio.</span>\nAVAssetWriterInput <span class=\"token operator\">*</span>assetWriterInput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInput assetWriterInputWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio outputSettings<span class=\"token punctuation\">:</span>compressionAudioSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Add the input to the writer if possible.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>assetWriter canAddInput<span class=\"token punctuation\">:</span>assetWriterInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>assetWriter addInput<span class=\"token punctuation\">:</span>assetWriterInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>需要注意的是，如果要以原本存储的格式来写入媒体数据，可以在 <code>outputSettings</code> 参数中传 <code>nil</code>。只有<code>asset writer</code> 使用 <code>AVFileTypeQuickTimeMovie</code> 的 <code>fileType</code> 进行初始化时，才能传 <code>nil</code>。</p>\n<p>您的 <code>asset writer input</code> 可以通过设置 <code>metadata</code> 和 <code>transform</code> 属性来包含一些元数据或为特定的轨道指定不同的变换。对于数据源是视频轨道的 <code>asset writer input</code>，您可以通过执行以下操作来将视频的原始变换保存在输出文件中：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVAsset <span class=\"token operator\">*</span>videoAsset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAsset with at least one video track#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nAVAssetTrack <span class=\"token operator\">*</span>videoAssetTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>videoAsset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span> objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nassetWriterInput<span class=\"token punctuation\">.</span>transform <span class=\"token operator\">=</span> videoAssetTrack<span class=\"token punctuation\">.</span>preferredTransform<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>需要注意的是 <code>metadata</code> 和 <code>transform</code> 这两个属性需要在开始写之前设定才会生效。</p>\n<p>将媒体数据写入输出文件时，有时我们可能需要分配像素数据缓冲区。这时可以使用 <code>AVAssetWriterInputPixelBufferAdaptor</code> 类。为了最大的效率，不要使用单独的池分配的像素缓冲区，而是使用像素缓冲适配器提供的像素缓冲池。以下代码创建一个在 <code>RGB</code> 域中工作的像素缓冲区对象，它将使用 <code>CGImage</code> 对象来创建其像素缓冲区：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSDictionary <span class=\"token operator\">*</span>pixelBufferAttributes <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n     kCVPixelBufferCGImageCompatibilityKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n     kCVPixelBufferCGBitmapContextCompatibilityKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n     kCVPixelBufferPixelFormatTypeKey<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInt<span class=\"token punctuation\">:</span>kCVPixelFormatType_32ARGB<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nAVAssetWriterInputPixelBufferAdaptor <span class=\"token operator\">*</span>inputPixelBufferAdaptor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput sourcePixelBufferAttributes<span class=\"token punctuation\">:</span>pixelBufferAttributes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>需要注意的是，所有 <code>AVAssetWriterInputPixelBufferAdaptor</code> 对象必须连接到单个 <code>asset writer input</code>。<code>Asset writer input</code> 必须接受 <code>AVMediaTypeVideo</code> 类型的媒体数据。</p>\n<h5 id=\"写媒体数据\"><a href=\"#写媒体数据\" class=\"headerlink\" title=\"写媒体数据\"></a>写媒体数据</h5><p>配置 <code>asset writer</code> 所需的所有输入后，即可开始写媒体数据。与 <code>asset reader</code> 一样，通过调用 <code>startWriting</code> 方法启动写入过程。然后，需要通过调用 <code>startSessionAtSourceTime:</code> 方法启动写入会话。<code>Asset writer</code> 完成的所有写入都必须在这些会话之一内进行，每个会话的时间范围不超出源中包含的媒体数据的时间范围。</p>\n<p>下面的代码展示了当我们的数据源是一个 <code>asset reader</code>，它提供从 <code>AVAsset</code> 对象读取的媒体数据，并且不希望包含资产前半部分的媒体数据：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">CMTime halfAssetDuration <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMultiplyByFloat64</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset<span class=\"token punctuation\">.</span>duration<span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter startSessionAtSourceTime<span class=\"token punctuation\">:</span>halfAssetDuration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//Implementation continues.</span>\n</code></pre>\n<p>通常，要结束写入会话，您必须调用 <code>endSessionAtSourceTime:</code> 方法。但是，如果写入会话直到文件的末尾，则可以通过调用 <code>finishWriting</code> 方法来结束。</p>\n<p>下面代码展示了使用单个 <code>input</code> 启动 <code>asset writer</code> 并写入其所有媒体数据：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// Prepare the asset writer for writing.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter startWriting<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Start a sample-writing session.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter startSessionAtSourceTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput requestMediaDataWhenReadyOnQueue<span class=\"token punctuation\">:</span>myInputSerialQueue usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput isReadyForMoreMediaData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Get the next sample buffer.</span>\n        CMSampleBufferRef nextSampleBuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> copyNextSampleBufferToWrite<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextSampleBuffer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// If it exists, append the next sample buffer to the output file.</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput appendSampleBuffer<span class=\"token punctuation\">:</span>nextSampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>nextSampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            nextSampleBuffer <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>上面代码中的 <code>copyNextSampleBufferToWrite</code> 方法只是一个占位方法。在这个方法里需要实现一些逻辑来返回将要写入的媒体数据，用 <code>CMSampleBufferRef</code> 对象表示，这里的 <code>sample buffer</code> 就可以用 <code>asset reader input</code> 作为数据来源。</p>\n<h4 id=\"重编码-Asset\"><a href=\"#重编码-Asset\" class=\"headerlink\" title=\"重编码 Asset\"></a>重编码 Asset</h4><p>您可以一起使用 <code>asset reader</code> 和 <code>asset writer</code> 对象将 <code>asset</code> 从一种格式转换为另一种。使用这些对象，我们对转换的控制比 <code>AVAssetExportSession</code> 要多得多。比如，我们可以选择哪些轨道要写入到输出文件中；指定输出格式；在转换过程中修改 <code>asset</code>。此过程的第一步只是根据需要设置 <code>asset reader outputs</code> 和 <code>asset writer inputs</code>。在 <code>asset reader</code> 完全配置后，可以分别调用 <code>startReading</code> 和 <code>startWriting</code> 方法来启动。</p>\n<p>以下代码展示了如何使用单个 <code>asset writer input</code> 来写入由单个 <code>asset reader output</code> 提供的媒体数据：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSString <span class=\"token operator\">*</span>serializationQueueDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%@ serialization queue\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create a serialization queue for reading and writing.</span>\ndispatch_queue_t serializationQueue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>serializationQueueDescription UTF8String<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput requestMediaDataWhenReadyOnQueue<span class=\"token punctuation\">:</span>serializationQueue usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput isReadyForMoreMediaData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Get the asset reader output's next sample buffer.</span>\n        CMSampleBufferRef sampleBuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderOutput copyNextSampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sampleBuffer <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// If it exists, append this sample buffer to the output file.</span>\n            BOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput appendSampleBuffer<span class=\"token punctuation\">:</span>sampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            sampleBuffer <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Check for errors that may have occurred when appending the new sample buffer.</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> AVAssetWriterStatusFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                NSError <span class=\"token operator\">*</span>failureError <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//Handle the error.</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// If the next sample buffer doesn't exist, find out why the asset reader output couldn't vend another one.</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> AVAssetReaderStatusFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                NSError <span class=\"token operator\">*</span>failureError <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//Handle the error here.</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// The asset reader output must have vended all of its samples. Mark the input as finished.</span>\n                <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>下面的代码展示了如何使用 <code>asset reader</code> 和 <code>asset writer</code> 将资产的第一个视频轨道和音频轨重新编码到新的文件中。其中主要包括下面这些步骤：</p>\n<ul>\n<li>使用序列化队列来处理读和写视听数据。</li>\n<li>初始化 <code>asset reader</code> 并配置两个 <code>output</code>，一个用于音频，另一个用于视频。</li>\n<li>初始化 <code>asset writer</code> 并配置两个 <code>input</code>，一个用于音频，另一个用于视频。</li>\n<li>使用 <code>asset reader</code> 通过两种不同的输出/输入组合异步地向 <code>asset writer</code> 提供媒体数据。</li>\n<li>使用 <code>dispatch group</code> 来完成重编码的异步调度。</li>\n<li>允许用户在编码开始后取消该操作。<br>下面是初始化的代码：</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 初始化过程：</span>\nNSString <span class=\"token operator\">*</span>serializationQueueDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%@ serialization queue\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create the main serialization queue.</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mainSerializationQueue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>serializationQueueDescription UTF8String<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSString <span class=\"token operator\">*</span>rwAudioSerializationQueueDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%@ rw audio serialization queue\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create the serialization queue to use for reading and writing the audio data.</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwAudioSerializationQueue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>rwAudioSerializationQueueDescription UTF8String<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSString <span class=\"token operator\">*</span>rwVideoSerializationQueueDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%@ rw video serialization queue\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Create the serialization queue to use for reading and writing the video data.</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwVideoSerializationQueue <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_queue_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>rwVideoSerializationQueueDescription UTF8String<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 加载资源：</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#AVAsset that you want to reencode#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>cancelled <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>outputURL <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>#NSURL representing desired output URL <span class=\"token keyword\">for</span> file generated by asset writer#<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// Asynchronously load the tracks of the asset you want to read.</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset loadValuesAsynchronouslyForKeys<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"tracks\"</span><span class=\"token punctuation\">]</span> completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Once the tracks have finished loading, dispatch the work to the main serialization queue.</span>\n    <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mainSerializationQueue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Due to asynchronous nature, check to see if user has already cancelled.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>cancelled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        BOOL success <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n        NSError <span class=\"token operator\">*</span>localError <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Check for success of loading the assets tracks.</span>\n        success <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset statusOfValueForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"tracks\"</span> error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>localError<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> AVKeyValueStatusLoaded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.</span>\n            NSFileManager <span class=\"token operator\">*</span>fm <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            NSString <span class=\"token operator\">*</span>localOutputPath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>outputURL path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>fm fileExistsAtPath<span class=\"token punctuation\">:</span>localOutputPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>fm removeItemAtPath<span class=\"token punctuation\">:</span>localOutputPath error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>localError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setupAssetReaderAndAssetWriter<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>localError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> startAssetReaderAndWriter<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>localError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> readingAndWritingDidFinishSuccessfully<span class=\"token punctuation\">:</span>success withError<span class=\"token punctuation\">:</span>localError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>下面是初始化 asset reader 和 writer 的代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>setupAssetReaderAndAssetWriter<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSError <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>outError <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">// Create and initialize the asset reader.</span>\n     <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetReader alloc<span class=\"token punctuation\">]</span> initWithAsset<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset error<span class=\"token punctuation\">:</span>outError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     BOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If the asset reader was successfully initialized, do the same for the asset writer.</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetWriter alloc<span class=\"token punctuation\">]</span> initWithURL<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>outputURL fileType<span class=\"token punctuation\">:</span>AVFileTypeQuickTimeMovie error<span class=\"token punctuation\">:</span>outError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          success <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.</span>\n          AVAssetTrack <span class=\"token operator\">*</span>assetAudioTrack <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>assetVideoTrack <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n          NSArray <span class=\"token operator\">*</span>audioTracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>audioTracks count<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               assetAudioTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>audioTracks objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          NSArray <span class=\"token operator\">*</span>videoTracks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>asset tracksWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>videoTracks count<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               assetVideoTrack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>videoTracks objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>assetAudioTrack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.</span>\n               NSDictionary <span class=\"token operator\">*</span>decompressionAudioSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span> AVFormatIDKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kAudioFormatLinearPCM<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderAudioOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack<span class=\"token punctuation\">:</span>assetAudioTrack outputSettings<span class=\"token punctuation\">:</span>decompressionAudioSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader addOutput<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderAudioOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Then, set the compression settings to 128kbps AAC and create the asset writer input.</span>\n               AudioChannelLayout stereoChannelLayout <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">.</span>mChannelLayoutTag <span class=\"token operator\">=</span> kAudioChannelLayoutTag_Stereo<span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">.</span>mChannelBitmap <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">.</span>mNumberChannelDescriptions <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               NSData <span class=\"token operator\">*</span>channelLayoutAsData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithBytes<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>stereoChannelLayout length<span class=\"token punctuation\">:</span><span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>AudioChannelLayout<span class=\"token punctuation\">,</span> mChannelDescriptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               NSDictionary <span class=\"token operator\">*</span>compressionAudioSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n                    AVFormatIDKey         <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kAudioFormatMPEG4AAC<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    AVEncoderBitRateKey   <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInteger<span class=\"token punctuation\">:</span><span class=\"token number\">128000</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    AVSampleRateKey       <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInteger<span class=\"token punctuation\">:</span><span class=\"token number\">44100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    AVChannelLayoutKey    <span class=\"token punctuation\">:</span> channelLayoutAsData<span class=\"token punctuation\">,</span>\n                    AVNumberOfChannelsKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInteger<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInput assetWriterInputWithMediaType<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>assetAudioTrack mediaType<span class=\"token punctuation\">]</span> outputSettings<span class=\"token punctuation\">:</span>compressionAudioSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter addInput<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>assetVideoTrack<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If there is a video track to read, set the decompression settings for YUV and create the asset reader output.</span>\n               NSDictionary <span class=\"token operator\">*</span>decompressionVideoSettings <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>kCVPixelBufferPixelFormatTypeKey     <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithUnsignedInt<span class=\"token punctuation\">:</span>kCVPixelFormatType_422YpCbCr8<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>kCVPixelBufferIOSurfacePropertiesKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSDictionary dictionary<span class=\"token punctuation\">]</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderVideoOutput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack<span class=\"token punctuation\">:</span>assetVideoTrack outputSettings<span class=\"token punctuation\">:</span>decompressionVideoSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader addOutput<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderVideoOutput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               CMFormatDescriptionRef formatDescription <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Grab the video format descriptions from the video track and grab the first one if it exists.</span>\n               NSArray <span class=\"token operator\">*</span>videoFormatDescriptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>assetVideoTrack formatDescriptions<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>videoFormatDescriptions count<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    formatDescription <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>__bridge CMFormatDescriptionRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>formatDescriptions objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span>\n               CGSize trackDimensions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>formatDescription<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    trackDimensions <span class=\"token operator\">=</span> <span class=\"token function\">CMVideoFormatDescriptionGetPresentationDimensions</span><span class=\"token punctuation\">(</span>formatDescription<span class=\"token punctuation\">,</span> false<span class=\"token punctuation\">,</span> false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    trackDimensions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>assetVideoTrack naturalSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span>\n               NSDictionary <span class=\"token operator\">*</span>compressionSettings <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>formatDescription<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    NSDictionary <span class=\"token operator\">*</span>cleanAperture <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n                    NSDictionary <span class=\"token operator\">*</span>pixelAspectRatio <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n                    CFDictionaryRef cleanApertureFromCMFormatDescription <span class=\"token operator\">=</span> <span class=\"token function\">CMFormatDescriptionGetExtension</span><span class=\"token punctuation\">(</span>formatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionExtension_CleanAperture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cleanApertureFromCMFormatDescription<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         cleanAperture <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n                              AVVideoCleanApertureWidthKey            <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>cleanApertureFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_CleanApertureWidth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                              AVVideoCleanApertureHeightKey           <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>cleanApertureFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_CleanApertureHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                              AVVideoCleanApertureHorizontalOffsetKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>cleanApertureFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_CleanApertureHorizontalOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                              AVVideoCleanApertureVerticalOffsetKey   <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>cleanApertureFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_CleanApertureVerticalOffset<span class=\"token punctuation\">)</span>\n                         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    CFDictionaryRef pixelAspectRatioFromCMFormatDescription <span class=\"token operator\">=</span> <span class=\"token function\">CMFormatDescriptionGetExtension</span><span class=\"token punctuation\">(</span>formatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionExtension_PixelAspectRatio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pixelAspectRatioFromCMFormatDescription<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         pixelAspectRatio <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n                              AVVideoPixelAspectRatioHorizontalSpacingKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>pixelAspectRatioFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                              AVVideoPixelAspectRatioVerticalSpacingKey   <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>pixelAspectRatioFromCMFormatDescription<span class=\"token punctuation\">,</span> kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing<span class=\"token punctuation\">)</span>\n                         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Add whichever settings we could grab from the format description to the compression settings dictionary.</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cleanAperture <span class=\"token operator\">||</span> pixelAspectRatio<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         NSMutableDictionary <span class=\"token operator\">*</span>mutableCompressionSettings <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cleanAperture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              <span class=\"token punctuation\">[</span>mutableCompressionSettings setObject<span class=\"token punctuation\">:</span>cleanAperture forKey<span class=\"token punctuation\">:</span>AVVideoCleanApertureKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pixelAspectRatio<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              <span class=\"token punctuation\">[</span>mutableCompressionSettings setObject<span class=\"token punctuation\">:</span>pixelAspectRatio forKey<span class=\"token punctuation\">:</span>AVVideoPixelAspectRatioKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                         compressionSettings <span class=\"token operator\">=</span> mutableCompressionSettings<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Create the video settings dictionary for H.264.</span>\n               NSMutableDictionary <span class=\"token operator\">*</span>videoSettings <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NSMutableDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>\n                    AVVideoCodecKey  <span class=\"token punctuation\">:</span> AVVideoCodecH264<span class=\"token punctuation\">,</span>\n                    AVVideoWidthKey  <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithDouble<span class=\"token punctuation\">:</span>trackDimensions<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                    AVVideoHeightKey <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>NSNumber numberWithDouble<span class=\"token punctuation\">:</span>trackDimensions<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">]</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Put the compression settings into the video settings dictionary if we were able to grab them.</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>compressionSettings<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">[</span>videoSettings setObject<span class=\"token punctuation\">:</span>compressionSettings forKey<span class=\"token punctuation\">:</span>AVVideoCompressionPropertiesKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Create the asset writer input and add it to the asset writer.</span>\n               <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInput assetWriterInputWithMediaType<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>videoTrack mediaType<span class=\"token punctuation\">]</span> outputSettings<span class=\"token punctuation\">:</span>videoSettings<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter addInput<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">return</span> success<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>下面是重新编码 asset 的代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>startAssetReaderAndWriter<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSError <span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>outError <span class=\"token punctuation\">{</span>\n     BOOL success <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n     <span class=\"token comment\" spellcheck=\"true\">// Attempt to start the asset reader.</span>\n     success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader startReading<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token operator\">*</span>outError <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If the reader started successfully, attempt to start the asset writer.</span>\n          success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter startWriting<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token operator\">*</span>outError <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup <span class=\"token operator\">=</span> <span class=\"token function\">dispatch_group_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter startSessionAtSourceTime<span class=\"token punctuation\">:</span>kCMTimeZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If there is audio to reencode, enter the dispatch group before beginning the work.</span>\n               <span class=\"token function\">dispatch_group_enter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput requestMediaDataWhenReadyOnQueue<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwAudioSerializationQueue usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Because the block is called asynchronously, check to see whether its task is complete.</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                     <span class=\"token punctuation\">}</span>\n                    BOOL completedOrFailed <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// If the task isn't complete yet, make sure that the input is actually ready for more media data.</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput isReadyForMoreMediaData<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>completedOrFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token comment\" spellcheck=\"true\">// Get the next audio sample buffer, and append it to the output file.</span>\n                         CMSampleBufferRef sampleBuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderAudioOutput copyNextSampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sampleBuffer <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              BOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput appendSampleBuffer<span class=\"token punctuation\">:</span>sampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                              <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                              sampleBuffer <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n                              completedOrFailed <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>success<span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                              completedOrFailed <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>completedOrFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token comment\" spellcheck=\"true\">// Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the audio work has finished).</span>\n                         BOOL oldFinished <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished<span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFinished <span class=\"token operator\">==</span> NO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                         <span class=\"token function\">dispatch_group_leave</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// If we had video to reencode, enter the dispatch group before beginning the work.</span>\n               <span class=\"token function\">dispatch_group_enter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput requestMediaDataWhenReadyOnQueue<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwVideoSerializationQueue usingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Because the block is called asynchronously, check to see whether its task is complete.</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                     <span class=\"token punctuation\">}</span>\n                    BOOL completedOrFailed <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// If the task isn't complete yet, make sure that the input is actually ready for more media data.</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput isReadyForMoreMediaData<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>completedOrFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token comment\" spellcheck=\"true\">// Get the next video sample buffer, and append it to the output file.</span>\n                         CMSampleBufferRef sampleBuffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReaderVideoOutput copyNextSampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sampleBuffer <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              BOOL success <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput appendSampleBuffer<span class=\"token punctuation\">:</span>sampleBuffer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                              <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>sampleBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                              sampleBuffer <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n                              completedOrFailed <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>success<span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                              completedOrFailed <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>completedOrFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token comment\" spellcheck=\"true\">// Mark the input as finished, but only if we haven't already done so, and then leave the dispatch group (since the video work has finished).</span>\n                         BOOL oldFinished <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished<span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFinished <span class=\"token operator\">==</span> NO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                         <span class=\"token function\">dispatch_group_leave</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token comment\" spellcheck=\"true\">// Set up the notification that the dispatch group will send when the audio and video work have both finished.</span>\n          <span class=\"token function\">dispatch_group_notify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mainSerializationQueue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n               BOOL finalSuccess <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n               NSError <span class=\"token operator\">*</span>finalError <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Check to see if the work has finished due to cancellation.</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>cancelled<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// If so, cancel the reader and writer.</span>\n                    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader cancelReading<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter cancelWriting<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// If cancellation didn't occur, first make sure that the asset reader didn't fail.</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader status<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> AVAssetReaderStatusFailed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         finalSuccess <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n                         finalError <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// If the asset reader didn't fail, attempt to stop the asset writer and check for any errors.</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finalSuccess<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         finalSuccess <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter finishWriting<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>finalSuccess<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                              finalError <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n               <span class=\"token punctuation\">}</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.</span>\n               <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> readingAndWritingDidFinishSuccessfully<span class=\"token punctuation\">:</span>finalSuccess withError<span class=\"token punctuation\">:</span>finalError<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token comment\" spellcheck=\"true\">// Return success here to indicate whether the asset reader and writer were started successfully.</span>\n     <span class=\"token keyword\">return</span> success<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>处理完成的代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>readingAndWritingDidFinishSuccessfully<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>success withError<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSError <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>error <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If the reencoding process failed, we need to cancel the asset reader and writer.</span>\n          <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetReader cancelReading<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriter cancelWriting<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Handle any UI tasks here related to failure.</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// Reencoding was successful, reset booleans.</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>cancelled <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n          <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token function\">dispatch_get_main_queue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Handle any UI tasks here related to success.</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>处理取消的代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>cancel\n<span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">// Handle cancellation asynchronously, but serialize it with the main queue.</span>\n     <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mainSerializationQueue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// If we had audio data to reencode, we need to cancel the audio work.</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Handle cancellation asynchronously again, but this time serialize it with the audio queue.</span>\n               <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwAudioSerializationQueue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.</span>\n                    BOOL oldFinished <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>audioFinished <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFinished <span class=\"token operator\">==</span> NO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterAudioInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Leave the dispatch group since the audio work is finished now.</span>\n                    <span class=\"token function\">dispatch_group_leave</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token comment\" spellcheck=\"true\">// Handle cancellation asynchronously again, but this time serialize it with the video queue.</span>\n               <span class=\"token function\">dispatch_async</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>rwVideoSerializationQueue<span class=\"token punctuation\">,</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn't already been marked as such.</span>\n                    BOOL oldFinished <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>videoFinished <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFinished <span class=\"token operator\">==</span> NO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                         <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>assetWriterVideoInput markAsFinished<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Leave the dispatch group, since the video work is finished now.</span>\n                    <span class=\"token function\">dispatch_group_leave</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>dispatchGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token comment\" spellcheck=\"true\">// Set the cancelled Boolean property to YES to cancel any work on the main queue as well.</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>cancelled <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"Asset-Output-设置助手\"><a href=\"#Asset-Output-设置助手\" class=\"headerlink\" title=\"Asset Output 设置助手\"></a>Asset Output 设置助手</h4><p><code>AVOutputSettingsAssistant</code> 类有助于为 <code>asset reader</code> 或 <code>writer</code> 创建输出设置字典。这使得设置更简单，特别是对于具有多个特定预设的高帧率 <code>H264</code> 电影。</p>\n<p>下面的示例是如何使用 <code>output settings assistant</code>：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">AVOutputSettingsAssistant <span class=\"token operator\">*</span>outputSettingsAssistant <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVOutputSettingsAssistant outputSettingsAssistantWithPreset<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#some preset#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCMFormatDescriptionRef audioFormat <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getAudioFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>audioFormat <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>outputSettingsAssistant setSourceAudioFormat<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CMAudioFormatDescriptionRef<span class=\"token punctuation\">)</span>audioFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nCMFormatDescriptionRef videoFormat <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getVideoFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>videoFormat <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>outputSettingsAssistant setSourceVideoFormat<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CMVideoFormatDescriptionRef<span class=\"token punctuation\">)</span>videoFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nCMTime assetMinVideoFrameDuration <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getMinFrameDuration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCMTime averageFrameDuration <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getAvgFrameDuration<span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span>outputSettingsAssistant setSourceVideoAverageFrameDuration<span class=\"token punctuation\">:</span>averageFrameDuration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>outputSettingsAssistant setSourceVideoMinFrameDuration<span class=\"token punctuation\">:</span>assetMinVideoFrameDuration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nAVAssetWriter <span class=\"token operator\">*</span>assetWriter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriter assetWriterWithURL<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#some URL#<span class=\"token operator\">></span> fileType<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>outputSettingsAssistant outputFileType<span class=\"token punctuation\">]</span> error<span class=\"token punctuation\">:</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetWriterInput <span class=\"token operator\">*</span>audioInput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInput assetWriterInputWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio outputSettings<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>outputSettingsAssistant audioSettings<span class=\"token punctuation\">]</span> sourceFormatHint<span class=\"token punctuation\">:</span>audioFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nAVAssetWriterInput <span class=\"token operator\">*</span>videoInput <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVAssetWriterInput assetWriterInputWithMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo outputSettings<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>outputSettingsAssistant videoSettings<span class=\"token punctuation\">]</span> sourceFormatHint<span class=\"token punctuation\">:</span>videoFormat<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>本文转自：<a href=\"http://www.samirchen.com/ios-av-asset\" target=\"_blank\" rel=\"external\">AVAudioFoundation(5)：音视频导出 | www.samirchen.com</a><br>本文主要内容来自 <a href=\"https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html\" target=\"_blank\" rel=\"external\">AVFoundation Programming Guide</a>。</p>\n<p>要读写音视频数据资源 <code>asset</code>，我们需要用到 <code>AVFoundation</code> 提供的文件导出 <code>API</code>。<code>AVAssetExportSession</code> 提供了比较简单的 API 来满足基本的导出需求，比如修改文件类型、剪辑资源长度。如果要满足更加深度的导出需求，我们则需要用到 <code>AVAssetReader</code> 和 <code>AVAssetWriter</code>。</p>\n<p>当我们需要去操作 <code>asset</code> 的内容时，我们可以用 <code>AVAssetReader</code>，比如读取 <code>asset</code> 中的音频轨道来展示波形等等。当我们想用一些音频采样或静态图片去生成 <code>asset</code> 时，我们可以使用 <code>AVAssetWriter</code>。</p>\n<p>需要注意的是 <code>AVAssetReader</code> 不适用于做实时处理。<code>AVAssetReader</code> 没法用来处理 HLS 之类的实时数据流。但是 <code>AVAssetWriter</code> 是可以用来处理实时数据源的，比如 <code>AVCaptureOutput</code>，当需要处理实时数据源时，需要设置 <code>expectsMediaDataInRealTime</code> 属性为 <code>YES</code>。如果对非实时数据源设置该属性为 <code>YES</code>，那么可能会造成你导出的文件有问题。</p>\n<h4 id=\"读取-Asset\"><a href=\"#读取-Asset\" class=\"headerlink\" title=\"读取 Asset\"></a>读取 Asset</h4><p>每一个 <code>AVAssetReader</code> 一次只能与一个 <code>asset</code> 关联，但是这个 <code>asset</code> 可以包含多个轨道。由于这个原因通常我们需要为 <code>AVAssetReader</code> 指定一个 <code>AVAssetReaderOutput</code> 的具体子类来具体操作 <code>asset</code> 的读取，比如：</p>\n<ul>\n<li><code>AVAssetReaderTrackOutput</code></li>\n<li><code>AVAssetReaderAudioMixOutput</code></li>\n<li><code>AVAssetReaderVideoCompositionOutput</code></li>\n</ul>\n<h5 id=\"创建-Asset-Reader\"><a href=\"#创建-Asset-Reader\" class=\"headerlink\" title=\"创建 Asset Reader\"></a>创建 Asset Reader</h5><p>初始化 <code>AVAssetReader</code> 时需要传入相应读取的 <code>asset</code>。</p>\n<pre><code class=\"objectivec\">NSError *outError;\nAVAsset *someAsset = &lt;#AVAsset that you want to read#&gt;;\nAVAssetReader *assetReader = [AVAssetReader assetReaderWithAsset:someAsset error:&amp;outError];\nBOOL success = (assetReader != nil);\n</code></pre>\n<p>需要注意的是要检查创建的 <code>asset reader</code> 是否为空。初始化失败时，可以查看具体的 <code>error</code> 信息。</p>\n<h5 id=\"创建-Asset-Reader-Outputs\"><a href=\"#创建-Asset-Reader-Outputs\" class=\"headerlink\" title=\"创建 Asset Reader Outputs\"></a>创建 Asset Reader Outputs</h5><p>在完成创建 <code>asset reader</code> 后，创建至少一个 <code>output</code> 对象来接收读取的媒体数据。当创建 <code>output</code> 对象时，要记得设置 <code>alwaysCopiesSampleData</code> 属性为 <code>NO</code>，这样你会获得性能上的提升。在本章中的示例代码中，这个属性都应该被设置为 NO。</p>\n<p>如果我们想从媒体资源中读取一个或多个轨道，并且可能会转换数据的格式，那么可以使用 <code>AVAssetReaderTrackOutput</code> 类，为每个 <code>AVAssetTrack</code> 轨道使用一个 <code>track output</code> 对象。</p>\n<p>下面的示例展示了使用 <code>asset reader</code> 来把一个 <code>audio track</code> 压缩为线性的 <code>PCM</code>：</p>\n<pre><code class=\"objecivec\">AVAsset *localAsset = assetReader.asset;\n// Get the audio track to read.\nAVAssetTrack *audioTrack = [[localAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];\n// Decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the output with the audio track and decompression settings.\nAVAssetReaderOutput *trackOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:trackOutput]) {\n    [assetReader addOutput:trackOutput];\n}\n</code></pre>\n<p>如果想从一个指定的 <code>asset track</code> 按它原本存储的格式读取媒体数据，设置 <code>outputSettings</code> 为 <code>nil</code> 即可。</p>\n<p>当想要读取用 <code>AVAudioMix</code> 或 <code>AVVideoComposition</code> 混音或编辑过的媒体数据时，需要对应的使用 <code>AVAssetReaderAudioMixOutput</code> 和 <code>AVAssetReaderVideoCompositionOutput</code>。一般，当我们从一个 <code>AVComposition</code> 读取媒体资源时，我们需要用到这些 <code>output</code> 类。</p>\n<p>使用一个单独的 <code>audio mix output</code> 我们就可以读取 <code>AVAudioMix</code> 混合过的 <code>asset</code> 中的多个音频轨道。为了指明这些音频轨道是如何混合的，我们需要在 <code>AVAssetReaderAudioMixOutput</code> 对象初始化完成后将对应的 <code>AVAudioMix</code> 对象设置给它的 <code>audioMix</code> 属性。</p>\n<p>下面的代码展示了如何基于一个 <code>asset</code> 来创建我们的 <code>audio mix output</code> 对象去处理所有的音频轨道，然后压缩这些音频轨道为线性 <code>PCM</code> 数据，并为 <code>output</code> 对象设置 <code>audioMix</code> 属性。</p>\n<pre><code class=\"objectivec\">AVAudioMix *audioMix = &lt;#An AVAudioMix that specifies how the audio tracks from the AVAsset are mixed#&gt;;\n// Assumes that assetReader was initialized with an AVComposition object.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the audio tracks to read.\nNSArray *audioTracks = [composition tracksWithMediaType:AVMediaTypeAudio];\n// Get the decompression settings for Linear PCM.\nNSDictionary *decompressionAudioSettings = @{AVFormatIDKey: [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM]};\n// Create the audio mix output with the audio tracks and decompression setttings.\nAVAssetReaderOutput *audioMixOutput = [AVAssetReaderAudioMixOutput assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];\n// Associate the audio mix used to mix the audio tracks being read with the output.\naudioMixOutput.audioMix = audioMix;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:audioMixOutput]) {\n    [assetReader addOutput:audioMixOutput];\n}\n</code></pre>\n<p>如果想要 <code>asset reader</code> 返回无压缩格式，那么就把 <code>audioSettings</code> 参数传为 <code>nil</code>。对于使用 <code>AVAssetReaderVideoCompositionOutput</code> 时，也是同样的道理。</p>\n<p>我们使用 <code>video composition output</code> 的方式跟上面类似。下面的代码展示了，如果读取多个视频轨道的媒体数据并将他们压缩为 <code>ARGB</code> 格式。</p>\n<pre><code class=\"objectivec\">AVVideoComposition *videoComposition = &lt;#An AVVideoComposition that specifies how the video tracks from the AVAsset are composited#&gt;;\n// Assumes assetReader was initialized with an AVComposition.\nAVComposition *composition = (AVComposition *) assetReader.asset;\n// Get the video tracks to read.\nNSArray *videoTracks = [composition tracksWithMediaType:AVMediaTypeVideo];\n// Decompression settings for ARGB.\nNSDictionary *decompressionVideoSettings = @{(id) kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (id) kCVPixelBufferIOSurfacePropertiesKey: [NSDictionary dictionary]};\n// Create the video composition output with the video tracks and decompression setttings.\nAVAssetReaderOutput *videoCompositionOutput = [AVAssetReaderVideoCompositionOutput assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];\n// Associate the video composition used to composite the video tracks being read with the output.\nvideoCompositionOutput.videoComposition = videoComposition;\n// Add the output to the reader if possible.\nif ([assetReader canAddOutput:videoCompositionOutput]) {\n    [assetReader addOutput:videoCompositionOutput];\n}\n</code></pre>\n<h5 id=\"读取-Asset-的媒体数据\"><a href=\"#读取-Asset-的媒体数据\" class=\"headerlink\" title=\"读取 Asset 的媒体数据\"></a>读取 Asset 的媒体数据</h5><p>To start reading after setting up all of the outputs you need, call the startReading method on your asset reader. Next, retrieve the media data individually from each output using the copyNextSampleBuffer method. To start up an asset reader with a single output and read all of its media samples, do the following:</p>\n<p>在 <code>output</code> 对象创建完成后，接着就要开始读取数据了，这时候我们需要调用 <code>asset reader</code> 的 <code>startReading</code> 接口。接着，使用 <code>copyNextSampleBuffer</code> 接口来从各个 <code>output</code> 来获取媒体数据。</p>\n<p>下面的代码展示了 <code>asset reader</code> 如何用一个 <code>output</code> 对象从 <code>asset</code> 中读取所有的媒体数据：</p>\n<pre><code class=\"objectivec\">// Start the asset reader up.\n[self.assetReader startReading];\nBOOL done = NO;\nwhile (!done) {\n    // Copy the next sample buffer from the reader output.\n    CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n    if (sampleBuffer) {\n        // Do something with sampleBuffer here.\n        CFRelease(sampleBuffer);\n        sampleBuffer = NULL;\n    } else {\n        // Find out why the asset reader output couldn&#39;t copy another sample buffer.\n        if (self.assetReader.status == AVAssetReaderStatusFailed) {\n            NSError *failureError = self.assetReader.error;\n            // Handle the error here.\n        } else {\n            // The asset reader output has read all of its samples.\n            done = YES;\n        } \n    }\n}\n</code></pre>\n<h4 id=\"写入-Asset\"><a href=\"#写入-Asset\" class=\"headerlink\" title=\"写入 Asset\"></a>写入 Asset</h4><p><code>AVAssetWriter</code> 类可以将媒体数据从多个源写入指定文件格式的单个文件。我们也不需要将 <code>asset writer</code> 对象与特定 <code>asset</code> 相关联，但必须为要创建的每个输出文件使用单独的 <code>asset writer</code>。由于 <code>asset writer</code> 可以从多个来源写出媒体数据，因此我们必须为每个要被写入到输出文件的轨道创建一个 <code>AVAssetWriterInput</code> 对象。每个 <code>AVAssetWriterInput</code> 对象都期望以 <code>CMSampleBufferRef</code> 对象的形式接收数据，但是如果要将 <code>CVPixelBufferRef</code> 对象附加到 <code>asset writer</code>，可以使用 <code>AVAssetWriterInputPixelBufferAdaptor</code> 类。</p>\n<h5 id=\"创建-Asset-Writer\"><a href=\"#创建-Asset-Writer\" class=\"headerlink\" title=\"创建 Asset Writer\"></a>创建 Asset Writer</h5><p>为了创建 <code>asset writer</code>，我们需要指定输出文件的 URL 和所需的文件类型。以下代码展示了如何初始化 <code>asset writer</code> 来创建 <code>QuickTime</code> 格式的视频：</p>\n<pre><code class=\"objectivec\">NSError *outError;\nNSURL *outputURL = &lt;#NSURL object representing the URL where you want to save the video#&gt;;\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:outputURL fileType:AVFileTypeQuickTimeMovie error:&amp;outError];\nBOOL success = (assetWriter != nil);\n</code></pre>\n<h5 id=\"创建-Asset-Writer-Inputs\"><a href=\"#创建-Asset-Writer-Inputs\" class=\"headerlink\" title=\"创建 Asset Writer Inputs\"></a>创建 Asset Writer Inputs</h5><p>想要用 <code>asset writer</code> 来写媒体数据，必须至少设置一个 <code>asset writer input</code>。例如，如果数据源已经使用 <code>CMSampleBufferRef</code> 类来表示，那么使用 <code>AVAssetWriterInput</code> 类即可。</p>\n<p>下面的代码展示了如何设置将音频媒体数据压缩为 <code>128 kbps AAC</code> 并将其连接到 <code>asset writer</code> 的 <code>input</code>：</p>\n<pre><code class=\"objectivec\">// Configure the channel layout as stereo.\nAudioChannelLayout stereoChannelLayout = {\n    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n    .mChannelBitmap = 0,\n    .mNumberChannelDescriptions = 0\n};\n\n// Convert the channel layout object to an NSData object.\nNSData *channelLayoutAsData = [NSData dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n\n// Get the compression settings for 128 kbps AAC.\nNSDictionary *compressionAudioSettings = @{\n    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n    AVChannelLayoutKey    : channelLayoutAsData,\n    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n};\n\n// Create the asset writer input with the compression settings and specify the media type as audio.\nAVAssetWriterInput *assetWriterInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:compressionAudioSettings];\n// Add the input to the writer if possible.\nif ([assetWriter canAddInput:assetWriterInput]) {\n    [assetWriter addInput:assetWriterInput];\n}\n</code></pre>\n<p>需要注意的是，如果要以原本存储的格式来写入媒体数据，可以在 <code>outputSettings</code> 参数中传 <code>nil</code>。只有<code>asset writer</code> 使用 <code>AVFileTypeQuickTimeMovie</code> 的 <code>fileType</code> 进行初始化时，才能传 <code>nil</code>。</p>\n<p>您的 <code>asset writer input</code> 可以通过设置 <code>metadata</code> 和 <code>transform</code> 属性来包含一些元数据或为特定的轨道指定不同的变换。对于数据源是视频轨道的 <code>asset writer input</code>，您可以通过执行以下操作来将视频的原始变换保存在输出文件中：</p>\n<pre><code class=\"objectivec\">AVAsset *videoAsset = &lt;#AVAsset with at least one video track#&gt;;\nAVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];\nassetWriterInput.transform = videoAssetTrack.preferredTransform;\n</code></pre>\n<p>需要注意的是 <code>metadata</code> 和 <code>transform</code> 这两个属性需要在开始写之前设定才会生效。</p>\n<p>将媒体数据写入输出文件时，有时我们可能需要分配像素数据缓冲区。这时可以使用 <code>AVAssetWriterInputPixelBufferAdaptor</code> 类。为了最大的效率，不要使用单独的池分配的像素缓冲区，而是使用像素缓冲适配器提供的像素缓冲池。以下代码创建一个在 <code>RGB</code> 域中工作的像素缓冲区对象，它将使用 <code>CGImage</code> 对象来创建其像素缓冲区：</p>\n<pre><code class=\"objectivec\">NSDictionary *pixelBufferAttributes = @{\n     kCVPixelBufferCGImageCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferCGBitmapContextCompatibilityKey: [NSNumber numberWithBool:YES],\n     kCVPixelBufferPixelFormatTypeKey: [NSNumber numberWithInt:kCVPixelFormatType_32ARGB]\n};\nAVAssetWriterInputPixelBufferAdaptor *inputPixelBufferAdaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:self.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];\n</code></pre>\n<p>需要注意的是，所有 <code>AVAssetWriterInputPixelBufferAdaptor</code> 对象必须连接到单个 <code>asset writer input</code>。<code>Asset writer input</code> 必须接受 <code>AVMediaTypeVideo</code> 类型的媒体数据。</p>\n<h5 id=\"写媒体数据\"><a href=\"#写媒体数据\" class=\"headerlink\" title=\"写媒体数据\"></a>写媒体数据</h5><p>配置 <code>asset writer</code> 所需的所有输入后，即可开始写媒体数据。与 <code>asset reader</code> 一样，通过调用 <code>startWriting</code> 方法启动写入过程。然后，需要通过调用 <code>startSessionAtSourceTime:</code> 方法启动写入会话。<code>Asset writer</code> 完成的所有写入都必须在这些会话之一内进行，每个会话的时间范围不超出源中包含的媒体数据的时间范围。</p>\n<p>下面的代码展示了当我们的数据源是一个 <code>asset reader</code>，它提供从 <code>AVAsset</code> 对象读取的媒体数据，并且不希望包含资产前半部分的媒体数据：</p>\n<pre><code class=\"objectivec\">CMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);\n[self.assetWriter startSessionAtSourceTime:halfAssetDuration];\n//Implementation continues.\n</code></pre>\n<p>通常，要结束写入会话，您必须调用 <code>endSessionAtSourceTime:</code> 方法。但是，如果写入会话直到文件的末尾，则可以通过调用 <code>finishWriting</code> 方法来结束。</p>\n<p>下面代码展示了使用单个 <code>input</code> 启动 <code>asset writer</code> 并写入其所有媒体数据：</p>\n<pre><code class=\"objectivec\">// Prepare the asset writer for writing.\n[self.assetWriter startWriting];\n// Start a sample-writing session.\n[self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the next sample buffer.\n        CMSampleBufferRef nextSampleBuffer = [self copyNextSampleBufferToWrite];\n        if (nextSampleBuffer) {\n            // If it exists, append the next sample buffer to the output file.\n            [self.assetWriterInput appendSampleBuffer:nextSampleBuffer];\n            CFRelease(nextSampleBuffer);\n            nextSampleBuffer = nil;\n        } else {\n            // Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.\n            [self.assetWriterInput markAsFinished];\n            break;\n        }\n    }\n}];\n</code></pre>\n<p>上面代码中的 <code>copyNextSampleBufferToWrite</code> 方法只是一个占位方法。在这个方法里需要实现一些逻辑来返回将要写入的媒体数据，用 <code>CMSampleBufferRef</code> 对象表示，这里的 <code>sample buffer</code> 就可以用 <code>asset reader input</code> 作为数据来源。</p>\n<h4 id=\"重编码-Asset\"><a href=\"#重编码-Asset\" class=\"headerlink\" title=\"重编码 Asset\"></a>重编码 Asset</h4><p>您可以一起使用 <code>asset reader</code> 和 <code>asset writer</code> 对象将 <code>asset</code> 从一种格式转换为另一种。使用这些对象，我们对转换的控制比 <code>AVAssetExportSession</code> 要多得多。比如，我们可以选择哪些轨道要写入到输出文件中；指定输出格式；在转换过程中修改 <code>asset</code>。此过程的第一步只是根据需要设置 <code>asset reader outputs</code> 和 <code>asset writer inputs</code>。在 <code>asset reader</code> 完全配置后，可以分别调用 <code>startReading</code> 和 <code>startWriting</code> 方法来启动。</p>\n<p>以下代码展示了如何使用单个 <code>asset writer input</code> 来写入由单个 <code>asset reader output</code> 提供的媒体数据：</p>\n<pre><code class=\"objectivec\">NSString *serializationQueueDescription = [NSString stringWithFormat:@&quot;%@ serialization queue&quot;, self];\n\n// Create a serialization queue for reading and writing.\ndispatch_queue_t serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\n\n// Specify the block to execute when the asset writer is ready for media data and the queue to call it on.\n[self.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^{\n    while ([self.assetWriterInput isReadyForMoreMediaData]) {\n        // Get the asset reader output&#39;s next sample buffer.\n        CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];\n        if (sampleBuffer != NULL) {\n            // If it exists, append this sample buffer to the output file.\n            BOOL success = [self.assetWriterInput appendSampleBuffer:sampleBuffer];\n            CFRelease(sampleBuffer);\n            sampleBuffer = NULL;\n            // Check for errors that may have occurred when appending the new sample buffer.\n            if (!success &amp;&amp; self.assetWriter.status == AVAssetWriterStatusFailed) {\n                NSError *failureError = self.assetWriter.error;\n                //Handle the error.\n            }\n        } else {\n            // If the next sample buffer doesn&#39;t exist, find out why the asset reader output couldn&#39;t vend another one.\n            if (self.assetReader.status == AVAssetReaderStatusFailed) {\n                NSError *failureError = self.assetReader.error;\n                //Handle the error here.\n            } else {\n                // The asset reader output must have vended all of its samples. Mark the input as finished.\n                [self.assetWriterInput markAsFinished];\n                break;\n            }\n        }\n    }\n}];\n</code></pre>\n<h4 id=\"一个完整示例\"><a href=\"#一个完整示例\" class=\"headerlink\" title=\"一个完整示例\"></a>一个完整示例</h4><p>下面的代码展示了如何使用 <code>asset reader</code> 和 <code>asset writer</code> 将资产的第一个视频轨道和音频轨重新编码到新的文件中。其中主要包括下面这些步骤：</p>\n<ul>\n<li>使用序列化队列来处理读和写视听数据。</li>\n<li>初始化 <code>asset reader</code> 并配置两个 <code>output</code>，一个用于音频，另一个用于视频。</li>\n<li>初始化 <code>asset writer</code> 并配置两个 <code>input</code>，一个用于音频，另一个用于视频。</li>\n<li>使用 <code>asset reader</code> 通过两种不同的输出/输入组合异步地向 <code>asset writer</code> 提供媒体数据。</li>\n<li>使用 <code>dispatch group</code> 来完成重编码的异步调度。</li>\n<li>允许用户在编码开始后取消该操作。<br>下面是初始化的代码：</li>\n</ul>\n<pre><code class=\"objectivec\">// 初始化过程：\nNSString *serializationQueueDescription = [NSString stringWithFormat:@&quot;%@ serialization queue&quot;, self];\n\n// Create the main serialization queue.\nself.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], NULL);\nNSString *rwAudioSerializationQueueDescription = [NSString stringWithFormat:@&quot;%@ rw audio serialization queue&quot;, self];\n\n// Create the serialization queue to use for reading and writing the audio data.\nself.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], NULL);\nNSString *rwVideoSerializationQueueDescription = [NSString stringWithFormat:@&quot;%@ rw video serialization queue&quot;, self];\n\n// Create the serialization queue to use for reading and writing the video data.\nself.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], NULL);\n\n\n// 加载资源：\nself.asset = &lt;#AVAsset that you want to reencode#&gt;;\nself.cancelled = NO;\nself.outputURL = &lt;#NSURL representing desired output URL for file generated by asset writer#&gt;;\n// Asynchronously load the tracks of the asset you want to read.\n[self.asset loadValuesAsynchronouslyForKeys:@[@&quot;tracks&quot;] completionHandler:^{\n    // Once the tracks have finished loading, dispatch the work to the main serialization queue.\n    dispatch_async(self.mainSerializationQueue, ^{\n        // Due to asynchronous nature, check to see if user has already cancelled.\n        if (self.cancelled) {\n            return;\n        }\n        BOOL success = YES;\n        NSError *localError = nil;\n        // Check for success of loading the assets tracks.\n        success = ([self.asset statusOfValueForKey:@&quot;tracks&quot; error:&amp;localError] == AVKeyValueStatusLoaded);\n        if (success) {\n            // If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.\n            NSFileManager *fm = [NSFileManager defaultManager];\n            NSString *localOutputPath = [self.outputURL path];\n            if ([fm fileExistsAtPath:localOutputPath]) {\n                success = [fm removeItemAtPath:localOutputPath error:&amp;localError];\n            }\n        }\n        if (success) {\n            success = [self setupAssetReaderAndAssetWriter:&amp;localError];\n        }\n        if (success) {\n            success = [self startAssetReaderAndWriter:&amp;localError];\n        }\n        if (!success) {\n            [self readingAndWritingDidFinishSuccessfully:success withError:localError];\n        }\n    });\n}];\n</code></pre>\n<p>下面是初始化 asset reader 和 writer 的代码：</p>\n<pre><code class=\"objectivec\">- (BOOL)setupAssetReaderAndAssetWriter:(NSError **)outError {\n     // Create and initialize the asset reader.\n     self.assetReader = [[AVAssetReader alloc] initWithAsset:self.asset error:outError];\n     BOOL success = (self.assetReader != nil);\n     if (success) {\n          // If the asset reader was successfully initialized, do the same for the asset writer.\n          self.assetWriter = [[AVAssetWriter alloc] initWithURL:self.outputURL fileType:AVFileTypeQuickTimeMovie error:outError];\n          success = (self.assetWriter != nil);\n     }\n\n     if (success) {\n          // If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.\n          AVAssetTrack *assetAudioTrack = nil, *assetVideoTrack = nil;\n          NSArray *audioTracks = [self.asset tracksWithMediaType:AVMediaTypeAudio];\n          if ([audioTracks count] &gt; 0) {\n               assetAudioTrack = [audioTracks objectAtIndex:0];\n          }\n          NSArray *videoTracks = [self.asset tracksWithMediaType:AVMediaTypeVideo];\n          if ([videoTracks count] &gt; 0) {\n               assetVideoTrack = [videoTracks objectAtIndex:0];\n          }\n\n          if (assetAudioTrack) {\n               // If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.\n               NSDictionary *decompressionAudioSettings = @{ AVFormatIDKey : [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM] };\n               self.assetReaderAudioOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];\n               [self.assetReader addOutput:self.assetReaderAudioOutput];\n               // Then, set the compression settings to 128kbps AAC and create the asset writer input.\n               AudioChannelLayout stereoChannelLayout = {\n                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,\n                    .mChannelBitmap = 0,\n                    .mNumberChannelDescriptions = 0\n               };\n               NSData *channelLayoutAsData = [NSData dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];\n               NSDictionary *compressionAudioSettings = @{\n                    AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],\n                    AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],\n                    AVSampleRateKey       : [NSNumber numberWithInteger:44100],\n                    AVChannelLayoutKey    : channelLayoutAsData,\n                    AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]\n               };\n               self.assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];\n               [self.assetWriter addInput:self.assetWriterAudioInput];\n          }\n\n          if (assetVideoTrack) {\n               // If there is a video track to read, set the decompression settings for YUV and create the asset reader output.\n               NSDictionary *decompressionVideoSettings = @{\n                    (id)kCVPixelBufferPixelFormatTypeKey     : [NSNumber numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],\n                    (id)kCVPixelBufferIOSurfacePropertiesKey : [NSDictionary dictionary]\n               };\n               self.assetReaderVideoOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];\n               [self.assetReader addOutput:self.assetReaderVideoOutput];\n               CMFormatDescriptionRef formatDescription = NULL;\n               // Grab the video format descriptions from the video track and grab the first one if it exists.\n               NSArray *videoFormatDescriptions = [assetVideoTrack formatDescriptions];\n               if ([videoFormatDescriptions count] &gt; 0) {\n                    formatDescription = (__bridge CMFormatDescriptionRef)[formatDescriptions objectAtIndex:0];\n               }\n               CGSize trackDimensions = {\n                    .width = 0.0,\n                    .height = 0.0,\n               };\n               // If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.\n               if (formatDescription) {\n                    trackDimensions = CMVideoFormatDescriptionGetPresentationDimensions(formatDescription, false, false);\n               } else {\n                    trackDimensions = [assetVideoTrack naturalSize];\n               }\n               NSDictionary *compressionSettings = nil;\n               // If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.\n               if (formatDescription) {\n                    NSDictionary *cleanAperture = nil;\n                    NSDictionary *pixelAspectRatio = nil;\n                    CFDictionaryRef cleanApertureFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_CleanAperture);\n                    if (cleanApertureFromCMFormatDescription) {\n                         cleanAperture = @{\n                              AVVideoCleanApertureWidthKey            : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),\n                              AVVideoCleanApertureHeightKey           : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),\n                              AVVideoCleanApertureHorizontalOffsetKey : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),\n                              AVVideoCleanApertureVerticalOffsetKey   : (id)CFDictionaryGetValue(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)\n                         };\n                    }\n                    CFDictionaryRef pixelAspectRatioFromCMFormatDescription = CMFormatDescriptionGetExtension(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);\n                    if (pixelAspectRatioFromCMFormatDescription) {\n                         pixelAspectRatio = @{\n                              AVVideoPixelAspectRatioHorizontalSpacingKey : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),\n                              AVVideoPixelAspectRatioVerticalSpacingKey   : (id)CFDictionaryGetValue(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)\n                         };\n                    }\n                    // Add whichever settings we could grab from the format description to the compression settings dictionary.\n                    if (cleanAperture || pixelAspectRatio) {\n                         NSMutableDictionary *mutableCompressionSettings = [NSMutableDictionary dictionary];\n                         if (cleanAperture) {\n                              [mutableCompressionSettings setObject:cleanAperture forKey:AVVideoCleanApertureKey];\n                         }\n                         if (pixelAspectRatio) {\n                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:AVVideoPixelAspectRatioKey];\n                         }\n                         compressionSettings = mutableCompressionSettings;\n                    }\n               }\n               // Create the video settings dictionary for H.264.\n               NSMutableDictionary *videoSettings = (NSMutableDictionary *) @{\n                    AVVideoCodecKey  : AVVideoCodecH264,\n                    AVVideoWidthKey  : [NSNumber numberWithDouble:trackDimensions.width],\n                    AVVideoHeightKey : [NSNumber numberWithDouble:trackDimensions.height]\n               };\n               // Put the compression settings into the video settings dictionary if we were able to grab them.\n               if (compressionSettings) {\n                    [videoSettings setObject:compressionSettings forKey:AVVideoCompressionPropertiesKey];\n               }\n               // Create the asset writer input and add it to the asset writer.\n               self.assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];\n               [self.assetWriter addInput:self.assetWriterVideoInput];\n          }\n     }\n     return success;\n}\n</code></pre>\n<p>下面是重新编码 asset 的代码：</p>\n<pre><code class=\"objectivec\">- (BOOL)startAssetReaderAndWriter:(NSError **)outError {\n     BOOL success = YES;\n     // Attempt to start the asset reader.\n     success = [self.assetReader startReading];\n     if (!success) {\n          *outError = [self.assetReader error];\n     }\n     if (success) {\n          // If the reader started successfully, attempt to start the asset writer.\n          success = [self.assetWriter startWriting];\n          if (!success) {\n               *outError = [self.assetWriter error];\n          }\n     }\n\n     if (success) {\n          // If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.\n          self.dispatchGroup = dispatch_group_create();\n          [self.assetWriter startSessionAtSourceTime:kCMTimeZero];\n          self.audioFinished = NO;\n          self.videoFinished = NO;\n\n          if (self.assetWriterAudioInput) {\n               // If there is audio to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.\n               [self.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:self.rwAudioSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.audioFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn&#39;t complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterAudioInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed) {\n                         // Get the next audio sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderAudioOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterAudioInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven&#39;t already done so, and then leave the dispatch group (since the audio work has finished).\n                         BOOL oldFinished = self.audioFinished;\n                         self.audioFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterAudioInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n\n          if (self.assetWriterVideoInput) {\n               // If we had video to reencode, enter the dispatch group before beginning the work.\n               dispatch_group_enter(self.dispatchGroup);\n               // Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.\n               [self.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:self.rwVideoSerializationQueue usingBlock:^{\n                    // Because the block is called asynchronously, check to see whether its task is complete.\n                    if (self.videoFinished) {\n                         return;\n                     }\n                    BOOL completedOrFailed = NO;\n                    // If the task isn&#39;t complete yet, make sure that the input is actually ready for more media data.\n                    while ([self.assetWriterVideoInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed) {\n                         // Get the next video sample buffer, and append it to the output file.\n                         CMSampleBufferRef sampleBuffer = [self.assetReaderVideoOutput copyNextSampleBuffer];\n                         if (sampleBuffer != NULL) {\n                              BOOL success = [self.assetWriterVideoInput appendSampleBuffer:sampleBuffer];\n                              CFRelease(sampleBuffer);\n                              sampleBuffer = NULL;\n                              completedOrFailed = !success;\n                         } else {\n                              completedOrFailed = YES;\n                         }\n                    }\n                    if (completedOrFailed) {\n                         // Mark the input as finished, but only if we haven&#39;t already done so, and then leave the dispatch group (since the video work has finished).\n                         BOOL oldFinished = self.videoFinished;\n                         self.videoFinished = YES;\n                         if (oldFinished == NO) {\n                              [self.assetWriterVideoInput markAsFinished];\n                         }\n                         dispatch_group_leave(self.dispatchGroup);\n                    }\n               }];\n          }\n          // Set up the notification that the dispatch group will send when the audio and video work have both finished.\n          dispatch_group_notify(self.dispatchGroup, self.mainSerializationQueue, ^{\n               BOOL finalSuccess = YES;\n               NSError *finalError = nil;\n               // Check to see if the work has finished due to cancellation.\n               if (self.cancelled) {\n                    // If so, cancel the reader and writer.\n                    [self.assetReader cancelReading];\n                    [self.assetWriter cancelWriting];\n               } else {\n                    // If cancellation didn&#39;t occur, first make sure that the asset reader didn&#39;t fail.\n                    if ([self.assetReader status] == AVAssetReaderStatusFailed) {\n                         finalSuccess = NO;\n                         finalError = [self.assetReader error];\n                    }\n                    // If the asset reader didn&#39;t fail, attempt to stop the asset writer and check for any errors.\n                    if (finalSuccess) {\n                         finalSuccess = [self.assetWriter finishWriting];\n                         if (!finalSuccess) {\n                              finalError = [self.assetWriter error];\n                         }\n                    }\n               }\n               // Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.\n               [self readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];\n          });\n     }\n     // Return success here to indicate whether the asset reader and writer were started successfully.\n     return success;\n}\n</code></pre>\n<p>处理完成的代码：</p>\n<pre><code class=\"objectivec\">- (void)readingAndWritingDidFinishSuccessfully:(BOOL)success withError:(NSError *)error {\n     if (!success) {\n          // If the reencoding process failed, we need to cancel the asset reader and writer.\n          [self.assetReader cancelReading];\n          [self.assetWriter cancelWriting];\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to failure.\n          });\n     } else {\n          // Reencoding was successful, reset booleans.\n          self.cancelled = NO;\n          self.videoFinished = NO;\n          self.audioFinished = NO;\n          dispatch_async(dispatch_get_main_queue(), ^{\n               // Handle any UI tasks here related to success.\n          });\n     }\n}\n</code></pre>\n<p>处理取消的代码：</p>\n<pre><code class=\"objectivec\">- (void)cancel\n{\n     // Handle cancellation asynchronously, but serialize it with the main queue.\n     dispatch_async(self.mainSerializationQueue, ^{\n          // If we had audio data to reencode, we need to cancel the audio work.\n          if (self.assetWriterAudioInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the audio queue.\n               dispatch_async(self.rwAudioSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#39;t already been marked as such.\n                    BOOL oldFinished = self.audioFinished;\n                    self.audioFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterAudioInput markAsFinished];\n                    }\n                    // Leave the dispatch group since the audio work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n\n          if (self.assetWriterVideoInput) {\n               // Handle cancellation asynchronously again, but this time serialize it with the video queue.\n               dispatch_async(self.rwVideoSerializationQueue, ^{\n                    // Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#39;t already been marked as such.\n                    BOOL oldFinished = self.videoFinished;\n                    self.videoFinished = YES;\n                    if (oldFinished == NO) {\n                         [self.assetWriterVideoInput markAsFinished];\n                    }\n                    // Leave the dispatch group, since the video work is finished now.\n                    dispatch_group_leave(self.dispatchGroup);\n               });\n          }\n          // Set the cancelled Boolean property to YES to cancel any work on the main queue as well.\n          self.cancelled = YES;\n     });\n}\n</code></pre>\n<h4 id=\"Asset-Output-设置助手\"><a href=\"#Asset-Output-设置助手\" class=\"headerlink\" title=\"Asset Output 设置助手\"></a>Asset Output 设置助手</h4><p><code>AVOutputSettingsAssistant</code> 类有助于为 <code>asset reader</code> 或 <code>writer</code> 创建输出设置字典。这使得设置更简单，特别是对于具有多个特定预设的高帧率 <code>H264</code> 电影。</p>\n<p>下面的示例是如何使用 <code>output settings assistant</code>：</p>\n<pre><code class=\"objectivec\">AVOutputSettingsAssistant *outputSettingsAssistant = [AVOutputSettingsAssistant outputSettingsAssistantWithPreset:&lt;#some preset#&gt;];\nCMFormatDescriptionRef audioFormat = [self getAudioFormat];\n\nif (audioFormat != NULL) {\n    [outputSettingsAssistant setSourceAudioFormat:(CMAudioFormatDescriptionRef)audioFormat];\n}\n\nCMFormatDescriptionRef videoFormat = [self getVideoFormat];\n\nif (videoFormat != NULL) {\n    [outputSettingsAssistant setSourceVideoFormat:(CMVideoFormatDescriptionRef)videoFormat];\n}\n\nCMTime assetMinVideoFrameDuration = [self getMinFrameDuration];\nCMTime averageFrameDuration = [self getAvgFrameDuration]\n\n[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];\n[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];\n\nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:&lt;#some URL#&gt; fileType:[outputSettingsAssistant outputFileType] error:NULL];\nAVAssetWriterInput *audioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];\nAVAssetWriterInput *videoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];\n</code></pre>\n"},{"title":"iOS小经验（三）","date":"2016-02-18T01:53:06.000Z","_content":"\n#### 1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\n```objectivec\n- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {\n    if ([vc isKindOfClass:[UINavigationController class]]) {\n        return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];\n    }else if ([vc isKindOfClass:[UITabBarController class]]){\n        return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];\n    } else {\n        if (vc.presentedViewController) {\n            return [self getVisibleViewControllerFrom:vc.presentedViewController];\n        } else {\n            return vc;\n        }\n    }\n}\n```\n\n#### 2、runtime为一个类动态添加属性\n```objectivec\n// 动态添加属性的本质是: 让对象的某个属性与值产生关联\n        objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n```\n\n#### 3、获取runtime为一个类动态添加的属性\n```objectivec\nobjc_getAssociatedObject(self, WZBPlaceholderViewKey);\n```\n\n#### 4、KVO监听某个对象的属性\n```objectivec\n// 添加监听者\n[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil];\n\n// 当监听的属性值变化的时候会来到这个方法\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"property\"]) {\n       [self textViewTextChange];\n       } else {\n     }\n}\n```\n\n#### 5、Reachability判断网络状态\n```objectivec\nNetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];\n    if (status == NotReachable) {\n        NSLog(@\"当前设备无网络\");\n    }\n    if (status == ReachableViaWiFi) {\n        NSLog(@\"当前wifi网络\");\n    }\n    if (status == ReachableViaWWAN) {\n        NSLog(@\"当前蜂窝移动网络\");\n    }\n```\n\n#### 6、AFNetworking监听网络状态\n```objectivec\n// 监听网络状况\n    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];\n    [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n        switch (status) {\n            case AFNetworkReachabilityStatusUnknown:\n                break;\n            case AFNetworkReachabilityStatusNotReachable: {\n                [SVProgressHUD showInfoWithStatus:@\"当前设备无网络\"];\n            }\n                break;\n            case AFNetworkReachabilityStatusReachableViaWiFi:\n                [SVProgressHUD showInfoWithStatus:@\"当前Wi-Fi网络\"];\n                break;\n            case AFNetworkReachabilityStatusReachableViaWWAN:\n                [SVProgressHUD showInfoWithStatus:@\"当前蜂窝移动网络\"];\n                break;\n            default:\n                break;\n        }\n    }];\n    [mgr startMonitoring];\n```\n\n#### 7、透明颜色不影响子视图透明度\n```objectivec\n[UIColor colorWithRed:<#(CGFloat)#> green:<#(CGFloat)#> blue:<#(CGFloat)#> alpha:<#(CGFloat)#>];\n```\n\n#### 8、取图片某一点的颜色\n```objectivec\n    if (point.x < 0 || point.y < 0) return nil;\n\n    CGImageRef imageRef = self.CGImage;\n    NSUInteger width = CGImageGetWidth(imageRef);\n    NSUInteger height = CGImageGetHeight(imageRef);\n    if (point.x >= width || point.y >= height) return nil;\n\n    unsigned char *rawData = malloc(height * width * 4);\n    if (!rawData) return nil;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    NSUInteger bytesPerPixel = 4;\n    NSUInteger bytesPerRow = bytesPerPixel * width;\n    NSUInteger bitsPerComponent = 8;\n    CGContextRef context = CGBitmapContextCreate(rawData,\n                                                 width,\n                                                 height,\n                                                 bitsPerComponent,\n                                                 bytesPerRow,\n                                                 colorSpace,\n                                                 kCGImageAlphaPremultipliedLast\n                                                 | kCGBitmapByteOrder32Big);\n    if (!context) {\n        free(rawData);\n        return nil;\n    }\n    CGColorSpaceRelease(colorSpace);\n    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);\n    CGContextRelease(context);\n\n    int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel;\n    CGFloat red   = (rawData[byteIndex]     * 1.0) / 255.0;\n    CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0;\n    CGFloat blue  = (rawData[byteIndex + 2] * 1.0) / 255.0;\n    CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0;\n\n    UIColor *result = nil;\n    result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n    free(rawData);\n    return result;\n```\n\n#### 9、判断该图片是否有透明度通道\n```objectivec\n  - (BOOL)hasAlphaChannel\n{\n    CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);\n    return (alpha == kCGImageAlphaFirst ||\n            alpha == kCGImageAlphaLast ||\n            alpha == kCGImageAlphaPremultipliedFirst ||\n            alpha == kCGImageAlphaPremultipliedLast);\n}\n```\n\n#### 10、获得灰度图\n```objectivec\n+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage\n{\n    int width = sourceImage.size.width;\n    int height = sourceImage.size.height;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);\n    CGColorSpaceRelease(colorSpace);\n\n    if (context == NULL) {\n        return nil;\n    }\n\n    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);\n    CGImageRef contextRef = CGBitmapContextCreateImage(context);\n    UIImage *grayImage = [UIImage imageWithCGImage:contextRef];\n    CGContextRelease(context);\n    CGImageRelease(contextRef);\n\n    return grayImage;\n}\n```\n\n#### 11、根据bundle中的文件名读取图片\n```objectivec\n   + (UIImage *)imageWithFileName:(NSString *)name {\n    NSString *extension = @\"png\";\n\n    NSArray *components = [name componentsSeparatedByString:@\".\"];\n    if ([components count] >= 2) {\n        NSUInteger lastIndex = components.count - 1;\n        extension = [components objectAtIndex:lastIndex];\n\n        name = [name substringToIndex:(name.length-(extension.length+1))];\n    }\n\n    // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片\n    if ([UIScreen mainScreen].scale == 2.0) {\n        name = [name stringByAppendingString:@\"@2x\"];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    if ([UIScreen mainScreen].scale == 3.0) {\n        name = [name stringByAppendingString:@\"@3x\"];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n    if (path) {\n        return [UIImage imageWithContentsOfFile:path];\n    }\n\n    return nil;\n}\n```\n\n#### 12、合并两个图片\n```objectivec\n+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage {\n    CGImageRef firstImageRef = firstImage.CGImage;\n    CGFloat firstWidth = CGImageGetWidth(firstImageRef);\n    CGFloat firstHeight = CGImageGetHeight(firstImageRef);\n    CGImageRef secondImageRef = secondImage.CGImage;\n    CGFloat secondWidth = CGImageGetWidth(secondImageRef);\n    CGFloat secondHeight = CGImageGetHeight(secondImageRef);\n    CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight));\n    UIGraphicsBeginImageContext(mergedSize);\n    [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)];\n    [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n\n#### 13、根据bundle中的图片名创建imageview\n```objectivec\n+ (id)imageViewWithImageNamed:(NSString*)imageName\n{\n    return [[UIImageView alloc] initWithImage:[UIImage imageNamed:imageName]];\n}\n```\n\n#### 14、为imageView添加倒影\n```objectivec\n    CGRect frame = self.frame;\n    frame.origin.y += (frame.size.height + 1);\n\n    UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame];\n    self.clipsToBounds = TRUE;\n    reflectionImageView.contentMode = self.contentMode;\n    [reflectionImageView setImage:self.image];\n    reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0);\n\n    CALayer *reflectionLayer = [reflectionImageView layer];\n\n    CAGradientLayer *gradientLayer = [CAGradientLayer layer];\n    gradientLayer.bounds = reflectionLayer.bounds;\n    gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5);\n    gradientLayer.colors = [NSArray arrayWithObjects:\n                            (id)[[UIColor clearColor] CGColor],\n                            (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil];\n\n    gradientLayer.startPoint = CGPointMake(0.5,0.5);\n    gradientLayer.endPoint = CGPointMake(0.5,1.0);\n    reflectionLayer.mask = gradientLayer;\n\n    [self.superview addSubview:reflectionImageView];\n```\n\n#### 15、画水印\n```objectivec\n// 画水印\n- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect\n{\n    if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 4.0)\n    {\n        UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);\n    }\n    //原图\n    [image drawInRect:self.bounds];\n    //水印图\n    [mark drawInRect:rect];\n    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    self.image = newPic;\n}\n```\n\n#### 16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\n```objectivec\n自定义UILabel\n// 重写label的textRectForBounds方法\n- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {\n    CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];\n    switch (self.textAlignmentType) {\n        case WZBTextAlignmentTypeLeftTop: {\n            rect.origin = bounds.origin;\n        }\n            break;\n        case WZBTextAlignmentTypeRightTop: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeLeftBottom: {\n            rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeRightBottom: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeTopCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeBottomCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeLeft: {\n            rect.origin = CGPointMake(0, rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeRight: {\n            rect.origin = CGPointMake(rect.origin.x, 0);\n        }\n            break;\n        case WZBTextAlignmentTypeCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2);\n        }\n            break;\n\n        default:\n            break;\n    }\n    return rect;\n}\n- (void)drawTextInRect:(CGRect)rect {\n    CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines];\n    [super drawTextInRect:textRect];\n}\n```\n\n#### 17、scrollView上的输入框，键盘挡住的问题\n```objectivec\n推荐用IQKeyboardManager这个框架！\n手动解决如下\n1、监听键盘弹出／消失的通知\n2、在通知中加入代码：\nNSDictionary* info = [aNotification userInfo];\nCGRect keyPadFrame=[[UIApplication sharedApplication].keyWindow convertRect:[[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue] fromView:self.view];\nCGSize kbSize =keyPadFrame.size;\nCGRect activeRect=[self.view convertRect:activeField.frame fromView:activeField.superview];\nCGRect aRect = self.view.bounds;\naRect.size.height -= (kbSize.height);\n\nCGPoint origin =  activeRect.origin;\norigin.y -= backScrollView.contentOffset.y;\nif (!CGRectContainsPoint(aRect, origin)) {\n    CGPoint scrollPoint = CGPointMake(0.0,CGRectGetMaxY(activeRect)-(aRect.size.height));\n    [backScrollView setContentOffset:scrollPoint animated:YES];\n}\n```\n\n#### 18、frame布局的cell动态高度\n```objectivec\n这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。\n```\n\n#### 19、AutoLayout布局的cell动态高度\n```objectivec\n// 1、设置tableView的属性\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 这个属性非0，估计cell高度\n// 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周\n```\n\n#### 20、使用performSelector:调用函数，内存泄漏问题\n\n>当我们在开发中使用[obj performSelector:NSSelectorFromString(@\"aMethod\")];这类方法时可能会收到一个警告\"performSelector may cause a leak because its selector is unknown\".\n是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！\n\n```objectivec\n使用以下代码调用即可：\nif (! obj) { return; }\nSEL selector = NSSelectorFromString(@\"aMethod\");\nIMP imp = [obj methodForSelector:selector];\nvoid (*func)(id, SEL) = (void *)imp;\nfunc(obj, selector);\n\n或者：\nSEL selector = NSSelectorFromString(@\"aMethod\");\n((void (*)(id, SEL))[obj methodForSelector:selector])(obj, selector);\n```\n\n#### 21、一个字符串是否包含另一个字符串\n```objectivec\n// 方法1\nif ([str1 containsString:str2]) {\n        NSLog(@\"str1包含str2\");\n    } else {\n        NSLog(@\"str1不包含str2\");\n    }\n\n// 方法2\nif ([str1 rangeOfString: str2].location == NSNotFound) {\n        NSLog(@\"str1不包含str2\");\n    } else {\n        NSLog(@\"str1包含str2\");\n    }\n```\n\n#### 22、cell去除选中效果\n```objective\ncell.selectionStyle = UITableViewCellSelectionStyleNone;\n```\n\n#### 23、cell点按效果\n```objective\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n}\n```\n\n\n#### 24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[<ViewController 0x7fea6ed05980> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash\n\n\n#### 25、真机测试的时候报错：Could not launch \"你的 App\"，process launch failed: Security\n```objective\n因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置->通用->描述文件->点击你的app的描述文件->点击信任\n```\n\n\n#### 26、真机测试的时候报错：Could not find Developer Disk Image\n\n>这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！\n\n#### 27、UITextView没有placeholder的问题？\n网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 [UITextView-WZB](https://github.com/WZBbiao/UITextView-WZB)\n\n\n#### 28、移除字符串中的空格和换行\n```objective\n+ (NSString *)removeSpaceAndNewline:(NSString *)str {\n    NSString *temp = [str stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    return temp;\n}\n```\n\n#### 29、判断字符串中是否有空格\n```objective\n+ (BOOL)isBlank:(NSString *)str {\n    NSRange _range = [str rangeOfString:@\" \"];\n    if (_range.location != NSNotFound) {\n        //有空格\n        return YES;\n    } else {\n        //没有空格\n        return NO;\n    }\n}\n```\n\n#### 30、获取一个视频的第一帧图片\n\n```objectivec\n    NSURL *url = [NSURL URLWithString:filepath];\n    AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil];\n    AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1];\n    generate1.appliesPreferredTrackTransform = YES;\n    NSError *err = NULL;\n    CMTime time = CMTimeMake(1, 2);\n    CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&err];\n    UIImage *one = [[UIImage alloc] initWithCGImage:oneRef];\n\n    return one;\n```\n\n\n","source":"_posts/iOS小经验（三）.md","raw":"---\ntitle: iOS小经验（三）\ndate: 2016-02-18 09:53:06\ncategories: \n\t- iOS小经验\n---\n\n#### 1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\n```objectivec\n- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {\n    if ([vc isKindOfClass:[UINavigationController class]]) {\n        return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];\n    }else if ([vc isKindOfClass:[UITabBarController class]]){\n        return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];\n    } else {\n        if (vc.presentedViewController) {\n            return [self getVisibleViewControllerFrom:vc.presentedViewController];\n        } else {\n            return vc;\n        }\n    }\n}\n```\n\n#### 2、runtime为一个类动态添加属性\n```objectivec\n// 动态添加属性的本质是: 让对象的某个属性与值产生关联\n        objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n```\n\n#### 3、获取runtime为一个类动态添加的属性\n```objectivec\nobjc_getAssociatedObject(self, WZBPlaceholderViewKey);\n```\n\n#### 4、KVO监听某个对象的属性\n```objectivec\n// 添加监听者\n[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil];\n\n// 当监听的属性值变化的时候会来到这个方法\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@\"property\"]) {\n       [self textViewTextChange];\n       } else {\n     }\n}\n```\n\n#### 5、Reachability判断网络状态\n```objectivec\nNetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];\n    if (status == NotReachable) {\n        NSLog(@\"当前设备无网络\");\n    }\n    if (status == ReachableViaWiFi) {\n        NSLog(@\"当前wifi网络\");\n    }\n    if (status == ReachableViaWWAN) {\n        NSLog(@\"当前蜂窝移动网络\");\n    }\n```\n\n#### 6、AFNetworking监听网络状态\n```objectivec\n// 监听网络状况\n    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];\n    [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n        switch (status) {\n            case AFNetworkReachabilityStatusUnknown:\n                break;\n            case AFNetworkReachabilityStatusNotReachable: {\n                [SVProgressHUD showInfoWithStatus:@\"当前设备无网络\"];\n            }\n                break;\n            case AFNetworkReachabilityStatusReachableViaWiFi:\n                [SVProgressHUD showInfoWithStatus:@\"当前Wi-Fi网络\"];\n                break;\n            case AFNetworkReachabilityStatusReachableViaWWAN:\n                [SVProgressHUD showInfoWithStatus:@\"当前蜂窝移动网络\"];\n                break;\n            default:\n                break;\n        }\n    }];\n    [mgr startMonitoring];\n```\n\n#### 7、透明颜色不影响子视图透明度\n```objectivec\n[UIColor colorWithRed:<#(CGFloat)#> green:<#(CGFloat)#> blue:<#(CGFloat)#> alpha:<#(CGFloat)#>];\n```\n\n#### 8、取图片某一点的颜色\n```objectivec\n    if (point.x < 0 || point.y < 0) return nil;\n\n    CGImageRef imageRef = self.CGImage;\n    NSUInteger width = CGImageGetWidth(imageRef);\n    NSUInteger height = CGImageGetHeight(imageRef);\n    if (point.x >= width || point.y >= height) return nil;\n\n    unsigned char *rawData = malloc(height * width * 4);\n    if (!rawData) return nil;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    NSUInteger bytesPerPixel = 4;\n    NSUInteger bytesPerRow = bytesPerPixel * width;\n    NSUInteger bitsPerComponent = 8;\n    CGContextRef context = CGBitmapContextCreate(rawData,\n                                                 width,\n                                                 height,\n                                                 bitsPerComponent,\n                                                 bytesPerRow,\n                                                 colorSpace,\n                                                 kCGImageAlphaPremultipliedLast\n                                                 | kCGBitmapByteOrder32Big);\n    if (!context) {\n        free(rawData);\n        return nil;\n    }\n    CGColorSpaceRelease(colorSpace);\n    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);\n    CGContextRelease(context);\n\n    int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel;\n    CGFloat red   = (rawData[byteIndex]     * 1.0) / 255.0;\n    CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0;\n    CGFloat blue  = (rawData[byteIndex + 2] * 1.0) / 255.0;\n    CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0;\n\n    UIColor *result = nil;\n    result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n    free(rawData);\n    return result;\n```\n\n#### 9、判断该图片是否有透明度通道\n```objectivec\n  - (BOOL)hasAlphaChannel\n{\n    CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);\n    return (alpha == kCGImageAlphaFirst ||\n            alpha == kCGImageAlphaLast ||\n            alpha == kCGImageAlphaPremultipliedFirst ||\n            alpha == kCGImageAlphaPremultipliedLast);\n}\n```\n\n#### 10、获得灰度图\n```objectivec\n+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage\n{\n    int width = sourceImage.size.width;\n    int height = sourceImage.size.height;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);\n    CGColorSpaceRelease(colorSpace);\n\n    if (context == NULL) {\n        return nil;\n    }\n\n    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);\n    CGImageRef contextRef = CGBitmapContextCreateImage(context);\n    UIImage *grayImage = [UIImage imageWithCGImage:contextRef];\n    CGContextRelease(context);\n    CGImageRelease(contextRef);\n\n    return grayImage;\n}\n```\n\n#### 11、根据bundle中的文件名读取图片\n```objectivec\n   + (UIImage *)imageWithFileName:(NSString *)name {\n    NSString *extension = @\"png\";\n\n    NSArray *components = [name componentsSeparatedByString:@\".\"];\n    if ([components count] >= 2) {\n        NSUInteger lastIndex = components.count - 1;\n        extension = [components objectAtIndex:lastIndex];\n\n        name = [name substringToIndex:(name.length-(extension.length+1))];\n    }\n\n    // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片\n    if ([UIScreen mainScreen].scale == 2.0) {\n        name = [name stringByAppendingString:@\"@2x\"];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    if ([UIScreen mainScreen].scale == 3.0) {\n        name = [name stringByAppendingString:@\"@3x\"];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n    if (path) {\n        return [UIImage imageWithContentsOfFile:path];\n    }\n\n    return nil;\n}\n```\n\n#### 12、合并两个图片\n```objectivec\n+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage {\n    CGImageRef firstImageRef = firstImage.CGImage;\n    CGFloat firstWidth = CGImageGetWidth(firstImageRef);\n    CGFloat firstHeight = CGImageGetHeight(firstImageRef);\n    CGImageRef secondImageRef = secondImage.CGImage;\n    CGFloat secondWidth = CGImageGetWidth(secondImageRef);\n    CGFloat secondHeight = CGImageGetHeight(secondImageRef);\n    CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight));\n    UIGraphicsBeginImageContext(mergedSize);\n    [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)];\n    [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n\n#### 13、根据bundle中的图片名创建imageview\n```objectivec\n+ (id)imageViewWithImageNamed:(NSString*)imageName\n{\n    return [[UIImageView alloc] initWithImage:[UIImage imageNamed:imageName]];\n}\n```\n\n#### 14、为imageView添加倒影\n```objectivec\n    CGRect frame = self.frame;\n    frame.origin.y += (frame.size.height + 1);\n\n    UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame];\n    self.clipsToBounds = TRUE;\n    reflectionImageView.contentMode = self.contentMode;\n    [reflectionImageView setImage:self.image];\n    reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0);\n\n    CALayer *reflectionLayer = [reflectionImageView layer];\n\n    CAGradientLayer *gradientLayer = [CAGradientLayer layer];\n    gradientLayer.bounds = reflectionLayer.bounds;\n    gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5);\n    gradientLayer.colors = [NSArray arrayWithObjects:\n                            (id)[[UIColor clearColor] CGColor],\n                            (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil];\n\n    gradientLayer.startPoint = CGPointMake(0.5,0.5);\n    gradientLayer.endPoint = CGPointMake(0.5,1.0);\n    reflectionLayer.mask = gradientLayer;\n\n    [self.superview addSubview:reflectionImageView];\n```\n\n#### 15、画水印\n```objectivec\n// 画水印\n- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect\n{\n    if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 4.0)\n    {\n        UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);\n    }\n    //原图\n    [image drawInRect:self.bounds];\n    //水印图\n    [mark drawInRect:rect];\n    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    self.image = newPic;\n}\n```\n\n#### 16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\n```objectivec\n自定义UILabel\n// 重写label的textRectForBounds方法\n- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {\n    CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];\n    switch (self.textAlignmentType) {\n        case WZBTextAlignmentTypeLeftTop: {\n            rect.origin = bounds.origin;\n        }\n            break;\n        case WZBTextAlignmentTypeRightTop: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeLeftBottom: {\n            rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeRightBottom: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeTopCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeBottomCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeLeft: {\n            rect.origin = CGPointMake(0, rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeRight: {\n            rect.origin = CGPointMake(rect.origin.x, 0);\n        }\n            break;\n        case WZBTextAlignmentTypeCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2);\n        }\n            break;\n\n        default:\n            break;\n    }\n    return rect;\n}\n- (void)drawTextInRect:(CGRect)rect {\n    CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines];\n    [super drawTextInRect:textRect];\n}\n```\n\n#### 17、scrollView上的输入框，键盘挡住的问题\n```objectivec\n推荐用IQKeyboardManager这个框架！\n手动解决如下\n1、监听键盘弹出／消失的通知\n2、在通知中加入代码：\nNSDictionary* info = [aNotification userInfo];\nCGRect keyPadFrame=[[UIApplication sharedApplication].keyWindow convertRect:[[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue] fromView:self.view];\nCGSize kbSize =keyPadFrame.size;\nCGRect activeRect=[self.view convertRect:activeField.frame fromView:activeField.superview];\nCGRect aRect = self.view.bounds;\naRect.size.height -= (kbSize.height);\n\nCGPoint origin =  activeRect.origin;\norigin.y -= backScrollView.contentOffset.y;\nif (!CGRectContainsPoint(aRect, origin)) {\n    CGPoint scrollPoint = CGPointMake(0.0,CGRectGetMaxY(activeRect)-(aRect.size.height));\n    [backScrollView setContentOffset:scrollPoint animated:YES];\n}\n```\n\n#### 18、frame布局的cell动态高度\n```objectivec\n这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。\n```\n\n#### 19、AutoLayout布局的cell动态高度\n```objectivec\n// 1、设置tableView的属性\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 这个属性非0，估计cell高度\n// 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周\n```\n\n#### 20、使用performSelector:调用函数，内存泄漏问题\n\n>当我们在开发中使用[obj performSelector:NSSelectorFromString(@\"aMethod\")];这类方法时可能会收到一个警告\"performSelector may cause a leak because its selector is unknown\".\n是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！\n\n```objectivec\n使用以下代码调用即可：\nif (! obj) { return; }\nSEL selector = NSSelectorFromString(@\"aMethod\");\nIMP imp = [obj methodForSelector:selector];\nvoid (*func)(id, SEL) = (void *)imp;\nfunc(obj, selector);\n\n或者：\nSEL selector = NSSelectorFromString(@\"aMethod\");\n((void (*)(id, SEL))[obj methodForSelector:selector])(obj, selector);\n```\n\n#### 21、一个字符串是否包含另一个字符串\n```objectivec\n// 方法1\nif ([str1 containsString:str2]) {\n        NSLog(@\"str1包含str2\");\n    } else {\n        NSLog(@\"str1不包含str2\");\n    }\n\n// 方法2\nif ([str1 rangeOfString: str2].location == NSNotFound) {\n        NSLog(@\"str1不包含str2\");\n    } else {\n        NSLog(@\"str1包含str2\");\n    }\n```\n\n#### 22、cell去除选中效果\n```objective\ncell.selectionStyle = UITableViewCellSelectionStyleNone;\n```\n\n#### 23、cell点按效果\n```objective\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n}\n```\n\n\n#### 24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[<ViewController 0x7fea6ed05980> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash\n\n\n#### 25、真机测试的时候报错：Could not launch \"你的 App\"，process launch failed: Security\n```objective\n因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置->通用->描述文件->点击你的app的描述文件->点击信任\n```\n\n\n#### 26、真机测试的时候报错：Could not find Developer Disk Image\n\n>这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！\n\n#### 27、UITextView没有placeholder的问题？\n网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 [UITextView-WZB](https://github.com/WZBbiao/UITextView-WZB)\n\n\n#### 28、移除字符串中的空格和换行\n```objective\n+ (NSString *)removeSpaceAndNewline:(NSString *)str {\n    NSString *temp = [str stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    return temp;\n}\n```\n\n#### 29、判断字符串中是否有空格\n```objective\n+ (BOOL)isBlank:(NSString *)str {\n    NSRange _range = [str rangeOfString:@\" \"];\n    if (_range.location != NSNotFound) {\n        //有空格\n        return YES;\n    } else {\n        //没有空格\n        return NO;\n    }\n}\n```\n\n#### 30、获取一个视频的第一帧图片\n\n```objectivec\n    NSURL *url = [NSURL URLWithString:filepath];\n    AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil];\n    AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1];\n    generate1.appliesPreferredTrackTransform = YES;\n    NSError *err = NULL;\n    CMTime time = CMTimeMake(1, 2);\n    CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&err];\n    UIImage *one = [[UIImage alloc] initWithCGImage:oneRef];\n\n    return one;\n```\n\n\n","slug":"iOS小经验（三）","published":1,"updated":"2017-07-16T14:49:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvq000rznuz9chc2rbx","content":"<h4 id=\"1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\"><a href=\"#1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\" class=\"headerlink\" title=\"1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\"></a>1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIViewController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getVisibleViewControllerFrom<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIViewController<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>vc <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>vc isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UINavigationController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getVisibleViewControllerFrom<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>UINavigationController<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> vc<span class=\"token punctuation\">)</span> visibleViewController<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>vc isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UITabBarController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getVisibleViewControllerFrom<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>UITabBarController<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> vc<span class=\"token punctuation\">)</span> selectedViewController<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vc<span class=\"token punctuation\">.</span>presentedViewController<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getVisibleViewControllerFrom<span class=\"token punctuation\">:</span>vc<span class=\"token punctuation\">.</span>presentedViewController<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> vc<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"2、runtime为一个类动态添加属性\"><a href=\"#2、runtime为一个类动态添加属性\" class=\"headerlink\" title=\"2、runtime为一个类动态添加属性\"></a>2、runtime为一个类动态添加属性</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 动态添加属性的本质是: 让对象的某个属性与值产生关联</span>\n        <span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> WZBPlaceholderViewKey<span class=\"token punctuation\">,</span> placeholderView<span class=\"token punctuation\">,</span> OBJC_ASSOCIATION_RETAIN_NONATOMIC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"3、获取runtime为一个类动态添加的属性\"><a href=\"#3、获取runtime为一个类动态添加的属性\" class=\"headerlink\" title=\"3、获取runtime为一个类动态添加的属性\"></a>3、获取runtime为一个类动态添加的属性</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">objc_getAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> WZBPlaceholderViewKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"4、KVO监听某个对象的属性\"><a href=\"#4、KVO监听某个对象的属性\" class=\"headerlink\" title=\"4、KVO监听某个对象的属性\"></a>4、KVO监听某个对象的属性</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 添加监听者</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> forKeyPath<span class=\"token punctuation\">:</span>property options<span class=\"token punctuation\">:</span>NSKeyValueObservingOptionNew context<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 当监听的属性值变化的时候会来到这个方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>observeValueForKeyPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>keyPath ofObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>object change<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>change context<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>context <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>keyPath isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"property\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> textViewTextChange<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"5、Reachability判断网络状态\"><a href=\"#5、Reachability判断网络状态\" class=\"headerlink\" title=\"5、Reachability判断网络状态\"></a>5、Reachability判断网络状态</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NetworkStatus status <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>Reachability reachabilityForInternetConnection<span class=\"token punctuation\">]</span> currentReachabilityStatus<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">==</span> NotReachable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前设备无网络\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">==</span> ReachableViaWiFi<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前wifi网络\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">==</span> ReachableViaWWAN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前蜂窝移动网络\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"6、AFNetworking监听网络状态\"><a href=\"#6、AFNetworking监听网络状态\" class=\"headerlink\" title=\"6、AFNetworking监听网络状态\"></a>6、AFNetworking监听网络状态</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 监听网络状况</span>\n    AFNetworkReachabilityManager <span class=\"token operator\">*</span>mgr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AFNetworkReachabilityManager sharedManager<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>mgr setReachabilityStatusChangeBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>AFNetworkReachabilityStatus status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> AFNetworkReachabilityStatusUnknown<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> AFNetworkReachabilityStatusNotReachable<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token punctuation\">[</span>SVProgressHUD showInfoWithStatus<span class=\"token punctuation\">:</span><span class=\"token string\">@\"当前设备无网络\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> AFNetworkReachabilityStatusReachableViaWiFi<span class=\"token punctuation\">:</span>\n                <span class=\"token punctuation\">[</span>SVProgressHUD showInfoWithStatus<span class=\"token punctuation\">:</span><span class=\"token string\">@\"当前Wi-Fi网络\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> AFNetworkReachabilityStatusReachableViaWWAN<span class=\"token punctuation\">:</span>\n                <span class=\"token punctuation\">[</span>SVProgressHUD showInfoWithStatus<span class=\"token punctuation\">:</span><span class=\"token string\">@\"当前蜂窝移动网络\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>mgr startMonitoring<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"7、透明颜色不影响子视图透明度\"><a href=\"#7、透明颜色不影响子视图透明度\" class=\"headerlink\" title=\"7、透明颜色不影响子视图透明度\"></a>7、透明颜色不影响子视图透明度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>#<span class=\"token operator\">></span> green<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>#<span class=\"token operator\">></span> blue<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>#<span class=\"token operator\">></span> alpha<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span>#<span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>#<span class=\"token operator\">></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"8、取图片某一点的颜色\"><a href=\"#8、取图片某一点的颜色\" class=\"headerlink\" title=\"8、取图片某一点的颜色\"></a>8、取图片某一点的颜色</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n\n    CGImageRef imageRef <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">;</span>\n    NSUInteger width <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetWidth</span><span class=\"token punctuation\">(</span>imageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSUInteger height <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetHeight</span><span class=\"token punctuation\">(</span>imageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">>=</span> width <span class=\"token operator\">||</span> point<span class=\"token punctuation\">.</span>y <span class=\"token operator\">>=</span> height<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>rawData <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>height <span class=\"token operator\">*</span> width <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>rawData<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n\n    CGColorSpaceRef colorSpace <span class=\"token operator\">=</span> <span class=\"token function\">CGColorSpaceCreateDeviceRGB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSUInteger bytesPerPixel <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    NSUInteger bytesPerRow <span class=\"token operator\">=</span> bytesPerPixel <span class=\"token operator\">*</span> width<span class=\"token punctuation\">;</span>\n    NSUInteger bitsPerComponent <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n    CGContextRef context <span class=\"token operator\">=</span> <span class=\"token function\">CGBitmapContextCreate</span><span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">,</span>\n                                                 width<span class=\"token punctuation\">,</span>\n                                                 height<span class=\"token punctuation\">,</span>\n                                                 bitsPerComponent<span class=\"token punctuation\">,</span>\n                                                 bytesPerRow<span class=\"token punctuation\">,</span>\n                                                 colorSpace<span class=\"token punctuation\">,</span>\n                                                 kCGImageAlphaPremultipliedLast\n                                                 <span class=\"token operator\">|</span> kCGBitmapByteOrder32Big<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">CGColorSpaceRelease</span><span class=\"token punctuation\">(</span>colorSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextDrawImage</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> imageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextRelease</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> byteIndex <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>bytesPerRow <span class=\"token operator\">*</span> point<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> point<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> bytesPerPixel<span class=\"token punctuation\">;</span>\n    CGFloat red   <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">[</span>byteIndex<span class=\"token punctuation\">]</span>     <span class=\"token operator\">*</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">255.0</span><span class=\"token punctuation\">;</span>\n    CGFloat green <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">[</span>byteIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">255.0</span><span class=\"token punctuation\">;</span>\n    CGFloat blue  <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">[</span>byteIndex <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">255.0</span><span class=\"token punctuation\">;</span>\n    CGFloat alpha <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">[</span>byteIndex <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">255.0</span><span class=\"token punctuation\">;</span>\n\n    UIColor <span class=\"token operator\">*</span>result <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span>red green<span class=\"token punctuation\">:</span>green blue<span class=\"token punctuation\">:</span>blue alpha<span class=\"token punctuation\">:</span>alpha<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"9、判断该图片是否有透明度通道\"><a href=\"#9、判断该图片是否有透明度通道\" class=\"headerlink\" title=\"9、判断该图片是否有透明度通道\"></a>9、判断该图片是否有透明度通道</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">  <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>hasAlphaChannel\n<span class=\"token punctuation\">{</span>\n    CGImageAlphaInfo alpha <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetAlphaInfo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>alpha <span class=\"token operator\">==</span> kCGImageAlphaFirst <span class=\"token operator\">||</span>\n            alpha <span class=\"token operator\">==</span> kCGImageAlphaLast <span class=\"token operator\">||</span>\n            alpha <span class=\"token operator\">==</span> kCGImageAlphaPremultipliedFirst <span class=\"token operator\">||</span>\n            alpha <span class=\"token operator\">==</span> kCGImageAlphaPremultipliedLast<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"10、获得灰度图\"><a href=\"#10、获得灰度图\" class=\"headerlink\" title=\"10、获得灰度图\"></a>10、获得灰度图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>covertToGrayImageFromImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>sourceImage\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> width <span class=\"token operator\">=</span> sourceImage<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> height <span class=\"token operator\">=</span> sourceImage<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n\n    CGColorSpaceRef colorSpace <span class=\"token operator\">=</span> <span class=\"token function\">CGColorSpaceCreateDeviceGray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGContextRef context <span class=\"token operator\">=</span> <span class=\"token function\">CGBitmapContextCreate</span> <span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">,</span>width<span class=\"token punctuation\">,</span>height<span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>colorSpace<span class=\"token punctuation\">,</span>kCGImageAlphaNone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGColorSpaceRelease</span><span class=\"token punctuation\">(</span>colorSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">CGContextDrawImage</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sourceImage<span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGImageRef contextRef <span class=\"token operator\">=</span> <span class=\"token function\">CGBitmapContextCreateImage</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>grayImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageWithCGImage<span class=\"token punctuation\">:</span>contextRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextRelease</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>contextRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> grayImage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"11、根据bundle中的文件名读取图片\"><a href=\"#11、根据bundle中的文件名读取图片\" class=\"headerlink\" title=\"11、根据bundle中的文件名读取图片\"></a>11、根据bundle中的文件名读取图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">   <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imageWithFileName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name <span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>extension <span class=\"token operator\">=</span> <span class=\"token string\">@\"png\"</span><span class=\"token punctuation\">;</span>\n\n    NSArray <span class=\"token operator\">*</span>components <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name componentsSeparatedByString<span class=\"token punctuation\">:</span><span class=\"token string\">@\".\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>components count<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSUInteger lastIndex <span class=\"token operator\">=</span> components<span class=\"token punctuation\">.</span>count <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        extension <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>components objectAtIndex<span class=\"token punctuation\">:</span>lastIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name substringToIndex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>extension<span class=\"token punctuation\">.</span>length<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>UIScreen mainScreen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>scale <span class=\"token operator\">==</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name stringByAppendingString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"@2x\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        NSString <span class=\"token operator\">*</span>path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span>name ofType<span class=\"token punctuation\">:</span>extension<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIImage imageWithContentsOfFile<span class=\"token punctuation\">:</span>path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>UIScreen mainScreen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>scale <span class=\"token operator\">==</span> <span class=\"token number\">3.0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name stringByAppendingString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"@3x\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        NSString <span class=\"token operator\">*</span>path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span>name ofType<span class=\"token punctuation\">:</span>extension<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIImage imageWithContentsOfFile<span class=\"token punctuation\">:</span>path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    NSString <span class=\"token operator\">*</span>path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span>name ofType<span class=\"token punctuation\">:</span>extension<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIImage imageWithContentsOfFile<span class=\"token punctuation\">:</span>path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12、合并两个图片\"><a href=\"#12、合并两个图片\" class=\"headerlink\" title=\"12、合并两个图片\"></a>12、合并两个图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>mergeImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstImage withImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>secondImage <span class=\"token punctuation\">{</span>\n    CGImageRef firstImageRef <span class=\"token operator\">=</span> firstImage<span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">;</span>\n    CGFloat firstWidth <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetWidth</span><span class=\"token punctuation\">(</span>firstImageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGFloat firstHeight <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetHeight</span><span class=\"token punctuation\">(</span>firstImageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGImageRef secondImageRef <span class=\"token operator\">=</span> secondImage<span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">;</span>\n    CGFloat secondWidth <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetWidth</span><span class=\"token punctuation\">(</span>secondImageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGFloat secondHeight <span class=\"token operator\">=</span> <span class=\"token function\">CGImageGetHeight</span><span class=\"token punctuation\">(</span>secondImageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGSize mergedSize <span class=\"token operator\">=</span> <span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span><span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>firstWidth<span class=\"token punctuation\">,</span> secondWidth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>firstHeight<span class=\"token punctuation\">,</span> secondHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>mergedSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>firstImage drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> firstWidth<span class=\"token punctuation\">,</span> firstHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>secondImage drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> secondWidth<span class=\"token punctuation\">,</span> secondHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"13、根据bundle中的图片名创建imageview\"><a href=\"#13、根据bundle中的图片名创建imageview\" class=\"headerlink\" title=\"13、根据bundle中的图片名创建imageview\"></a>13、根据bundle中的图片名创建imageview</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>imageViewWithImageNamed<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imageName\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIImageView alloc<span class=\"token punctuation\">]</span> initWithImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span>imageName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"14、为imageView添加倒影\"><a href=\"#14、为imageView添加倒影\" class=\"headerlink\" title=\"14、为imageView添加倒影\"></a>14、为imageView添加倒影</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    CGRect frame <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">;</span>\n    frame<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>frame<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    UIImageView <span class=\"token operator\">*</span>reflectionImageView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIImageView alloc<span class=\"token punctuation\">]</span> initWithFrame<span class=\"token punctuation\">:</span>frame<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>clipsToBounds <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>\n    reflectionImageView<span class=\"token punctuation\">.</span>contentMode <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>contentMode<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>reflectionImageView setImage<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    reflectionImageView<span class=\"token punctuation\">.</span>transform <span class=\"token operator\">=</span> <span class=\"token function\">CGAffineTransformMakeScale</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    CALayer <span class=\"token operator\">*</span>reflectionLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>reflectionImageView layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    CAGradientLayer <span class=\"token operator\">*</span>gradientLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAGradientLayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    gradientLayer<span class=\"token punctuation\">.</span>bounds <span class=\"token operator\">=</span> reflectionLayer<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">;</span>\n    gradientLayer<span class=\"token punctuation\">.</span>position <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span>reflectionLayer<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> reflectionLayer<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gradientLayer<span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSArray arrayWithObjects<span class=\"token punctuation\">:</span>\n                            <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span> CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                            <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span><span class=\"token number\">1.0</span> green<span class=\"token punctuation\">:</span><span class=\"token number\">1.0</span> blue<span class=\"token punctuation\">:</span><span class=\"token number\">1.0</span> alpha<span class=\"token punctuation\">:</span><span class=\"token number\">0.3</span><span class=\"token punctuation\">]</span> CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    gradientLayer<span class=\"token punctuation\">.</span>startPoint <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    gradientLayer<span class=\"token punctuation\">.</span>endPoint <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    reflectionLayer<span class=\"token punctuation\">.</span>mask <span class=\"token operator\">=</span> gradientLayer<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>superview addSubview<span class=\"token punctuation\">:</span>reflectionImageView<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"15、画水印\"><a href=\"#15、画水印\" class=\"headerlink\" title=\"15、画水印\"></a>15、画水印</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 画水印</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> setImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image withWaterMark<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>mark inRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>rect\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> systemVersion<span class=\"token punctuation\">]</span> floatValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">4.0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//原图</span>\n    <span class=\"token punctuation\">[</span>image drawInRect<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//水印图</span>\n    <span class=\"token punctuation\">[</span>mark drawInRect<span class=\"token punctuation\">:</span>rect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>newPic <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>image <span class=\"token operator\">=</span> newPic<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\"><a href=\"#16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\" class=\"headerlink\" title=\"16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\"></a>16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">自定义UILabel\n<span class=\"token comment\" spellcheck=\"true\">// 重写label的textRectForBounds方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>textRectForBounds<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>bounds limitedToNumberOfLines<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>numberOfLines <span class=\"token punctuation\">{</span>\n    CGRect rect <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> textRectForBounds<span class=\"token punctuation\">:</span>bounds limitedToNumberOfLines<span class=\"token punctuation\">:</span>numberOfLines<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>textAlignmentType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeLeftTop<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> bounds<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeRightTop<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetMaxX</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> bounds<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeLeftBottom<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeRightBottom<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetMaxX</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeTopCenter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeBottomCenter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeLeft<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeRight<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> WZBTextAlignmentTypeCenter<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            rect<span class=\"token punctuation\">.</span>origin <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetHeight</span><span class=\"token punctuation\">(</span>bounds<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">CGRectGetHeight</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> rect<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>drawTextInRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>rect <span class=\"token punctuation\">{</span>\n    CGRect textRect <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> textRectForBounds<span class=\"token punctuation\">:</span>rect limitedToNumberOfLines<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>numberOfLines<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> drawTextInRect<span class=\"token punctuation\">:</span>textRect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"17、scrollView上的输入框，键盘挡住的问题\"><a href=\"#17、scrollView上的输入框，键盘挡住的问题\" class=\"headerlink\" title=\"17、scrollView上的输入框，键盘挡住的问题\"></a>17、scrollView上的输入框，键盘挡住的问题</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">推荐用IQKeyboardManager这个框架！\n手动解决如下\n<span class=\"token number\">1</span>、监听键盘弹出／消失的通知\n<span class=\"token number\">2</span>、在通知中加入代码：\nNSDictionary<span class=\"token operator\">*</span> info <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>aNotification userInfo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCGRect keyPadFrame<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>keyWindow convertRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>info objectForKey<span class=\"token punctuation\">:</span>UIKeyboardFrameBeginUserInfoKey<span class=\"token punctuation\">]</span> CGRectValue<span class=\"token punctuation\">]</span> fromView<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCGSize kbSize <span class=\"token operator\">=</span>keyPadFrame<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">;</span>\nCGRect activeRect<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view convertRect<span class=\"token punctuation\">:</span>activeField<span class=\"token punctuation\">.</span>frame fromView<span class=\"token punctuation\">:</span>activeField<span class=\"token punctuation\">.</span>superview<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCGRect aRect <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">;</span>\naRect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>kbSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nCGPoint origin <span class=\"token operator\">=</span>  activeRect<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">;</span>\norigin<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span><span class=\"token operator\">=</span> backScrollView<span class=\"token punctuation\">.</span>contentOffset<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">CGRectContainsPoint</span><span class=\"token punctuation\">(</span>aRect<span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CGPoint scrollPoint <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token function\">CGRectGetMaxY</span><span class=\"token punctuation\">(</span>activeRect<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>aRect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>backScrollView setContentOffset<span class=\"token punctuation\">:</span>scrollPoint animated<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"18、frame布局的cell动态高度\"><a href=\"#18、frame布局的cell动态高度\" class=\"headerlink\" title=\"18、frame布局的cell动态高度\"></a>18、frame布局的cell动态高度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。\n</code></pre>\n<h4 id=\"19、AutoLayout布局的cell动态高度\"><a href=\"#19、AutoLayout布局的cell动态高度\" class=\"headerlink\" title=\"19、AutoLayout布局的cell动态高度\"></a>19、AutoLayout布局的cell动态高度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 1、设置tableView的属性</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView<span class=\"token punctuation\">.</span>rowHeight <span class=\"token operator\">=</span> UITableViewAutomaticDimension<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView<span class=\"token punctuation\">.</span>estimatedRowHeight <span class=\"token operator\">=</span> <span class=\"token number\">44.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 这个属性非0，估计cell高度</span>\n<span class=\"token comment\" spellcheck=\"true\">// 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周</span>\n</code></pre>\n<h4 id=\"20、使用performSelector-调用函数，内存泄漏问题\"><a href=\"#20、使用performSelector-调用函数，内存泄漏问题\" class=\"headerlink\" title=\"20、使用performSelector:调用函数，内存泄漏问题\"></a>20、使用performSelector:调用函数，内存泄漏问题</h4><blockquote>\n<p>当我们在开发中使用[obj performSelector:NSSelectorFromString(@”aMethod”)];这类方法时可能会收到一个警告”performSelector may cause a leak because its selector is unknown”.<br>是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！</p>\n</blockquote>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">使用以下代码调用即可：\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\nSEL selector <span class=\"token operator\">=</span> <span class=\"token function\">NSSelectorFromString</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"aMethod\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nIMP imp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>obj methodForSelector<span class=\"token punctuation\">:</span>selector<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> SEL<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imp<span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n或者：\nSEL selector <span class=\"token operator\">=</span> <span class=\"token function\">NSSelectorFromString</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"aMethod\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> SEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>obj methodForSelector<span class=\"token punctuation\">:</span>selector<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> selector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"21、一个字符串是否包含另一个字符串\"><a href=\"#21、一个字符串是否包含另一个字符串\" class=\"headerlink\" title=\"21、一个字符串是否包含另一个字符串\"></a>21、一个字符串是否包含另一个字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法1</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>str1 containsString<span class=\"token punctuation\">:</span>str2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"str1包含str2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"str1不包含str2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法2</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>str1 rangeOfString<span class=\"token punctuation\">:</span> str2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>location <span class=\"token operator\">==</span> NSNotFound<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"str1不包含str2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"str1包含str2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"22、cell去除选中效果\"><a href=\"#22、cell去除选中效果\" class=\"headerlink\" title=\"22、cell去除选中效果\"></a>22、cell去除选中效果</h4><pre class=\" language-objective\"><code class=\"language-objective\">cell.selectionStyle = UITableViewCellSelectionStyleNone;\n</code></pre>\n<h4 id=\"23、cell点按效果\"><a href=\"#23、cell点按效果\" class=\"headerlink\" title=\"23、cell点按效果\"></a>23、cell点按效果</h4><pre class=\" language-objective\"><code class=\"language-objective\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n}\n</code></pre>\n<h4 id=\"24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key的crash\"><a href=\"#24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key的crash\" class=\"headerlink\" title=\"24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash\"></a>24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[<viewcontroller 0x7fea6ed05980=\"\"> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash</viewcontroller></h4><h4 id=\"25、真机测试的时候报错：Could-not-launch-“你的-App”，process-launch-failed-Security\"><a href=\"#25、真机测试的时候报错：Could-not-launch-“你的-App”，process-launch-failed-Security\" class=\"headerlink\" title=\"25、真机测试的时候报错：Could not launch “你的 App”，process launch failed: Security\"></a>25、真机测试的时候报错：Could not launch “你的 App”，process launch failed: Security</h4><pre class=\" language-objective\"><code class=\"language-objective\">因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置->通用->描述文件->点击你的app的描述文件->点击信任\n</code></pre>\n<h4 id=\"26、真机测试的时候报错：Could-not-find-Developer-Disk-Image\"><a href=\"#26、真机测试的时候报错：Could-not-find-Developer-Disk-Image\" class=\"headerlink\" title=\"26、真机测试的时候报错：Could not find Developer Disk Image\"></a>26、真机测试的时候报错：Could not find Developer Disk Image</h4><blockquote>\n<p>这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！</p>\n</blockquote>\n<h4 id=\"27、UITextView没有placeholder的问题？\"><a href=\"#27、UITextView没有placeholder的问题？\" class=\"headerlink\" title=\"27、UITextView没有placeholder的问题？\"></a>27、UITextView没有placeholder的问题？</h4><p>网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 <a href=\"https://github.com/WZBbiao/UITextView-WZB\" target=\"_blank\" rel=\"external\">UITextView-WZB</a></p>\n<h4 id=\"28、移除字符串中的空格和换行\"><a href=\"#28、移除字符串中的空格和换行\" class=\"headerlink\" title=\"28、移除字符串中的空格和换行\"></a>28、移除字符串中的空格和换行</h4><pre class=\" language-objective\"><code class=\"language-objective\">+ (NSString *)removeSpaceAndNewline:(NSString *)str {\n    NSString *temp = [str stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    temp = [temp stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    return temp;\n}\n</code></pre>\n<h4 id=\"29、判断字符串中是否有空格\"><a href=\"#29、判断字符串中是否有空格\" class=\"headerlink\" title=\"29、判断字符串中是否有空格\"></a>29、判断字符串中是否有空格</h4><pre class=\" language-objective\"><code class=\"language-objective\">+ (BOOL)isBlank:(NSString *)str {\n    NSRange _range = [str rangeOfString:@\" \"];\n    if (_range.location != NSNotFound) {\n        //有空格\n        return YES;\n    } else {\n        //没有空格\n        return NO;\n    }\n}\n</code></pre>\n<h4 id=\"30、获取一个视频的第一帧图片\"><a href=\"#30、获取一个视频的第一帧图片\" class=\"headerlink\" title=\"30、获取一个视频的第一帧图片\"></a>30、获取一个视频的第一帧图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    NSURL <span class=\"token operator\">*</span>url <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSURL URLWithString<span class=\"token punctuation\">:</span>filepath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    AVURLAsset <span class=\"token operator\">*</span>asset1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVURLAsset alloc<span class=\"token punctuation\">]</span> initWithURL<span class=\"token punctuation\">:</span>url options<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    AVAssetImageGenerator <span class=\"token operator\">*</span>generate1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>AVAssetImageGenerator alloc<span class=\"token punctuation\">]</span> initWithAsset<span class=\"token punctuation\">:</span>asset1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    generate1<span class=\"token punctuation\">.</span>appliesPreferredTrackTransform <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n    NSError <span class=\"token operator\">*</span>err <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    CMTime time <span class=\"token operator\">=</span> <span class=\"token function\">CMTimeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGImageRef oneRef <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>generate1 copyCGImageAtTime<span class=\"token punctuation\">:</span>time actualTime<span class=\"token punctuation\">:</span><span class=\"token constant\">NULL</span> error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>err<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>one <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIImage alloc<span class=\"token punctuation\">]</span> initWithCGImage<span class=\"token punctuation\">:</span>oneRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> one<span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\"><a href=\"#1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\" class=\"headerlink\" title=\"1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到\"></a>1、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到</h4><pre><code class=\"objectivec\">- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {\n    if ([vc isKindOfClass:[UINavigationController class]]) {\n        return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];\n    }else if ([vc isKindOfClass:[UITabBarController class]]){\n        return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];\n    } else {\n        if (vc.presentedViewController) {\n            return [self getVisibleViewControllerFrom:vc.presentedViewController];\n        } else {\n            return vc;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"2、runtime为一个类动态添加属性\"><a href=\"#2、runtime为一个类动态添加属性\" class=\"headerlink\" title=\"2、runtime为一个类动态添加属性\"></a>2、runtime为一个类动态添加属性</h4><pre><code class=\"objectivec\">// 动态添加属性的本质是: 让对象的某个属性与值产生关联\n        objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n</code></pre>\n<h4 id=\"3、获取runtime为一个类动态添加的属性\"><a href=\"#3、获取runtime为一个类动态添加的属性\" class=\"headerlink\" title=\"3、获取runtime为一个类动态添加的属性\"></a>3、获取runtime为一个类动态添加的属性</h4><pre><code class=\"objectivec\">objc_getAssociatedObject(self, WZBPlaceholderViewKey);\n</code></pre>\n<h4 id=\"4、KVO监听某个对象的属性\"><a href=\"#4、KVO监听某个对象的属性\" class=\"headerlink\" title=\"4、KVO监听某个对象的属性\"></a>4、KVO监听某个对象的属性</h4><pre><code class=\"objectivec\">// 添加监听者\n[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil];\n\n// 当监听的属性值变化的时候会来到这个方法\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {\n    if ([keyPath isEqualToString:@&quot;property&quot;]) {\n       [self textViewTextChange];\n       } else {\n     }\n}\n</code></pre>\n<h4 id=\"5、Reachability判断网络状态\"><a href=\"#5、Reachability判断网络状态\" class=\"headerlink\" title=\"5、Reachability判断网络状态\"></a>5、Reachability判断网络状态</h4><pre><code class=\"objectivec\">NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];\n    if (status == NotReachable) {\n        NSLog(@&quot;当前设备无网络&quot;);\n    }\n    if (status == ReachableViaWiFi) {\n        NSLog(@&quot;当前wifi网络&quot;);\n    }\n    if (status == ReachableViaWWAN) {\n        NSLog(@&quot;当前蜂窝移动网络&quot;);\n    }\n</code></pre>\n<h4 id=\"6、AFNetworking监听网络状态\"><a href=\"#6、AFNetworking监听网络状态\" class=\"headerlink\" title=\"6、AFNetworking监听网络状态\"></a>6、AFNetworking监听网络状态</h4><pre><code class=\"objectivec\">// 监听网络状况\n    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];\n    [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n        switch (status) {\n            case AFNetworkReachabilityStatusUnknown:\n                break;\n            case AFNetworkReachabilityStatusNotReachable: {\n                [SVProgressHUD showInfoWithStatus:@&quot;当前设备无网络&quot;];\n            }\n                break;\n            case AFNetworkReachabilityStatusReachableViaWiFi:\n                [SVProgressHUD showInfoWithStatus:@&quot;当前Wi-Fi网络&quot;];\n                break;\n            case AFNetworkReachabilityStatusReachableViaWWAN:\n                [SVProgressHUD showInfoWithStatus:@&quot;当前蜂窝移动网络&quot;];\n                break;\n            default:\n                break;\n        }\n    }];\n    [mgr startMonitoring];\n</code></pre>\n<h4 id=\"7、透明颜色不影响子视图透明度\"><a href=\"#7、透明颜色不影响子视图透明度\" class=\"headerlink\" title=\"7、透明颜色不影响子视图透明度\"></a>7、透明颜色不影响子视图透明度</h4><pre><code class=\"objectivec\">[UIColor colorWithRed:&lt;#(CGFloat)#&gt; green:&lt;#(CGFloat)#&gt; blue:&lt;#(CGFloat)#&gt; alpha:&lt;#(CGFloat)#&gt;];\n</code></pre>\n<h4 id=\"8、取图片某一点的颜色\"><a href=\"#8、取图片某一点的颜色\" class=\"headerlink\" title=\"8、取图片某一点的颜色\"></a>8、取图片某一点的颜色</h4><pre><code class=\"objectivec\">    if (point.x &lt; 0 || point.y &lt; 0) return nil;\n\n    CGImageRef imageRef = self.CGImage;\n    NSUInteger width = CGImageGetWidth(imageRef);\n    NSUInteger height = CGImageGetHeight(imageRef);\n    if (point.x &gt;= width || point.y &gt;= height) return nil;\n\n    unsigned char *rawData = malloc(height * width * 4);\n    if (!rawData) return nil;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    NSUInteger bytesPerPixel = 4;\n    NSUInteger bytesPerRow = bytesPerPixel * width;\n    NSUInteger bitsPerComponent = 8;\n    CGContextRef context = CGBitmapContextCreate(rawData,\n                                                 width,\n                                                 height,\n                                                 bitsPerComponent,\n                                                 bytesPerRow,\n                                                 colorSpace,\n                                                 kCGImageAlphaPremultipliedLast\n                                                 | kCGBitmapByteOrder32Big);\n    if (!context) {\n        free(rawData);\n        return nil;\n    }\n    CGColorSpaceRelease(colorSpace);\n    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);\n    CGContextRelease(context);\n\n    int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel;\n    CGFloat red   = (rawData[byteIndex]     * 1.0) / 255.0;\n    CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0;\n    CGFloat blue  = (rawData[byteIndex + 2] * 1.0) / 255.0;\n    CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0;\n\n    UIColor *result = nil;\n    result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n    free(rawData);\n    return result;\n</code></pre>\n<h4 id=\"9、判断该图片是否有透明度通道\"><a href=\"#9、判断该图片是否有透明度通道\" class=\"headerlink\" title=\"9、判断该图片是否有透明度通道\"></a>9、判断该图片是否有透明度通道</h4><pre><code class=\"objectivec\">  - (BOOL)hasAlphaChannel\n{\n    CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);\n    return (alpha == kCGImageAlphaFirst ||\n            alpha == kCGImageAlphaLast ||\n            alpha == kCGImageAlphaPremultipliedFirst ||\n            alpha == kCGImageAlphaPremultipliedLast);\n}\n</code></pre>\n<h4 id=\"10、获得灰度图\"><a href=\"#10、获得灰度图\" class=\"headerlink\" title=\"10、获得灰度图\"></a>10、获得灰度图</h4><pre><code class=\"objectivec\">+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage\n{\n    int width = sourceImage.size.width;\n    int height = sourceImage.size.height;\n\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);\n    CGColorSpaceRelease(colorSpace);\n\n    if (context == NULL) {\n        return nil;\n    }\n\n    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);\n    CGImageRef contextRef = CGBitmapContextCreateImage(context);\n    UIImage *grayImage = [UIImage imageWithCGImage:contextRef];\n    CGContextRelease(context);\n    CGImageRelease(contextRef);\n\n    return grayImage;\n}\n</code></pre>\n<h4 id=\"11、根据bundle中的文件名读取图片\"><a href=\"#11、根据bundle中的文件名读取图片\" class=\"headerlink\" title=\"11、根据bundle中的文件名读取图片\"></a>11、根据bundle中的文件名读取图片</h4><pre><code class=\"objectivec\">   + (UIImage *)imageWithFileName:(NSString *)name {\n    NSString *extension = @&quot;png&quot;;\n\n    NSArray *components = [name componentsSeparatedByString:@&quot;.&quot;];\n    if ([components count] &gt;= 2) {\n        NSUInteger lastIndex = components.count - 1;\n        extension = [components objectAtIndex:lastIndex];\n\n        name = [name substringToIndex:(name.length-(extension.length+1))];\n    }\n\n    // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片\n    if ([UIScreen mainScreen].scale == 2.0) {\n        name = [name stringByAppendingString:@&quot;@2x&quot;];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    if ([UIScreen mainScreen].scale == 3.0) {\n        name = [name stringByAppendingString:@&quot;@3x&quot;];\n\n        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n        if (path != nil) {\n            return [UIImage imageWithContentsOfFile:path];\n        }\n    }\n\n    NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n    if (path) {\n        return [UIImage imageWithContentsOfFile:path];\n    }\n\n    return nil;\n}\n</code></pre>\n<h4 id=\"12、合并两个图片\"><a href=\"#12、合并两个图片\" class=\"headerlink\" title=\"12、合并两个图片\"></a>12、合并两个图片</h4><pre><code class=\"objectivec\">+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage {\n    CGImageRef firstImageRef = firstImage.CGImage;\n    CGFloat firstWidth = CGImageGetWidth(firstImageRef);\n    CGFloat firstHeight = CGImageGetHeight(firstImageRef);\n    CGImageRef secondImageRef = secondImage.CGImage;\n    CGFloat secondWidth = CGImageGetWidth(secondImageRef);\n    CGFloat secondHeight = CGImageGetHeight(secondImageRef);\n    CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight));\n    UIGraphicsBeginImageContext(mergedSize);\n    [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)];\n    [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre>\n<h4 id=\"13、根据bundle中的图片名创建imageview\"><a href=\"#13、根据bundle中的图片名创建imageview\" class=\"headerlink\" title=\"13、根据bundle中的图片名创建imageview\"></a>13、根据bundle中的图片名创建imageview</h4><pre><code class=\"objectivec\">+ (id)imageViewWithImageNamed:(NSString*)imageName\n{\n    return [[UIImageView alloc] initWithImage:[UIImage imageNamed:imageName]];\n}\n</code></pre>\n<h4 id=\"14、为imageView添加倒影\"><a href=\"#14、为imageView添加倒影\" class=\"headerlink\" title=\"14、为imageView添加倒影\"></a>14、为imageView添加倒影</h4><pre><code class=\"objectivec\">    CGRect frame = self.frame;\n    frame.origin.y += (frame.size.height + 1);\n\n    UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame];\n    self.clipsToBounds = TRUE;\n    reflectionImageView.contentMode = self.contentMode;\n    [reflectionImageView setImage:self.image];\n    reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0);\n\n    CALayer *reflectionLayer = [reflectionImageView layer];\n\n    CAGradientLayer *gradientLayer = [CAGradientLayer layer];\n    gradientLayer.bounds = reflectionLayer.bounds;\n    gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5);\n    gradientLayer.colors = [NSArray arrayWithObjects:\n                            (id)[[UIColor clearColor] CGColor],\n                            (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil];\n\n    gradientLayer.startPoint = CGPointMake(0.5,0.5);\n    gradientLayer.endPoint = CGPointMake(0.5,1.0);\n    reflectionLayer.mask = gradientLayer;\n\n    [self.superview addSubview:reflectionImageView];\n</code></pre>\n<h4 id=\"15、画水印\"><a href=\"#15、画水印\" class=\"headerlink\" title=\"15、画水印\"></a>15、画水印</h4><pre><code class=\"objectivec\">// 画水印\n- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect\n{\n    if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0)\n    {\n        UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);\n    }\n    //原图\n    [image drawInRect:self.bounds];\n    //水印图\n    [mark drawInRect:rect];\n    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    self.image = newPic;\n}\n</code></pre>\n<h4 id=\"16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\"><a href=\"#16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\" class=\"headerlink\" title=\"16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部\"></a>16、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部</h4><pre><code class=\"objectivec\">自定义UILabel\n// 重写label的textRectForBounds方法\n- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {\n    CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];\n    switch (self.textAlignmentType) {\n        case WZBTextAlignmentTypeLeftTop: {\n            rect.origin = bounds.origin;\n        }\n            break;\n        case WZBTextAlignmentTypeRightTop: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeLeftBottom: {\n            rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeRightBottom: {\n            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeTopCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeBottomCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height);\n        }\n            break;\n        case WZBTextAlignmentTypeLeft: {\n            rect.origin = CGPointMake(0, rect.origin.y);\n        }\n            break;\n        case WZBTextAlignmentTypeRight: {\n            rect.origin = CGPointMake(rect.origin.x, 0);\n        }\n            break;\n        case WZBTextAlignmentTypeCenter: {\n            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2);\n        }\n            break;\n\n        default:\n            break;\n    }\n    return rect;\n}\n- (void)drawTextInRect:(CGRect)rect {\n    CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines];\n    [super drawTextInRect:textRect];\n}\n</code></pre>\n<h4 id=\"17、scrollView上的输入框，键盘挡住的问题\"><a href=\"#17、scrollView上的输入框，键盘挡住的问题\" class=\"headerlink\" title=\"17、scrollView上的输入框，键盘挡住的问题\"></a>17、scrollView上的输入框，键盘挡住的问题</h4><pre><code class=\"objectivec\">推荐用IQKeyboardManager这个框架！\n手动解决如下\n1、监听键盘弹出／消失的通知\n2、在通知中加入代码：\nNSDictionary* info = [aNotification userInfo];\nCGRect keyPadFrame=[[UIApplication sharedApplication].keyWindow convertRect:[[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue] fromView:self.view];\nCGSize kbSize =keyPadFrame.size;\nCGRect activeRect=[self.view convertRect:activeField.frame fromView:activeField.superview];\nCGRect aRect = self.view.bounds;\naRect.size.height -= (kbSize.height);\n\nCGPoint origin =  activeRect.origin;\norigin.y -= backScrollView.contentOffset.y;\nif (!CGRectContainsPoint(aRect, origin)) {\n    CGPoint scrollPoint = CGPointMake(0.0,CGRectGetMaxY(activeRect)-(aRect.size.height));\n    [backScrollView setContentOffset:scrollPoint animated:YES];\n}\n</code></pre>\n<h4 id=\"18、frame布局的cell动态高度\"><a href=\"#18、frame布局的cell动态高度\" class=\"headerlink\" title=\"18、frame布局的cell动态高度\"></a>18、frame布局的cell动态高度</h4><pre><code class=\"objectivec\">这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。\n</code></pre>\n<h4 id=\"19、AutoLayout布局的cell动态高度\"><a href=\"#19、AutoLayout布局的cell动态高度\" class=\"headerlink\" title=\"19、AutoLayout布局的cell动态高度\"></a>19、AutoLayout布局的cell动态高度</h4><pre><code class=\"objectivec\">// 1、设置tableView的属性\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 这个属性非0，估计cell高度\n// 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周\n</code></pre>\n<h4 id=\"20、使用performSelector-调用函数，内存泄漏问题\"><a href=\"#20、使用performSelector-调用函数，内存泄漏问题\" class=\"headerlink\" title=\"20、使用performSelector:调用函数，内存泄漏问题\"></a>20、使用performSelector:调用函数，内存泄漏问题</h4><blockquote>\n<p>当我们在开发中使用[obj performSelector:NSSelectorFromString(@”aMethod”)];这类方法时可能会收到一个警告”performSelector may cause a leak because its selector is unknown”.<br>是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！</p>\n</blockquote>\n<pre><code class=\"objectivec\">使用以下代码调用即可：\nif (! obj) { return; }\nSEL selector = NSSelectorFromString(@&quot;aMethod&quot;);\nIMP imp = [obj methodForSelector:selector];\nvoid (*func)(id, SEL) = (void *)imp;\nfunc(obj, selector);\n\n或者：\nSEL selector = NSSelectorFromString(@&quot;aMethod&quot;);\n((void (*)(id, SEL))[obj methodForSelector:selector])(obj, selector);\n</code></pre>\n<h4 id=\"21、一个字符串是否包含另一个字符串\"><a href=\"#21、一个字符串是否包含另一个字符串\" class=\"headerlink\" title=\"21、一个字符串是否包含另一个字符串\"></a>21、一个字符串是否包含另一个字符串</h4><pre><code class=\"objectivec\">// 方法1\nif ([str1 containsString:str2]) {\n        NSLog(@&quot;str1包含str2&quot;);\n    } else {\n        NSLog(@&quot;str1不包含str2&quot;);\n    }\n\n// 方法2\nif ([str1 rangeOfString: str2].location == NSNotFound) {\n        NSLog(@&quot;str1不包含str2&quot;);\n    } else {\n        NSLog(@&quot;str1包含str2&quot;);\n    }\n</code></pre>\n<h4 id=\"22、cell去除选中效果\"><a href=\"#22、cell去除选中效果\" class=\"headerlink\" title=\"22、cell去除选中效果\"></a>22、cell去除选中效果</h4><pre><code class=\"objective\">cell.selectionStyle = UITableViewCellSelectionStyleNone;\n</code></pre>\n<h4 id=\"23、cell点按效果\"><a href=\"#23、cell点按效果\" class=\"headerlink\" title=\"23、cell点按效果\"></a>23、cell点按效果</h4><pre><code class=\"objective\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n}\n</code></pre>\n<h4 id=\"24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key的crash\"><a href=\"#24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似-setValue-forUndefinedKey-this-class-is-not-key-value-coding-compliant-for-the-key的crash\" class=\"headerlink\" title=\"24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash\"></a>24、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[<viewcontroller 0x7fea6ed05980=\"\"> setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash</viewcontroller></h4><h4 id=\"25、真机测试的时候报错：Could-not-launch-“你的-App”，process-launch-failed-Security\"><a href=\"#25、真机测试的时候报错：Could-not-launch-“你的-App”，process-launch-failed-Security\" class=\"headerlink\" title=\"25、真机测试的时候报错：Could not launch “你的 App”，process launch failed: Security\"></a>25、真机测试的时候报错：Could not launch “你的 App”，process launch failed: Security</h4><pre><code class=\"objective\">因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置-&gt;通用-&gt;描述文件-&gt;点击你的app的描述文件-&gt;点击信任\n</code></pre>\n<h4 id=\"26、真机测试的时候报错：Could-not-find-Developer-Disk-Image\"><a href=\"#26、真机测试的时候报错：Could-not-find-Developer-Disk-Image\" class=\"headerlink\" title=\"26、真机测试的时候报错：Could not find Developer Disk Image\"></a>26、真机测试的时候报错：Could not find Developer Disk Image</h4><blockquote>\n<p>这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！</p>\n</blockquote>\n<h4 id=\"27、UITextView没有placeholder的问题？\"><a href=\"#27、UITextView没有placeholder的问题？\" class=\"headerlink\" title=\"27、UITextView没有placeholder的问题？\"></a>27、UITextView没有placeholder的问题？</h4><p>网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 <a href=\"https://github.com/WZBbiao/UITextView-WZB\" target=\"_blank\" rel=\"external\">UITextView-WZB</a></p>\n<h4 id=\"28、移除字符串中的空格和换行\"><a href=\"#28、移除字符串中的空格和换行\" class=\"headerlink\" title=\"28、移除字符串中的空格和换行\"></a>28、移除字符串中的空格和换行</h4><pre><code class=\"objective\">+ (NSString *)removeSpaceAndNewline:(NSString *)str {\n    NSString *temp = [str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];\n    temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\r&quot; withString:@&quot;&quot;];\n    temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;&quot;];\n    return temp;\n}\n</code></pre>\n<h4 id=\"29、判断字符串中是否有空格\"><a href=\"#29、判断字符串中是否有空格\" class=\"headerlink\" title=\"29、判断字符串中是否有空格\"></a>29、判断字符串中是否有空格</h4><pre><code class=\"objective\">+ (BOOL)isBlank:(NSString *)str {\n    NSRange _range = [str rangeOfString:@&quot; &quot;];\n    if (_range.location != NSNotFound) {\n        //有空格\n        return YES;\n    } else {\n        //没有空格\n        return NO;\n    }\n}\n</code></pre>\n<h4 id=\"30、获取一个视频的第一帧图片\"><a href=\"#30、获取一个视频的第一帧图片\" class=\"headerlink\" title=\"30、获取一个视频的第一帧图片\"></a>30、获取一个视频的第一帧图片</h4><pre><code class=\"objectivec\">    NSURL *url = [NSURL URLWithString:filepath];\n    AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil];\n    AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1];\n    generate1.appliesPreferredTrackTransform = YES;\n    NSError *err = NULL;\n    CMTime time = CMTimeMake(1, 2);\n    CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err];\n    UIImage *one = [[UIImage alloc] initWithCGImage:oneRef];\n\n    return one;\n</code></pre>\n"},{"title":"iOS小经验（二）","date":"2016-02-14T01:53:06.000Z","_content":"#### 1、自定义NSLog\n```objectivec\n#ifdef DEBUG\n#define NSLog(fmt, ...) NSLog((@\"%s [Line %d] \" fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define NSLog(...)\n#endif\n```\n\n#### 2、Font\n```objectivec\n#define FontL(s)             [UIFont systemFontOfSize:s weight:UIFontWeightLight]\n#define FontR(s)             [UIFont systemFontOfSize:s weight:UIFontWeightRegular]\n#define FontB(s)             [UIFont systemFontOfSize:s weight:UIFontWeightBold]\n#define FontT(s)             [UIFont systemFontOfSize:s weight:UIFontWeightThin]\n#define Font(s)              FontL(s)\n```\n\n#### 3、FORMAT\n```objectivec\n#define FORMAT(f, ...)      [NSString stringWithFormat:f, ## __VA_ARGS__]\n```\n\n#### 4、在主线程上运行\n```objectivec\n#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);\n```\n\n#### 5、开启异步线程\n```objectivec\n#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);\n```\n\n#### 6、通知\n```objectivec\n#define NOTIF_ADD(n, f)     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]\n#define NOTIF_POST(n, o)    [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]\n#define NOTIF_REMV()        [[NSNotificationCenter defaultCenter] removeObserver:self]\n```\n\n#### 7、随机颜色\n```objectivec\n+ (UIColor *)RandomColor {\n    NSInteger aRedValue = arc4random() % 255;\n    NSInteger aGreenValue = arc4random() % 255;\n    NSInteger aBlueValue = arc4random() % 255;\n    UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];\n    return randColor;\n}\n```\n\n\n#### 8、获取window\n```objectivec\n+(UIWindow*)getWindow {\n    UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow;\n    for (id item in [UIApplication sharedApplication].windows) {\n        if ([item class] == [UIWindow class]) {\n            if (!((UIWindow*)item).hidden) {\n                win = item;\n                break;\n            }\n        }\n    }\n    return win;\n}\n```\n\n#### 9、修改textField的placeholder的字体颜色、大小\n```objectivec\n[textField setValue:[UIColor redColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@\"_placeholderLabel.font\"];\n```\n\n\n#### 10、统一收起键盘\n```objectivec\n[[[UIApplication sharedApplication] keyWindow] endEditing:YES];\n```\n\n#### 11、控制屏幕旋转，在控制器中写\n```objectivec\n/** 是否支持自动转屏 */\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n/** 支持哪些屏幕方向 */\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;\n}\n\n/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {\n    return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;\n}\n```\n\n#### 12、获取app缓存大小\n```objectivec\n- (CGFloat)getCachSize {\n\n    NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];\n    //获取自定义缓存大小\n    //用枚举器遍历 一个文件夹的内容\n    //1.获取 文件夹枚举器\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"];\n    NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];\n    __block NSUInteger count = 0;\n    //2.遍历\n    for (NSString *fileName in enumerator) {\n        NSString *path = [myCachePath stringByAppendingPathComponent:fileName];\n        NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];\n        count += fileDict.fileSize;//自定义所有缓存大小\n    }\n    // 得到是字节  转化为M\n    CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;\n    return totalSize;\n}\n```\n\n#### 13、清理app缓存\n```objectivec\n- (void)handleClearView {\n    //删除两部分\n    //1.删除 sd 图片缓存\n    //先清除内存中的图片缓存\n    [[SDImageCache sharedImageCache] clearMemory];\n    //清除磁盘的缓存\n    [[SDImageCache sharedImageCache] clearDisk];\n    //2.删除自己缓存\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"];\n    [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];\n}\n```\n\n#### 14、模型转字典\n```objectivec\nstatic NSSet *classes;\n\n- (NSMutableDictionary *)getParameterDictionary {\n\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n    Class c = self.class;\n\n    while (c) {\n        unsigned count;\n        objc_property_t *properties = class_copyPropertyList([c class], &count);\n\n        for (int i = 0; i < count; i++) {\n            NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];\n            dict[key] = [self valueForKey:key];\n        }\n        free(properties);\n\n        // 获得父类\n        c = class_getSuperclass(c);\n\n        if ([self isClassFromFoundation:c]) break;\n    }\n    return dict;\n}\n\n- (BOOL)isClassFromFoundation:(Class)c\n{\n    if (c == [NSObject class] || c == [NSManagedObject class]) return YES;\n\n    __block BOOL result = NO;\n    [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {\n        if ([c isSubclassOfClass:foundationClass]) {\n            result = YES;\n            *stop = YES;\n        }\n    }];\n    return result;\n}\n\n- (NSSet *)foundationClasses\n{\n    if (classes == nil) {\n        // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断\n        classes = [NSSet setWithObjects:\n                              [NSURL class],\n                              [NSDate class],\n                              [NSValue class],\n                              [NSData class],\n                              [NSError class],\n                              [NSArray class],\n                              [NSDictionary class],\n                              [NSString class],\n                              [NSAttributedString class], nil];\n    }\n    return classes;\n}\n```\n\n#### 15、交换两个方法实现\n```objectivec\nClass aClass = [self class]; \n\n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n\n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        }\n```\n\n#### 6、打印百分号和引号\n```objectivec\n    NSLog(@\"%%\");\n    NSLog(@\"\\\"\");\n```\n\n#### 17、几个常用权限判断\n```objectivec\n    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {\n        NSLog(@\"没有定位权限\");\n    }\n    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];\n    if (statusVideo == AVAuthorizationStatusDenied) {\n        NSLog(@\"没有摄像头权限\");\n    }\n    //是否有麦克风权限\n    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];\n    if (statusAudio == AVAuthorizationStatusDenied) {\n        NSLog(@\"没有录音权限\");\n    }\n    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {\n        if (status == PHAuthorizationStatusDenied) {\n            NSLog(@\"没有相册权限\");\n        }\n    }];\n```\n\n#### 18、获取手机型号\n```objectivec\n    + (NSString *)getDeviceInfo {\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];\n    if ([platform isEqualToString:@\"iPhone1,1\"]) return @\"iPhone 2G\";\n    if ([platform isEqualToString:@\"iPhone1,2\"]) return @\"iPhone 3G\";\n    if ([platform isEqualToString:@\"iPhone2,1\"]) return @\"iPhone 3GS\";\n    if ([platform isEqualToString:@\"iPhone3,1\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone3,2\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone3,3\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone4,1\"]) return @\"iPhone 4S\";\n    if ([platform isEqualToString:@\"iPhone5,1\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,2\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,3\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone5,4\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone6,1\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone6,2\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone7,1\"]) return @\"iPhone 6 Plus\";\n    if ([platform isEqualToString:@\"iPhone7,2\"]) return @\"iPhone 6\";\n    if ([platform isEqualToString:@\"iPhone8,1\"]) return @\"iPhone 6s\";\n    if ([platform isEqualToString:@\"iPhone8,2\"]) return @\"iPhone 6s Plus\";\n    // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付\n    if ([platform isEqualToString:@\"iPhone9,1\"])    return @\"国行、日版、港行iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,2\"])    return @\"港行、国行iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone9,3\"])    return @\"美版、台版iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,4\"])    return @\"美版、台版iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone8,4\"]) return @\"iPhone SE\";\n    if ([platform isEqualToString:@\"iPod1,1\"]) return @\"iPod Touch 1G\";\n    if ([platform isEqualToString:@\"iPod2,1\"]) return @\"iPod Touch 2G\";\n    if ([platform isEqualToString:@\"iPod3,1\"]) return @\"iPod Touch 3G\";\n    if ([platform isEqualToString:@\"iPod4,1\"]) return @\"iPod Touch 4G\";\n    if ([platform isEqualToString:@\"iPod5,1\"]) return @\"iPod Touch 5G\";\n    if ([platform isEqualToString:@\"iPad1,1\"]) return @\"iPad 1G\";\n    if ([platform isEqualToString:@\"iPad2,1\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,2\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,3\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,4\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,5\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad2,6\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad2,7\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad3,1\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,2\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,3\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,4\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad3,5\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad3,6\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad4,1\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,2\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,3\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,4\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"iPad4,5\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"iPad4,6\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"i386\"]) return @\"iPhone Simulator\";\n    if ([platform isEqualToString:@\"x86_64\"]) return @\"iPhone Simulator\";\n    return platform;\n}\n```\n\n#### 19、长按复制功能\n```objectivec\n- (void)viewDidLoad\n{\n    [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];\n}\n- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress {\n    if (longPress.state == UIGestureRecognizerStateBegan) {\n        UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n        pasteboard.string = @\"需要复制的文本\";\n    }\n}\n```\n\n#### 20、cocoapods升级\n```objectivec\n在终端执行 sudo gem install -n / usr / local / bin cocoapods --pre\n```\n\n#### 21、设置启动页后，依然显示之前的\n```objectivec\n删除app，手机重启，重新安装\n```\n\n#### 22、判断图片类型\n```objectivec\n//通过图片Data数据第一个字节 来获取图片扩展名\n- (NSString *)contentTypeForImageData:(NSData *)data\n{\n    uint8_t c;\n    [data getBytes:&c length:1];\n    switch (c)\n    {\n        case 0xFF:\n            return @\"jpeg\";\n\n        case 0x89:\n            return @\"png\";\n\n        case 0x47:\n            return @\"gif\";\n\n        case 0x49:\n        case 0x4D:\n            return @\"tiff\";\n\n        case 0x52:\n        if ([data length] < 12) {\n            return nil;\n        }\n\n        NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];\n        if ([testString hasPrefix:@\"RIFF\"]\n            && [testString hasSuffix:@\"WEBP\"])\n        {\n            return @\"webp\";\n        }\n\n        return nil;\n    }\n\n    return nil;\n}\n```\n\n#### 23、获取手机和app信息\n```objectivec\nNSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n CFShow(infoDictionary);  \n// app名称  \n NSString *app_Name = [infoDictionary objectForKey:@\"CFBundleDisplayName\"];  \n // app版本  \n NSString *app_Version = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"];  \n // app build版本  \n NSString *app_build = [infoDictionary objectForKey:@\"CFBundleVersion\"];  \n\n\n\n    //手机序列号  \n    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  \n    NSLog(@\"手机序列号: %@\",identifierNumber);  \n    //手机别名： 用户定义的名称  \n    NSString* userPhoneName = [[UIDevice currentDevice] name];  \n    NSLog(@\"手机别名: %@\", userPhoneName);  \n    //设备名称  \n    NSString* deviceName = [[UIDevice currentDevice] systemName];  \n    NSLog(@\"设备名称: %@\",deviceName );  \n    //手机系统版本  \n    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  \n    NSLog(@\"手机系统版本: %@\", phoneVersion);  \n    //手机型号  \n    NSString* phoneModel = [[UIDevice currentDevice] model];  \n    NSLog(@\"手机型号: %@\",phoneModel );  \n    //地方型号  （国际化区域名称）  \n    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  \n    NSLog(@\"国际化区域名称: %@\",localPhoneModel );  \n\n    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n    // 当前应用名称  \n    NSString *appCurName = [infoDictionary objectForKey:@\"CFBundleDisplayName\"];  \n    NSLog(@\"当前应用名称：%@\",appCurName);  \n    // 当前应用软件版本  比如：1.0.1  \n    NSString *appCurVersion = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"];  \n    NSLog(@\"当前应用软件版本:%@\",appCurVersion);  \n    // 当前应用版本号码   int类型  \n    NSString *appCurVersionNum = [infoDictionary objectForKey:@\"CFBundleVersion\"];  \n    NSLog(@\"当前应用版本号码：%@\",appCurVersionNum);\n```\n\n#### 24、获取一个类的所有属性\n```objectivec\nid LenderClass = objc_getClass(\"Lender\");\nunsigned int outCount, i;\nobjc_property_t *properties = class_copyPropertyList(LenderClass, &outCount);\nfor (i = 0; i < outCount; i++) {\n    objc_property_t property = properties[i];\n    fprintf(stdout, \"%s %s\\n\", property_getName(property), property_getAttributes(property));\n}\n```\n\n#### 25、image圆角\n```objectivec\n- (UIImage *)circleImage\n{\n    // NO代表透明\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n    // 获得上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 添加一个圆\n    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n    // 方形变圆形\n    CGContextAddEllipseInRect(ctx, rect);\n    // 裁剪\n    CGContextClip(ctx);\n    // 将图片画上去\n    [self drawInRect:rect];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n\n#### 26、image拉伸\n```objectivec\n+ (UIImage *)resizableImage:(NSString *)imageName\n{\n    UIImage *image = [UIImage imageNamed:imageName];\n    CGFloat imageW = image.size.width;\n    CGFloat imageH = image.size.height;\n    return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch];\n}\n```\n\n#### 27、JSON字符串转字典\n```objectivec\n+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {\n    NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];\n    NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];\n    return responseJSON;\n}\n```\n\n#### 28、身份证号验证\n```objectivec\n- (BOOL)validateIdentityCard {\n    BOOL flag;\n    if (self.length <= 0) {\n        flag = NO;\n        return flag;\n    }\n    NSString *regex2 = @\"^(\\\\d{14}|\\\\d{17})(\\\\d|[xX])$\";\n    NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex2];\n    return [identityCardPredicate evaluateWithObject:self];\n}\n```\n\n#### 29、获取设备mac地址\n\n```objectivec\n+ (NSString *)macAddress {\n    int                 mib[6];\n    size_t              len;\n    char                *buf;\n    unsigned char       *ptr;\n    struct if_msghdr    *ifm;\n    struct sockaddr_dl  *sdl;\n\n    mib[0] = CTL_NET;\n    mib[1] = AF_ROUTE;\n    mib[2] = 0;\n    mib[3] = AF_LINK;\n    mib[4] = NET_RT_IFLIST;\n\n    if((mib[5] = if_nametoindex(\"en0\")) == 0) {\n        printf(\"Error: if_nametoindex error\\n\");\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {\n        printf(\"Error: sysctl, take 1\\n\");\n        return NULL;\n    }\n\n    if((buf = malloc(len)) == NULL) {\n        printf(\"Could not allocate memory. Rrror!\\n\");\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, buf, &len, NULL, 0) < 0) {\n        printf(\"Error: sysctl, take 2\");\n        return NULL;\n    }\n\n    ifm = (struct if_msghdr *)buf;\n    sdl = (struct sockaddr_dl *)(ifm + 1);\n    ptr = (unsigned char *)LLADDR(sdl);\n    NSString *outstring = [NSString stringWithFormat:@\"%02X:%02X:%02X:%02X:%02X:%02X\",\n                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];\n    free(buf);\n\n    return outstring;\n}\n```\n\n#### 30、导入自定义字体库\n```objectivec\n1、找到你想用的字体的 ttf 格式，拖入工程\n2、在工程的plist中增加一行数组，“Fonts provided by application”\n3、为这个key添加一个item，value为你刚才导入的ttf文件名\n4、直接使用即可：label.font = [UIFont fontWithName:@\"你刚才导入的ttf文件名\" size:20.0]；\n```\n\n","source":"_posts/iOS小经验（二）.md","raw":"---\ntitle: iOS小经验（二）\ndate: 2016-02-14 09:53:06\ncategories: \n\t- iOS小经验\n---\n#### 1、自定义NSLog\n```objectivec\n#ifdef DEBUG\n#define NSLog(fmt, ...) NSLog((@\"%s [Line %d] \" fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define NSLog(...)\n#endif\n```\n\n#### 2、Font\n```objectivec\n#define FontL(s)             [UIFont systemFontOfSize:s weight:UIFontWeightLight]\n#define FontR(s)             [UIFont systemFontOfSize:s weight:UIFontWeightRegular]\n#define FontB(s)             [UIFont systemFontOfSize:s weight:UIFontWeightBold]\n#define FontT(s)             [UIFont systemFontOfSize:s weight:UIFontWeightThin]\n#define Font(s)              FontL(s)\n```\n\n#### 3、FORMAT\n```objectivec\n#define FORMAT(f, ...)      [NSString stringWithFormat:f, ## __VA_ARGS__]\n```\n\n#### 4、在主线程上运行\n```objectivec\n#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);\n```\n\n#### 5、开启异步线程\n```objectivec\n#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);\n```\n\n#### 6、通知\n```objectivec\n#define NOTIF_ADD(n, f)     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]\n#define NOTIF_POST(n, o)    [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]\n#define NOTIF_REMV()        [[NSNotificationCenter defaultCenter] removeObserver:self]\n```\n\n#### 7、随机颜色\n```objectivec\n+ (UIColor *)RandomColor {\n    NSInteger aRedValue = arc4random() % 255;\n    NSInteger aGreenValue = arc4random() % 255;\n    NSInteger aBlueValue = arc4random() % 255;\n    UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];\n    return randColor;\n}\n```\n\n\n#### 8、获取window\n```objectivec\n+(UIWindow*)getWindow {\n    UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow;\n    for (id item in [UIApplication sharedApplication].windows) {\n        if ([item class] == [UIWindow class]) {\n            if (!((UIWindow*)item).hidden) {\n                win = item;\n                break;\n            }\n        }\n    }\n    return win;\n}\n```\n\n#### 9、修改textField的placeholder的字体颜色、大小\n```objectivec\n[textField setValue:[UIColor redColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@\"_placeholderLabel.font\"];\n```\n\n\n#### 10、统一收起键盘\n```objectivec\n[[[UIApplication sharedApplication] keyWindow] endEditing:YES];\n```\n\n#### 11、控制屏幕旋转，在控制器中写\n```objectivec\n/** 是否支持自动转屏 */\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n/** 支持哪些屏幕方向 */\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;\n}\n\n/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {\n    return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;\n}\n```\n\n#### 12、获取app缓存大小\n```objectivec\n- (CGFloat)getCachSize {\n\n    NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];\n    //获取自定义缓存大小\n    //用枚举器遍历 一个文件夹的内容\n    //1.获取 文件夹枚举器\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"];\n    NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];\n    __block NSUInteger count = 0;\n    //2.遍历\n    for (NSString *fileName in enumerator) {\n        NSString *path = [myCachePath stringByAppendingPathComponent:fileName];\n        NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];\n        count += fileDict.fileSize;//自定义所有缓存大小\n    }\n    // 得到是字节  转化为M\n    CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;\n    return totalSize;\n}\n```\n\n#### 13、清理app缓存\n```objectivec\n- (void)handleClearView {\n    //删除两部分\n    //1.删除 sd 图片缓存\n    //先清除内存中的图片缓存\n    [[SDImageCache sharedImageCache] clearMemory];\n    //清除磁盘的缓存\n    [[SDImageCache sharedImageCache] clearDisk];\n    //2.删除自己缓存\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@\"Library/Caches\"];\n    [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];\n}\n```\n\n#### 14、模型转字典\n```objectivec\nstatic NSSet *classes;\n\n- (NSMutableDictionary *)getParameterDictionary {\n\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n    Class c = self.class;\n\n    while (c) {\n        unsigned count;\n        objc_property_t *properties = class_copyPropertyList([c class], &count);\n\n        for (int i = 0; i < count; i++) {\n            NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];\n            dict[key] = [self valueForKey:key];\n        }\n        free(properties);\n\n        // 获得父类\n        c = class_getSuperclass(c);\n\n        if ([self isClassFromFoundation:c]) break;\n    }\n    return dict;\n}\n\n- (BOOL)isClassFromFoundation:(Class)c\n{\n    if (c == [NSObject class] || c == [NSManagedObject class]) return YES;\n\n    __block BOOL result = NO;\n    [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {\n        if ([c isSubclassOfClass:foundationClass]) {\n            result = YES;\n            *stop = YES;\n        }\n    }];\n    return result;\n}\n\n- (NSSet *)foundationClasses\n{\n    if (classes == nil) {\n        // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断\n        classes = [NSSet setWithObjects:\n                              [NSURL class],\n                              [NSDate class],\n                              [NSValue class],\n                              [NSData class],\n                              [NSError class],\n                              [NSArray class],\n                              [NSDictionary class],\n                              [NSString class],\n                              [NSAttributedString class], nil];\n    }\n    return classes;\n}\n```\n\n#### 15、交换两个方法实现\n```objectivec\nClass aClass = [self class]; \n\n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n\n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        }\n```\n\n#### 6、打印百分号和引号\n```objectivec\n    NSLog(@\"%%\");\n    NSLog(@\"\\\"\");\n```\n\n#### 17、几个常用权限判断\n```objectivec\n    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {\n        NSLog(@\"没有定位权限\");\n    }\n    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];\n    if (statusVideo == AVAuthorizationStatusDenied) {\n        NSLog(@\"没有摄像头权限\");\n    }\n    //是否有麦克风权限\n    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];\n    if (statusAudio == AVAuthorizationStatusDenied) {\n        NSLog(@\"没有录音权限\");\n    }\n    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {\n        if (status == PHAuthorizationStatusDenied) {\n            NSLog(@\"没有相册权限\");\n        }\n    }];\n```\n\n#### 18、获取手机型号\n```objectivec\n    + (NSString *)getDeviceInfo {\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];\n    if ([platform isEqualToString:@\"iPhone1,1\"]) return @\"iPhone 2G\";\n    if ([platform isEqualToString:@\"iPhone1,2\"]) return @\"iPhone 3G\";\n    if ([platform isEqualToString:@\"iPhone2,1\"]) return @\"iPhone 3GS\";\n    if ([platform isEqualToString:@\"iPhone3,1\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone3,2\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone3,3\"]) return @\"iPhone 4\";\n    if ([platform isEqualToString:@\"iPhone4,1\"]) return @\"iPhone 4S\";\n    if ([platform isEqualToString:@\"iPhone5,1\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,2\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,3\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone5,4\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone6,1\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone6,2\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone7,1\"]) return @\"iPhone 6 Plus\";\n    if ([platform isEqualToString:@\"iPhone7,2\"]) return @\"iPhone 6\";\n    if ([platform isEqualToString:@\"iPhone8,1\"]) return @\"iPhone 6s\";\n    if ([platform isEqualToString:@\"iPhone8,2\"]) return @\"iPhone 6s Plus\";\n    // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付\n    if ([platform isEqualToString:@\"iPhone9,1\"])    return @\"国行、日版、港行iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,2\"])    return @\"港行、国行iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone9,3\"])    return @\"美版、台版iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,4\"])    return @\"美版、台版iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone8,4\"]) return @\"iPhone SE\";\n    if ([platform isEqualToString:@\"iPod1,1\"]) return @\"iPod Touch 1G\";\n    if ([platform isEqualToString:@\"iPod2,1\"]) return @\"iPod Touch 2G\";\n    if ([platform isEqualToString:@\"iPod3,1\"]) return @\"iPod Touch 3G\";\n    if ([platform isEqualToString:@\"iPod4,1\"]) return @\"iPod Touch 4G\";\n    if ([platform isEqualToString:@\"iPod5,1\"]) return @\"iPod Touch 5G\";\n    if ([platform isEqualToString:@\"iPad1,1\"]) return @\"iPad 1G\";\n    if ([platform isEqualToString:@\"iPad2,1\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,2\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,3\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,4\"]) return @\"iPad 2\";\n    if ([platform isEqualToString:@\"iPad2,5\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad2,6\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad2,7\"]) return @\"iPad Mini 1G\";\n    if ([platform isEqualToString:@\"iPad3,1\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,2\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,3\"]) return @\"iPad 3\";\n    if ([platform isEqualToString:@\"iPad3,4\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad3,5\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad3,6\"]) return @\"iPad 4\";\n    if ([platform isEqualToString:@\"iPad4,1\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,2\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,3\"]) return @\"iPad Air\";\n    if ([platform isEqualToString:@\"iPad4,4\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"iPad4,5\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"iPad4,6\"]) return @\"iPad Mini 2G\";\n    if ([platform isEqualToString:@\"i386\"]) return @\"iPhone Simulator\";\n    if ([platform isEqualToString:@\"x86_64\"]) return @\"iPhone Simulator\";\n    return platform;\n}\n```\n\n#### 19、长按复制功能\n```objectivec\n- (void)viewDidLoad\n{\n    [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];\n}\n- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress {\n    if (longPress.state == UIGestureRecognizerStateBegan) {\n        UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n        pasteboard.string = @\"需要复制的文本\";\n    }\n}\n```\n\n#### 20、cocoapods升级\n```objectivec\n在终端执行 sudo gem install -n / usr / local / bin cocoapods --pre\n```\n\n#### 21、设置启动页后，依然显示之前的\n```objectivec\n删除app，手机重启，重新安装\n```\n\n#### 22、判断图片类型\n```objectivec\n//通过图片Data数据第一个字节 来获取图片扩展名\n- (NSString *)contentTypeForImageData:(NSData *)data\n{\n    uint8_t c;\n    [data getBytes:&c length:1];\n    switch (c)\n    {\n        case 0xFF:\n            return @\"jpeg\";\n\n        case 0x89:\n            return @\"png\";\n\n        case 0x47:\n            return @\"gif\";\n\n        case 0x49:\n        case 0x4D:\n            return @\"tiff\";\n\n        case 0x52:\n        if ([data length] < 12) {\n            return nil;\n        }\n\n        NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];\n        if ([testString hasPrefix:@\"RIFF\"]\n            && [testString hasSuffix:@\"WEBP\"])\n        {\n            return @\"webp\";\n        }\n\n        return nil;\n    }\n\n    return nil;\n}\n```\n\n#### 23、获取手机和app信息\n```objectivec\nNSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n CFShow(infoDictionary);  \n// app名称  \n NSString *app_Name = [infoDictionary objectForKey:@\"CFBundleDisplayName\"];  \n // app版本  \n NSString *app_Version = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"];  \n // app build版本  \n NSString *app_build = [infoDictionary objectForKey:@\"CFBundleVersion\"];  \n\n\n\n    //手机序列号  \n    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  \n    NSLog(@\"手机序列号: %@\",identifierNumber);  \n    //手机别名： 用户定义的名称  \n    NSString* userPhoneName = [[UIDevice currentDevice] name];  \n    NSLog(@\"手机别名: %@\", userPhoneName);  \n    //设备名称  \n    NSString* deviceName = [[UIDevice currentDevice] systemName];  \n    NSLog(@\"设备名称: %@\",deviceName );  \n    //手机系统版本  \n    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  \n    NSLog(@\"手机系统版本: %@\", phoneVersion);  \n    //手机型号  \n    NSString* phoneModel = [[UIDevice currentDevice] model];  \n    NSLog(@\"手机型号: %@\",phoneModel );  \n    //地方型号  （国际化区域名称）  \n    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  \n    NSLog(@\"国际化区域名称: %@\",localPhoneModel );  \n\n    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n    // 当前应用名称  \n    NSString *appCurName = [infoDictionary objectForKey:@\"CFBundleDisplayName\"];  \n    NSLog(@\"当前应用名称：%@\",appCurName);  \n    // 当前应用软件版本  比如：1.0.1  \n    NSString *appCurVersion = [infoDictionary objectForKey:@\"CFBundleShortVersionString\"];  \n    NSLog(@\"当前应用软件版本:%@\",appCurVersion);  \n    // 当前应用版本号码   int类型  \n    NSString *appCurVersionNum = [infoDictionary objectForKey:@\"CFBundleVersion\"];  \n    NSLog(@\"当前应用版本号码：%@\",appCurVersionNum);\n```\n\n#### 24、获取一个类的所有属性\n```objectivec\nid LenderClass = objc_getClass(\"Lender\");\nunsigned int outCount, i;\nobjc_property_t *properties = class_copyPropertyList(LenderClass, &outCount);\nfor (i = 0; i < outCount; i++) {\n    objc_property_t property = properties[i];\n    fprintf(stdout, \"%s %s\\n\", property_getName(property), property_getAttributes(property));\n}\n```\n\n#### 25、image圆角\n```objectivec\n- (UIImage *)circleImage\n{\n    // NO代表透明\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n    // 获得上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 添加一个圆\n    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n    // 方形变圆形\n    CGContextAddEllipseInRect(ctx, rect);\n    // 裁剪\n    CGContextClip(ctx);\n    // 将图片画上去\n    [self drawInRect:rect];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n\n#### 26、image拉伸\n```objectivec\n+ (UIImage *)resizableImage:(NSString *)imageName\n{\n    UIImage *image = [UIImage imageNamed:imageName];\n    CGFloat imageW = image.size.width;\n    CGFloat imageH = image.size.height;\n    return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch];\n}\n```\n\n#### 27、JSON字符串转字典\n```objectivec\n+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {\n    NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];\n    NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];\n    return responseJSON;\n}\n```\n\n#### 28、身份证号验证\n```objectivec\n- (BOOL)validateIdentityCard {\n    BOOL flag;\n    if (self.length <= 0) {\n        flag = NO;\n        return flag;\n    }\n    NSString *regex2 = @\"^(\\\\d{14}|\\\\d{17})(\\\\d|[xX])$\";\n    NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex2];\n    return [identityCardPredicate evaluateWithObject:self];\n}\n```\n\n#### 29、获取设备mac地址\n\n```objectivec\n+ (NSString *)macAddress {\n    int                 mib[6];\n    size_t              len;\n    char                *buf;\n    unsigned char       *ptr;\n    struct if_msghdr    *ifm;\n    struct sockaddr_dl  *sdl;\n\n    mib[0] = CTL_NET;\n    mib[1] = AF_ROUTE;\n    mib[2] = 0;\n    mib[3] = AF_LINK;\n    mib[4] = NET_RT_IFLIST;\n\n    if((mib[5] = if_nametoindex(\"en0\")) == 0) {\n        printf(\"Error: if_nametoindex error\\n\");\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {\n        printf(\"Error: sysctl, take 1\\n\");\n        return NULL;\n    }\n\n    if((buf = malloc(len)) == NULL) {\n        printf(\"Could not allocate memory. Rrror!\\n\");\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, buf, &len, NULL, 0) < 0) {\n        printf(\"Error: sysctl, take 2\");\n        return NULL;\n    }\n\n    ifm = (struct if_msghdr *)buf;\n    sdl = (struct sockaddr_dl *)(ifm + 1);\n    ptr = (unsigned char *)LLADDR(sdl);\n    NSString *outstring = [NSString stringWithFormat:@\"%02X:%02X:%02X:%02X:%02X:%02X\",\n                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];\n    free(buf);\n\n    return outstring;\n}\n```\n\n#### 30、导入自定义字体库\n```objectivec\n1、找到你想用的字体的 ttf 格式，拖入工程\n2、在工程的plist中增加一行数组，“Fonts provided by application”\n3、为这个key添加一个item，value为你刚才导入的ttf文件名\n4、直接使用即可：label.font = [UIFont fontWithName:@\"你刚才导入的ttf文件名\" size:20.0]；\n```\n\n","slug":"iOS小经验（二）","published":1,"updated":"2017-07-16T14:49:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvs000tznuzolbfg5dd","content":"<h4 id=\"1、自定义NSLog\"><a href=\"#1、自定义NSLog\" class=\"headerlink\" title=\"1、自定义NSLog\"></a>1、自定义NSLog</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> DEBUG</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NSLog(fmt, ...) NSLog((@\"%s [Line %d] \" fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NSLog(...)</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n</code></pre>\n<h4 id=\"2、Font\"><a href=\"#2、Font\" class=\"headerlink\" title=\"2、Font\"></a>2、Font</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FontL(s)             [UIFont systemFontOfSize:s weight:UIFontWeightLight]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FontR(s)             [UIFont systemFontOfSize:s weight:UIFontWeightRegular]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FontB(s)             [UIFont systemFontOfSize:s weight:UIFontWeightBold]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FontT(s)             [UIFont systemFontOfSize:s weight:UIFontWeightThin]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> Font(s)              FontL(s)</span>\n</code></pre>\n<h4 id=\"3、FORMAT\"><a href=\"#3、FORMAT\" class=\"headerlink\" title=\"3、FORMAT\"></a>3、FORMAT</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FORMAT(f, ...)      [NSString stringWithFormat:f, ## __VA_ARGS__]</span>\n</code></pre>\n<h4 id=\"4、在主线程上运行\"><a href=\"#4、在主线程上运行\" class=\"headerlink\" title=\"4、在主线程上运行\"></a>4、在主线程上运行</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);</span>\n</code></pre>\n<h4 id=\"5、开启异步线程\"><a href=\"#5、开启异步线程\" class=\"headerlink\" title=\"5、开启异步线程\"></a>5、开启异步线程</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);</span>\n</code></pre>\n<h4 id=\"6、通知\"><a href=\"#6、通知\" class=\"headerlink\" title=\"6、通知\"></a>6、通知</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NOTIF_ADD(n, f)     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NOTIF_POST(n, o)    [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NOTIF_REMV()        [[NSNotificationCenter defaultCenter] removeObserver:self]</span>\n</code></pre>\n<h4 id=\"7、随机颜色\"><a href=\"#7、随机颜色\" class=\"headerlink\" title=\"7、随机颜色\"></a>7、随机颜色</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>RandomColor <span class=\"token punctuation\">{</span>\n    NSInteger aRedValue <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">255</span><span class=\"token punctuation\">;</span>\n    NSInteger aGreenValue <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">255</span><span class=\"token punctuation\">;</span>\n    NSInteger aBlueValue <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">255</span><span class=\"token punctuation\">;</span>\n    UIColor <span class=\"token operator\">*</span>randColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span>aRedValue <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span> green<span class=\"token punctuation\">:</span>aGreenValue <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span> blue<span class=\"token punctuation\">:</span>aBlueValue <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span> alpha<span class=\"token punctuation\">:</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> randColor<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"8、获取window\"><a href=\"#8、获取window\" class=\"headerlink\" title=\"8、获取window\"></a>8、获取window</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>UIWindow<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getWindow <span class=\"token punctuation\">{</span>\n    UIWindow<span class=\"token operator\">*</span> win <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[UIApplication sharedApplication].keyWindow;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>id item <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>windows<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>item class<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>UIWindow class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>UIWindow<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hidden<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                win <span class=\"token operator\">=</span> item<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> win<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"9、修改textField的placeholder的字体颜色、大小\"><a href=\"#9、修改textField的placeholder的字体颜色、大小\" class=\"headerlink\" title=\"9、修改textField的placeholder的字体颜色、大小\"></a>9、修改textField的placeholder的字体颜色、大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>textField setValue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span> forKeyPath<span class=\"token punctuation\">:</span><span class=\"token string\">@\"_placeholderLabel.textColor\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>textField setValue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIFont boldSystemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">16</span><span class=\"token punctuation\">]</span> forKeyPath<span class=\"token punctuation\">:</span><span class=\"token string\">@\"_placeholderLabel.font\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"10、统一收起键盘\"><a href=\"#10、统一收起键盘\" class=\"headerlink\" title=\"10、统一收起键盘\"></a>10、统一收起键盘</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span> keyWindow<span class=\"token punctuation\">]</span> endEditing<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"11、控制屏幕旋转，在控制器中写\"><a href=\"#11、控制屏幕旋转，在控制器中写\" class=\"headerlink\" title=\"11、控制屏幕旋转，在控制器中写\"></a>11、控制屏幕旋转，在控制器中写</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/** 是否支持自动转屏 */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>shouldAutorotate <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/** 支持哪些屏幕方向 */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIInterfaceOrientationMask<span class=\"token punctuation\">)</span>supportedInterfaceOrientations <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> UIInterfaceOrientationMaskLandscapeLeft <span class=\"token operator\">|</span> UIInterfaceOrientationMaskLandscapeRight<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIInterfaceOrientation<span class=\"token punctuation\">)</span>preferredInterfaceOrientationForPresentation <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> UIInterfaceOrientationLandscapeLeft <span class=\"token operator\">|</span> UIInterfaceOrientationLandscapeRight<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12、获取app缓存大小\"><a href=\"#12、获取app缓存大小\" class=\"headerlink\" title=\"12、获取app缓存大小\"></a>12、获取app缓存大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>getCachSize <span class=\"token punctuation\">{</span>\n\n    NSUInteger imageCacheSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>SDImageCache sharedImageCache<span class=\"token punctuation\">]</span> getSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取自定义缓存大小</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用枚举器遍历 一个文件夹的内容</span>\n    <span class=\"token comment\" spellcheck=\"true\">//1.获取 文件夹枚举器</span>\n    NSString <span class=\"token operator\">*</span>myCachePath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token function\">NSHomeDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> stringByAppendingPathComponent<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Library/Caches\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSDirectoryEnumerator <span class=\"token operator\">*</span>enumerator <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> enumeratorAtPath<span class=\"token punctuation\">:</span>myCachePath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    __block NSUInteger count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//2.遍历</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span>fileName <span class=\"token keyword\">in</span> enumerator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSString <span class=\"token operator\">*</span>path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>myCachePath stringByAppendingPathComponent<span class=\"token punctuation\">:</span>fileName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        NSDictionary <span class=\"token operator\">*</span>fileDict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> attributesOfItemAtPath<span class=\"token punctuation\">:</span>path error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> fileDict<span class=\"token punctuation\">.</span>fileSize<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//自定义所有缓存大小</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 得到是字节  转化为M</span>\n    CGFloat totalSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>imageCacheSize<span class=\"token operator\">+</span>count<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> totalSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"13、清理app缓存\"><a href=\"#13、清理app缓存\" class=\"headerlink\" title=\"13、清理app缓存\"></a>13、清理app缓存</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>handleClearView <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//删除两部分</span>\n    <span class=\"token comment\" spellcheck=\"true\">//1.删除 sd 图片缓存</span>\n    <span class=\"token comment\" spellcheck=\"true\">//先清除内存中的图片缓存</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>SDImageCache sharedImageCache<span class=\"token punctuation\">]</span> clearMemory<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//清除磁盘的缓存</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>SDImageCache sharedImageCache<span class=\"token punctuation\">]</span> clearDisk<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//2.删除自己缓存</span>\n    NSString <span class=\"token operator\">*</span>myCachePath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token function\">NSHomeDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> stringByAppendingPathComponent<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Library/Caches\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> removeItemAtPath<span class=\"token punctuation\">:</span>myCachePath error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"14、模型转字典\"><a href=\"#14、模型转字典\" class=\"headerlink\" title=\"14、模型转字典\"></a>14、模型转字典</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">static</span> NSSet <span class=\"token operator\">*</span>classes<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSMutableDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getParameterDictionary <span class=\"token punctuation\">{</span>\n\n    NSMutableDictionary <span class=\"token operator\">*</span>dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    Class c <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>class<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">unsigned</span> count<span class=\"token punctuation\">;</span>\n        objc_property_t <span class=\"token operator\">*</span>properties <span class=\"token operator\">=</span> <span class=\"token function\">class_copyPropertyList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>c class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSString <span class=\"token operator\">*</span>key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span><span class=\"token function\">property_getName</span><span class=\"token punctuation\">(</span>properties<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            dict<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> valueForKey<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>properties<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 获得父类</span>\n        c <span class=\"token operator\">=</span> <span class=\"token function\">class_getSuperclass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> isClassFromFoundation<span class=\"token punctuation\">:</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> dict<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isClassFromFoundation<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>Class<span class=\"token punctuation\">)</span>c\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>NSObject class<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> c <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>NSManagedObject class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n\n    __block BOOL result <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> foundationClasses<span class=\"token punctuation\">]</span> enumerateObjectsUsingBlock<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>Class foundationClass<span class=\"token punctuation\">,</span> BOOL <span class=\"token operator\">*</span>stop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>c isSubclassOfClass<span class=\"token punctuation\">:</span>foundationClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">*</span>stop <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSSet <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>foundationClasses\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>classes <span class=\"token operator\">==</span> nil<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断</span>\n        classes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSSet setWithObjects<span class=\"token punctuation\">:</span>\n                              <span class=\"token punctuation\">[</span>NSURL class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSDate class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSValue class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSData class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSError class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSArray class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSDictionary class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSString class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                              <span class=\"token punctuation\">[</span>NSAttributedString class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> classes<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"15、交换两个方法实现\"><a href=\"#15、交换两个方法实现\" class=\"headerlink\" title=\"15、交换两个方法实现\"></a>15、交换两个方法实现</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">Class aClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n\n        SEL originalSelector <span class=\"token operator\">=</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>viewWillAppear<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        SEL swizzledSelector <span class=\"token operator\">=</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>xxx_viewWillAppear<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n        Method originalMethod <span class=\"token operator\">=</span> <span class=\"token function\">class_getInstanceMethod</span><span class=\"token punctuation\">(</span>aClass<span class=\"token punctuation\">,</span> originalSelector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        Method swizzledMethod <span class=\"token operator\">=</span> <span class=\"token function\">class_getInstanceMethod</span><span class=\"token punctuation\">(</span>aClass<span class=\"token punctuation\">,</span> swizzledSelector<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n        BOOL didAddMethod <span class=\"token operator\">=</span> \n            <span class=\"token function\">class_addMethod</span><span class=\"token punctuation\">(</span>aClass<span class=\"token punctuation\">,</span> \n                originalSelector<span class=\"token punctuation\">,</span> \n                <span class=\"token function\">method_getImplementation</span><span class=\"token punctuation\">(</span>swizzledMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                <span class=\"token function\">method_getTypeEncoding</span><span class=\"token punctuation\">(</span>swizzledMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>didAddMethod<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token function\">class_replaceMethod</span><span class=\"token punctuation\">(</span>aClass<span class=\"token punctuation\">,</span> \n                swizzledSelector<span class=\"token punctuation\">,</span> \n                <span class=\"token function\">method_getImplementation</span><span class=\"token punctuation\">(</span>originalMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                <span class=\"token function\">method_getTypeEncoding</span><span class=\"token punctuation\">(</span>originalMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token function\">method_exchangeImplementations</span><span class=\"token punctuation\">(</span>originalMethod<span class=\"token punctuation\">,</span> swizzledMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"6、打印百分号和引号\"><a href=\"#6、打印百分号和引号\" class=\"headerlink\" title=\"6、打印百分号和引号\"></a>6、打印百分号和引号</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%%\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"\\\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"17、几个常用权限判断\"><a href=\"#17、几个常用权限判断\" class=\"headerlink\" title=\"17、几个常用权限判断\"></a>17、几个常用权限判断</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>CLLocationManager authorizationStatus<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span>kCLAuthorizationStatusDenied<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"没有定位权限\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    AVAuthorizationStatus statusVideo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDevice authorizationStatusForMediaType<span class=\"token punctuation\">:</span>AVMediaTypeVideo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>statusVideo <span class=\"token operator\">==</span> AVAuthorizationStatusDenied<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"没有摄像头权限\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//是否有麦克风权限</span>\n    AVAuthorizationStatus statusAudio <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVCaptureDevice authorizationStatusForMediaType<span class=\"token punctuation\">:</span>AVMediaTypeAudio<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>statusAudio <span class=\"token operator\">==</span> AVAuthorizationStatusDenied<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"没有录音权限\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">[</span>PHPhotoLibrary requestAuthorization<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>PHAuthorizationStatus status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">==</span> PHAuthorizationStatusDenied<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"没有相册权限\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"18、获取手机型号\"><a href=\"#18、获取手机型号\" class=\"headerlink\" title=\"18、获取手机型号\"></a>18、获取手机型号</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getDeviceInfo <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> utsname systemInfo<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uname</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>systemInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>platform <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithCString<span class=\"token punctuation\">:</span>systemInfo<span class=\"token punctuation\">.</span>machine encoding<span class=\"token punctuation\">:</span>NSASCIIStringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone1,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 2G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone1,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 3G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone2,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 3GS\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone3,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone3,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone3,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone4,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 4S\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone5,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone5,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone5,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5c\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone5,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5c\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone6,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5s\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone6,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 5s\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone7,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 6 Plus\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone7,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 6\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone8,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 6s\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone8,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone 6s Plus\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone9,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>    <span class=\"token keyword\">return</span> <span class=\"token string\">@\"国行、日版、港行iPhone 7\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone9,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>    <span class=\"token keyword\">return</span> <span class=\"token string\">@\"港行、国行iPhone 7 Plus\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone9,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>    <span class=\"token keyword\">return</span> <span class=\"token string\">@\"美版、台版iPhone 7\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone9,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>    <span class=\"token keyword\">return</span> <span class=\"token string\">@\"美版、台版iPhone 7 Plus\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPhone8,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone SE\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPod1,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPod Touch 1G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPod2,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPod Touch 2G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPod3,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPod Touch 3G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPod4,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPod Touch 4G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPod5,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPod Touch 5G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad1,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 1G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,5\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 1G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,6\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 1G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad2,7\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 1G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 3\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 3\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 3\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,5\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad3,6\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad 4\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Air\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Air\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Air\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,4\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 2G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,5\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 2G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"iPad4,6\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPad Mini 2G\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"i386\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone Simulator\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>platform isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"x86_64\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token string\">@\"iPhone Simulator\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> platform<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"19、长按复制功能\"><a href=\"#19、长按复制功能\" class=\"headerlink\" title=\"19、长按复制功能\"></a>19、长按复制功能</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view addGestureRecognizer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UILongPressGestureRecognizer alloc<span class=\"token punctuation\">]</span> initWithTarget<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> action<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>pasteBoard<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>pasteBoard<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UILongPressGestureRecognizer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>longPress <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>longPress<span class=\"token punctuation\">.</span>state <span class=\"token operator\">==</span> UIGestureRecognizerStateBegan<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        UIPasteboard <span class=\"token operator\">*</span>pasteboard <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIPasteboard generalPasteboard<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        pasteboard<span class=\"token punctuation\">.</span>string <span class=\"token operator\">=</span> <span class=\"token string\">@\"需要复制的文本\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"20、cocoapods升级\"><a href=\"#20、cocoapods升级\" class=\"headerlink\" title=\"20、cocoapods升级\"></a>20、cocoapods升级</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">在终端执行 sudo gem install <span class=\"token operator\">-</span>n <span class=\"token operator\">/</span> usr <span class=\"token operator\">/</span> local <span class=\"token operator\">/</span> bin cocoapods <span class=\"token operator\">--</span>pre\n</code></pre>\n<h4 id=\"21、设置启动页后，依然显示之前的\"><a href=\"#21、设置启动页后，依然显示之前的\" class=\"headerlink\" title=\"21、设置启动页后，依然显示之前的\"></a>21、设置启动页后，依然显示之前的</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">删除app，手机重启，重新安装\n</code></pre>\n<h4 id=\"22、判断图片类型\"><a href=\"#22、判断图片类型\" class=\"headerlink\" title=\"22、判断图片类型\"></a>22、判断图片类型</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//通过图片Data数据第一个字节 来获取图片扩展名</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>contentTypeForImageData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>data\n<span class=\"token punctuation\">{</span>\n    uint8_t c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>data getBytes<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>c length<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">@\"jpeg\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0x89</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">@\"png\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0x47</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">@\"gif\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0x49</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0x4D</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">@\"tiff\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">case</span> <span class=\"token number\">0x52</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>data length<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        NSString <span class=\"token operator\">*</span>testString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>data subdataWithRange<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> encoding<span class=\"token punctuation\">:</span>NSASCIIStringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>testString hasPrefix<span class=\"token punctuation\">:</span><span class=\"token string\">@\"RIFF\"</span><span class=\"token punctuation\">]</span>\n            <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span>testString hasSuffix<span class=\"token punctuation\">:</span><span class=\"token string\">@\"WEBP\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">@\"webp\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"23、获取手机和app信息\"><a href=\"#23、获取手机和app信息\" class=\"headerlink\" title=\"23、获取手机和app信息\"></a>23、获取手机和app信息</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSDictionary <span class=\"token operator\">*</span>infoDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> infoDictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n <span class=\"token function\">CFShow</span><span class=\"token punctuation\">(</span>infoDictionary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token comment\" spellcheck=\"true\">// app名称  </span>\n NSString <span class=\"token operator\">*</span>app_Name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleDisplayName\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n <span class=\"token comment\" spellcheck=\"true\">// app版本  </span>\n NSString <span class=\"token operator\">*</span>app_Version <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleShortVersionString\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n <span class=\"token comment\" spellcheck=\"true\">// app build版本  </span>\n NSString <span class=\"token operator\">*</span>app_build <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleVersion\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//手机序列号  </span>\n    NSString<span class=\"token operator\">*</span> identifierNumber <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> uniqueIdentifier<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"手机序列号: %@\"</span><span class=\"token punctuation\">,</span>identifierNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//手机别名： 用户定义的名称  </span>\n    NSString<span class=\"token operator\">*</span> userPhoneName <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"手机别名: %@\"</span><span class=\"token punctuation\">,</span> userPhoneName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//设备名称  </span>\n    NSString<span class=\"token operator\">*</span> deviceName <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> systemName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"设备名称: %@\"</span><span class=\"token punctuation\">,</span>deviceName <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//手机系统版本  </span>\n    NSString<span class=\"token operator\">*</span> phoneVersion <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> systemVersion<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"手机系统版本: %@\"</span><span class=\"token punctuation\">,</span> phoneVersion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//手机型号  </span>\n    NSString<span class=\"token operator\">*</span> phoneModel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> model<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"手机型号: %@\"</span><span class=\"token punctuation\">,</span>phoneModel <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//地方型号  （国际化区域名称）  </span>\n    NSString<span class=\"token operator\">*</span> localPhoneModel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> localizedModel<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"国际化区域名称: %@\"</span><span class=\"token punctuation\">,</span>localPhoneModel <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n    NSDictionary <span class=\"token operator\">*</span>infoDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> infoDictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">// 当前应用名称  </span>\n    NSString <span class=\"token operator\">*</span>appCurName <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleDisplayName\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前应用名称：%@\"</span><span class=\"token punctuation\">,</span>appCurName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">// 当前应用软件版本  比如：1.0.1  </span>\n    NSString <span class=\"token operator\">*</span>appCurVersion <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleShortVersionString\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前应用软件版本:%@\"</span><span class=\"token punctuation\">,</span>appCurVersion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">// 当前应用版本号码   int类型  </span>\n    NSString <span class=\"token operator\">*</span>appCurVersionNum <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>infoDictionary objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CFBundleVersion\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"当前应用版本号码：%@\"</span><span class=\"token punctuation\">,</span>appCurVersionNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"24、获取一个类的所有属性\"><a href=\"#24、获取一个类的所有属性\" class=\"headerlink\" title=\"24、获取一个类的所有属性\"></a>24、获取一个类的所有属性</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">id LenderClass <span class=\"token operator\">=</span> <span class=\"token function\">objc_getClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Lender\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> outCount<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">;</span>\nobjc_property_t <span class=\"token operator\">*</span>properties <span class=\"token operator\">=</span> <span class=\"token function\">class_copyPropertyList</span><span class=\"token punctuation\">(</span>LenderClass<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>outCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> outCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    objc_property_t property <span class=\"token operator\">=</span> properties<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stdout</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"%s %s\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">property_getName</span><span class=\"token punctuation\">(</span>property<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">property_getAttributes</span><span class=\"token punctuation\">(</span>property<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"25、image圆角\"><a href=\"#25、image圆角\" class=\"headerlink\" title=\"25、image圆角\"></a>25、image圆角</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>circleImage\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// NO代表透明</span>\n    <span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得上下文</span>\n    CGContextRef ctx <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 添加一个圆</span>\n    CGRect rect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 方形变圆形</span>\n    <span class=\"token function\">CGContextAddEllipseInRect</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 裁剪</span>\n    <span class=\"token function\">CGContextClip</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将图片画上去</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> drawInRect<span class=\"token punctuation\">:</span>rect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"26、image拉伸\"><a href=\"#26、image拉伸\" class=\"headerlink\" title=\"26、image拉伸\"></a>26、image拉伸</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>resizableImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imageName\n<span class=\"token punctuation\">{</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span>imageName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CGFloat imageW <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n    CGFloat imageH <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>image resizableImageWithCapInsets<span class=\"token punctuation\">:</span><span class=\"token function\">UIEdgeInsetsMake</span><span class=\"token punctuation\">(</span>imageH <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> imageW <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> imageH <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> imageW <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> resizingMode<span class=\"token punctuation\">:</span>UIImageResizingModeStretch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"27、JSON字符串转字典\"><a href=\"#27、JSON字符串转字典\" class=\"headerlink\" title=\"27、JSON字符串转字典\"></a>27、JSON字符串转字典</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>parseJSONStringToNSDictionary<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>JSONString <span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>JSONData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>JSONString dataUsingEncoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSDictionary <span class=\"token operator\">*</span>responseJSON <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSJSONSerialization JSONObjectWithData<span class=\"token punctuation\">:</span>JSONData options<span class=\"token punctuation\">:</span>NSJSONReadingMutableLeaves error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> responseJSON<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"28、身份证号验证\"><a href=\"#28、身份证号验证\" class=\"headerlink\" title=\"28、身份证号验证\"></a>28、身份证号验证</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>validateIdentityCard <span class=\"token punctuation\">{</span>\n    BOOL flag<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        flag <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> flag<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    NSString <span class=\"token operator\">*</span>regex2 <span class=\"token operator\">=</span> <span class=\"token string\">@\"^(\\\\d{14}|\\\\d{17})(\\\\d|[xX])$\"</span><span class=\"token punctuation\">;</span>\n    NSPredicate <span class=\"token operator\">*</span>identityCardPredicate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span>regex2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>identityCardPredicate evaluateWithObject<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"29、获取设备mac地址\"><a href=\"#29、获取设备mac地址\" class=\"headerlink\" title=\"29、获取设备mac地址\"></a>29、获取设备mac地址</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>macAddress <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span>                 mib<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    size_t              len<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span>                <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span>       <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> if_msghdr    <span class=\"token operator\">*</span>ifm<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> sockaddr_dl  <span class=\"token operator\">*</span>sdl<span class=\"token punctuation\">;</span>\n\n    mib<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> CTL_NET<span class=\"token punctuation\">;</span>\n    mib<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> AF_ROUTE<span class=\"token punctuation\">;</span>\n    mib<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    mib<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> AF_LINK<span class=\"token punctuation\">;</span>\n    mib<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> NET_RT_IFLIST<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mib<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">if_nametoindex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"en0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: if_nametoindex error\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">sysctl</span><span class=\"token punctuation\">(</span>mib<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>len<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: sysctl, take 1\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>buf <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Could not allocate memory. Rrror!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">sysctl</span><span class=\"token punctuation\">(</span>mib<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>len<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error: sysctl, take 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    ifm <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> if_msghdr <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>buf<span class=\"token punctuation\">;</span>\n    sdl <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr_dl <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ifm <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">LLADDR</span><span class=\"token punctuation\">(</span>sdl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>outstring <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%02X:%02X:%02X:%02X:%02X:%02X\"</span><span class=\"token punctuation\">,</span>\n                           <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> outstring<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"30、导入自定义字体库\"><a href=\"#30、导入自定义字体库\" class=\"headerlink\" title=\"30、导入自定义字体库\"></a>30、导入自定义字体库</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token number\">1</span>、找到你想用的字体的 ttf 格式，拖入工程\n<span class=\"token number\">2</span>、在工程的plist中增加一行数组，“Fonts provided by application”\n<span class=\"token number\">3</span>、为这个key添加一个item，value为你刚才导入的ttf文件名\n<span class=\"token number\">4</span>、直接使用即可：label<span class=\"token punctuation\">.</span>font <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIFont fontWithName<span class=\"token punctuation\">:</span><span class=\"token string\">@\"你刚才导入的ttf文件名\"</span> size<span class=\"token punctuation\">:</span><span class=\"token number\">20.0</span><span class=\"token punctuation\">]</span>；\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、自定义NSLog\"><a href=\"#1、自定义NSLog\" class=\"headerlink\" title=\"1、自定义NSLog\"></a>1、自定义NSLog</h4><pre><code class=\"objectivec\">#ifdef DEBUG\n#define NSLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)\n#else\n#define NSLog(...)\n#endif\n</code></pre>\n<h4 id=\"2、Font\"><a href=\"#2、Font\" class=\"headerlink\" title=\"2、Font\"></a>2、Font</h4><pre><code class=\"objectivec\">#define FontL(s)             [UIFont systemFontOfSize:s weight:UIFontWeightLight]\n#define FontR(s)             [UIFont systemFontOfSize:s weight:UIFontWeightRegular]\n#define FontB(s)             [UIFont systemFontOfSize:s weight:UIFontWeightBold]\n#define FontT(s)             [UIFont systemFontOfSize:s weight:UIFontWeightThin]\n#define Font(s)              FontL(s)\n</code></pre>\n<h4 id=\"3、FORMAT\"><a href=\"#3、FORMAT\" class=\"headerlink\" title=\"3、FORMAT\"></a>3、FORMAT</h4><pre><code class=\"objectivec\">#define FORMAT(f, ...)      [NSString stringWithFormat:f, ## __VA_ARGS__]\n</code></pre>\n<h4 id=\"4、在主线程上运行\"><a href=\"#4、在主线程上运行\" class=\"headerlink\" title=\"4、在主线程上运行\"></a>4、在主线程上运行</h4><pre><code class=\"objectivec\">#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);\n</code></pre>\n<h4 id=\"5、开启异步线程\"><a href=\"#5、开启异步线程\" class=\"headerlink\" title=\"5、开启异步线程\"></a>5、开启异步线程</h4><pre><code class=\"objectivec\">#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);\n</code></pre>\n<h4 id=\"6、通知\"><a href=\"#6、通知\" class=\"headerlink\" title=\"6、通知\"></a>6、通知</h4><pre><code class=\"objectivec\">#define NOTIF_ADD(n, f)     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]\n#define NOTIF_POST(n, o)    [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]\n#define NOTIF_REMV()        [[NSNotificationCenter defaultCenter] removeObserver:self]\n</code></pre>\n<h4 id=\"7、随机颜色\"><a href=\"#7、随机颜色\" class=\"headerlink\" title=\"7、随机颜色\"></a>7、随机颜色</h4><pre><code class=\"objectivec\">+ (UIColor *)RandomColor {\n    NSInteger aRedValue = arc4random() % 255;\n    NSInteger aGreenValue = arc4random() % 255;\n    NSInteger aBlueValue = arc4random() % 255;\n    UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];\n    return randColor;\n}\n</code></pre>\n<h4 id=\"8、获取window\"><a href=\"#8、获取window\" class=\"headerlink\" title=\"8、获取window\"></a>8、获取window</h4><pre><code class=\"objectivec\">+(UIWindow*)getWindow {\n    UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow;\n    for (id item in [UIApplication sharedApplication].windows) {\n        if ([item class] == [UIWindow class]) {\n            if (!((UIWindow*)item).hidden) {\n                win = item;\n                break;\n            }\n        }\n    }\n    return win;\n}\n</code></pre>\n<h4 id=\"9、修改textField的placeholder的字体颜色、大小\"><a href=\"#9、修改textField的placeholder的字体颜色、大小\" class=\"headerlink\" title=\"9、修改textField的placeholder的字体颜色、大小\"></a>9、修改textField的placeholder的字体颜色、大小</h4><pre><code class=\"objectivec\">[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];\n[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;];\n</code></pre>\n<h4 id=\"10、统一收起键盘\"><a href=\"#10、统一收起键盘\" class=\"headerlink\" title=\"10、统一收起键盘\"></a>10、统一收起键盘</h4><pre><code class=\"objectivec\">[[[UIApplication sharedApplication] keyWindow] endEditing:YES];\n</code></pre>\n<h4 id=\"11、控制屏幕旋转，在控制器中写\"><a href=\"#11、控制屏幕旋转，在控制器中写\" class=\"headerlink\" title=\"11、控制屏幕旋转，在控制器中写\"></a>11、控制屏幕旋转，在控制器中写</h4><pre><code class=\"objectivec\">/** 是否支持自动转屏 */\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n/** 支持哪些屏幕方向 */\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;\n}\n\n/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {\n    return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;\n}\n</code></pre>\n<h4 id=\"12、获取app缓存大小\"><a href=\"#12、获取app缓存大小\" class=\"headerlink\" title=\"12、获取app缓存大小\"></a>12、获取app缓存大小</h4><pre><code class=\"objectivec\">- (CGFloat)getCachSize {\n\n    NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];\n    //获取自定义缓存大小\n    //用枚举器遍历 一个文件夹的内容\n    //1.获取 文件夹枚举器\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;];\n    NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];\n    __block NSUInteger count = 0;\n    //2.遍历\n    for (NSString *fileName in enumerator) {\n        NSString *path = [myCachePath stringByAppendingPathComponent:fileName];\n        NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];\n        count += fileDict.fileSize;//自定义所有缓存大小\n    }\n    // 得到是字节  转化为M\n    CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;\n    return totalSize;\n}\n</code></pre>\n<h4 id=\"13、清理app缓存\"><a href=\"#13、清理app缓存\" class=\"headerlink\" title=\"13、清理app缓存\"></a>13、清理app缓存</h4><pre><code class=\"objectivec\">- (void)handleClearView {\n    //删除两部分\n    //1.删除 sd 图片缓存\n    //先清除内存中的图片缓存\n    [[SDImageCache sharedImageCache] clearMemory];\n    //清除磁盘的缓存\n    [[SDImageCache sharedImageCache] clearDisk];\n    //2.删除自己缓存\n    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;];\n    [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];\n}\n</code></pre>\n<h4 id=\"14、模型转字典\"><a href=\"#14、模型转字典\" class=\"headerlink\" title=\"14、模型转字典\"></a>14、模型转字典</h4><pre><code class=\"objectivec\">static NSSet *classes;\n\n- (NSMutableDictionary *)getParameterDictionary {\n\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n\n    Class c = self.class;\n\n    while (c) {\n        unsigned count;\n        objc_property_t *properties = class_copyPropertyList([c class], &amp;count);\n\n        for (int i = 0; i &lt; count; i++) {\n            NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];\n            dict[key] = [self valueForKey:key];\n        }\n        free(properties);\n\n        // 获得父类\n        c = class_getSuperclass(c);\n\n        if ([self isClassFromFoundation:c]) break;\n    }\n    return dict;\n}\n\n- (BOOL)isClassFromFoundation:(Class)c\n{\n    if (c == [NSObject class] || c == [NSManagedObject class]) return YES;\n\n    __block BOOL result = NO;\n    [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {\n        if ([c isSubclassOfClass:foundationClass]) {\n            result = YES;\n            *stop = YES;\n        }\n    }];\n    return result;\n}\n\n- (NSSet *)foundationClasses\n{\n    if (classes == nil) {\n        // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断\n        classes = [NSSet setWithObjects:\n                              [NSURL class],\n                              [NSDate class],\n                              [NSValue class],\n                              [NSData class],\n                              [NSError class],\n                              [NSArray class],\n                              [NSDictionary class],\n                              [NSString class],\n                              [NSAttributedString class], nil];\n    }\n    return classes;\n}\n</code></pre>\n<h4 id=\"15、交换两个方法实现\"><a href=\"#15、交换两个方法实现\" class=\"headerlink\" title=\"15、交换两个方法实现\"></a>15、交换两个方法实现</h4><pre><code class=\"objectivec\">Class aClass = [self class]; \n\n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n\n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        }\n</code></pre>\n<h4 id=\"6、打印百分号和引号\"><a href=\"#6、打印百分号和引号\" class=\"headerlink\" title=\"6、打印百分号和引号\"></a>6、打印百分号和引号</h4><pre><code class=\"objectivec\">    NSLog(@&quot;%%&quot;);\n    NSLog(@&quot;\\&quot;&quot;);\n</code></pre>\n<h4 id=\"17、几个常用权限判断\"><a href=\"#17、几个常用权限判断\" class=\"headerlink\" title=\"17、几个常用权限判断\"></a>17、几个常用权限判断</h4><pre><code class=\"objectivec\">    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {\n        NSLog(@&quot;没有定位权限&quot;);\n    }\n    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];\n    if (statusVideo == AVAuthorizationStatusDenied) {\n        NSLog(@&quot;没有摄像头权限&quot;);\n    }\n    //是否有麦克风权限\n    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];\n    if (statusAudio == AVAuthorizationStatusDenied) {\n        NSLog(@&quot;没有录音权限&quot;);\n    }\n    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {\n        if (status == PHAuthorizationStatusDenied) {\n            NSLog(@&quot;没有相册权限&quot;);\n        }\n    }];\n</code></pre>\n<h4 id=\"18、获取手机型号\"><a href=\"#18、获取手机型号\" class=\"headerlink\" title=\"18、获取手机型号\"></a>18、获取手机型号</h4><pre><code class=\"objectivec\">    + (NSString *)getDeviceInfo {\n    struct utsname systemInfo;\n    uname(&amp;systemInfo);\n    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];\n    if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;\n    if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;\n    if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;\n    if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;\n    if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;\n    if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;\n    if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;\n    if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;\n    if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;\n    if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;;\n    if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;\n    if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;;\n    if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;\n    if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;\n    if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;\n    if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;\n    if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;\n    // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付\n    if ([platform isEqualToString:@&quot;iPhone9,1&quot;])    return @&quot;国行、日版、港行iPhone 7&quot;;\n    if ([platform isEqualToString:@&quot;iPhone9,2&quot;])    return @&quot;港行、国行iPhone 7 Plus&quot;;\n    if ([platform isEqualToString:@&quot;iPhone9,3&quot;])    return @&quot;美版、台版iPhone 7&quot;;\n    if ([platform isEqualToString:@&quot;iPhone9,4&quot;])    return @&quot;美版、台版iPhone 7 Plus&quot;;\n    if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;\n    if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;\n    if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;\n    if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;\n    if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;\n    if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;;\n    if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;;\n    if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;\n    if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G&quot;;\n    if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G&quot;;\n    if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;;\n    if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;\n    return platform;\n}\n</code></pre>\n<h4 id=\"19、长按复制功能\"><a href=\"#19、长按复制功能\" class=\"headerlink\" title=\"19、长按复制功能\"></a>19、长按复制功能</h4><pre><code class=\"objectivec\">- (void)viewDidLoad\n{\n    [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];\n}\n- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress {\n    if (longPress.state == UIGestureRecognizerStateBegan) {\n        UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\n        pasteboard.string = @&quot;需要复制的文本&quot;;\n    }\n}\n</code></pre>\n<h4 id=\"20、cocoapods升级\"><a href=\"#20、cocoapods升级\" class=\"headerlink\" title=\"20、cocoapods升级\"></a>20、cocoapods升级</h4><pre><code class=\"objectivec\">在终端执行 sudo gem install -n / usr / local / bin cocoapods --pre\n</code></pre>\n<h4 id=\"21、设置启动页后，依然显示之前的\"><a href=\"#21、设置启动页后，依然显示之前的\" class=\"headerlink\" title=\"21、设置启动页后，依然显示之前的\"></a>21、设置启动页后，依然显示之前的</h4><pre><code class=\"objectivec\">删除app，手机重启，重新安装\n</code></pre>\n<h4 id=\"22、判断图片类型\"><a href=\"#22、判断图片类型\" class=\"headerlink\" title=\"22、判断图片类型\"></a>22、判断图片类型</h4><pre><code class=\"objectivec\">//通过图片Data数据第一个字节 来获取图片扩展名\n- (NSString *)contentTypeForImageData:(NSData *)data\n{\n    uint8_t c;\n    [data getBytes:&amp;c length:1];\n    switch (c)\n    {\n        case 0xFF:\n            return @&quot;jpeg&quot;;\n\n        case 0x89:\n            return @&quot;png&quot;;\n\n        case 0x47:\n            return @&quot;gif&quot;;\n\n        case 0x49:\n        case 0x4D:\n            return @&quot;tiff&quot;;\n\n        case 0x52:\n        if ([data length] &lt; 12) {\n            return nil;\n        }\n\n        NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];\n        if ([testString hasPrefix:@&quot;RIFF&quot;]\n            &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;])\n        {\n            return @&quot;webp&quot;;\n        }\n\n        return nil;\n    }\n\n    return nil;\n}\n</code></pre>\n<h4 id=\"23、获取手机和app信息\"><a href=\"#23、获取手机和app信息\" class=\"headerlink\" title=\"23、获取手机和app信息\"></a>23、获取手机和app信息</h4><pre><code class=\"objectivec\">NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n CFShow(infoDictionary);  \n// app名称  \n NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  \n // app版本  \n NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  \n // app build版本  \n NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  \n\n\n\n    //手机序列号  \n    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  \n    NSLog(@&quot;手机序列号: %@&quot;,identifierNumber);  \n    //手机别名： 用户定义的名称  \n    NSString* userPhoneName = [[UIDevice currentDevice] name];  \n    NSLog(@&quot;手机别名: %@&quot;, userPhoneName);  \n    //设备名称  \n    NSString* deviceName = [[UIDevice currentDevice] systemName];  \n    NSLog(@&quot;设备名称: %@&quot;,deviceName );  \n    //手机系统版本  \n    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  \n    NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion);  \n    //手机型号  \n    NSString* phoneModel = [[UIDevice currentDevice] model];  \n    NSLog(@&quot;手机型号: %@&quot;,phoneModel );  \n    //地方型号  （国际化区域名称）  \n    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  \n    NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel );  \n\n    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  \n    // 当前应用名称  \n    NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  \n    NSLog(@&quot;当前应用名称：%@&quot;,appCurName);  \n    // 当前应用软件版本  比如：1.0.1  \n    NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  \n    NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion);  \n    // 当前应用版本号码   int类型  \n    NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  \n    NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum);\n</code></pre>\n<h4 id=\"24、获取一个类的所有属性\"><a href=\"#24、获取一个类的所有属性\" class=\"headerlink\" title=\"24、获取一个类的所有属性\"></a>24、获取一个类的所有属性</h4><pre><code class=\"objectivec\">id LenderClass = objc_getClass(&quot;Lender&quot;);\nunsigned int outCount, i;\nobjc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);\nfor (i = 0; i &lt; outCount; i++) {\n    objc_property_t property = properties[i];\n    fprintf(stdout, &quot;%s %s\\n&quot;, property_getName(property), property_getAttributes(property));\n}\n</code></pre>\n<h4 id=\"25、image圆角\"><a href=\"#25、image圆角\" class=\"headerlink\" title=\"25、image圆角\"></a>25、image圆角</h4><pre><code class=\"objectivec\">- (UIImage *)circleImage\n{\n    // NO代表透明\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n    // 获得上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 添加一个圆\n    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n    // 方形变圆形\n    CGContextAddEllipseInRect(ctx, rect);\n    // 裁剪\n    CGContextClip(ctx);\n    // 将图片画上去\n    [self drawInRect:rect];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre>\n<h4 id=\"26、image拉伸\"><a href=\"#26、image拉伸\" class=\"headerlink\" title=\"26、image拉伸\"></a>26、image拉伸</h4><pre><code class=\"objectivec\">+ (UIImage *)resizableImage:(NSString *)imageName\n{\n    UIImage *image = [UIImage imageNamed:imageName];\n    CGFloat imageW = image.size.width;\n    CGFloat imageH = image.size.height;\n    return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch];\n}\n</code></pre>\n<h4 id=\"27、JSON字符串转字典\"><a href=\"#27、JSON字符串转字典\" class=\"headerlink\" title=\"27、JSON字符串转字典\"></a>27、JSON字符串转字典</h4><pre><code class=\"objectivec\">+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {\n    NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];\n    NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];\n    return responseJSON;\n}\n</code></pre>\n<h4 id=\"28、身份证号验证\"><a href=\"#28、身份证号验证\" class=\"headerlink\" title=\"28、身份证号验证\"></a>28、身份证号验证</h4><pre><code class=\"objectivec\">- (BOOL)validateIdentityCard {\n    BOOL flag;\n    if (self.length &lt;= 0) {\n        flag = NO;\n        return flag;\n    }\n    NSString *regex2 = @&quot;^(\\\\d{14}|\\\\d{17})(\\\\d|[xX])$&quot;;\n    NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex2];\n    return [identityCardPredicate evaluateWithObject:self];\n}\n</code></pre>\n<h4 id=\"29、获取设备mac地址\"><a href=\"#29、获取设备mac地址\" class=\"headerlink\" title=\"29、获取设备mac地址\"></a>29、获取设备mac地址</h4><pre><code class=\"objectivec\">+ (NSString *)macAddress {\n    int                 mib[6];\n    size_t              len;\n    char                *buf;\n    unsigned char       *ptr;\n    struct if_msghdr    *ifm;\n    struct sockaddr_dl  *sdl;\n\n    mib[0] = CTL_NET;\n    mib[1] = AF_ROUTE;\n    mib[2] = 0;\n    mib[3] = AF_LINK;\n    mib[4] = NET_RT_IFLIST;\n\n    if((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) {\n        printf(&quot;Error: if_nametoindex error\\n&quot;);\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) {\n        printf(&quot;Error: sysctl, take 1\\n&quot;);\n        return NULL;\n    }\n\n    if((buf = malloc(len)) == NULL) {\n        printf(&quot;Could not allocate memory. Rrror!\\n&quot;);\n        return NULL;\n    }\n\n    if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) {\n        printf(&quot;Error: sysctl, take 2&quot;);\n        return NULL;\n    }\n\n    ifm = (struct if_msghdr *)buf;\n    sdl = (struct sockaddr_dl *)(ifm + 1);\n    ptr = (unsigned char *)LLADDR(sdl);\n    NSString *outstring = [NSString stringWithFormat:@&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;,\n                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];\n    free(buf);\n\n    return outstring;\n}\n</code></pre>\n<h4 id=\"30、导入自定义字体库\"><a href=\"#30、导入自定义字体库\" class=\"headerlink\" title=\"30、导入自定义字体库\"></a>30、导入自定义字体库</h4><pre><code class=\"objectivec\">1、找到你想用的字体的 ttf 格式，拖入工程\n2、在工程的plist中增加一行数组，“Fonts provided by application”\n3、为这个key添加一个item，value为你刚才导入的ttf文件名\n4、直接使用即可：label.font = [UIFont fontWithName:@&quot;你刚才导入的ttf文件名&quot; size:20.0]；\n</code></pre>\n"},{"title":"iOS小经验（五）","date":"2016-03-14T01:53:06.000Z","_content":"\n\n#### 1、让UILabel在指定的地方换行\n```objectivec\n// 换行符为\\n,在需要换行的地方加上这个符号即可，如 \nlabel.numberOfLines = 0;\nlabel.text = @\"此处\\n换行\";\n```\n\n#### 2、摇一摇功能\n```objectivec\n1、打开摇一摇功能\n    [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;\n2、让需要摇动的控制器成为第一响应者\n[self becomeFirstResponder];\n3、实现以下方法\n\n// 开始摇动\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 取消摇动\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 摇动结束\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event\n```\n\n#### 3、获取图片大小\n```objectivec\nCGFloat imageWidth = image.size.width;\nCGFloat imageHeight = imageWidth * image.scale;\n```\n\n#### 4、获取view的坐标在整个window上的位置\n```objectivec\n// v上的(0, 0)点在toView上的位置\nCGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject];\n或者\nCGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject];\n```\n\n#### 5、提交App Store审核程序限制\n```objectivec\n您的应用程序的未压缩大小必须小于4GB。每个Mach-O可执行文件（例如app_name.app/app_name）不能超过这些限制：\n对于MinimumOSVersion小于7.0的应用程序：TEXT二进制文件中所有部分的总数最多为80 MB 。\n对于MinimumOSVersion7.x到8.x的应用程序：TEXT对于二进制文件中每个体系结构片段的每个片段，最大为60 MB 。\n对于MinimumOSVersion9.0或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为500 MB 。参阅：iTunes Connect开发者指南\n```\n\n#### 6、修改UISegmentedControl的字体大小\n```objectivec\n[segment setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:15.0f]} forState:UIControlStateNormal];\n```\n\n#### 7、在非ViewController的地方弹出UIAlertController对话框\n```objectivec\n//  最好抽成一个分类\nUIAlertController *alertController = [UIAlertController alertControllerWithTitle:@\"Title\" message:@\"message\" preferredStyle:UIAlertControllerStyleAlert];\n//...\nid rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;\nif([rootViewController isKindOfClass:[UINavigationController class]])\n{\n    rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject;\n}\nif([rootViewController isKindOfClass:[UITabBarController class]])\n{\n    rootViewController = ((UITabBarController *)rootViewController).selectedViewController;\n}\n[rootViewController presentViewController:alertController animated:YES completion:nil\n```\n#### 8、获取一个view所属的控制器\n```objectivec\n// view分类方法\n- (UIViewController *)belongViewController {\n    for (UIView *next = [self superview]; next; next = next.superview) {\n        UIResponder* nextResponder = [next nextResponder];\n        if ([nextResponder isKindOfClass:[UIViewController class]]) {\n            return (UIViewController *)nextResponder;\n        }\n    }\n    return nil;\n}\n```\n\n#### 9、UIImage和base64互转\n```objectivec\n// view分类方法\n- (NSString *)encodeToBase64String:(UIImage *)image {\n return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];\n}\n\n- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData {\n  NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];\n  return [UIImage imageWithData:data];\n}\n```\n\n#### 10、UIWebView设置背景透明\n```objectivec\n[webView setBackgroundColor:[UIColor clearColor]];\n[webView setOpaque:NO];\n```\n\n#### 11、判断NSDate是不是今天\n```objectivec\nNSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate];\nNSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]];\nif([today day] == [otherDay day] &&\n   [today month] == [otherDay month] &&\n   [today year] == [otherDay year] &&\n   [today era] == [otherDay era]) {\n    // 是今天\n}\n```\n\n#### 12、设置tableView分割线颜色\n```objectivec\n[self.tableView setSeparatorColor:[UIColor myColor]];\n```\n\n#### 13、设置屏幕方向\n```objectivec\n NSNumber *orientationTarget = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft];\n[[UIDevice currentDevice] setValue:orientationTarget forKey:@\"orientation\"];\n[UIViewController attemptRotationToDeviceOrientation];\n```\n\n#### 14、比较两个颜色是否相等\n```objectivec\n- (BOOL)isEqualToColor:(UIColor *)otherColor {\n    CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();\n\n    UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {\n        if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {\n            const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);\n            CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};\n            CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );\n\n            UIColor *color = [UIColor colorWithCGColor:colorRef];\n            CGColorRelease(colorRef);\n            return color;            \n        } else\n            return color;\n    };\n\n    UIColor *selfColor = convertColorToRGBSpace(self);\n    otherColor = convertColorToRGBSpace(otherColor);\n    CGColorSpaceRelease(colorSpaceRGB);\n\n    return [selfColor isEqual:otherColor];\n}\n```\n\n#### 15、tableViewCell分割线顶到头\n```objectivec\n- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {\n    [cell setSeparatorInset:UIEdgeInsetsZero];\n    [cell setLayoutMargins:UIEdgeInsetsZero];\n    cell.preservesSuperviewLayoutMargins = NO;\n}\n\n- (void)viewDidLayoutSubviews {\n    [self.tableView setSeparatorInset:UIEdgeInsetsZero];\n    [self.tableView setLayoutMargins:UIEdgeInsetsZero];\n}\n```\n\n#### 16、不让控制器的view随着控制器的xib拉伸或压缩\n```objectivec\nself.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n```\n\n#### 17、`cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.`\n\n>解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了\n在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可\n\n#### 18、安装cocoapods的时候出现 ERROR: While executing gem ... (Errno::EPERM)\n```\nOperation not permitted - /usr/bin/pod\n```\n\n#### 19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\n```objectivec\n[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\n```\n\n#### 20、检查一个rect是否包含一个point\n```objectivec\n// point是否在rect内\nBOOL isContains = CGRectContainsPoint(rect, point);\n```\n\n#### 21、在指定的宽度下，让UILabel自动设置最佳font\n```objectivec\nlabel.adjustsFontSizeToFitWidth = YES;\n```\n\n#### 22、将一个image保存在相册中\n```objectivec\nUIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);\n\n或者\n#import <Photos/Photos.h>\n[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{\n        PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];\n        changeRequest.creationDate          = [NSDate date];\n    } completionHandler:^(BOOL success, NSError *error) {\n        if (success) {\n            NSLog(@\"successfully saved\");\n        }\n        else {\n            NSLog(@\"error saving to photos: %@\", error);\n        }\n    }];\n\n```\n\n#### 23、修改cell.imageView的大小\n```objectivec\nUIImage *icon = [UIImage imageNamed:@\"\"];\nCGSize itemSize = CGSizeMake(30, 30);\nUIGraphicsBeginImageContextWithOptions(itemSize, NO ,0.0);\nCGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);\n[icon drawInRect:imageRect];\ncell.imageView.image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\n```\n\n#### 24、为一个view添加虚线边框\n```objectivec\n CAShapeLayer *border = [CAShapeLayer layer];\n    border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;\n    border.fillColor = nil;\n    border.lineDashPattern = @[@4, @2];\n    border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;\n    border.frame = view.bounds;\n    [view.layer addSublayer:border];\n```\n\n#### 25、UITextView中打开或禁用复制，剪切，选择，全选等功能\n```objectivec\n// 继承UITextView重写这个方法\n- (BOOL)canPerformAction:(SEL)action withSender:(id)sender\n{\n// 返回NO为禁用，YES为开启\n    // 粘贴\n    if (action == @selector(paste:)) return NO;\n    // 剪切\n    if (action == @selector(cut:)) return NO;\n    // 复制\n    if (action == @selector(copy:)) return NO;\n    // 选择\n    if (action == @selector(select:)) return NO;\n    // 选中全部\n    if (action == @selector(selectAll:)) return NO;\n    // 删除\n    if (action == @selector(delete:)) return NO;\n    // 分享\n    if (action == @selector(share)) return NO;\n    return [super canPerformAction:action withSender:sender];\n}\n\n```\n\n#### 26、设置UILabel行间距\n```objectivec\nNSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];\n    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];\n    [style setLineSpacing:20];\n    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];\n    label.attributedText = attrString;\n```\n![](http://upload-images.jianshu.io/upload_images/1432270-736756a6216a6753.gif?imageMogr2/auto-orient/strip)\n\n#### 27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题\n```objectivec\n// 方法一、\n// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典\nNSArray * array = \n    [NSArray arrayWithObjects: @\"first\", @\"second\", nil];\n[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];\n\n// 方法二、\n// 使用NSInvocation\nSEL aSelector = NSSelectorFromString(@\"doSoming:argument2:\");\n    NSInteger argument1 = 10;\n    NSString *argument2 = @\"argument2\";\n    if([self respondsToSelector:aSelector]) {\n        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];\n        [inv setSelector:aSelector];\n        [inv setTarget:self];\n        [inv setArgument:&(argument1) atIndex:2];\n        [inv setArgument:&(argument2) atIndex:3];\n        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];\n    }\n```\n\n#### 28、UILabel显示不同颜色字体\n```objectivec\nNSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];\nlabel.attributedText = string;\n```\n\n#### 29、比较两个CGRect/CGSize/CGPoint是否相等\n```objectivec\nif (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等\n        // do some\n    }\n    if (CGPointEqualToPoint(point1, point2)) { // 两个点相等\n        // do some\n    }\n    if (CGSizeEqualToSize(size1, size2)) { // 两个size相等\n        // do some\n    }\n```\n\n#### 30、比较两个NSDate相差多少小时\n```objectivec\n NSDate* date1 = someDate;\n NSDate* date2 = someOtherDate;\n NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2];\n double secondsInAnHour = 3600;\n// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数\n NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;\n```\n\n","source":"_posts/iOS小经验（五）.md","raw":"---\ntitle: iOS小经验（五）\ndate: 2016-03-14 09:53:06\ncategories: \n\t- iOS小经验\n---\n\n\n#### 1、让UILabel在指定的地方换行\n```objectivec\n// 换行符为\\n,在需要换行的地方加上这个符号即可，如 \nlabel.numberOfLines = 0;\nlabel.text = @\"此处\\n换行\";\n```\n\n#### 2、摇一摇功能\n```objectivec\n1、打开摇一摇功能\n    [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;\n2、让需要摇动的控制器成为第一响应者\n[self becomeFirstResponder];\n3、实现以下方法\n\n// 开始摇动\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 取消摇动\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 摇动结束\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event\n```\n\n#### 3、获取图片大小\n```objectivec\nCGFloat imageWidth = image.size.width;\nCGFloat imageHeight = imageWidth * image.scale;\n```\n\n#### 4、获取view的坐标在整个window上的位置\n```objectivec\n// v上的(0, 0)点在toView上的位置\nCGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject];\n或者\nCGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject];\n```\n\n#### 5、提交App Store审核程序限制\n```objectivec\n您的应用程序的未压缩大小必须小于4GB。每个Mach-O可执行文件（例如app_name.app/app_name）不能超过这些限制：\n对于MinimumOSVersion小于7.0的应用程序：TEXT二进制文件中所有部分的总数最多为80 MB 。\n对于MinimumOSVersion7.x到8.x的应用程序：TEXT对于二进制文件中每个体系结构片段的每个片段，最大为60 MB 。\n对于MinimumOSVersion9.0或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为500 MB 。参阅：iTunes Connect开发者指南\n```\n\n#### 6、修改UISegmentedControl的字体大小\n```objectivec\n[segment setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:15.0f]} forState:UIControlStateNormal];\n```\n\n#### 7、在非ViewController的地方弹出UIAlertController对话框\n```objectivec\n//  最好抽成一个分类\nUIAlertController *alertController = [UIAlertController alertControllerWithTitle:@\"Title\" message:@\"message\" preferredStyle:UIAlertControllerStyleAlert];\n//...\nid rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;\nif([rootViewController isKindOfClass:[UINavigationController class]])\n{\n    rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject;\n}\nif([rootViewController isKindOfClass:[UITabBarController class]])\n{\n    rootViewController = ((UITabBarController *)rootViewController).selectedViewController;\n}\n[rootViewController presentViewController:alertController animated:YES completion:nil\n```\n#### 8、获取一个view所属的控制器\n```objectivec\n// view分类方法\n- (UIViewController *)belongViewController {\n    for (UIView *next = [self superview]; next; next = next.superview) {\n        UIResponder* nextResponder = [next nextResponder];\n        if ([nextResponder isKindOfClass:[UIViewController class]]) {\n            return (UIViewController *)nextResponder;\n        }\n    }\n    return nil;\n}\n```\n\n#### 9、UIImage和base64互转\n```objectivec\n// view分类方法\n- (NSString *)encodeToBase64String:(UIImage *)image {\n return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];\n}\n\n- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData {\n  NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];\n  return [UIImage imageWithData:data];\n}\n```\n\n#### 10、UIWebView设置背景透明\n```objectivec\n[webView setBackgroundColor:[UIColor clearColor]];\n[webView setOpaque:NO];\n```\n\n#### 11、判断NSDate是不是今天\n```objectivec\nNSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate];\nNSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]];\nif([today day] == [otherDay day] &&\n   [today month] == [otherDay month] &&\n   [today year] == [otherDay year] &&\n   [today era] == [otherDay era]) {\n    // 是今天\n}\n```\n\n#### 12、设置tableView分割线颜色\n```objectivec\n[self.tableView setSeparatorColor:[UIColor myColor]];\n```\n\n#### 13、设置屏幕方向\n```objectivec\n NSNumber *orientationTarget = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft];\n[[UIDevice currentDevice] setValue:orientationTarget forKey:@\"orientation\"];\n[UIViewController attemptRotationToDeviceOrientation];\n```\n\n#### 14、比较两个颜色是否相等\n```objectivec\n- (BOOL)isEqualToColor:(UIColor *)otherColor {\n    CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();\n\n    UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {\n        if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {\n            const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);\n            CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};\n            CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );\n\n            UIColor *color = [UIColor colorWithCGColor:colorRef];\n            CGColorRelease(colorRef);\n            return color;            \n        } else\n            return color;\n    };\n\n    UIColor *selfColor = convertColorToRGBSpace(self);\n    otherColor = convertColorToRGBSpace(otherColor);\n    CGColorSpaceRelease(colorSpaceRGB);\n\n    return [selfColor isEqual:otherColor];\n}\n```\n\n#### 15、tableViewCell分割线顶到头\n```objectivec\n- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {\n    [cell setSeparatorInset:UIEdgeInsetsZero];\n    [cell setLayoutMargins:UIEdgeInsetsZero];\n    cell.preservesSuperviewLayoutMargins = NO;\n}\n\n- (void)viewDidLayoutSubviews {\n    [self.tableView setSeparatorInset:UIEdgeInsetsZero];\n    [self.tableView setLayoutMargins:UIEdgeInsetsZero];\n}\n```\n\n#### 16、不让控制器的view随着控制器的xib拉伸或压缩\n```objectivec\nself.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n```\n\n#### 17、`cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.`\n\n>解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了\n在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可\n\n#### 18、安装cocoapods的时候出现 ERROR: While executing gem ... (Errno::EPERM)\n```\nOperation not permitted - /usr/bin/pod\n```\n\n#### 19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\n```objectivec\n[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\n```\n\n#### 20、检查一个rect是否包含一个point\n```objectivec\n// point是否在rect内\nBOOL isContains = CGRectContainsPoint(rect, point);\n```\n\n#### 21、在指定的宽度下，让UILabel自动设置最佳font\n```objectivec\nlabel.adjustsFontSizeToFitWidth = YES;\n```\n\n#### 22、将一个image保存在相册中\n```objectivec\nUIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);\n\n或者\n#import <Photos/Photos.h>\n[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{\n        PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];\n        changeRequest.creationDate          = [NSDate date];\n    } completionHandler:^(BOOL success, NSError *error) {\n        if (success) {\n            NSLog(@\"successfully saved\");\n        }\n        else {\n            NSLog(@\"error saving to photos: %@\", error);\n        }\n    }];\n\n```\n\n#### 23、修改cell.imageView的大小\n```objectivec\nUIImage *icon = [UIImage imageNamed:@\"\"];\nCGSize itemSize = CGSizeMake(30, 30);\nUIGraphicsBeginImageContextWithOptions(itemSize, NO ,0.0);\nCGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);\n[icon drawInRect:imageRect];\ncell.imageView.image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\n```\n\n#### 24、为一个view添加虚线边框\n```objectivec\n CAShapeLayer *border = [CAShapeLayer layer];\n    border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;\n    border.fillColor = nil;\n    border.lineDashPattern = @[@4, @2];\n    border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;\n    border.frame = view.bounds;\n    [view.layer addSublayer:border];\n```\n\n#### 25、UITextView中打开或禁用复制，剪切，选择，全选等功能\n```objectivec\n// 继承UITextView重写这个方法\n- (BOOL)canPerformAction:(SEL)action withSender:(id)sender\n{\n// 返回NO为禁用，YES为开启\n    // 粘贴\n    if (action == @selector(paste:)) return NO;\n    // 剪切\n    if (action == @selector(cut:)) return NO;\n    // 复制\n    if (action == @selector(copy:)) return NO;\n    // 选择\n    if (action == @selector(select:)) return NO;\n    // 选中全部\n    if (action == @selector(selectAll:)) return NO;\n    // 删除\n    if (action == @selector(delete:)) return NO;\n    // 分享\n    if (action == @selector(share)) return NO;\n    return [super canPerformAction:action withSender:sender];\n}\n\n```\n\n#### 26、设置UILabel行间距\n```objectivec\nNSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];\n    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];\n    [style setLineSpacing:20];\n    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];\n    label.attributedText = attrString;\n```\n![](http://upload-images.jianshu.io/upload_images/1432270-736756a6216a6753.gif?imageMogr2/auto-orient/strip)\n\n#### 27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题\n```objectivec\n// 方法一、\n// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典\nNSArray * array = \n    [NSArray arrayWithObjects: @\"first\", @\"second\", nil];\n[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];\n\n// 方法二、\n// 使用NSInvocation\nSEL aSelector = NSSelectorFromString(@\"doSoming:argument2:\");\n    NSInteger argument1 = 10;\n    NSString *argument2 = @\"argument2\";\n    if([self respondsToSelector:aSelector]) {\n        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];\n        [inv setSelector:aSelector];\n        [inv setTarget:self];\n        [inv setArgument:&(argument1) atIndex:2];\n        [inv setArgument:&(argument2) atIndex:3];\n        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];\n    }\n```\n\n#### 28、UILabel显示不同颜色字体\n```objectivec\nNSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];\nlabel.attributedText = string;\n```\n\n#### 29、比较两个CGRect/CGSize/CGPoint是否相等\n```objectivec\nif (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等\n        // do some\n    }\n    if (CGPointEqualToPoint(point1, point2)) { // 两个点相等\n        // do some\n    }\n    if (CGSizeEqualToSize(size1, size2)) { // 两个size相等\n        // do some\n    }\n```\n\n#### 30、比较两个NSDate相差多少小时\n```objectivec\n NSDate* date1 = someDate;\n NSDate* date2 = someOtherDate;\n NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2];\n double secondsInAnHour = 3600;\n// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数\n NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;\n```\n\n","slug":"iOS小经验（五）","published":1,"updated":"2017-07-16T14:49:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvu000wznuz3a5t53al","content":"<h4 id=\"1、让UILabel在指定的地方换行\"><a href=\"#1、让UILabel在指定的地方换行\" class=\"headerlink\" title=\"1、让UILabel在指定的地方换行\"></a>1、让UILabel在指定的地方换行</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 换行符为\\n,在需要换行的地方加上这个符号即可，如 </span>\nlabel<span class=\"token punctuation\">.</span>numberOfLines <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nlabel<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">@\"此处\\n换行\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"2、摇一摇功能\"><a href=\"#2、摇一摇功能\" class=\"headerlink\" title=\"2、摇一摇功能\"></a>2、摇一摇功能</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token number\">1</span>、打开摇一摇功能\n    <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>applicationSupportsShakeToEdit <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token number\">2</span>、让需要摇动的控制器成为第一响应者\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> becomeFirstResponder<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">3</span>、实现以下方法\n\n<span class=\"token comment\" spellcheck=\"true\">// 开始摇动</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>motionBegan<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEventSubtype<span class=\"token punctuation\">)</span>motion withEvent<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEvent <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>event\n<span class=\"token comment\" spellcheck=\"true\">// 取消摇动</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>motionCancelled<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEventSubtype<span class=\"token punctuation\">)</span>motion withEvent<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEvent <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>event\n<span class=\"token comment\" spellcheck=\"true\">// 摇动结束</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>motionEnded<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEventSubtype<span class=\"token punctuation\">)</span>motion withEvent<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIEvent <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>event\n</code></pre>\n<h4 id=\"3、获取图片大小\"><a href=\"#3、获取图片大小\" class=\"headerlink\" title=\"3、获取图片大小\"></a>3、获取图片大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">CGFloat imageWidth <span class=\"token operator\">=</span> image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\nCGFloat imageHeight <span class=\"token operator\">=</span> imageWidth <span class=\"token operator\">*</span> image<span class=\"token punctuation\">.</span>scale<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"4、获取view的坐标在整个window上的位置\"><a href=\"#4、获取view的坐标在整个window上的位置\" class=\"headerlink\" title=\"4、获取view的坐标在整个window上的位置\"></a>4、获取view的坐标在整个window上的位置</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// v上的(0, 0)点在toView上的位置</span>\nCGPoint point <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>v convertPoint<span class=\"token punctuation\">:</span><span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> toView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>windows<span class=\"token punctuation\">.</span>lastObject<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n或者\nCGPoint point <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">.</span>superview convertPoint<span class=\"token punctuation\">:</span>v<span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">.</span>origin toView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>windows<span class=\"token punctuation\">.</span>lastObject<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"5、提交App-Store审核程序限制\"><a href=\"#5、提交App-Store审核程序限制\" class=\"headerlink\" title=\"5、提交App Store审核程序限制\"></a>5、提交App Store审核程序限制</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">您的应用程序的未压缩大小必须小于4GB。每个Mach<span class=\"token operator\">-</span>O可执行文件（例如app_name<span class=\"token punctuation\">.</span>app<span class=\"token operator\">/</span>app_name）不能超过这些限制：\n对于MinimumOSVersion小于<span class=\"token number\">7.0</span>的应用程序：TEXT二进制文件中所有部分的总数最多为<span class=\"token number\">80</span> MB 。\n对于MinimumOSVersion7<span class=\"token punctuation\">.</span>x到<span class=\"token number\">8</span><span class=\"token punctuation\">.</span>x的应用程序：TEXT对于二进制文件中每个体系结构片段的每个片段，最大为<span class=\"token number\">60</span> MB 。\n对于MinimumOSVersion9<span class=\"token number\">.0</span>或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为<span class=\"token number\">500</span> MB 。参阅：iTunes Connect开发者指南\n</code></pre>\n<h4 id=\"6、修改UISegmentedControl的字体大小\"><a href=\"#6、修改UISegmentedControl的字体大小\" class=\"headerlink\" title=\"6、修改UISegmentedControl的字体大小\"></a>6、修改UISegmentedControl的字体大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>segment setTitleTextAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>NSFontAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">15.0f</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> forState<span class=\"token punctuation\">:</span>UIControlStateNormal<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"7、在非ViewController的地方弹出UIAlertController对话框\"><a href=\"#7、在非ViewController的地方弹出UIAlertController对话框\" class=\"headerlink\" title=\"7、在非ViewController的地方弹出UIAlertController对话框\"></a>7、在非ViewController的地方弹出UIAlertController对话框</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//  最好抽成一个分类</span>\nUIAlertController <span class=\"token operator\">*</span>alertController <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIAlertController alertControllerWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Title\"</span> message<span class=\"token punctuation\">:</span><span class=\"token string\">@\"message\"</span> preferredStyle<span class=\"token punctuation\">:</span>UIAlertControllerStyleAlert<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//...</span>\nid rootViewController <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>delegate<span class=\"token punctuation\">.</span>window<span class=\"token punctuation\">.</span>rootViewController<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>rootViewController isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UINavigationController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    rootViewController <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>UINavigationController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>rootViewController<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>viewControllers<span class=\"token punctuation\">.</span>firstObject<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>rootViewController isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UITabBarController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    rootViewController <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>UITabBarController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>rootViewController<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>selectedViewController<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span>rootViewController presentViewController<span class=\"token punctuation\">:</span>alertController animated<span class=\"token punctuation\">:</span>YES completion<span class=\"token punctuation\">:</span>nil\n</code></pre>\n<h4 id=\"8、获取一个view所属的控制器\"><a href=\"#8、获取一个view所属的控制器\" class=\"headerlink\" title=\"8、获取一个view所属的控制器\"></a>8、获取一个view所属的控制器</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// view分类方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIViewController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>belongViewController <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>UIView <span class=\"token operator\">*</span>next <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> superview<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> next<span class=\"token punctuation\">;</span> next <span class=\"token operator\">=</span> next<span class=\"token punctuation\">.</span>superview<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        UIResponder<span class=\"token operator\">*</span> nextResponder <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>next nextResponder<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nextResponder isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIViewController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>UIViewController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>nextResponder<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"9、UIImage和base64互转\"><a href=\"#9、UIImage和base64互转\" class=\"headerlink\" title=\"9、UIImage和base64互转\"></a>9、UIImage和base64互转</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// view分类方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encodeToBase64String<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token function\">UIImagePNGRepresentation</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">)</span> base64EncodedStringWithOptions<span class=\"token punctuation\">:</span>NSDataBase64Encoding64CharacterLineLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decodeBase64ToImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>strEncodeData <span class=\"token punctuation\">{</span>\n  NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSData alloc<span class=\"token punctuation\">]</span>initWithBase64EncodedString<span class=\"token punctuation\">:</span>strEncodeData options<span class=\"token punctuation\">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIImage imageWithData<span class=\"token punctuation\">:</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"10、UIWebView设置背景透明\"><a href=\"#10、UIWebView设置背景透明\" class=\"headerlink\" title=\"10、UIWebView设置背景透明\"></a>10、UIWebView设置背景透明</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>webView setBackgroundColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>webView setOpaque<span class=\"token punctuation\">:</span>NO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"11、判断NSDate是不是今天\"><a href=\"#11、判断NSDate是不是今天\" class=\"headerlink\" title=\"11、判断NSDate是不是今天\"></a>11、判断NSDate是不是今天</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSDateComponents <span class=\"token operator\">*</span>otherDay <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSCalendar currentCalendar<span class=\"token punctuation\">]</span> components<span class=\"token punctuation\">:</span>NSCalendarUnitEra <span class=\"token operator\">|</span> NSCalendarUnitYear <span class=\"token operator\">|</span> NSCalendarUnitMonth <span class=\"token operator\">|</span> NSCalendarUnitDay fromDate<span class=\"token punctuation\">:</span>aDate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSDateComponents <span class=\"token operator\">*</span>today <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSCalendar currentCalendar<span class=\"token punctuation\">]</span> components<span class=\"token punctuation\">:</span>NSCalendarUnitEra <span class=\"token operator\">|</span> NSCalendarUnitYear <span class=\"token operator\">|</span> NSCalendarUnitMonth <span class=\"token operator\">|</span> NSCalendarUnitDay fromDate<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSDate date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>today day<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>otherDay day<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span>\n   <span class=\"token punctuation\">[</span>today month<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>otherDay month<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span>\n   <span class=\"token punctuation\">[</span>today year<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>otherDay year<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span>\n   <span class=\"token punctuation\">[</span>today era<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">[</span>otherDay era<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 是今天</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12、设置tableView分割线颜色\"><a href=\"#12、设置tableView分割线颜色\" class=\"headerlink\" title=\"12、设置tableView分割线颜色\"></a>12、设置tableView分割线颜色</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView setSeparatorColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor myColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"13、设置屏幕方向\"><a href=\"#13、设置屏幕方向\" class=\"headerlink\" title=\"13、设置屏幕方向\"></a>13、设置屏幕方向</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> NSNumber <span class=\"token operator\">*</span>orientationTarget <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInt<span class=\"token punctuation\">:</span>UIInterfaceOrientationLandscapeLeft<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIDevice currentDevice<span class=\"token punctuation\">]</span> setValue<span class=\"token punctuation\">:</span>orientationTarget forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"orientation\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>UIViewController attemptRotationToDeviceOrientation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"14、比较两个颜色是否相等\"><a href=\"#14、比较两个颜色是否相等\" class=\"headerlink\" title=\"14、比较两个颜色是否相等\"></a>14、比较两个颜色是否相等</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isEqualToColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>otherColor <span class=\"token punctuation\">{</span>\n    CGColorSpaceRef colorSpaceRGB <span class=\"token operator\">=</span> <span class=\"token function\">CGColorSpaceCreateDeviceRGB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">^</span>convertColorToRGBSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>UIColor<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span>color<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGColorSpaceGetModel</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGColorGetColorSpace</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">.</span>CGColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> kCGColorSpaceModelMonochrome<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> CGFloat <span class=\"token operator\">*</span>oldComponents <span class=\"token operator\">=</span> <span class=\"token function\">CGColorGetComponents</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">.</span>CGColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            CGFloat components<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>oldComponents<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> oldComponents<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> oldComponents<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> oldComponents<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            CGColorRef colorRef <span class=\"token operator\">=</span> <span class=\"token function\">CGColorCreate</span><span class=\"token punctuation\">(</span> colorSpaceRGB<span class=\"token punctuation\">,</span> components <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            UIColor <span class=\"token operator\">*</span>color <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor colorWithCGColor<span class=\"token punctuation\">:</span>colorRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">CGColorRelease</span><span class=\"token punctuation\">(</span>colorRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> color<span class=\"token punctuation\">;</span>            \n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n            <span class=\"token keyword\">return</span> color<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    UIColor <span class=\"token operator\">*</span>selfColor <span class=\"token operator\">=</span> <span class=\"token function\">convertColorToRGBSpace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    otherColor <span class=\"token operator\">=</span> <span class=\"token function\">convertColorToRGBSpace</span><span class=\"token punctuation\">(</span>otherColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGColorSpaceRelease</span><span class=\"token punctuation\">(</span>colorSpaceRGB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>selfColor isEqual<span class=\"token punctuation\">:</span>otherColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"15、tableViewCell分割线顶到头\"><a href=\"#15、tableViewCell分割线顶到头\" class=\"headerlink\" title=\"15、tableViewCell分割线顶到头\"></a>15、tableViewCell分割线顶到头</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>tableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView willDisplayCell<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableViewCell <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>cell forRowAtIndexPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSIndexPath <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>indexPath <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>cell setSeparatorInset<span class=\"token punctuation\">:</span>UIEdgeInsetsZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>cell setLayoutMargins<span class=\"token punctuation\">:</span>UIEdgeInsetsZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    cell<span class=\"token punctuation\">.</span>preservesSuperviewLayoutMargins <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLayoutSubviews <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView setSeparatorInset<span class=\"token punctuation\">:</span>UIEdgeInsetsZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView setLayoutMargins<span class=\"token punctuation\">:</span>UIEdgeInsetsZero<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"16、不让控制器的view随着控制器的xib拉伸或压缩\"><a href=\"#16、不让控制器的view随着控制器的xib拉伸或压缩\" class=\"headerlink\" title=\"16、不让控制器的view随着控制器的xib拉伸或压缩\"></a>16、不让控制器的view随着控制器的xib拉伸或压缩</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">.</span>autoresizingMask <span class=\"token operator\">=</span> UIViewAutoresizingFlexibleWidth <span class=\"token operator\">|</span> UIViewAutoresizingFlexibleHeight<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"17、cocoaPods报错-Unable-to-add-a-source-with-url-https-github-com-CocoaPods-Specs-git-named-master-1-You-can-try-adding-it-manually-in-cocoapods-repos-or-via-pod-repo-add\"><a href=\"#17、cocoaPods报错-Unable-to-add-a-source-with-url-https-github-com-CocoaPods-Specs-git-named-master-1-You-can-try-adding-it-manually-in-cocoapods-repos-or-via-pod-repo-add\" class=\"headerlink\" title=\"17、cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.\"></a>17、<code>cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.</code></h4><blockquote>\n<p>解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了<br>在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可</p>\n</blockquote>\n<h4 id=\"18、安装cocoapods的时候出现-ERROR-While-executing-gem-…-Errno-EPERM\"><a href=\"#18、安装cocoapods的时候出现-ERROR-While-executing-gem-…-Errno-EPERM\" class=\"headerlink\" title=\"18、安装cocoapods的时候出现 ERROR: While executing gem … (Errno::EPERM)\"></a>18、安装cocoapods的时候出现 ERROR: While executing gem … (Errno::EPERM)</h4><pre><code>Operation not permitted - /usr/bin/pod\n</code></pre><h4 id=\"19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\"><a href=\"#19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\" class=\"headerlink\" title=\"19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\"></a>19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>networkActivityIndicatorVisible <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"20、检查一个rect是否包含一个point\"><a href=\"#20、检查一个rect是否包含一个point\" class=\"headerlink\" title=\"20、检查一个rect是否包含一个point\"></a>20、检查一个rect是否包含一个point</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// point是否在rect内</span>\nBOOL isContains <span class=\"token operator\">=</span> <span class=\"token function\">CGRectContainsPoint</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">,</span> point<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"21、在指定的宽度下，让UILabel自动设置最佳font\"><a href=\"#21、在指定的宽度下，让UILabel自动设置最佳font\" class=\"headerlink\" title=\"21、在指定的宽度下，让UILabel自动设置最佳font\"></a>21、在指定的宽度下，让UILabel自动设置最佳font</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">label<span class=\"token punctuation\">.</span>adjustsFontSizeToFitWidth <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"22、将一个image保存在相册中\"><a href=\"#22、将一个image保存在相册中\" class=\"headerlink\" title=\"22、将一个image保存在相册中\"></a>22、将一个image保存在相册中</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">UIImageWriteToSavedPhotosAlbum</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n或者\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;Photos/Photos.h></span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>PHPhotoLibrary sharedPhotoLibrary<span class=\"token punctuation\">]</span> performChanges<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        PHAssetChangeRequest <span class=\"token operator\">*</span>changeRequest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>PHAssetChangeRequest creationRequestForAssetFromImage<span class=\"token punctuation\">:</span>image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        changeRequest<span class=\"token punctuation\">.</span>creationDate          <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSDate date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> completionHandler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>BOOL success<span class=\"token punctuation\">,</span> NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"successfully saved\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"error saving to photos: %@\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"23、修改cell-imageView的大小\"><a href=\"#23、修改cell-imageView的大小\" class=\"headerlink\" title=\"23、修改cell.imageView的大小\"></a>23、修改cell.imageView的大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UIImage <span class=\"token operator\">*</span>icon <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nCGSize itemSize <span class=\"token operator\">=</span> <span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span>itemSize<span class=\"token punctuation\">,</span> NO <span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCGRect imageRect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> itemSize<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> itemSize<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>icon drawInRect<span class=\"token punctuation\">:</span>imageRect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\ncell<span class=\"token punctuation\">.</span>imageView<span class=\"token punctuation\">.</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"24、为一个view添加虚线边框\"><a href=\"#24、为一个view添加虚线边框\" class=\"headerlink\" title=\"24、为一个view添加虚线边框\"></a>24、为一个view添加虚线边框</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> CAShapeLayer <span class=\"token operator\">*</span>border <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAShapeLayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    border<span class=\"token punctuation\">.</span>strokeColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span><span class=\"token number\">67</span><span class=\"token operator\">/</span><span class=\"token number\">255.0f</span> green<span class=\"token punctuation\">:</span><span class=\"token number\">37</span><span class=\"token operator\">/</span><span class=\"token number\">255.0f</span> blue<span class=\"token punctuation\">:</span><span class=\"token number\">83</span><span class=\"token operator\">/</span><span class=\"token number\">255.0f</span> alpha<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>CGColor<span class=\"token punctuation\">;</span>\n    border<span class=\"token punctuation\">.</span>fillColor <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    border<span class=\"token punctuation\">.</span>lineDashPattern <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    border<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIBezierPath bezierPathWithRect<span class=\"token punctuation\">:</span>view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>CGPath<span class=\"token punctuation\">;</span>\n    border<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>view<span class=\"token punctuation\">.</span>layer addSublayer<span class=\"token punctuation\">:</span>border<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"25、UITextView中打开或禁用复制，剪切，选择，全选等功能\"><a href=\"#25、UITextView中打开或禁用复制，剪切，选择，全选等功能\" class=\"headerlink\" title=\"25、UITextView中打开或禁用复制，剪切，选择，全选等功能\"></a>25、UITextView中打开或禁用复制，剪切，选择，全选等功能</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 继承UITextView重写这个方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>canPerformAction<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SEL<span class=\"token punctuation\">)</span>action withSender<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>sender\n<span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 返回NO为禁用，YES为开启</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 粘贴</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>paste<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 剪切</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>cut<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 复制</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>copy<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 选择</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>select<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 选中全部</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>selectAll<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 删除</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>delete<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 分享</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>action <span class=\"token operator\">==</span> <span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>share<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> canPerformAction<span class=\"token punctuation\">:</span>action withSender<span class=\"token punctuation\">:</span>sender<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"26、设置UILabel行间距\"><a href=\"#26、设置UILabel行间距\" class=\"headerlink\" title=\"26、设置UILabel行间距\"></a>26、设置UILabel行间距</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableAttributedString<span class=\"token operator\">*</span> attrString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableAttributedString  alloc<span class=\"token punctuation\">]</span> initWithString<span class=\"token punctuation\">:</span>label<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSMutableParagraphStyle <span class=\"token operator\">*</span>style <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableParagraphStyle alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>style setLineSpacing<span class=\"token punctuation\">:</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>attrString addAttribute<span class=\"token punctuation\">:</span>NSParagraphStyleAttributeName value<span class=\"token punctuation\">:</span>style range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> label<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    label<span class=\"token punctuation\">.</span>attributedText <span class=\"token operator\">=</span> attrString<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-736756a6216a6753.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h4 id=\"27、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题\"><a href=\"#27、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题\" class=\"headerlink\" title=\"27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题\"></a>27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法一、</span>\n<span class=\"token comment\" spellcheck=\"true\">// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典</span>\nNSArray <span class=\"token operator\">*</span> array <span class=\"token operator\">=</span> \n    <span class=\"token punctuation\">[</span>NSArray arrayWithObjects<span class=\"token punctuation\">:</span> <span class=\"token string\">@\"first\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"second\"</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> performSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>fooFirstInput<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span> withObject<span class=\"token punctuation\">:</span> array afterDelay<span class=\"token punctuation\">:</span><span class=\"token number\">15.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二、</span>\n<span class=\"token comment\" spellcheck=\"true\">// 使用NSInvocation</span>\nSEL aSelector <span class=\"token operator\">=</span> <span class=\"token function\">NSSelectorFromString</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"doSoming:argument2:\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSInteger argument1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>argument2 <span class=\"token operator\">=</span> <span class=\"token string\">@\"argument2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> respondsToSelector<span class=\"token punctuation\">:</span>aSelector<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSInvocation <span class=\"token operator\">*</span>inv <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSInvocation invocationWithMethodSignature<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> methodSignatureForSelector<span class=\"token punctuation\">:</span>aSelector<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>inv setSelector<span class=\"token punctuation\">:</span>aSelector<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>inv setTarget<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>inv setArgument<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>argument1<span class=\"token punctuation\">)</span> atIndex<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>inv setArgument<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>argument2<span class=\"token punctuation\">)</span> atIndex<span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>inv performSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>invoke<span class=\"token punctuation\">)</span> withObject<span class=\"token punctuation\">:</span>nil afterDelay<span class=\"token punctuation\">:</span><span class=\"token number\">15.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"28、UILabel显示不同颜色字体\"><a href=\"#28、UILabel显示不同颜色字体\" class=\"headerlink\" title=\"28、UILabel显示不同颜色字体\"></a>28、UILabel显示不同颜色字体</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableAttributedString <span class=\"token operator\">*</span> string <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableAttributedString alloc<span class=\"token punctuation\">]</span> initWithString<span class=\"token punctuation\">:</span>label<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>string addAttribute<span class=\"token punctuation\">:</span>NSForegroundColorAttributeName value<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>string addAttribute<span class=\"token punctuation\">:</span>NSForegroundColorAttributeName value<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor greenColor<span class=\"token punctuation\">]</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>string addAttribute<span class=\"token punctuation\">:</span>NSForegroundColorAttributeName value<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor blueColor<span class=\"token punctuation\">]</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nlabel<span class=\"token punctuation\">.</span>attributedText <span class=\"token operator\">=</span> string<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"29、比较两个CGRect-CGSize-CGPoint是否相等\"><a href=\"#29、比较两个CGRect-CGSize-CGPoint是否相等\" class=\"headerlink\" title=\"29、比较两个CGRect/CGSize/CGPoint是否相等\"></a>29、比较两个CGRect/CGSize/CGPoint是否相等</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGRectEqualToRect</span><span class=\"token punctuation\">(</span>rect1<span class=\"token punctuation\">,</span> rect2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 两个区域相等</span>\n        <span class=\"token comment\" spellcheck=\"true\">// do some</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGPointEqualToPoint</span><span class=\"token punctuation\">(</span>point1<span class=\"token punctuation\">,</span> point2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 两个点相等</span>\n        <span class=\"token comment\" spellcheck=\"true\">// do some</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGSizeEqualToSize</span><span class=\"token punctuation\">(</span>size1<span class=\"token punctuation\">,</span> size2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 两个size相等</span>\n        <span class=\"token comment\" spellcheck=\"true\">// do some</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"30、比较两个NSDate相差多少小时\"><a href=\"#30、比较两个NSDate相差多少小时\" class=\"headerlink\" title=\"30、比较两个NSDate相差多少小时\"></a>30、比较两个NSDate相差多少小时</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> NSDate<span class=\"token operator\">*</span> date1 <span class=\"token operator\">=</span> someDate<span class=\"token punctuation\">;</span>\n NSDate<span class=\"token operator\">*</span> date2 <span class=\"token operator\">=</span> someOtherDate<span class=\"token punctuation\">;</span>\n NSTimeInterval distanceBetweenDates <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>date1 timeIntervalSinceDate<span class=\"token punctuation\">:</span>date2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">double</span> secondsInAnHour <span class=\"token operator\">=</span> <span class=\"token number\">3600</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数</span>\n NSInteger hoursBetweenDates <span class=\"token operator\">=</span> distanceBetweenDates <span class=\"token operator\">/</span> secondsInAnHour<span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、让UILabel在指定的地方换行\"><a href=\"#1、让UILabel在指定的地方换行\" class=\"headerlink\" title=\"1、让UILabel在指定的地方换行\"></a>1、让UILabel在指定的地方换行</h4><pre><code class=\"objectivec\">// 换行符为\\n,在需要换行的地方加上这个符号即可，如 \nlabel.numberOfLines = 0;\nlabel.text = @&quot;此处\\n换行&quot;;\n</code></pre>\n<h4 id=\"2、摇一摇功能\"><a href=\"#2、摇一摇功能\" class=\"headerlink\" title=\"2、摇一摇功能\"></a>2、摇一摇功能</h4><pre><code class=\"objectivec\">1、打开摇一摇功能\n    [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;\n2、让需要摇动的控制器成为第一响应者\n[self becomeFirstResponder];\n3、实现以下方法\n\n// 开始摇动\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 取消摇动\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event\n// 摇动结束\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event\n</code></pre>\n<h4 id=\"3、获取图片大小\"><a href=\"#3、获取图片大小\" class=\"headerlink\" title=\"3、获取图片大小\"></a>3、获取图片大小</h4><pre><code class=\"objectivec\">CGFloat imageWidth = image.size.width;\nCGFloat imageHeight = imageWidth * image.scale;\n</code></pre>\n<h4 id=\"4、获取view的坐标在整个window上的位置\"><a href=\"#4、获取view的坐标在整个window上的位置\" class=\"headerlink\" title=\"4、获取view的坐标在整个window上的位置\"></a>4、获取view的坐标在整个window上的位置</h4><pre><code class=\"objectivec\">// v上的(0, 0)点在toView上的位置\nCGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject];\n或者\nCGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject];\n</code></pre>\n<h4 id=\"5、提交App-Store审核程序限制\"><a href=\"#5、提交App-Store审核程序限制\" class=\"headerlink\" title=\"5、提交App Store审核程序限制\"></a>5、提交App Store审核程序限制</h4><pre><code class=\"objectivec\">您的应用程序的未压缩大小必须小于4GB。每个Mach-O可执行文件（例如app_name.app/app_name）不能超过这些限制：\n对于MinimumOSVersion小于7.0的应用程序：TEXT二进制文件中所有部分的总数最多为80 MB 。\n对于MinimumOSVersion7.x到8.x的应用程序：TEXT对于二进制文件中每个体系结构片段的每个片段，最大为60 MB 。\n对于MinimumOSVersion9.0或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为500 MB 。参阅：iTunes Connect开发者指南\n</code></pre>\n<h4 id=\"6、修改UISegmentedControl的字体大小\"><a href=\"#6、修改UISegmentedControl的字体大小\" class=\"headerlink\" title=\"6、修改UISegmentedControl的字体大小\"></a>6、修改UISegmentedControl的字体大小</h4><pre><code class=\"objectivec\">[segment setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:15.0f]} forState:UIControlStateNormal];\n</code></pre>\n<h4 id=\"7、在非ViewController的地方弹出UIAlertController对话框\"><a href=\"#7、在非ViewController的地方弹出UIAlertController对话框\" class=\"headerlink\" title=\"7、在非ViewController的地方弹出UIAlertController对话框\"></a>7、在非ViewController的地方弹出UIAlertController对话框</h4><pre><code class=\"objectivec\">//  最好抽成一个分类\nUIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;Title&quot; message:@&quot;message&quot; preferredStyle:UIAlertControllerStyleAlert];\n//...\nid rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;\nif([rootViewController isKindOfClass:[UINavigationController class]])\n{\n    rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject;\n}\nif([rootViewController isKindOfClass:[UITabBarController class]])\n{\n    rootViewController = ((UITabBarController *)rootViewController).selectedViewController;\n}\n[rootViewController presentViewController:alertController animated:YES completion:nil\n</code></pre>\n<h4 id=\"8、获取一个view所属的控制器\"><a href=\"#8、获取一个view所属的控制器\" class=\"headerlink\" title=\"8、获取一个view所属的控制器\"></a>8、获取一个view所属的控制器</h4><pre><code class=\"objectivec\">// view分类方法\n- (UIViewController *)belongViewController {\n    for (UIView *next = [self superview]; next; next = next.superview) {\n        UIResponder* nextResponder = [next nextResponder];\n        if ([nextResponder isKindOfClass:[UIViewController class]]) {\n            return (UIViewController *)nextResponder;\n        }\n    }\n    return nil;\n}\n</code></pre>\n<h4 id=\"9、UIImage和base64互转\"><a href=\"#9、UIImage和base64互转\" class=\"headerlink\" title=\"9、UIImage和base64互转\"></a>9、UIImage和base64互转</h4><pre><code class=\"objectivec\">// view分类方法\n- (NSString *)encodeToBase64String:(UIImage *)image {\n return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];\n}\n\n- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData {\n  NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];\n  return [UIImage imageWithData:data];\n}\n</code></pre>\n<h4 id=\"10、UIWebView设置背景透明\"><a href=\"#10、UIWebView设置背景透明\" class=\"headerlink\" title=\"10、UIWebView设置背景透明\"></a>10、UIWebView设置背景透明</h4><pre><code class=\"objectivec\">[webView setBackgroundColor:[UIColor clearColor]];\n[webView setOpaque:NO];\n</code></pre>\n<h4 id=\"11、判断NSDate是不是今天\"><a href=\"#11、判断NSDate是不是今天\" class=\"headerlink\" title=\"11、判断NSDate是不是今天\"></a>11、判断NSDate是不是今天</h4><pre><code class=\"objectivec\">NSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate];\nNSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]];\nif([today day] == [otherDay day] &amp;&amp;\n   [today month] == [otherDay month] &amp;&amp;\n   [today year] == [otherDay year] &amp;&amp;\n   [today era] == [otherDay era]) {\n    // 是今天\n}\n</code></pre>\n<h4 id=\"12、设置tableView分割线颜色\"><a href=\"#12、设置tableView分割线颜色\" class=\"headerlink\" title=\"12、设置tableView分割线颜色\"></a>12、设置tableView分割线颜色</h4><pre><code class=\"objectivec\">[self.tableView setSeparatorColor:[UIColor myColor]];\n</code></pre>\n<h4 id=\"13、设置屏幕方向\"><a href=\"#13、设置屏幕方向\" class=\"headerlink\" title=\"13、设置屏幕方向\"></a>13、设置屏幕方向</h4><pre><code class=\"objectivec\"> NSNumber *orientationTarget = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft];\n[[UIDevice currentDevice] setValue:orientationTarget forKey:@&quot;orientation&quot;];\n[UIViewController attemptRotationToDeviceOrientation];\n</code></pre>\n<h4 id=\"14、比较两个颜色是否相等\"><a href=\"#14、比较两个颜色是否相等\" class=\"headerlink\" title=\"14、比较两个颜色是否相等\"></a>14、比较两个颜色是否相等</h4><pre><code class=\"objectivec\">- (BOOL)isEqualToColor:(UIColor *)otherColor {\n    CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();\n\n    UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {\n        if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {\n            const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);\n            CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};\n            CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );\n\n            UIColor *color = [UIColor colorWithCGColor:colorRef];\n            CGColorRelease(colorRef);\n            return color;            \n        } else\n            return color;\n    };\n\n    UIColor *selfColor = convertColorToRGBSpace(self);\n    otherColor = convertColorToRGBSpace(otherColor);\n    CGColorSpaceRelease(colorSpaceRGB);\n\n    return [selfColor isEqual:otherColor];\n}\n</code></pre>\n<h4 id=\"15、tableViewCell分割线顶到头\"><a href=\"#15、tableViewCell分割线顶到头\" class=\"headerlink\" title=\"15、tableViewCell分割线顶到头\"></a>15、tableViewCell分割线顶到头</h4><pre><code class=\"objectivec\">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {\n    [cell setSeparatorInset:UIEdgeInsetsZero];\n    [cell setLayoutMargins:UIEdgeInsetsZero];\n    cell.preservesSuperviewLayoutMargins = NO;\n}\n\n- (void)viewDidLayoutSubviews {\n    [self.tableView setSeparatorInset:UIEdgeInsetsZero];\n    [self.tableView setLayoutMargins:UIEdgeInsetsZero];\n}\n</code></pre>\n<h4 id=\"16、不让控制器的view随着控制器的xib拉伸或压缩\"><a href=\"#16、不让控制器的view随着控制器的xib拉伸或压缩\" class=\"headerlink\" title=\"16、不让控制器的view随着控制器的xib拉伸或压缩\"></a>16、不让控制器的view随着控制器的xib拉伸或压缩</h4><pre><code class=\"objectivec\">self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n</code></pre>\n<h4 id=\"17、cocoaPods报错-Unable-to-add-a-source-with-url-https-github-com-CocoaPods-Specs-git-named-master-1-You-can-try-adding-it-manually-in-cocoapods-repos-or-via-pod-repo-add\"><a href=\"#17、cocoaPods报错-Unable-to-add-a-source-with-url-https-github-com-CocoaPods-Specs-git-named-master-1-You-can-try-adding-it-manually-in-cocoapods-repos-or-via-pod-repo-add\" class=\"headerlink\" title=\"17、cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.\"></a>17、<code>cocoaPods报错 : [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.You can try adding it manually in ~/.cocoapods/repos or via pod repo add.</code></h4><blockquote>\n<p>解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了<br>在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可</p>\n</blockquote>\n<h4 id=\"18、安装cocoapods的时候出现-ERROR-While-executing-gem-…-Errno-EPERM\"><a href=\"#18、安装cocoapods的时候出现-ERROR-While-executing-gem-…-Errno-EPERM\" class=\"headerlink\" title=\"18、安装cocoapods的时候出现 ERROR: While executing gem … (Errno::EPERM)\"></a>18、安装cocoapods的时候出现 ERROR: While executing gem … (Errno::EPERM)</h4><pre><code>Operation not permitted - /usr/bin/pod\n</code></pre><h4 id=\"19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\"><a href=\"#19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\" class=\"headerlink\" title=\"19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花\"></a>19、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花</h4><pre><code class=\"objectivec\">[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\n</code></pre>\n<h4 id=\"20、检查一个rect是否包含一个point\"><a href=\"#20、检查一个rect是否包含一个point\" class=\"headerlink\" title=\"20、检查一个rect是否包含一个point\"></a>20、检查一个rect是否包含一个point</h4><pre><code class=\"objectivec\">// point是否在rect内\nBOOL isContains = CGRectContainsPoint(rect, point);\n</code></pre>\n<h4 id=\"21、在指定的宽度下，让UILabel自动设置最佳font\"><a href=\"#21、在指定的宽度下，让UILabel自动设置最佳font\" class=\"headerlink\" title=\"21、在指定的宽度下，让UILabel自动设置最佳font\"></a>21、在指定的宽度下，让UILabel自动设置最佳font</h4><pre><code class=\"objectivec\">label.adjustsFontSizeToFitWidth = YES;\n</code></pre>\n<h4 id=\"22、将一个image保存在相册中\"><a href=\"#22、将一个image保存在相册中\" class=\"headerlink\" title=\"22、将一个image保存在相册中\"></a>22、将一个image保存在相册中</h4><pre><code class=\"objectivec\">UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);\n\n或者\n#import &lt;Photos/Photos.h&gt;\n[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{\n        PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];\n        changeRequest.creationDate          = [NSDate date];\n    } completionHandler:^(BOOL success, NSError *error) {\n        if (success) {\n            NSLog(@&quot;successfully saved&quot;);\n        }\n        else {\n            NSLog(@&quot;error saving to photos: %@&quot;, error);\n        }\n    }];\n</code></pre>\n<h4 id=\"23、修改cell-imageView的大小\"><a href=\"#23、修改cell-imageView的大小\" class=\"headerlink\" title=\"23、修改cell.imageView的大小\"></a>23、修改cell.imageView的大小</h4><pre><code class=\"objectivec\">UIImage *icon = [UIImage imageNamed:@&quot;&quot;];\nCGSize itemSize = CGSizeMake(30, 30);\nUIGraphicsBeginImageContextWithOptions(itemSize, NO ,0.0);\nCGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);\n[icon drawInRect:imageRect];\ncell.imageView.image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\n</code></pre>\n<h4 id=\"24、为一个view添加虚线边框\"><a href=\"#24、为一个view添加虚线边框\" class=\"headerlink\" title=\"24、为一个view添加虚线边框\"></a>24、为一个view添加虚线边框</h4><pre><code class=\"objectivec\"> CAShapeLayer *border = [CAShapeLayer layer];\n    border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;\n    border.fillColor = nil;\n    border.lineDashPattern = @[@4, @2];\n    border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;\n    border.frame = view.bounds;\n    [view.layer addSublayer:border];\n</code></pre>\n<h4 id=\"25、UITextView中打开或禁用复制，剪切，选择，全选等功能\"><a href=\"#25、UITextView中打开或禁用复制，剪切，选择，全选等功能\" class=\"headerlink\" title=\"25、UITextView中打开或禁用复制，剪切，选择，全选等功能\"></a>25、UITextView中打开或禁用复制，剪切，选择，全选等功能</h4><pre><code class=\"objectivec\">// 继承UITextView重写这个方法\n- (BOOL)canPerformAction:(SEL)action withSender:(id)sender\n{\n// 返回NO为禁用，YES为开启\n    // 粘贴\n    if (action == @selector(paste:)) return NO;\n    // 剪切\n    if (action == @selector(cut:)) return NO;\n    // 复制\n    if (action == @selector(copy:)) return NO;\n    // 选择\n    if (action == @selector(select:)) return NO;\n    // 选中全部\n    if (action == @selector(selectAll:)) return NO;\n    // 删除\n    if (action == @selector(delete:)) return NO;\n    // 分享\n    if (action == @selector(share)) return NO;\n    return [super canPerformAction:action withSender:sender];\n}\n</code></pre>\n<h4 id=\"26、设置UILabel行间距\"><a href=\"#26、设置UILabel行间距\" class=\"headerlink\" title=\"26、设置UILabel行间距\"></a>26、设置UILabel行间距</h4><pre><code class=\"objectivec\">NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];\n    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];\n    [style setLineSpacing:20];\n    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];\n    label.attributedText = attrString;\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-736756a6216a6753.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h4 id=\"27、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题\"><a href=\"#27、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题\" class=\"headerlink\" title=\"27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题\"></a>27、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h4><pre><code class=\"objectivec\">// 方法一、\n// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典\nNSArray * array = \n    [NSArray arrayWithObjects: @&quot;first&quot;, @&quot;second&quot;, nil];\n[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];\n\n// 方法二、\n// 使用NSInvocation\nSEL aSelector = NSSelectorFromString(@&quot;doSoming:argument2:&quot;);\n    NSInteger argument1 = 10;\n    NSString *argument2 = @&quot;argument2&quot;;\n    if([self respondsToSelector:aSelector]) {\n        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];\n        [inv setSelector:aSelector];\n        [inv setTarget:self];\n        [inv setArgument:&amp;(argument1) atIndex:2];\n        [inv setArgument:&amp;(argument2) atIndex:3];\n        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];\n    }\n</code></pre>\n<h4 id=\"28、UILabel显示不同颜色字体\"><a href=\"#28、UILabel显示不同颜色字体\" class=\"headerlink\" title=\"28、UILabel显示不同颜色字体\"></a>28、UILabel显示不同颜色字体</h4><pre><code class=\"objectivec\">NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];\n[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];\nlabel.attributedText = string;\n</code></pre>\n<h4 id=\"29、比较两个CGRect-CGSize-CGPoint是否相等\"><a href=\"#29、比较两个CGRect-CGSize-CGPoint是否相等\" class=\"headerlink\" title=\"29、比较两个CGRect/CGSize/CGPoint是否相等\"></a>29、比较两个CGRect/CGSize/CGPoint是否相等</h4><pre><code class=\"objectivec\">if (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等\n        // do some\n    }\n    if (CGPointEqualToPoint(point1, point2)) { // 两个点相等\n        // do some\n    }\n    if (CGSizeEqualToSize(size1, size2)) { // 两个size相等\n        // do some\n    }\n</code></pre>\n<h4 id=\"30、比较两个NSDate相差多少小时\"><a href=\"#30、比较两个NSDate相差多少小时\" class=\"headerlink\" title=\"30、比较两个NSDate相差多少小时\"></a>30、比较两个NSDate相差多少小时</h4><pre><code class=\"objectivec\"> NSDate* date1 = someDate;\n NSDate* date2 = someOtherDate;\n NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2];\n double secondsInAnHour = 3600;\n// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数\n NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;\n</code></pre>\n"},{"title":"iOS小经验（六）","date":"2016-03-17T01:53:06.000Z","_content":"\n\n#### 1、每个cell之间增加间距\n```objectivec\n// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView\n{\n    return yourArry.count;\n}\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    return 1;\n}\n-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section\n{\n    return cellSpacingHeight;\n}\n\n// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。\n\n// 方法三，自定义cell，重写setFrame：方法\n- (void)setFrame:(CGRect)frame\n{\n    frame.size.height -= 20;\n    [super setFrame:frame];\n}\n```\n\n#### 7、播放一张张连续的图片\n```objectivec\n// 加入现在有三张图片分别为animate_1、animate_2、animate_3\n// 方法一\n    imageView.animationImages = @[[UIImage imageNamed:@\"animate_1\"], [UIImage imageNamed:@\"animate_2\"], [UIImage imageNamed:@\"animate_3\"]];\nimageView.animationDuration = 1.0;\n// 方法二\n    imageView.image = [UIImage animatedImageNamed:@\"animate_\" duration:1.0];\n// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024\n```\n\n#### 3、加载gif图片\n\n>推荐使用这个框架 [FLAnimatedImage](https://github.com/Flipboard/FLAnimatedImage)\n\n#### 4、防止离屏渲染为image添加圆角\n```objectivec\n// image分类\n- (UIImage *)circleImage\n{\n// NO代表透明\nUIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n// 获得上下文\nCGContextRef ctx = UIGraphicsGetCurrentContext();\n// 添加一个圆\nCGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n// 方形变圆形\nCGContextAddEllipseInRect(ctx, rect);\n// 裁剪\nCGContextClip(ctx);\n// 将图片画上去\n[self drawInRect:rect];\nUIImage *image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\nreturn image;\n}\n```\n\n#### 5、查看系统所有字体\n```objectivec\n// 打印字体\nfor (id familyName in [UIFont familyNames]) {\n    NSLog(@\"%@\", familyName);\n    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@\"  %@\", fontName);\n}\n// 也可以进入这个网址查看 http://iosfonts.com/\n\n```\n\n#### 6、获取随机数\n```objectivec\nNSInteger i = arc4random();\n```\n\n#### 7、获取随机数小数(0-1之间)\n```objectivec\n#define ARC4RANDOM_MAX      0x100000000\ndouble val = ((double)arc4random() / ARC4RANDOM_MAX);\n```\n\n#### 8、AVPlayer视频播放完成的通知监听\n```objectivec\n[[NSNotificationCenter defaultCenter] \n      addObserver:self\n      selector:@selector(videoPlayEnd)\n      name:AVPlayerItemDidPlayToEndTimeNotification \n      object:nil];\n\n```\n\n#### 9、判断两个rect是否有交叉\n```objectivec\n if (CGRectIntersectsRect(rect1, rect2)) {\n}\n```\n\n#### 10、判断一个字符串是否为数字\n```objectivec\nNSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];\n    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)\n    {\n      // 是数字\n    } else\n    {\n      // 不是数字\n    }\n\n```\n#### 11、将一个view保存为pdf格式\n```objectivec\n- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename\n{\n    NSMutableData *pdfData = [NSMutableData data];\n    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);\n    UIGraphicsBeginPDFPage();\n    CGContextRef pdfContext = UIGraphicsGetCurrentContext();\n    [aView.layer renderInContext:pdfContext];\n    UIGraphicsEndPDFContext();\n\n    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);\n    NSString* documentDirectory = [documentDirectories objectAtIndex:0];\n    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];\n    [pdfData writeToFile:documentDirectoryFilename atomically:YES];\n    NSLog(@\"documentDirectoryFileName: %@\",documentDirectoryFilename);\n}\n\n```\n\n#### 12、让一个view在父视图中心\n```objectivec\nchild.center = [parent convertPoint:parent.center fromView:parent.superview];\n```\n\n#### 13、获取当前导航控制器下前一个控制器\n```objectivec\n- (UIViewController *)backViewController\n{\n    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];\n\n    if ( myIndex != 0 && myIndex != NSNotFound ) {\n        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];\n    } else {\n        return nil;\n    }\n}\n```\n\n#### 14、保存UIImage到本地\n```objectivec\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@\"Image.png\"];\n[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];\n```\n\n#### 15、键盘上方增加工具栏\n```objectivec\nUIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];\n[keyboardDoneButtonView sizeToFit];\nUIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@\"Done\"\n                                                               style:UIBarButtonItemStyleBordered target:self\n                                                              action:@selector(doneClicked:)];\n[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];\ntxtField.inputAccessoryView = keyboardDoneButtonView;\n\n```\n\n#### 16、copy一个view\n>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃\n但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下\n\n```objectivec\nid copyOfView = \n[NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];\n```\n\n#### 17、在image上绘制文字并生成新的image\n```objectivec\nUIFont *font = [UIFont boldSystemFontOfSize:12];\n    UIGraphicsBeginImageContext(image.size);\n    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];\n    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);\n    [[UIColor whiteColor] set];\n    [text drawInRect:CGRectIntegral(rect) withFont:font]; \n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n```\n\n#### 18、判断一个view是否为另一个view的子视图\n```objectivec\n// 如果myView是self.view本身，也会返回yes\nBOOL isSubView = [myView isDescendantOfView:self.view];\n```\n\n#### 19、判断一个字符串是否包含另一个字符串\n```objectivec\n// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二\nif ([str containsString:otherStr]) NSLog(@\"包含\");\n\n// 方法二\nNSRange range = [str rangeOfString:otherStr];\nif (range.location != NSNotFound) NSLog(@\"包含\");\n```\n\n#### 20、UICollectionView自动滚动到某行\n```objectivec\n// 重写viewDidLayoutSubviews方法\n-(void)viewDidLayoutSubviews {\n   [super viewDidLayoutSubviews];\n   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];\n}\n```\n\n#### 21、修改系统UIAlertController\n```objectivec\n// 但是据说这种方法会被App Store拒绝(慎用！)\nUIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@\"\" message:@\"\" preferredStyle:UIAlertControllerStyleActionSheet];\n    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@\"我是一个大文本\"];\n    [hogan addAttribute:NSFontAttributeName\n                  value:[UIFont systemFontOfSize:30]\n                  range:NSMakeRange(4, 1)];\n    [hogan addAttribute:NSForegroundColorAttributeName\n                  value:[UIColor redColor]\n                  range:NSMakeRange(4, 1)];\n    [alertVC setValue:hogan forKey:@\"attributedTitle\"];\n\n    UIAlertAction *button = [UIAlertAction actionWithTitle:@\"Label text\" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];\n    UIImage *accessoryImage = [UIImage imageNamed:@\"1\"];\n    [button setValue:accessoryImage forKey:@\"image\"];\n    [alertVC addAction:button];\n    [self presentViewController:alertVC animated:YES completion:nil];\n```\n\n#### 22、判断某一行的cell是否已经显示\n```objectivec\nCGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];\nBOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);\n```\n\n#### 23、让导航控制器pop回指定的控制器\n```objectivec\nNSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];\nfor (UIViewController *aViewController in allViewControllers) {\n    if ([aViewController isKindOfClass:[RequiredViewController class]]) {\n        [self.navigationController popToViewController:aViewController animated:NO];\n    }\n}\n\n```\n\n#### 24、动画修改label上的文字\n```objectivec\n// 方法一\nCATransition *animation = [CATransition animation];\n    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    animation.type = kCATransitionFade;\n    animation.duration = 0.75;\n    [self.label.layer addAnimation:animation forKey:@\"kCATransitionFade\"];\n    self.label.text = @\"New\";\n\n// 方法二\n[UIView transitionWithView:self.label\n                      duration:0.25f\n                       options:UIViewAnimationOptionTransitionCrossDissolve\n                    animations:^{\n\n                        self.label.text = @\"Well done!\";\n\n                    } completion:nil];\n\n// 方法三\n[UIView animateWithDuration:1.0\n                     animations:^{\n                         self.label.alpha = 0.0f;\n                         self.label.text = @\"newText\";\n                         self.label.alpha = 1.0f;\n                     }];\n\n```\n\n#### 25、判断字典中是否包含某个key值\n```objectivec\nif ([dic objectForKey:@\"yourKey\"]) {\n    NSLog(@\"有这个值\");\n} else {\n    NSLog(@\"没有这个值\");\n}\n```\n\n#### 26、获取屏幕方向\n```objectivec\nUIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;\n\nif(orientation == 0) //Default orientation \n    //默认\nelse if(orientation == UIInterfaceOrientationPortrait)\n    //竖屏\nelse if(orientation == UIInterfaceOrientationLandscapeLeft)\n    // 左横屏\nelse if(orientation == UIInterfaceOrientationLandscapeRight)\n    //右横屏\n```\n\n#### 27、设置UIImage的透明度\n```objectivec\n// 方法一、添加UIImage分类\n- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);\n\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);\n\n    CGContextScaleCTM(ctx, 1, -1);\n    CGContextTranslateCTM(ctx, 0, -area.size.height);\n\n    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);\n\n    CGContextSetAlpha(ctx, alpha);\n\n    CGContextDrawImage(ctx, area, self.CGImage);\n\n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n\n    UIGraphicsEndImageContext();\n\n    return newImage;\n}\n\n// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度\nUIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@\"yourImage\"]];\nimageView.alpha = 0.5;\n```\n\n#### 28、Attempt to mutate immutable object with insertString:atIndex:\n\n>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用\n\n#### 29、UIWebView添加单击手势不响应\n```objectivec\nUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];\n        tap.delegate = self;\n        [_webView addGestureRecognizer:tap];\n\n// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{\n    return YES;\n}\n```\n\n#### 30、获取手机RAM容量\n```objectivec\n// 需要导入#import <mach/mach.h>\nmach_port_t host_port;\n    mach_msg_type_number_t host_size;\n    vm_size_t pagesize;\n\n    host_port = mach_host_self();\n    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);\n    host_page_size(host_port, &pagesize);\n\n    vm_statistics_data_t vm_stat;\n\n    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&vm_stat, &host_size) != KERN_SUCCESS) {\n        NSLog(@\"Failed to fetch vm statistics\");\n    }\n\n    /* Stats in bytes */\n    natural_t mem_used = (vm_stat.active_count +\n                          vm_stat.inactive_count +\n                          vm_stat.wire_count) * pagesize;\n    natural_t mem_free = vm_stat.free_count * pagesize;\n    natural_t mem_total = mem_used + mem_free;\n    NSLog(@\"已用: %u 可用: %u 总共: %u\", mem_used, mem_free, mem_total);\n```\n\n","source":"_posts/iOS小经验（六）.md","raw":"---\ntitle: iOS小经验（六）\ndate: 2016-03-17 09:53:06\ncategories: \n\t- iOS小经验\n---\n\n\n#### 1、每个cell之间增加间距\n```objectivec\n// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView\n{\n    return yourArry.count;\n}\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    return 1;\n}\n-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section\n{\n    return cellSpacingHeight;\n}\n\n// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。\n\n// 方法三，自定义cell，重写setFrame：方法\n- (void)setFrame:(CGRect)frame\n{\n    frame.size.height -= 20;\n    [super setFrame:frame];\n}\n```\n\n#### 7、播放一张张连续的图片\n```objectivec\n// 加入现在有三张图片分别为animate_1、animate_2、animate_3\n// 方法一\n    imageView.animationImages = @[[UIImage imageNamed:@\"animate_1\"], [UIImage imageNamed:@\"animate_2\"], [UIImage imageNamed:@\"animate_3\"]];\nimageView.animationDuration = 1.0;\n// 方法二\n    imageView.image = [UIImage animatedImageNamed:@\"animate_\" duration:1.0];\n// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024\n```\n\n#### 3、加载gif图片\n\n>推荐使用这个框架 [FLAnimatedImage](https://github.com/Flipboard/FLAnimatedImage)\n\n#### 4、防止离屏渲染为image添加圆角\n```objectivec\n// image分类\n- (UIImage *)circleImage\n{\n// NO代表透明\nUIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n// 获得上下文\nCGContextRef ctx = UIGraphicsGetCurrentContext();\n// 添加一个圆\nCGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n// 方形变圆形\nCGContextAddEllipseInRect(ctx, rect);\n// 裁剪\nCGContextClip(ctx);\n// 将图片画上去\n[self drawInRect:rect];\nUIImage *image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\nreturn image;\n}\n```\n\n#### 5、查看系统所有字体\n```objectivec\n// 打印字体\nfor (id familyName in [UIFont familyNames]) {\n    NSLog(@\"%@\", familyName);\n    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@\"  %@\", fontName);\n}\n// 也可以进入这个网址查看 http://iosfonts.com/\n\n```\n\n#### 6、获取随机数\n```objectivec\nNSInteger i = arc4random();\n```\n\n#### 7、获取随机数小数(0-1之间)\n```objectivec\n#define ARC4RANDOM_MAX      0x100000000\ndouble val = ((double)arc4random() / ARC4RANDOM_MAX);\n```\n\n#### 8、AVPlayer视频播放完成的通知监听\n```objectivec\n[[NSNotificationCenter defaultCenter] \n      addObserver:self\n      selector:@selector(videoPlayEnd)\n      name:AVPlayerItemDidPlayToEndTimeNotification \n      object:nil];\n\n```\n\n#### 9、判断两个rect是否有交叉\n```objectivec\n if (CGRectIntersectsRect(rect1, rect2)) {\n}\n```\n\n#### 10、判断一个字符串是否为数字\n```objectivec\nNSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];\n    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)\n    {\n      // 是数字\n    } else\n    {\n      // 不是数字\n    }\n\n```\n#### 11、将一个view保存为pdf格式\n```objectivec\n- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename\n{\n    NSMutableData *pdfData = [NSMutableData data];\n    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);\n    UIGraphicsBeginPDFPage();\n    CGContextRef pdfContext = UIGraphicsGetCurrentContext();\n    [aView.layer renderInContext:pdfContext];\n    UIGraphicsEndPDFContext();\n\n    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);\n    NSString* documentDirectory = [documentDirectories objectAtIndex:0];\n    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];\n    [pdfData writeToFile:documentDirectoryFilename atomically:YES];\n    NSLog(@\"documentDirectoryFileName: %@\",documentDirectoryFilename);\n}\n\n```\n\n#### 12、让一个view在父视图中心\n```objectivec\nchild.center = [parent convertPoint:parent.center fromView:parent.superview];\n```\n\n#### 13、获取当前导航控制器下前一个控制器\n```objectivec\n- (UIViewController *)backViewController\n{\n    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];\n\n    if ( myIndex != 0 && myIndex != NSNotFound ) {\n        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];\n    } else {\n        return nil;\n    }\n}\n```\n\n#### 14、保存UIImage到本地\n```objectivec\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@\"Image.png\"];\n[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];\n```\n\n#### 15、键盘上方增加工具栏\n```objectivec\nUIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];\n[keyboardDoneButtonView sizeToFit];\nUIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@\"Done\"\n                                                               style:UIBarButtonItemStyleBordered target:self\n                                                              action:@selector(doneClicked:)];\n[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];\ntxtField.inputAccessoryView = keyboardDoneButtonView;\n\n```\n\n#### 16、copy一个view\n>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃\n但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下\n\n```objectivec\nid copyOfView = \n[NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];\n```\n\n#### 17、在image上绘制文字并生成新的image\n```objectivec\nUIFont *font = [UIFont boldSystemFontOfSize:12];\n    UIGraphicsBeginImageContext(image.size);\n    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];\n    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);\n    [[UIColor whiteColor] set];\n    [text drawInRect:CGRectIntegral(rect) withFont:font]; \n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n```\n\n#### 18、判断一个view是否为另一个view的子视图\n```objectivec\n// 如果myView是self.view本身，也会返回yes\nBOOL isSubView = [myView isDescendantOfView:self.view];\n```\n\n#### 19、判断一个字符串是否包含另一个字符串\n```objectivec\n// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二\nif ([str containsString:otherStr]) NSLog(@\"包含\");\n\n// 方法二\nNSRange range = [str rangeOfString:otherStr];\nif (range.location != NSNotFound) NSLog(@\"包含\");\n```\n\n#### 20、UICollectionView自动滚动到某行\n```objectivec\n// 重写viewDidLayoutSubviews方法\n-(void)viewDidLayoutSubviews {\n   [super viewDidLayoutSubviews];\n   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];\n}\n```\n\n#### 21、修改系统UIAlertController\n```objectivec\n// 但是据说这种方法会被App Store拒绝(慎用！)\nUIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@\"\" message:@\"\" preferredStyle:UIAlertControllerStyleActionSheet];\n    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@\"我是一个大文本\"];\n    [hogan addAttribute:NSFontAttributeName\n                  value:[UIFont systemFontOfSize:30]\n                  range:NSMakeRange(4, 1)];\n    [hogan addAttribute:NSForegroundColorAttributeName\n                  value:[UIColor redColor]\n                  range:NSMakeRange(4, 1)];\n    [alertVC setValue:hogan forKey:@\"attributedTitle\"];\n\n    UIAlertAction *button = [UIAlertAction actionWithTitle:@\"Label text\" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];\n    UIImage *accessoryImage = [UIImage imageNamed:@\"1\"];\n    [button setValue:accessoryImage forKey:@\"image\"];\n    [alertVC addAction:button];\n    [self presentViewController:alertVC animated:YES completion:nil];\n```\n\n#### 22、判断某一行的cell是否已经显示\n```objectivec\nCGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];\nBOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);\n```\n\n#### 23、让导航控制器pop回指定的控制器\n```objectivec\nNSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];\nfor (UIViewController *aViewController in allViewControllers) {\n    if ([aViewController isKindOfClass:[RequiredViewController class]]) {\n        [self.navigationController popToViewController:aViewController animated:NO];\n    }\n}\n\n```\n\n#### 24、动画修改label上的文字\n```objectivec\n// 方法一\nCATransition *animation = [CATransition animation];\n    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    animation.type = kCATransitionFade;\n    animation.duration = 0.75;\n    [self.label.layer addAnimation:animation forKey:@\"kCATransitionFade\"];\n    self.label.text = @\"New\";\n\n// 方法二\n[UIView transitionWithView:self.label\n                      duration:0.25f\n                       options:UIViewAnimationOptionTransitionCrossDissolve\n                    animations:^{\n\n                        self.label.text = @\"Well done!\";\n\n                    } completion:nil];\n\n// 方法三\n[UIView animateWithDuration:1.0\n                     animations:^{\n                         self.label.alpha = 0.0f;\n                         self.label.text = @\"newText\";\n                         self.label.alpha = 1.0f;\n                     }];\n\n```\n\n#### 25、判断字典中是否包含某个key值\n```objectivec\nif ([dic objectForKey:@\"yourKey\"]) {\n    NSLog(@\"有这个值\");\n} else {\n    NSLog(@\"没有这个值\");\n}\n```\n\n#### 26、获取屏幕方向\n```objectivec\nUIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;\n\nif(orientation == 0) //Default orientation \n    //默认\nelse if(orientation == UIInterfaceOrientationPortrait)\n    //竖屏\nelse if(orientation == UIInterfaceOrientationLandscapeLeft)\n    // 左横屏\nelse if(orientation == UIInterfaceOrientationLandscapeRight)\n    //右横屏\n```\n\n#### 27、设置UIImage的透明度\n```objectivec\n// 方法一、添加UIImage分类\n- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);\n\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);\n\n    CGContextScaleCTM(ctx, 1, -1);\n    CGContextTranslateCTM(ctx, 0, -area.size.height);\n\n    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);\n\n    CGContextSetAlpha(ctx, alpha);\n\n    CGContextDrawImage(ctx, area, self.CGImage);\n\n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n\n    UIGraphicsEndImageContext();\n\n    return newImage;\n}\n\n// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度\nUIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@\"yourImage\"]];\nimageView.alpha = 0.5;\n```\n\n#### 28、Attempt to mutate immutable object with insertString:atIndex:\n\n>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用\n\n#### 29、UIWebView添加单击手势不响应\n```objectivec\nUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];\n        tap.delegate = self;\n        [_webView addGestureRecognizer:tap];\n\n// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{\n    return YES;\n}\n```\n\n#### 30、获取手机RAM容量\n```objectivec\n// 需要导入#import <mach/mach.h>\nmach_port_t host_port;\n    mach_msg_type_number_t host_size;\n    vm_size_t pagesize;\n\n    host_port = mach_host_self();\n    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);\n    host_page_size(host_port, &pagesize);\n\n    vm_statistics_data_t vm_stat;\n\n    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&vm_stat, &host_size) != KERN_SUCCESS) {\n        NSLog(@\"Failed to fetch vm statistics\");\n    }\n\n    /* Stats in bytes */\n    natural_t mem_used = (vm_stat.active_count +\n                          vm_stat.inactive_count +\n                          vm_stat.wire_count) * pagesize;\n    natural_t mem_free = vm_stat.free_count * pagesize;\n    natural_t mem_total = mem_used + mem_free;\n    NSLog(@\"已用: %u 可用: %u 总共: %u\", mem_used, mem_free, mem_total);\n```\n\n","slug":"iOS小经验（六）","published":1,"updated":"2017-07-16T14:50:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tvx000yznuziznhx1em","content":"<h4 id=\"1、每个cell之间增加间距\"><a href=\"#1、每个cell之间增加间距\" class=\"headerlink\" title=\"1、每个cell之间增加间距\"></a>1、每个cell之间增加间距</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>numberOfSectionsInTableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> yourArry<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>tableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView numberOfRowsInSection<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>section\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>tableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView heightForHeaderInSection<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>section\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> cellSpacingHeight<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法三，自定义cell，重写setFrame：方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setFrame<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>frame\n<span class=\"token punctuation\">{</span>\n    frame<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> setFrame<span class=\"token punctuation\">:</span>frame<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"7、播放一张张连续的图片\"><a href=\"#7、播放一张张连续的图片\" class=\"headerlink\" title=\"7、播放一张张连续的图片\"></a>7、播放一张张连续的图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 加入现在有三张图片分别为animate_1、animate_2、animate_3</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法一</span>\n    imageView<span class=\"token punctuation\">.</span>animationImages <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"animate_1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"animate_2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"animate_3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nimageView<span class=\"token punctuation\">.</span>animationDuration <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法二</span>\n    imageView<span class=\"token punctuation\">.</span>image <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage animatedImageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"animate_\"</span> duration<span class=\"token punctuation\">:</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024</span>\n</code></pre>\n<h4 id=\"3、加载gif图片\"><a href=\"#3、加载gif图片\" class=\"headerlink\" title=\"3、加载gif图片\"></a>3、加载gif图片</h4><blockquote>\n<p>推荐使用这个框架 <a href=\"https://github.com/Flipboard/FLAnimatedImage\" target=\"_blank\" rel=\"external\">FLAnimatedImage</a></p>\n</blockquote>\n<h4 id=\"4、防止离屏渲染为image添加圆角\"><a href=\"#4、防止离屏渲染为image添加圆角\" class=\"headerlink\" title=\"4、防止离屏渲染为image添加圆角\"></a>4、防止离屏渲染为image添加圆角</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// image分类</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>circleImage\n<span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// NO代表透明</span>\n<span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 获得上下文</span>\nCGContextRef ctx <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 添加一个圆</span>\nCGRect rect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方形变圆形</span>\n<span class=\"token function\">CGContextAddEllipseInRect</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 裁剪</span>\n<span class=\"token function\">CGContextClip</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 将图片画上去</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> drawInRect<span class=\"token punctuation\">:</span>rect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nUIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"5、查看系统所有字体\"><a href=\"#5、查看系统所有字体\" class=\"headerlink\" title=\"5、查看系统所有字体\"></a>5、查看系统所有字体</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 打印字体</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>id familyName <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span>UIFont familyNames<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> familyName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>id fontName <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span>UIFont fontNamesForFamilyName<span class=\"token punctuation\">:</span>familyName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"  %@\"</span><span class=\"token punctuation\">,</span> fontName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 也可以进入这个网址查看 http://iosfonts.com/</span>\n</code></pre>\n<h4 id=\"6、获取随机数\"><a href=\"#6、获取随机数\" class=\"headerlink\" title=\"6、获取随机数\"></a>6、获取随机数</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSInteger i <span class=\"token operator\">=</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"7、获取随机数小数-0-1之间\"><a href=\"#7、获取随机数小数-0-1之间\" class=\"headerlink\" title=\"7、获取随机数小数(0-1之间)\"></a>7、获取随机数小数(0-1之间)</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ARC4RANDOM_MAX      0x100000000</span>\n<span class=\"token keyword\">double</span> val <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span><span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> ARC4RANDOM_MAX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"8、AVPlayer视频播放完成的通知监听\"><a href=\"#8、AVPlayer视频播放完成的通知监听\" class=\"headerlink\" title=\"8、AVPlayer视频播放完成的通知监听\"></a>8、AVPlayer视频播放完成的通知监听</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSNotificationCenter defaultCenter<span class=\"token punctuation\">]</span> \n      addObserver<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span>\n      selector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>videoPlayEnd<span class=\"token punctuation\">)</span>\n      name<span class=\"token punctuation\">:</span>AVPlayerItemDidPlayToEndTimeNotification \n      object<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"9、判断两个rect是否有交叉\"><a href=\"#9、判断两个rect是否有交叉\" class=\"headerlink\" title=\"9、判断两个rect是否有交叉\"></a>9、判断两个rect是否有交叉</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">CGRectIntersectsRect</span><span class=\"token punctuation\">(</span>rect1<span class=\"token punctuation\">,</span> rect2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"10、判断一个字符串是否为数字\"><a href=\"#10、判断一个字符串是否为数字\" class=\"headerlink\" title=\"10、判断一个字符串是否为数字\"></a>10、判断一个字符串是否为数字</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSCharacterSet <span class=\"token operator\">*</span>notDigits <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSCharacterSet decimalDigitCharacterSet<span class=\"token punctuation\">]</span> invertedSet<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>str rangeOfCharacterFromSet<span class=\"token punctuation\">:</span>notDigits<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>location <span class=\"token operator\">==</span> NSNotFound<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 是数字</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 不是数字</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"11、将一个view保存为pdf格式\"><a href=\"#11、将一个view保存为pdf格式\" class=\"headerlink\" title=\"11、将一个view保存为pdf格式\"></a>11、将一个view保存为pdf格式</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>createPDFfromUIView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIView<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>aView saveToDocumentsWithFileName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>aFilename\n<span class=\"token punctuation\">{</span>\n    NSMutableData <span class=\"token operator\">*</span>pdfData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableData data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginPDFContextToData</span><span class=\"token punctuation\">(</span>pdfData<span class=\"token punctuation\">,</span> aView<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginPDFPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGContextRef pdfContext <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>aView<span class=\"token punctuation\">.</span>layer renderInContext<span class=\"token punctuation\">:</span>pdfContext<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndPDFContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    NSArray<span class=\"token operator\">*</span> documentDirectories <span class=\"token operator\">=</span> <span class=\"token function\">NSSearchPathForDirectoriesInDomains</span><span class=\"token punctuation\">(</span>NSDocumentDirectory<span class=\"token punctuation\">,</span> NSUserDomainMask<span class=\"token punctuation\">,</span>YES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString<span class=\"token operator\">*</span> documentDirectory <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>documentDirectories objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString<span class=\"token operator\">*</span> documentDirectoryFilename <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>documentDirectory stringByAppendingPathComponent<span class=\"token punctuation\">:</span>aFilename<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>pdfData writeToFile<span class=\"token punctuation\">:</span>documentDirectoryFilename atomically<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"documentDirectoryFileName: %@\"</span><span class=\"token punctuation\">,</span>documentDirectoryFilename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12、让一个view在父视图中心\"><a href=\"#12、让一个view在父视图中心\" class=\"headerlink\" title=\"12、让一个view在父视图中心\"></a>12、让一个view在父视图中心</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">child<span class=\"token punctuation\">.</span>center <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>parent convertPoint<span class=\"token punctuation\">:</span>parent<span class=\"token punctuation\">.</span>center fromView<span class=\"token punctuation\">:</span>parent<span class=\"token punctuation\">.</span>superview<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"13、获取当前导航控制器下前一个控制器\"><a href=\"#13、获取当前导航控制器下前一个控制器\" class=\"headerlink\" title=\"13、获取当前导航控制器下前一个控制器\"></a>13、获取当前导航控制器下前一个控制器</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIViewController <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>backViewController\n<span class=\"token punctuation\">{</span>\n    NSInteger myIndex <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController<span class=\"token punctuation\">.</span>viewControllers indexOfObject<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> myIndex <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> myIndex <span class=\"token operator\">!=</span> NSNotFound <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController<span class=\"token punctuation\">.</span>viewControllers objectAtIndex<span class=\"token punctuation\">:</span>myIndex<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"14、保存UIImage到本地\"><a href=\"#14、保存UIImage到本地\" class=\"headerlink\" title=\"14、保存UIImage到本地\"></a>14、保存UIImage到本地</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>paths <span class=\"token operator\">=</span> <span class=\"token function\">NSSearchPathForDirectoriesInDomains</span><span class=\"token punctuation\">(</span>NSDocumentDirectory<span class=\"token punctuation\">,</span> NSUserDomainMask<span class=\"token punctuation\">,</span> YES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nNSString <span class=\"token operator\">*</span>filePath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>paths objectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> stringByAppendingPathComponent<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Image.png\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token function\">UIImagePNGRepresentation</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">)</span> writeToFile<span class=\"token punctuation\">:</span>filePath atomically<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"15、键盘上方增加工具栏\"><a href=\"#15、键盘上方增加工具栏\" class=\"headerlink\" title=\"15、键盘上方增加工具栏\"></a>15、键盘上方增加工具栏</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UIToolbar <span class=\"token operator\">*</span>keyboardDoneButtonView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIToolbar alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>keyboardDoneButtonView sizeToFit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nUIBarButtonItem <span class=\"token operator\">*</span>doneButton <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIBarButtonItem alloc<span class=\"token punctuation\">]</span> initWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Done\"</span>\n                                                               style<span class=\"token punctuation\">:</span>UIBarButtonItemStyleBordered target<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span>\n                                                              action<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>doneClicked<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>keyboardDoneButtonView setItems<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSArray arrayWithObjects<span class=\"token punctuation\">:</span>doneButton<span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\ntxtField<span class=\"token punctuation\">.</span>inputAccessoryView <span class=\"token operator\">=</span> keyboardDoneButtonView<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"16、copy一个view\"><a href=\"#16、copy一个view\" class=\"headerlink\" title=\"16、copy一个view\"></a>16、copy一个view</h4><blockquote>\n<p>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃<br>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</p>\n</blockquote>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">id copyOfView <span class=\"token operator\">=</span> \n<span class=\"token punctuation\">[</span>NSKeyedUnarchiver unarchiveObjectWithData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSKeyedArchiver archivedDataWithRootObject<span class=\"token punctuation\">:</span>originalView<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"17、在image上绘制文字并生成新的image\"><a href=\"#17、在image上绘制文字并生成新的image\" class=\"headerlink\" title=\"17、在image上绘制文字并生成新的image\"></a>17、在image上绘制文字并生成新的image</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UIFont <span class=\"token operator\">*</span>font <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIFont boldSystemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">12</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>image drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span>image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CGRect rect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span>point<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> point<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> image<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor whiteColor<span class=\"token punctuation\">]</span> set<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>text drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectIntegral</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">)</span> withFont<span class=\"token punctuation\">:</span>font<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n    UIImage <span class=\"token operator\">*</span>newImage <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"18、判断一个view是否为另一个view的子视图\"><a href=\"#18、判断一个view是否为另一个view的子视图\" class=\"headerlink\" title=\"18、判断一个view是否为另一个view的子视图\"></a>18、判断一个view是否为另一个view的子视图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 如果myView是self.view本身，也会返回yes</span>\nBOOL isSubView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>myView isDescendantOfView<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"19、判断一个字符串是否包含另一个字符串\"><a href=\"#19、判断一个字符串是否包含另一个字符串\" class=\"headerlink\" title=\"19、判断一个字符串是否包含另一个字符串\"></a>19、判断一个字符串是否包含另一个字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>str containsString<span class=\"token punctuation\">:</span>otherStr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"包含\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二</span>\nNSRange range <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>str rangeOfString<span class=\"token punctuation\">:</span>otherStr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound<span class=\"token punctuation\">)</span> <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"包含\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"20、UICollectionView自动滚动到某行\"><a href=\"#20、UICollectionView自动滚动到某行\" class=\"headerlink\" title=\"20、UICollectionView自动滚动到某行\"></a>20、UICollectionView自动滚动到某行</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 重写viewDidLayoutSubviews方法</span>\n<span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLayoutSubviews <span class=\"token punctuation\">{</span>\n   <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLayoutSubviews<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>collectionView scrollToItemAtIndexPath<span class=\"token punctuation\">:</span>indexPath atScrollPosition<span class=\"token punctuation\">:</span>UICollectionViewScrollPositionCenteredVertically animated<span class=\"token punctuation\">:</span>NO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"21、修改系统UIAlertController\"><a href=\"#21、修改系统UIAlertController\" class=\"headerlink\" title=\"21、修改系统UIAlertController\"></a>21、修改系统UIAlertController</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 但是据说这种方法会被App Store拒绝(慎用！)</span>\nUIAlertController <span class=\"token operator\">*</span>alertVC <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIAlertController alertControllerWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span> message<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span> preferredStyle<span class=\"token punctuation\">:</span>UIAlertControllerStyleActionSheet<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSMutableAttributedString <span class=\"token operator\">*</span>hogan <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableAttributedString alloc<span class=\"token punctuation\">]</span> initWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"我是一个大文本\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>hogan addAttribute<span class=\"token punctuation\">:</span>NSFontAttributeName\n                  value<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">30</span><span class=\"token punctuation\">]</span>\n                  range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>hogan addAttribute<span class=\"token punctuation\">:</span>NSForegroundColorAttributeName\n                  value<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span>\n                  range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>alertVC setValue<span class=\"token punctuation\">:</span>hogan forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"attributedTitle\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    UIAlertAction <span class=\"token operator\">*</span>button <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIAlertAction actionWithTitle<span class=\"token punctuation\">:</span><span class=\"token string\">@\"Label text\"</span> style<span class=\"token punctuation\">:</span>UIAlertActionStyleDefault handler<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>UIAlertAction <span class=\"token operator\">*</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>accessoryImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageNamed<span class=\"token punctuation\">:</span><span class=\"token string\">@\"1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>button setValue<span class=\"token punctuation\">:</span>accessoryImage forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"image\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>alertVC addAction<span class=\"token punctuation\">:</span>button<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> presentViewController<span class=\"token punctuation\">:</span>alertVC animated<span class=\"token punctuation\">:</span>YES completion<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"22、判断某一行的cell是否已经显示\"><a href=\"#22、判断某一行的cell是否已经显示\" class=\"headerlink\" title=\"22、判断某一行的cell是否已经显示\"></a>22、判断某一行的cell是否已经显示</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">CGRect cellRect <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>tableView rectForRowAtIndexPath<span class=\"token punctuation\">:</span>indexPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nBOOL completelyVisible <span class=\"token operator\">=</span> <span class=\"token function\">CGRectContainsRect</span><span class=\"token punctuation\">(</span>tableView<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">,</span> cellRect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"23、让导航控制器pop回指定的控制器\"><a href=\"#23、让导航控制器pop回指定的控制器\" class=\"headerlink\" title=\"23、让导航控制器pop回指定的控制器\"></a>23、让导航控制器pop回指定的控制器</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span>allViewControllers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithArray<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController viewControllers<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>UIViewController <span class=\"token operator\">*</span>aViewController <span class=\"token keyword\">in</span> allViewControllers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>aViewController isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>RequiredViewController class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController popToViewController<span class=\"token punctuation\">:</span>aViewController animated<span class=\"token punctuation\">:</span>NO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"24、动画修改label上的文字\"><a href=\"#24、动画修改label上的文字\" class=\"headerlink\" title=\"24、动画修改label上的文字\"></a>24、动画修改label上的文字</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法一</span>\nCATransition <span class=\"token operator\">*</span>animation <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CATransition animation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    animation<span class=\"token punctuation\">.</span>timingFunction <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAMediaTimingFunction functionWithName<span class=\"token punctuation\">:</span>kCAMediaTimingFunctionEaseInEaseOut<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    animation<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> kCATransitionFade<span class=\"token punctuation\">;</span>\n    animation<span class=\"token punctuation\">.</span>duration <span class=\"token operator\">=</span> <span class=\"token number\">0.75</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>layer addAnimation<span class=\"token punctuation\">:</span>animation forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"kCATransitionFade\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">@\"New\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二</span>\n<span class=\"token punctuation\">[</span>UIView transitionWithView<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label\n                      duration<span class=\"token punctuation\">:</span><span class=\"token number\">0.25f</span>\n                       options<span class=\"token punctuation\">:</span>UIViewAnimationOptionTransitionCrossDissolve\n                    animations<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n\n                        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">@\"Well done!\"</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token punctuation\">}</span> completion<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法三</span>\n<span class=\"token punctuation\">[</span>UIView animateWithDuration<span class=\"token punctuation\">:</span><span class=\"token number\">1.0</span>\n                     animations<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n                         <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>alpha <span class=\"token operator\">=</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">@\"newText\"</span><span class=\"token punctuation\">;</span>\n                         <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>label<span class=\"token punctuation\">.</span>alpha <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span>\n                     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"25、判断字典中是否包含某个key值\"><a href=\"#25、判断字典中是否包含某个key值\" class=\"headerlink\" title=\"25、判断字典中是否包含某个key值\"></a>25、判断字典中是否包含某个key值</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>dic objectForKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"yourKey\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"有这个值\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"没有这个值\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"26、获取屏幕方向\"><a href=\"#26、获取屏幕方向\" class=\"headerlink\" title=\"26、获取屏幕方向\"></a>26、获取屏幕方向</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UIInterfaceOrientation orientation <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>statusBarOrientation<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//Default orientation </span>\n    <span class=\"token comment\" spellcheck=\"true\">//默认</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">==</span> UIInterfaceOrientationPortrait<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//竖屏</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">==</span> UIInterfaceOrientationLandscapeLeft<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 左横屏</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">==</span> UIInterfaceOrientationLandscapeRight<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">//右横屏</span>\n</code></pre>\n<h4 id=\"27、设置UIImage的透明度\"><a href=\"#27、设置UIImage的透明度\" class=\"headerlink\" title=\"27、设置UIImage的透明度\"></a>27、设置UIImage的透明度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 方法一、添加UIImage分类</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>imageByApplyingAlpha<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span> alpha <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    CGContextRef ctx <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGRect area <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">CGContextScaleCTM</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextTranslateCTM</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>area<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">CGContextSetBlendMode</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> kCGBlendModeMultiply<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">CGContextSetAlpha</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> alpha<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">CGContextDrawImage</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> area<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    UIImage <span class=\"token operator\">*</span>newImage <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> newImage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度</span>\nUIImageView <span class=\"token operator\">*</span>imageView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIImageView alloc<span class=\"token punctuation\">]</span> initWithImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIImage imageWithName<span class=\"token punctuation\">:</span><span class=\"token string\">@\"yourImage\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nimageView<span class=\"token punctuation\">.</span>alpha <span class=\"token operator\">=</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"28、Attempt-to-mutate-immutable-object-with-insertString-atIndex\"><a href=\"#28、Attempt-to-mutate-immutable-object-with-insertString-atIndex\" class=\"headerlink\" title=\"28、Attempt to mutate immutable object with insertString:atIndex:\"></a>28、Attempt to mutate immutable object with insertString:atIndex:</h4><blockquote>\n<p>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</p>\n</blockquote>\n<h4 id=\"29、UIWebView添加单击手势不响应\"><a href=\"#29、UIWebView添加单击手势不响应\" class=\"headerlink\" title=\"29、UIWebView添加单击手势不响应\"></a>29、UIWebView添加单击手势不响应</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UITapGestureRecognizer <span class=\"token operator\">*</span>tap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UITapGestureRecognizer alloc<span class=\"token punctuation\">]</span> initWithTarget<span class=\"token punctuation\">:</span><span class=\"token keyword\">self</span> action<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>webViewClick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tap<span class=\"token punctuation\">.</span>delegate <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>_webView addGestureRecognizer<span class=\"token punctuation\">:</span>tap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>gestureRecognizer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIGestureRecognizer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIGestureRecognizer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>otherGestureRecognizer<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"30、获取手机RAM容量\"><a href=\"#30、获取手机RAM容量\" class=\"headerlink\" title=\"30、获取手机RAM容量\"></a>30、获取手机RAM容量</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 需要导入#import &lt;mach/mach.h></span>\nmach_port_t host_port<span class=\"token punctuation\">;</span>\n    mach_msg_type_number_t host_size<span class=\"token punctuation\">;</span>\n    vm_size_t pagesize<span class=\"token punctuation\">;</span>\n\n    host_port <span class=\"token operator\">=</span> <span class=\"token function\">mach_host_self</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    host_size <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vm_statistics_data_t<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>integer_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">host_page_size</span><span class=\"token punctuation\">(</span>host_port<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pagesize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    vm_statistics_data_t vm_stat<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">host_statistics</span><span class=\"token punctuation\">(</span>host_port<span class=\"token punctuation\">,</span> HOST_VM_INFO<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>host_info_t<span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>vm_stat<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>host_size<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> KERN_SUCCESS<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"Failed to fetch vm statistics\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* Stats in bytes */</span>\n    natural_t mem_used <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>vm_stat<span class=\"token punctuation\">.</span>active_count <span class=\"token operator\">+</span>\n                          vm_stat<span class=\"token punctuation\">.</span>inactive_count <span class=\"token operator\">+</span>\n                          vm_stat<span class=\"token punctuation\">.</span>wire_count<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> pagesize<span class=\"token punctuation\">;</span>\n    natural_t mem_free <span class=\"token operator\">=</span> vm_stat<span class=\"token punctuation\">.</span>free_count <span class=\"token operator\">*</span> pagesize<span class=\"token punctuation\">;</span>\n    natural_t mem_total <span class=\"token operator\">=</span> mem_used <span class=\"token operator\">+</span> mem_free<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"已用: %u 可用: %u 总共: %u\"</span><span class=\"token punctuation\">,</span> mem_used<span class=\"token punctuation\">,</span> mem_free<span class=\"token punctuation\">,</span> mem_total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、每个cell之间增加间距\"><a href=\"#1、每个cell之间增加间距\" class=\"headerlink\" title=\"1、每个cell之间增加间距\"></a>1、每个cell之间增加间距</h4><pre><code class=\"objectivec\">// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)\n- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView\n{\n    return yourArry.count;\n}\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    return 1;\n}\n-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section\n{\n    return cellSpacingHeight;\n}\n\n// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。\n\n// 方法三，自定义cell，重写setFrame：方法\n- (void)setFrame:(CGRect)frame\n{\n    frame.size.height -= 20;\n    [super setFrame:frame];\n}\n</code></pre>\n<h4 id=\"7、播放一张张连续的图片\"><a href=\"#7、播放一张张连续的图片\" class=\"headerlink\" title=\"7、播放一张张连续的图片\"></a>7、播放一张张连续的图片</h4><pre><code class=\"objectivec\">// 加入现在有三张图片分别为animate_1、animate_2、animate_3\n// 方法一\n    imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];\nimageView.animationDuration = 1.0;\n// 方法二\n    imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];\n// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024\n</code></pre>\n<h4 id=\"3、加载gif图片\"><a href=\"#3、加载gif图片\" class=\"headerlink\" title=\"3、加载gif图片\"></a>3、加载gif图片</h4><blockquote>\n<p>推荐使用这个框架 <a href=\"https://github.com/Flipboard/FLAnimatedImage\" target=\"_blank\" rel=\"external\">FLAnimatedImage</a></p>\n</blockquote>\n<h4 id=\"4、防止离屏渲染为image添加圆角\"><a href=\"#4、防止离屏渲染为image添加圆角\" class=\"headerlink\" title=\"4、防止离屏渲染为image添加圆角\"></a>4、防止离屏渲染为image添加圆角</h4><pre><code class=\"objectivec\">// image分类\n- (UIImage *)circleImage\n{\n// NO代表透明\nUIGraphicsBeginImageContextWithOptions(self.size, NO, 1);\n// 获得上下文\nCGContextRef ctx = UIGraphicsGetCurrentContext();\n// 添加一个圆\nCGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);\n// 方形变圆形\nCGContextAddEllipseInRect(ctx, rect);\n// 裁剪\nCGContextClip(ctx);\n// 将图片画上去\n[self drawInRect:rect];\nUIImage *image = UIGraphicsGetImageFromCurrentImageContext();\nUIGraphicsEndImageContext();\nreturn image;\n}\n</code></pre>\n<h4 id=\"5、查看系统所有字体\"><a href=\"#5、查看系统所有字体\" class=\"headerlink\" title=\"5、查看系统所有字体\"></a>5、查看系统所有字体</h4><pre><code class=\"objectivec\">// 打印字体\nfor (id familyName in [UIFont familyNames]) {\n    NSLog(@&quot;%@&quot;, familyName);\n    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@&quot;  %@&quot;, fontName);\n}\n// 也可以进入这个网址查看 http://iosfonts.com/\n</code></pre>\n<h4 id=\"6、获取随机数\"><a href=\"#6、获取随机数\" class=\"headerlink\" title=\"6、获取随机数\"></a>6、获取随机数</h4><pre><code class=\"objectivec\">NSInteger i = arc4random();\n</code></pre>\n<h4 id=\"7、获取随机数小数-0-1之间\"><a href=\"#7、获取随机数小数-0-1之间\" class=\"headerlink\" title=\"7、获取随机数小数(0-1之间)\"></a>7、获取随机数小数(0-1之间)</h4><pre><code class=\"objectivec\">#define ARC4RANDOM_MAX      0x100000000\ndouble val = ((double)arc4random() / ARC4RANDOM_MAX);\n</code></pre>\n<h4 id=\"8、AVPlayer视频播放完成的通知监听\"><a href=\"#8、AVPlayer视频播放完成的通知监听\" class=\"headerlink\" title=\"8、AVPlayer视频播放完成的通知监听\"></a>8、AVPlayer视频播放完成的通知监听</h4><pre><code class=\"objectivec\">[[NSNotificationCenter defaultCenter] \n      addObserver:self\n      selector:@selector(videoPlayEnd)\n      name:AVPlayerItemDidPlayToEndTimeNotification \n      object:nil];\n</code></pre>\n<h4 id=\"9、判断两个rect是否有交叉\"><a href=\"#9、判断两个rect是否有交叉\" class=\"headerlink\" title=\"9、判断两个rect是否有交叉\"></a>9、判断两个rect是否有交叉</h4><pre><code class=\"objectivec\"> if (CGRectIntersectsRect(rect1, rect2)) {\n}\n</code></pre>\n<h4 id=\"10、判断一个字符串是否为数字\"><a href=\"#10、判断一个字符串是否为数字\" class=\"headerlink\" title=\"10、判断一个字符串是否为数字\"></a>10、判断一个字符串是否为数字</h4><pre><code class=\"objectivec\">NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];\n    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)\n    {\n      // 是数字\n    } else\n    {\n      // 不是数字\n    }\n</code></pre>\n<h4 id=\"11、将一个view保存为pdf格式\"><a href=\"#11、将一个view保存为pdf格式\" class=\"headerlink\" title=\"11、将一个view保存为pdf格式\"></a>11、将一个view保存为pdf格式</h4><pre><code class=\"objectivec\">- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename\n{\n    NSMutableData *pdfData = [NSMutableData data];\n    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);\n    UIGraphicsBeginPDFPage();\n    CGContextRef pdfContext = UIGraphicsGetCurrentContext();\n    [aView.layer renderInContext:pdfContext];\n    UIGraphicsEndPDFContext();\n\n    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);\n    NSString* documentDirectory = [documentDirectories objectAtIndex:0];\n    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];\n    [pdfData writeToFile:documentDirectoryFilename atomically:YES];\n    NSLog(@&quot;documentDirectoryFileName: %@&quot;,documentDirectoryFilename);\n}\n</code></pre>\n<h4 id=\"12、让一个view在父视图中心\"><a href=\"#12、让一个view在父视图中心\" class=\"headerlink\" title=\"12、让一个view在父视图中心\"></a>12、让一个view在父视图中心</h4><pre><code class=\"objectivec\">child.center = [parent convertPoint:parent.center fromView:parent.superview];\n</code></pre>\n<h4 id=\"13、获取当前导航控制器下前一个控制器\"><a href=\"#13、获取当前导航控制器下前一个控制器\" class=\"headerlink\" title=\"13、获取当前导航控制器下前一个控制器\"></a>13、获取当前导航控制器下前一个控制器</h4><pre><code class=\"objectivec\">- (UIViewController *)backViewController\n{\n    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];\n\n    if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) {\n        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];\n    } else {\n        return nil;\n    }\n}\n</code></pre>\n<h4 id=\"14、保存UIImage到本地\"><a href=\"#14、保存UIImage到本地\" class=\"headerlink\" title=\"14、保存UIImage到本地\"></a>14、保存UIImage到本地</h4><pre><code class=\"objectivec\">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Image.png&quot;];\n[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];\n</code></pre>\n<h4 id=\"15、键盘上方增加工具栏\"><a href=\"#15、键盘上方增加工具栏\" class=\"headerlink\" title=\"15、键盘上方增加工具栏\"></a>15、键盘上方增加工具栏</h4><pre><code class=\"objectivec\">UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];\n[keyboardDoneButtonView sizeToFit];\nUIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;Done&quot;\n                                                               style:UIBarButtonItemStyleBordered target:self\n                                                              action:@selector(doneClicked:)];\n[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];\ntxtField.inputAccessoryView = keyboardDoneButtonView;\n</code></pre>\n<h4 id=\"16、copy一个view\"><a href=\"#16、copy一个view\" class=\"headerlink\" title=\"16、copy一个view\"></a>16、copy一个view</h4><blockquote>\n<p>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃<br>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</p>\n</blockquote>\n<pre><code class=\"objectivec\">id copyOfView = \n[NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];\n</code></pre>\n<h4 id=\"17、在image上绘制文字并生成新的image\"><a href=\"#17、在image上绘制文字并生成新的image\" class=\"headerlink\" title=\"17、在image上绘制文字并生成新的image\"></a>17、在image上绘制文字并生成新的image</h4><pre><code class=\"objectivec\">UIFont *font = [UIFont boldSystemFontOfSize:12];\n    UIGraphicsBeginImageContext(image.size);\n    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];\n    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);\n    [[UIColor whiteColor] set];\n    [text drawInRect:CGRectIntegral(rect) withFont:font]; \n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n</code></pre>\n<h4 id=\"18、判断一个view是否为另一个view的子视图\"><a href=\"#18、判断一个view是否为另一个view的子视图\" class=\"headerlink\" title=\"18、判断一个view是否为另一个view的子视图\"></a>18、判断一个view是否为另一个view的子视图</h4><pre><code class=\"objectivec\">// 如果myView是self.view本身，也会返回yes\nBOOL isSubView = [myView isDescendantOfView:self.view];\n</code></pre>\n<h4 id=\"19、判断一个字符串是否包含另一个字符串\"><a href=\"#19、判断一个字符串是否包含另一个字符串\" class=\"headerlink\" title=\"19、判断一个字符串是否包含另一个字符串\"></a>19、判断一个字符串是否包含另一个字符串</h4><pre><code class=\"objectivec\">// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二\nif ([str containsString:otherStr]) NSLog(@&quot;包含&quot;);\n\n// 方法二\nNSRange range = [str rangeOfString:otherStr];\nif (range.location != NSNotFound) NSLog(@&quot;包含&quot;);\n</code></pre>\n<h4 id=\"20、UICollectionView自动滚动到某行\"><a href=\"#20、UICollectionView自动滚动到某行\" class=\"headerlink\" title=\"20、UICollectionView自动滚动到某行\"></a>20、UICollectionView自动滚动到某行</h4><pre><code class=\"objectivec\">// 重写viewDidLayoutSubviews方法\n-(void)viewDidLayoutSubviews {\n   [super viewDidLayoutSubviews];\n   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];\n}\n</code></pre>\n<h4 id=\"21、修改系统UIAlertController\"><a href=\"#21、修改系统UIAlertController\" class=\"headerlink\" title=\"21、修改系统UIAlertController\"></a>21、修改系统UIAlertController</h4><pre><code class=\"objectivec\">// 但是据说这种方法会被App Store拒绝(慎用！)\nUIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet];\n    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@&quot;我是一个大文本&quot;];\n    [hogan addAttribute:NSFontAttributeName\n                  value:[UIFont systemFontOfSize:30]\n                  range:NSMakeRange(4, 1)];\n    [hogan addAttribute:NSForegroundColorAttributeName\n                  value:[UIColor redColor]\n                  range:NSMakeRange(4, 1)];\n    [alertVC setValue:hogan forKey:@&quot;attributedTitle&quot;];\n\n    UIAlertAction *button = [UIAlertAction actionWithTitle:@&quot;Label text&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];\n    UIImage *accessoryImage = [UIImage imageNamed:@&quot;1&quot;];\n    [button setValue:accessoryImage forKey:@&quot;image&quot;];\n    [alertVC addAction:button];\n    [self presentViewController:alertVC animated:YES completion:nil];\n</code></pre>\n<h4 id=\"22、判断某一行的cell是否已经显示\"><a href=\"#22、判断某一行的cell是否已经显示\" class=\"headerlink\" title=\"22、判断某一行的cell是否已经显示\"></a>22、判断某一行的cell是否已经显示</h4><pre><code class=\"objectivec\">CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];\nBOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);\n</code></pre>\n<h4 id=\"23、让导航控制器pop回指定的控制器\"><a href=\"#23、让导航控制器pop回指定的控制器\" class=\"headerlink\" title=\"23、让导航控制器pop回指定的控制器\"></a>23、让导航控制器pop回指定的控制器</h4><pre><code class=\"objectivec\">NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];\nfor (UIViewController *aViewController in allViewControllers) {\n    if ([aViewController isKindOfClass:[RequiredViewController class]]) {\n        [self.navigationController popToViewController:aViewController animated:NO];\n    }\n}\n</code></pre>\n<h4 id=\"24、动画修改label上的文字\"><a href=\"#24、动画修改label上的文字\" class=\"headerlink\" title=\"24、动画修改label上的文字\"></a>24、动画修改label上的文字</h4><pre><code class=\"objectivec\">// 方法一\nCATransition *animation = [CATransition animation];\n    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    animation.type = kCATransitionFade;\n    animation.duration = 0.75;\n    [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];\n    self.label.text = @&quot;New&quot;;\n\n// 方法二\n[UIView transitionWithView:self.label\n                      duration:0.25f\n                       options:UIViewAnimationOptionTransitionCrossDissolve\n                    animations:^{\n\n                        self.label.text = @&quot;Well done!&quot;;\n\n                    } completion:nil];\n\n// 方法三\n[UIView animateWithDuration:1.0\n                     animations:^{\n                         self.label.alpha = 0.0f;\n                         self.label.text = @&quot;newText&quot;;\n                         self.label.alpha = 1.0f;\n                     }];\n</code></pre>\n<h4 id=\"25、判断字典中是否包含某个key值\"><a href=\"#25、判断字典中是否包含某个key值\" class=\"headerlink\" title=\"25、判断字典中是否包含某个key值\"></a>25、判断字典中是否包含某个key值</h4><pre><code class=\"objectivec\">if ([dic objectForKey:@&quot;yourKey&quot;]) {\n    NSLog(@&quot;有这个值&quot;);\n} else {\n    NSLog(@&quot;没有这个值&quot;);\n}\n</code></pre>\n<h4 id=\"26、获取屏幕方向\"><a href=\"#26、获取屏幕方向\" class=\"headerlink\" title=\"26、获取屏幕方向\"></a>26、获取屏幕方向</h4><pre><code class=\"objectivec\">UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;\n\nif(orientation == 0) //Default orientation \n    //默认\nelse if(orientation == UIInterfaceOrientationPortrait)\n    //竖屏\nelse if(orientation == UIInterfaceOrientationLandscapeLeft)\n    // 左横屏\nelse if(orientation == UIInterfaceOrientationLandscapeRight)\n    //右横屏\n</code></pre>\n<h4 id=\"27、设置UIImage的透明度\"><a href=\"#27、设置UIImage的透明度\" class=\"headerlink\" title=\"27、设置UIImage的透明度\"></a>27、设置UIImage的透明度</h4><pre><code class=\"objectivec\">// 方法一、添加UIImage分类\n- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {\n    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);\n\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);\n\n    CGContextScaleCTM(ctx, 1, -1);\n    CGContextTranslateCTM(ctx, 0, -area.size.height);\n\n    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);\n\n    CGContextSetAlpha(ctx, alpha);\n\n    CGContextDrawImage(ctx, area, self.CGImage);\n\n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n\n    UIGraphicsEndImageContext();\n\n    return newImage;\n}\n\n// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度\nUIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@&quot;yourImage&quot;]];\nimageView.alpha = 0.5;\n</code></pre>\n<h4 id=\"28、Attempt-to-mutate-immutable-object-with-insertString-atIndex\"><a href=\"#28、Attempt-to-mutate-immutable-object-with-insertString-atIndex\" class=\"headerlink\" title=\"28、Attempt to mutate immutable object with insertString:atIndex:\"></a>28、Attempt to mutate immutable object with insertString:atIndex:</h4><blockquote>\n<p>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</p>\n</blockquote>\n<h4 id=\"29、UIWebView添加单击手势不响应\"><a href=\"#29、UIWebView添加单击手势不响应\" class=\"headerlink\" title=\"29、UIWebView添加单击手势不响应\"></a>29、UIWebView添加单击手势不响应</h4><pre><code class=\"objectivec\">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];\n        tap.delegate = self;\n        [_webView addGestureRecognizer:tap];\n\n// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{\n    return YES;\n}\n</code></pre>\n<h4 id=\"30、获取手机RAM容量\"><a href=\"#30、获取手机RAM容量\" class=\"headerlink\" title=\"30、获取手机RAM容量\"></a>30、获取手机RAM容量</h4><pre><code class=\"objectivec\">// 需要导入#import &lt;mach/mach.h&gt;\nmach_port_t host_port;\n    mach_msg_type_number_t host_size;\n    vm_size_t pagesize;\n\n    host_port = mach_host_self();\n    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);\n    host_page_size(host_port, &amp;pagesize);\n\n    vm_statistics_data_t vm_stat;\n\n    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) {\n        NSLog(@&quot;Failed to fetch vm statistics&quot;);\n    }\n\n    /* Stats in bytes */\n    natural_t mem_used = (vm_stat.active_count +\n                          vm_stat.inactive_count +\n                          vm_stat.wire_count) * pagesize;\n    natural_t mem_free = vm_stat.free_count * pagesize;\n    natural_t mem_total = mem_used + mem_free;\n    NSLog(@&quot;已用: %u 可用: %u 总共: %u&quot;, mem_used, mem_free, mem_total);\n</code></pre>\n"},{"title":"iOS小经验（四）","date":"2016-02-26T01:53:06.000Z","_content":"#### 1、获取视频的时长\n```objectivec\n+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString {\n    NSURL *videoUrl = [NSURL URLWithString:urlString];\n    AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl];\n    CMTime time = [avUrl duration];\n    int seconds = ceil(time.value/time.timescale);\n    return seconds;\n}\n```\n\n#### 2、字符串是否为空\n```objectivec\n+ (BOOL)isEqualToNil:(NSString *)str {\n    return str.length <= 0 || [str isEqualToString:@\"\"] || !str;\n}\n```\n#### 3、将app上传到App Store的时候通常会遇到这个问题\n\n![](http://upload-images.jianshu.io/upload_images/1432270-8b75d749ac20c31e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！\n但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。\n如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。\n\n#### 4、当tableView占不满一屏时，去除下边多余的单元格\n```objectivec\nself.tableView.tableHeaderView = [UIView new];\nself.tableView.tableFooterView = [UIView new];\n```\n\n#### 5、isKindOfClass和isMemberOfClass的区别\n```objectivec\nisKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。\nisMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类)\n```\n\n#### 6、__block\n```objectivec\n当一个局部变量需要在block里改变时，需要在定义时加上__block修饰，具体请看官方文档 http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6\n```\n\n#### 7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0\n> 这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法\n\n#### 8、UITableView (<UITableView: 0x7ff19b027000; >) failed to obtain a cell from its dataSource (<ViewController: 0x7ff19a507520>)\n\n>这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃\n\n#### 9、约束如何做UIView动画？\n```objectivec\n1、把需要改的约束Constraint拖条线出来，成为属性\n2、在需要动画的地方加入代码，改变此属性的constant属性\n3、开始做UIView动画，动画里边调用layoutIfNeeded方法\n\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint;\nself.buttonTopConstraint.constant = 100;\n    [UIView animateWithDuration:.5 animations:^{\n        [self.view layoutIfNeeded];\n    }];\n```\n\n#### 10、从NSURL中拿到链接字符串\n```objectivec\nNSString *urlString = myURL.absoluteString;\n```\n\n#### 11、将tableView滚动到顶部\n```objectivec\n[tableView setContentOffset:CGPointZero animated:YES];\n或者\n[tableView scrollRectToVisible:CGRectMake(0, 0, 1, 1) animated:YES];\n```\n\n#### 12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\n```objectivec\n[youButton removeTarget:nil action:nil forControlEvents:UIControlEventAllEvents];\n```\n#### 13、某个字体的高度\n```objectivec\nfont.lineHeight;\n```\n\n#### 14、删除某个view所有的子视图\n```objectivec\n[[someView subviews]\n makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n#### 15、删除NSUserDefaults所有记录\n```objectivec\n//方法一\n  NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];\n [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];   \n //方法二  \n- (void)resetDefaults {   \n  NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];\n     NSDictionary * dict = [defs dictionaryRepresentation];\n     for (id key in dict) {\n          [defs removeObjectForKey:key];\n     }\n      [defs synchronize];\n }\n// 方法三\n[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]];\n```\n\n#### 16、禁用系统滑动返回功能\n```objectivec\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\nif ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self;\n    }\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n    if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil;\n    }\n}\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer\n{\n     return NO;\n}\n```\n\n#### 17、模拟器报错\n![](http://upload-images.jianshu.io/upload_images/1432270-76da2a462b9f1eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>解决办法：\n打开模拟器->Simulator->Reset Content and Settings...\n如果不行，就重启试试！\n\n#### 18、自定义cell选中背景颜色\n```objectivec\nUIView *bgColorView = [[UIView alloc] init];\nbgColorView.backgroundColor = [UIColor redColor];\n[cell setSelectedBackgroundView:bgColorView];\n```\n\n#### 19、UILabel设置内边距\n```objectivec\n子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect {\n    // 边距，上左下右\n    UIEdgeInsets insets = {0, 5, 0, 5};\n    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];\n}\n```\n\n#### 20、UILabel设置文字描边\n```objectivec\n子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect\n{\n    CGContextRef c = UIGraphicsGetCurrentContext();\n    // 设置描边宽度\n    CGContextSetLineWidth(c, 1);\n    CGContextSetLineJoin(c, kCGLineJoinRound);\n    CGContextSetTextDrawingMode(c, kCGTextStroke);\n    // 描边颜色\n    self.textColor = [UIColor redColor];\n    [super drawTextInRect:rect];\n    // 文本颜色\n    self.textColor = [UIColor yellowColor];\n    CGContextSetTextDrawingMode(c, kCGTextFill);\n    [super drawTextInRect:rect];\n}\n```\n\n#### 21、使用模拟器截图\n```objectivec\n快捷键command + s\n或者File->Save Screen Shot\n```\n\n#### 22、scrollView滚动到最下边\n```objectivec\nCGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);\n[scrollView setContentOffset:bottomOffset animated:YES];\n```\n\n#### 23、UIView背景颜色渐变\n```objectivec\n    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)];\n    [self.view addSubview:view];\n    CAGradientLayer *gradient = [CAGradientLayer layer];\n    gradient.frame = view.bounds;\n    gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil];\n    [view.layer insertSublayer:gradient atIndex:0];\n```\n\n#### 24、停止UIView动画\n```objectivec\n[yourView.layer removeAllAnimations]\n```\n\n#### 25、为UIView某个角添加圆角\n```objectivec\n// 左上角和右下角添加圆角\nUIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    CAShapeLayer *maskLayer = [CAShapeLayer layer];\n    maskLayer.frame = view.bounds;\n    maskLayer.path = maskPath.CGPath;\n    view.layer.mask = maskLayer;\n```\n\n#### 26、删除Xcode Derived data缓存数据\n![](http://upload-images.jianshu.io/upload_images/1432270-6da089f7000ad432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  27、将一个view放置在其兄弟视图的最上面\n```objectivec\n[parentView bringSubviewToFront:yourView]\n```\n\n#### 28、将一个view放置在其兄弟视图的最下面\n```objectivec\n[parentView sendSubviewToBack:yourView]\n```\n\n#### 29、让手机震动一下\n```objectivec\n倒入框架\n#import <AudioToolbox/AudioToolbox.h>\nAudioServicesPlayAlertSound(kSystemSoundID_Vibrate);\n或者\nAudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n```\n\n#### 30、layoutSubviews方法什么时候调用？\n\n>1、init方法不会调用\n2、addSubview方法等时候会调用\n3、bounds改变的时候调用\n4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)\n5、旋转设备的时候调用\n6、子视图被移除的时候调用\n参考请看：http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/\n\n\n\n","source":"_posts/iOS小经验（四）.md","raw":"---\ntitle: iOS小经验（四）\ndate: 2016-02-26 09:53:06\ncategories: \n\t- iOS小经验\n---\n#### 1、获取视频的时长\n```objectivec\n+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString {\n    NSURL *videoUrl = [NSURL URLWithString:urlString];\n    AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl];\n    CMTime time = [avUrl duration];\n    int seconds = ceil(time.value/time.timescale);\n    return seconds;\n}\n```\n\n#### 2、字符串是否为空\n```objectivec\n+ (BOOL)isEqualToNil:(NSString *)str {\n    return str.length <= 0 || [str isEqualToString:@\"\"] || !str;\n}\n```\n#### 3、将app上传到App Store的时候通常会遇到这个问题\n\n![](http://upload-images.jianshu.io/upload_images/1432270-8b75d749ac20c31e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！\n但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。\n如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。\n\n#### 4、当tableView占不满一屏时，去除下边多余的单元格\n```objectivec\nself.tableView.tableHeaderView = [UIView new];\nself.tableView.tableFooterView = [UIView new];\n```\n\n#### 5、isKindOfClass和isMemberOfClass的区别\n```objectivec\nisKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。\nisMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类)\n```\n\n#### 6、__block\n```objectivec\n当一个局部变量需要在block里改变时，需要在定义时加上__block修饰，具体请看官方文档 http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6\n```\n\n#### 7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0\n> 这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法\n\n#### 8、UITableView (<UITableView: 0x7ff19b027000; >) failed to obtain a cell from its dataSource (<ViewController: 0x7ff19a507520>)\n\n>这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃\n\n#### 9、约束如何做UIView动画？\n```objectivec\n1、把需要改的约束Constraint拖条线出来，成为属性\n2、在需要动画的地方加入代码，改变此属性的constant属性\n3、开始做UIView动画，动画里边调用layoutIfNeeded方法\n\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint;\nself.buttonTopConstraint.constant = 100;\n    [UIView animateWithDuration:.5 animations:^{\n        [self.view layoutIfNeeded];\n    }];\n```\n\n#### 10、从NSURL中拿到链接字符串\n```objectivec\nNSString *urlString = myURL.absoluteString;\n```\n\n#### 11、将tableView滚动到顶部\n```objectivec\n[tableView setContentOffset:CGPointZero animated:YES];\n或者\n[tableView scrollRectToVisible:CGRectMake(0, 0, 1, 1) animated:YES];\n```\n\n#### 12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\n```objectivec\n[youButton removeTarget:nil action:nil forControlEvents:UIControlEventAllEvents];\n```\n#### 13、某个字体的高度\n```objectivec\nfont.lineHeight;\n```\n\n#### 14、删除某个view所有的子视图\n```objectivec\n[[someView subviews]\n makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n#### 15、删除NSUserDefaults所有记录\n```objectivec\n//方法一\n  NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];\n [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];   \n //方法二  \n- (void)resetDefaults {   \n  NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];\n     NSDictionary * dict = [defs dictionaryRepresentation];\n     for (id key in dict) {\n          [defs removeObjectForKey:key];\n     }\n      [defs synchronize];\n }\n// 方法三\n[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]];\n```\n\n#### 16、禁用系统滑动返回功能\n```objectivec\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\nif ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self;\n    }\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n    if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil;\n    }\n}\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer\n{\n     return NO;\n}\n```\n\n#### 17、模拟器报错\n![](http://upload-images.jianshu.io/upload_images/1432270-76da2a462b9f1eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>解决办法：\n打开模拟器->Simulator->Reset Content and Settings...\n如果不行，就重启试试！\n\n#### 18、自定义cell选中背景颜色\n```objectivec\nUIView *bgColorView = [[UIView alloc] init];\nbgColorView.backgroundColor = [UIColor redColor];\n[cell setSelectedBackgroundView:bgColorView];\n```\n\n#### 19、UILabel设置内边距\n```objectivec\n子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect {\n    // 边距，上左下右\n    UIEdgeInsets insets = {0, 5, 0, 5};\n    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];\n}\n```\n\n#### 20、UILabel设置文字描边\n```objectivec\n子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect\n{\n    CGContextRef c = UIGraphicsGetCurrentContext();\n    // 设置描边宽度\n    CGContextSetLineWidth(c, 1);\n    CGContextSetLineJoin(c, kCGLineJoinRound);\n    CGContextSetTextDrawingMode(c, kCGTextStroke);\n    // 描边颜色\n    self.textColor = [UIColor redColor];\n    [super drawTextInRect:rect];\n    // 文本颜色\n    self.textColor = [UIColor yellowColor];\n    CGContextSetTextDrawingMode(c, kCGTextFill);\n    [super drawTextInRect:rect];\n}\n```\n\n#### 21、使用模拟器截图\n```objectivec\n快捷键command + s\n或者File->Save Screen Shot\n```\n\n#### 22、scrollView滚动到最下边\n```objectivec\nCGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);\n[scrollView setContentOffset:bottomOffset animated:YES];\n```\n\n#### 23、UIView背景颜色渐变\n```objectivec\n    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)];\n    [self.view addSubview:view];\n    CAGradientLayer *gradient = [CAGradientLayer layer];\n    gradient.frame = view.bounds;\n    gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil];\n    [view.layer insertSublayer:gradient atIndex:0];\n```\n\n#### 24、停止UIView动画\n```objectivec\n[yourView.layer removeAllAnimations]\n```\n\n#### 25、为UIView某个角添加圆角\n```objectivec\n// 左上角和右下角添加圆角\nUIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    CAShapeLayer *maskLayer = [CAShapeLayer layer];\n    maskLayer.frame = view.bounds;\n    maskLayer.path = maskPath.CGPath;\n    view.layer.mask = maskLayer;\n```\n\n#### 26、删除Xcode Derived data缓存数据\n![](http://upload-images.jianshu.io/upload_images/1432270-6da089f7000ad432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  27、将一个view放置在其兄弟视图的最上面\n```objectivec\n[parentView bringSubviewToFront:yourView]\n```\n\n#### 28、将一个view放置在其兄弟视图的最下面\n```objectivec\n[parentView sendSubviewToBack:yourView]\n```\n\n#### 29、让手机震动一下\n```objectivec\n倒入框架\n#import <AudioToolbox/AudioToolbox.h>\nAudioServicesPlayAlertSound(kSystemSoundID_Vibrate);\n或者\nAudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n```\n\n#### 30、layoutSubviews方法什么时候调用？\n\n>1、init方法不会调用\n2、addSubview方法等时候会调用\n3、bounds改变的时候调用\n4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)\n5、旋转设备的时候调用\n6、子视图被移除的时候调用\n参考请看：http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/\n\n\n\n","slug":"iOS小经验（四）","published":1,"updated":"2017-07-16T14:49:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tw10010znuzrrqy1mv2","content":"<h4 id=\"1、获取视频的时长\"><a href=\"#1、获取视频的时长\" class=\"headerlink\" title=\"1、获取视频的时长\"></a>1、获取视频的时长</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>getVideoTimeByUrlString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>urlString <span class=\"token punctuation\">{</span>\n    NSURL <span class=\"token operator\">*</span>videoUrl <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSURL URLWithString<span class=\"token punctuation\">:</span>urlString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    AVURLAsset <span class=\"token operator\">*</span>avUrl <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AVURLAsset assetWithURL<span class=\"token punctuation\">:</span>videoUrl<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CMTime time <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>avUrl duration<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> seconds <span class=\"token operator\">=</span> <span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>value<span class=\"token operator\">/</span>time<span class=\"token punctuation\">.</span>timescale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> seconds<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"2、字符串是否为空\"><a href=\"#2、字符串是否为空\" class=\"headerlink\" title=\"2、字符串是否为空\"></a>2、字符串是否为空</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isEqualToNil<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span>str isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>str<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"3、将app上传到App-Store的时候通常会遇到这个问题\"><a href=\"#3、将app上传到App-Store的时候通常会遇到这个问题\" class=\"headerlink\" title=\"3、将app上传到App Store的时候通常会遇到这个问题\"></a>3、将app上传到App Store的时候通常会遇到这个问题</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-8b75d749ac20c31e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！<br>但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。<br>如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。</p>\n</blockquote>\n<h4 id=\"4、当tableView占不满一屏时，去除下边多余的单元格\"><a href=\"#4、当tableView占不满一屏时，去除下边多余的单元格\" class=\"headerlink\" title=\"4、当tableView占不满一屏时，去除下边多余的单元格\"></a>4、当tableView占不满一屏时，去除下边多余的单元格</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView<span class=\"token punctuation\">.</span>tableHeaderView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIView new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView<span class=\"token punctuation\">.</span>tableFooterView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIView new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"5、isKindOfClass和isMemberOfClass的区别\"><a href=\"#5、isKindOfClass和isMemberOfClass的区别\" class=\"headerlink\" title=\"5、isKindOfClass和isMemberOfClass的区别\"></a>5、isKindOfClass和isMemberOfClass的区别</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">isKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。\nisMemberOfClass更加精准，它只能判断这个对象类型是否为这个类<span class=\"token punctuation\">(</span>不能判断子类<span class=\"token punctuation\">)</span>\n</code></pre>\n<h4 id=\"6、-block\"><a href=\"#6、-block\" class=\"headerlink\" title=\"6、__block\"></a>6、__block</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">当一个局部变量需要在block里改变时，需要在定义时加上__block修饰，具体请看官方文档 http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>developer<span class=\"token punctuation\">.</span>apple<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>library<span class=\"token operator\">/</span>ios<span class=\"token operator\">/</span>documentation<span class=\"token operator\">/</span>cocoa<span class=\"token operator\">/</span>Conceptual<span class=\"token operator\">/</span>Blocks<span class=\"token operator\">/</span>Articles<span class=\"token operator\">/</span>bxVariables<span class=\"token punctuation\">.</span>html#<span class=\"token comment\" spellcheck=\"true\">//apple_ref/doc/uid/TP40007502-CH6-SW6</span>\n</code></pre>\n<h4 id=\"7、-ViewController-aMethod-unrecognized-selector-sent-to-instance-0x7fe91e607fb0\"><a href=\"#7、-ViewController-aMethod-unrecognized-selector-sent-to-instance-0x7fe91e607fb0\" class=\"headerlink\" title=\"7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0\"></a>7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0</h4><blockquote>\n<p>这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法</p>\n</blockquote>\n<h4 id=\"8、UITableView-failed-to-obtain-a-cell-from-its-dataSource\"><a href=\"#8、UITableView-failed-to-obtain-a-cell-from-its-dataSource\" class=\"headerlink\" title=\"8、UITableView () failed to obtain a cell from its dataSource ()\"></a>8、UITableView (<uitableview: 0x7ff19b027000;=\"\">) failed to obtain a cell from its dataSource (<viewcontroller: 0x7ff19a507520=\"\">)</viewcontroller:></uitableview:></h4><blockquote>\n<p>这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃</p>\n</blockquote>\n<h4 id=\"9、约束如何做UIView动画？\"><a href=\"#9、约束如何做UIView动画？\" class=\"headerlink\" title=\"9、约束如何做UIView动画？\"></a>9、约束如何做UIView动画？</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token number\">1</span>、把需要改的约束Constraint拖条线出来，成为属性\n<span class=\"token number\">2</span>、在需要动画的地方加入代码，改变此属性的constant属性\n<span class=\"token number\">3</span>、开始做UIView动画，动画里边调用layoutIfNeeded方法\n\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>weak<span class=\"token punctuation\">,</span> nonatomic<span class=\"token punctuation\">)</span> IBOutlet NSLayoutConstraint <span class=\"token operator\">*</span>buttonTopConstraint<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>buttonTopConstraint<span class=\"token punctuation\">.</span>constant <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>UIView animateWithDuration<span class=\"token punctuation\">:</span><span class=\"token punctuation\">.</span><span class=\"token number\">5</span> animations<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view layoutIfNeeded<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"10、从NSURL中拿到链接字符串\"><a href=\"#10、从NSURL中拿到链接字符串\" class=\"headerlink\" title=\"10、从NSURL中拿到链接字符串\"></a>10、从NSURL中拿到链接字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSString <span class=\"token operator\">*</span>urlString <span class=\"token operator\">=</span> myURL<span class=\"token punctuation\">.</span>absoluteString<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"11、将tableView滚动到顶部\"><a href=\"#11、将tableView滚动到顶部\" class=\"headerlink\" title=\"11、将tableView滚动到顶部\"></a>11、将tableView滚动到顶部</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>tableView setContentOffset<span class=\"token punctuation\">:</span>CGPointZero animated<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n或者\n<span class=\"token punctuation\">[</span>tableView scrollRectToVisible<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> animated<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"12、如果用addTarget-action-forControlEvents-方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\"><a href=\"#12、如果用addTarget-action-forControlEvents-方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\" class=\"headerlink\" title=\"12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\"></a>12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>youButton removeTarget<span class=\"token punctuation\">:</span>nil action<span class=\"token punctuation\">:</span>nil forControlEvents<span class=\"token punctuation\">:</span>UIControlEventAllEvents<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"13、某个字体的高度\"><a href=\"#13、某个字体的高度\" class=\"headerlink\" title=\"13、某个字体的高度\"></a>13、某个字体的高度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">font<span class=\"token punctuation\">.</span>lineHeight<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"14、删除某个view所有的子视图\"><a href=\"#14、删除某个view所有的子视图\" class=\"headerlink\" title=\"14、删除某个view所有的子视图\"></a>14、删除某个view所有的子视图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>someView subviews<span class=\"token punctuation\">]</span>\n makeObjectsPerformSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>removeFromSuperview<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"15、删除NSUserDefaults所有记录\"><a href=\"#15、删除NSUserDefaults所有记录\" class=\"headerlink\" title=\"15、删除NSUserDefaults所有记录\"></a>15、删除NSUserDefaults所有记录</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//方法一</span>\n  NSString <span class=\"token operator\">*</span>appDomain <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> bundleIdentifier<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSUserDefaults standardUserDefaults<span class=\"token punctuation\">]</span> removePersistentDomainForName<span class=\"token punctuation\">:</span>appDomain<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   \n <span class=\"token comment\" spellcheck=\"true\">//方法二  </span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>resetDefaults <span class=\"token punctuation\">{</span>   \n  NSUserDefaults <span class=\"token operator\">*</span> defs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSUserDefaults standardUserDefaults<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     NSDictionary <span class=\"token operator\">*</span> dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>defs dictionaryRepresentation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>id key <span class=\"token keyword\">in</span> dict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token punctuation\">[</span>defs removeObjectForKey<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">[</span>defs synchronize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 方法三</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSUserDefaults standardUserDefaults<span class=\"token punctuation\">]</span> setPersistentDomain<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSDictionary dictionary<span class=\"token punctuation\">]</span> forName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> bundleIdentifier<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"16、禁用系统滑动返回功能\"><a href=\"#16、禁用系统滑动返回功能\" class=\"headerlink\" title=\"16、禁用系统滑动返回功能\"></a>16、禁用系统滑动返回功能</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidAppear<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>animated\n<span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidAppear<span class=\"token punctuation\">:</span>animated<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController respondsToSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>interactivePopGestureRecognizer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController<span class=\"token punctuation\">.</span>interactivePopGestureRecognizer<span class=\"token punctuation\">.</span>delegate <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewWillDisappear<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>animated <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewWillDisappear<span class=\"token punctuation\">:</span>animated<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController respondsToSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>interactivePopGestureRecognizer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController<span class=\"token punctuation\">.</span>interactivePopGestureRecognizer<span class=\"token punctuation\">.</span>delegate <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>gestureRecognizerShouldBegin<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIGestureRecognizer <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>gestureRecognizer\n<span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"17、模拟器报错\"><a href=\"#17、模拟器报错\" class=\"headerlink\" title=\"17、模拟器报错\"></a>17、模拟器报错</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-76da2a462b9f1eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>解决办法：<br>打开模拟器-&gt;Simulator-&gt;Reset Content and Settings…<br>如果不行，就重启试试！</p>\n</blockquote>\n<h4 id=\"18、自定义cell选中背景颜色\"><a href=\"#18、自定义cell选中背景颜色\" class=\"headerlink\" title=\"18、自定义cell选中背景颜色\"></a>18、自定义cell选中背景颜色</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">UIView <span class=\"token operator\">*</span>bgColorView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIView alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nbgColorView<span class=\"token punctuation\">.</span>backgroundColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>cell setSelectedBackgroundView<span class=\"token punctuation\">:</span>bgColorView<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"19、UILabel设置内边距\"><a href=\"#19、UILabel设置内边距\" class=\"headerlink\" title=\"19、UILabel设置内边距\"></a>19、UILabel设置内边距</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">子类化UILabel，重写drawTextInRect方法\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>drawTextInRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>rect <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 边距，上左下右</span>\n    UIEdgeInsets insets <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> drawTextInRect<span class=\"token punctuation\">:</span><span class=\"token function\">UIEdgeInsetsInsetRect</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">,</span> insets<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"20、UILabel设置文字描边\"><a href=\"#20、UILabel设置文字描边\" class=\"headerlink\" title=\"20、UILabel设置文字描边\"></a>20、UILabel设置文字描边</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">子类化UILabel，重写drawTextInRect方法\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>drawTextInRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>rect\n<span class=\"token punctuation\">{</span>\n    CGContextRef c <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 设置描边宽度</span>\n    <span class=\"token function\">CGContextSetLineWidth</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextSetLineJoin</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> kCGLineJoinRound<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextSetTextDrawingMode</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> kCGTextStroke<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 描边颜色</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>textColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> drawTextInRect<span class=\"token punctuation\">:</span>rect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 文本颜色</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>textColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor yellowColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextSetTextDrawingMode</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> kCGTextFill<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> drawTextInRect<span class=\"token punctuation\">:</span>rect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"21、使用模拟器截图\"><a href=\"#21、使用模拟器截图\" class=\"headerlink\" title=\"21、使用模拟器截图\"></a>21、使用模拟器截图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">快捷键command <span class=\"token operator\">+</span> s\n或者File<span class=\"token operator\">-></span>Save Screen Shot\n</code></pre>\n<h4 id=\"22、scrollView滚动到最下边\"><a href=\"#22、scrollView滚动到最下边\" class=\"headerlink\" title=\"22、scrollView滚动到最下边\"></a>22、scrollView滚动到最下边</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">CGPoint bottomOffset <span class=\"token operator\">=</span> <span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> scrollView<span class=\"token punctuation\">.</span>contentSize<span class=\"token punctuation\">.</span>height <span class=\"token operator\">-</span> scrollView<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>scrollView setContentOffset<span class=\"token punctuation\">:</span>bottomOffset animated<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"23、UIView背景颜色渐变\"><a href=\"#23、UIView背景颜色渐变\" class=\"headerlink\" title=\"23、UIView背景颜色渐变\"></a>23、UIView背景颜色渐变</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    UIView <span class=\"token operator\">*</span>view <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIView alloc<span class=\"token punctuation\">]</span> initWithFrame<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">320</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>view addSubview<span class=\"token punctuation\">:</span>view<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CAGradientLayer <span class=\"token operator\">*</span>gradient <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAGradientLayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    gradient<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">;</span>\n    gradient<span class=\"token punctuation\">.</span>colors <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSArray arrayWithObjects<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor blackColor<span class=\"token punctuation\">]</span> CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIColor whiteColor<span class=\"token punctuation\">]</span> CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>view<span class=\"token punctuation\">.</span>layer insertSublayer<span class=\"token punctuation\">:</span>gradient atIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"24、停止UIView动画\"><a href=\"#24、停止UIView动画\" class=\"headerlink\" title=\"24、停止UIView动画\"></a>24、停止UIView动画</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>yourView<span class=\"token punctuation\">.</span>layer removeAllAnimations<span class=\"token punctuation\">]</span>\n</code></pre>\n<h4 id=\"25、为UIView某个角添加圆角\"><a href=\"#25、为UIView某个角添加圆角\" class=\"headerlink\" title=\"25、为UIView某个角添加圆角\"></a>25、为UIView某个角添加圆角</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 左上角和右下角添加圆角</span>\nUIBezierPath <span class=\"token operator\">*</span>maskPath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIBezierPath bezierPathWithRoundedRect<span class=\"token punctuation\">:</span>view<span class=\"token punctuation\">.</span>bounds byRoundingCorners<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIRectCornerTopLeft <span class=\"token operator\">|</span> UIRectCornerBottomRight<span class=\"token punctuation\">)</span> cornerRadii<span class=\"token punctuation\">:</span><span class=\"token function\">CGSizeMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CAShapeLayer <span class=\"token operator\">*</span>maskLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAShapeLayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    maskLayer<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">;</span>\n    maskLayer<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> maskPath<span class=\"token punctuation\">.</span>CGPath<span class=\"token punctuation\">;</span>\n    view<span class=\"token punctuation\">.</span>layer<span class=\"token punctuation\">.</span>mask <span class=\"token operator\">=</span> maskLayer<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"26、删除Xcode-Derived-data缓存数据\"><a href=\"#26、删除Xcode-Derived-data缓存数据\" class=\"headerlink\" title=\"26、删除Xcode Derived data缓存数据\"></a>26、删除Xcode Derived data缓存数据</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-6da089f7000ad432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"27、将一个view放置在其兄弟视图的最上面\"><a href=\"#27、将一个view放置在其兄弟视图的最上面\" class=\"headerlink\" title=\"27、将一个view放置在其兄弟视图的最上面\"></a>27、将一个view放置在其兄弟视图的最上面</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>parentView bringSubviewToFront<span class=\"token punctuation\">:</span>yourView<span class=\"token punctuation\">]</span>\n</code></pre>\n<h4 id=\"28、将一个view放置在其兄弟视图的最下面\"><a href=\"#28、将一个view放置在其兄弟视图的最下面\" class=\"headerlink\" title=\"28、将一个view放置在其兄弟视图的最下面\"></a>28、将一个view放置在其兄弟视图的最下面</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>parentView sendSubviewToBack<span class=\"token punctuation\">:</span>yourView<span class=\"token punctuation\">]</span>\n</code></pre>\n<h4 id=\"29、让手机震动一下\"><a href=\"#29、让手机震动一下\" class=\"headerlink\" title=\"29、让手机震动一下\"></a>29、让手机震动一下</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">倒入框架\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;AudioToolbox/AudioToolbox.h></span>\n<span class=\"token function\">AudioServicesPlayAlertSound</span><span class=\"token punctuation\">(</span>kSystemSoundID_Vibrate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n或者\n<span class=\"token function\">AudioServicesPlaySystemSound</span><span class=\"token punctuation\">(</span>kSystemSoundID_Vibrate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"30、layoutSubviews方法什么时候调用？\"><a href=\"#30、layoutSubviews方法什么时候调用？\" class=\"headerlink\" title=\"30、layoutSubviews方法什么时候调用？\"></a>30、layoutSubviews方法什么时候调用？</h4><blockquote>\n<p>1、init方法不会调用<br>2、addSubview方法等时候会调用<br>3、bounds改变的时候调用<br>4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)<br>5、旋转设备的时候调用<br>6、子视图被移除的时候调用<br>参考请看：<a href=\"http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/\" target=\"_blank\" rel=\"external\">http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/</a></p>\n</blockquote>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、获取视频的时长\"><a href=\"#1、获取视频的时长\" class=\"headerlink\" title=\"1、获取视频的时长\"></a>1、获取视频的时长</h4><pre><code class=\"objectivec\">+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString {\n    NSURL *videoUrl = [NSURL URLWithString:urlString];\n    AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl];\n    CMTime time = [avUrl duration];\n    int seconds = ceil(time.value/time.timescale);\n    return seconds;\n}\n</code></pre>\n<h4 id=\"2、字符串是否为空\"><a href=\"#2、字符串是否为空\" class=\"headerlink\" title=\"2、字符串是否为空\"></a>2、字符串是否为空</h4><pre><code class=\"objectivec\">+ (BOOL)isEqualToNil:(NSString *)str {\n    return str.length &lt;= 0 || [str isEqualToString:@&quot;&quot;] || !str;\n}\n</code></pre>\n<h4 id=\"3、将app上传到App-Store的时候通常会遇到这个问题\"><a href=\"#3、将app上传到App-Store的时候通常会遇到这个问题\" class=\"headerlink\" title=\"3、将app上传到App Store的时候通常会遇到这个问题\"></a>3、将app上传到App Store的时候通常会遇到这个问题</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-8b75d749ac20c31e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！<br>但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。<br>如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。</p>\n</blockquote>\n<h4 id=\"4、当tableView占不满一屏时，去除下边多余的单元格\"><a href=\"#4、当tableView占不满一屏时，去除下边多余的单元格\" class=\"headerlink\" title=\"4、当tableView占不满一屏时，去除下边多余的单元格\"></a>4、当tableView占不满一屏时，去除下边多余的单元格</h4><pre><code class=\"objectivec\">self.tableView.tableHeaderView = [UIView new];\nself.tableView.tableFooterView = [UIView new];\n</code></pre>\n<h4 id=\"5、isKindOfClass和isMemberOfClass的区别\"><a href=\"#5、isKindOfClass和isMemberOfClass的区别\" class=\"headerlink\" title=\"5、isKindOfClass和isMemberOfClass的区别\"></a>5、isKindOfClass和isMemberOfClass的区别</h4><pre><code class=\"objectivec\">isKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。\nisMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类)\n</code></pre>\n<h4 id=\"6、-block\"><a href=\"#6、-block\" class=\"headerlink\" title=\"6、__block\"></a>6、__block</h4><pre><code class=\"objectivec\">当一个局部变量需要在block里改变时，需要在定义时加上__block修饰，具体请看官方文档 http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6\n</code></pre>\n<h4 id=\"7、-ViewController-aMethod-unrecognized-selector-sent-to-instance-0x7fe91e607fb0\"><a href=\"#7、-ViewController-aMethod-unrecognized-selector-sent-to-instance-0x7fe91e607fb0\" class=\"headerlink\" title=\"7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0\"></a>7、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0</h4><blockquote>\n<p>这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法</p>\n</blockquote>\n<h4 id=\"8、UITableView-failed-to-obtain-a-cell-from-its-dataSource\"><a href=\"#8、UITableView-failed-to-obtain-a-cell-from-its-dataSource\" class=\"headerlink\" title=\"8、UITableView () failed to obtain a cell from its dataSource ()\"></a>8、UITableView (<uitableview: 0x7ff19b027000;=\"\">) failed to obtain a cell from its dataSource (<viewcontroller: 0x7ff19a507520=\"\">)</viewcontroller:></uitableview:></h4><blockquote>\n<p>这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃</p>\n</blockquote>\n<h4 id=\"9、约束如何做UIView动画？\"><a href=\"#9、约束如何做UIView动画？\" class=\"headerlink\" title=\"9、约束如何做UIView动画？\"></a>9、约束如何做UIView动画？</h4><pre><code class=\"objectivec\">1、把需要改的约束Constraint拖条线出来，成为属性\n2、在需要动画的地方加入代码，改变此属性的constant属性\n3、开始做UIView动画，动画里边调用layoutIfNeeded方法\n\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint;\nself.buttonTopConstraint.constant = 100;\n    [UIView animateWithDuration:.5 animations:^{\n        [self.view layoutIfNeeded];\n    }];\n</code></pre>\n<h4 id=\"10、从NSURL中拿到链接字符串\"><a href=\"#10、从NSURL中拿到链接字符串\" class=\"headerlink\" title=\"10、从NSURL中拿到链接字符串\"></a>10、从NSURL中拿到链接字符串</h4><pre><code class=\"objectivec\">NSString *urlString = myURL.absoluteString;\n</code></pre>\n<h4 id=\"11、将tableView滚动到顶部\"><a href=\"#11、将tableView滚动到顶部\" class=\"headerlink\" title=\"11、将tableView滚动到顶部\"></a>11、将tableView滚动到顶部</h4><pre><code class=\"objectivec\">[tableView setContentOffset:CGPointZero animated:YES];\n或者\n[tableView scrollRectToVisible:CGRectMake(0, 0, 1, 1) animated:YES];\n</code></pre>\n<h4 id=\"12、如果用addTarget-action-forControlEvents-方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\"><a href=\"#12、如果用addTarget-action-forControlEvents-方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\" class=\"headerlink\" title=\"12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码\"></a>12、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码</h4><pre><code class=\"objectivec\">[youButton removeTarget:nil action:nil forControlEvents:UIControlEventAllEvents];\n</code></pre>\n<h4 id=\"13、某个字体的高度\"><a href=\"#13、某个字体的高度\" class=\"headerlink\" title=\"13、某个字体的高度\"></a>13、某个字体的高度</h4><pre><code class=\"objectivec\">font.lineHeight;\n</code></pre>\n<h4 id=\"14、删除某个view所有的子视图\"><a href=\"#14、删除某个view所有的子视图\" class=\"headerlink\" title=\"14、删除某个view所有的子视图\"></a>14、删除某个view所有的子视图</h4><pre><code class=\"objectivec\">[[someView subviews]\n makeObjectsPerformSelector:@selector(removeFromSuperview)];\n</code></pre>\n<h4 id=\"15、删除NSUserDefaults所有记录\"><a href=\"#15、删除NSUserDefaults所有记录\" class=\"headerlink\" title=\"15、删除NSUserDefaults所有记录\"></a>15、删除NSUserDefaults所有记录</h4><pre><code class=\"objectivec\">//方法一\n  NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];\n [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];   \n //方法二  \n- (void)resetDefaults {   \n  NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];\n     NSDictionary * dict = [defs dictionaryRepresentation];\n     for (id key in dict) {\n          [defs removeObjectForKey:key];\n     }\n      [defs synchronize];\n }\n// 方法三\n[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]];\n</code></pre>\n<h4 id=\"16、禁用系统滑动返回功能\"><a href=\"#16、禁用系统滑动返回功能\" class=\"headerlink\" title=\"16、禁用系统滑动返回功能\"></a>16、禁用系统滑动返回功能</h4><pre><code class=\"objectivec\">- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\nif ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self;\n    }\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n    if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil;\n    }\n}\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer\n{\n     return NO;\n}\n</code></pre>\n<h4 id=\"17、模拟器报错\"><a href=\"#17、模拟器报错\" class=\"headerlink\" title=\"17、模拟器报错\"></a>17、模拟器报错</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-76da2a462b9f1eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>解决办法：<br>打开模拟器-&gt;Simulator-&gt;Reset Content and Settings…<br>如果不行，就重启试试！</p>\n</blockquote>\n<h4 id=\"18、自定义cell选中背景颜色\"><a href=\"#18、自定义cell选中背景颜色\" class=\"headerlink\" title=\"18、自定义cell选中背景颜色\"></a>18、自定义cell选中背景颜色</h4><pre><code class=\"objectivec\">UIView *bgColorView = [[UIView alloc] init];\nbgColorView.backgroundColor = [UIColor redColor];\n[cell setSelectedBackgroundView:bgColorView];\n</code></pre>\n<h4 id=\"19、UILabel设置内边距\"><a href=\"#19、UILabel设置内边距\" class=\"headerlink\" title=\"19、UILabel设置内边距\"></a>19、UILabel设置内边距</h4><pre><code class=\"objectivec\">子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect {\n    // 边距，上左下右\n    UIEdgeInsets insets = {0, 5, 0, 5};\n    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];\n}\n</code></pre>\n<h4 id=\"20、UILabel设置文字描边\"><a href=\"#20、UILabel设置文字描边\" class=\"headerlink\" title=\"20、UILabel设置文字描边\"></a>20、UILabel设置文字描边</h4><pre><code class=\"objectivec\">子类化UILabel，重写drawTextInRect方法\n- (void)drawTextInRect:(CGRect)rect\n{\n    CGContextRef c = UIGraphicsGetCurrentContext();\n    // 设置描边宽度\n    CGContextSetLineWidth(c, 1);\n    CGContextSetLineJoin(c, kCGLineJoinRound);\n    CGContextSetTextDrawingMode(c, kCGTextStroke);\n    // 描边颜色\n    self.textColor = [UIColor redColor];\n    [super drawTextInRect:rect];\n    // 文本颜色\n    self.textColor = [UIColor yellowColor];\n    CGContextSetTextDrawingMode(c, kCGTextFill);\n    [super drawTextInRect:rect];\n}\n</code></pre>\n<h4 id=\"21、使用模拟器截图\"><a href=\"#21、使用模拟器截图\" class=\"headerlink\" title=\"21、使用模拟器截图\"></a>21、使用模拟器截图</h4><pre><code class=\"objectivec\">快捷键command + s\n或者File-&gt;Save Screen Shot\n</code></pre>\n<h4 id=\"22、scrollView滚动到最下边\"><a href=\"#22、scrollView滚动到最下边\" class=\"headerlink\" title=\"22、scrollView滚动到最下边\"></a>22、scrollView滚动到最下边</h4><pre><code class=\"objectivec\">CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);\n[scrollView setContentOffset:bottomOffset animated:YES];\n</code></pre>\n<h4 id=\"23、UIView背景颜色渐变\"><a href=\"#23、UIView背景颜色渐变\" class=\"headerlink\" title=\"23、UIView背景颜色渐变\"></a>23、UIView背景颜色渐变</h4><pre><code class=\"objectivec\">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)];\n    [self.view addSubview:view];\n    CAGradientLayer *gradient = [CAGradientLayer layer];\n    gradient.frame = view.bounds;\n    gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil];\n    [view.layer insertSublayer:gradient atIndex:0];\n</code></pre>\n<h4 id=\"24、停止UIView动画\"><a href=\"#24、停止UIView动画\" class=\"headerlink\" title=\"24、停止UIView动画\"></a>24、停止UIView动画</h4><pre><code class=\"objectivec\">[yourView.layer removeAllAnimations]\n</code></pre>\n<h4 id=\"25、为UIView某个角添加圆角\"><a href=\"#25、为UIView某个角添加圆角\" class=\"headerlink\" title=\"25、为UIView某个角添加圆角\"></a>25、为UIView某个角添加圆角</h4><pre><code class=\"objectivec\">// 左上角和右下角添加圆角\nUIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];\n    CAShapeLayer *maskLayer = [CAShapeLayer layer];\n    maskLayer.frame = view.bounds;\n    maskLayer.path = maskPath.CGPath;\n    view.layer.mask = maskLayer;\n</code></pre>\n<h4 id=\"26、删除Xcode-Derived-data缓存数据\"><a href=\"#26、删除Xcode-Derived-data缓存数据\" class=\"headerlink\" title=\"26、删除Xcode Derived data缓存数据\"></a>26、删除Xcode Derived data缓存数据</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1432270-6da089f7000ad432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"27、将一个view放置在其兄弟视图的最上面\"><a href=\"#27、将一个view放置在其兄弟视图的最上面\" class=\"headerlink\" title=\"27、将一个view放置在其兄弟视图的最上面\"></a>27、将一个view放置在其兄弟视图的最上面</h4><pre><code class=\"objectivec\">[parentView bringSubviewToFront:yourView]\n</code></pre>\n<h4 id=\"28、将一个view放置在其兄弟视图的最下面\"><a href=\"#28、将一个view放置在其兄弟视图的最下面\" class=\"headerlink\" title=\"28、将一个view放置在其兄弟视图的最下面\"></a>28、将一个view放置在其兄弟视图的最下面</h4><pre><code class=\"objectivec\">[parentView sendSubviewToBack:yourView]\n</code></pre>\n<h4 id=\"29、让手机震动一下\"><a href=\"#29、让手机震动一下\" class=\"headerlink\" title=\"29、让手机震动一下\"></a>29、让手机震动一下</h4><pre><code class=\"objectivec\">倒入框架\n#import &lt;AudioToolbox/AudioToolbox.h&gt;\nAudioServicesPlayAlertSound(kSystemSoundID_Vibrate);\n或者\nAudioServicesPlaySystemSound(kSystemSoundID_Vibrate);\n</code></pre>\n<h4 id=\"30、layoutSubviews方法什么时候调用？\"><a href=\"#30、layoutSubviews方法什么时候调用？\" class=\"headerlink\" title=\"30、layoutSubviews方法什么时候调用？\"></a>30、layoutSubviews方法什么时候调用？</h4><blockquote>\n<p>1、init方法不会调用<br>2、addSubview方法等时候会调用<br>3、bounds改变的时候调用<br>4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)<br>5、旋转设备的时候调用<br>6、子视图被移除的时候调用<br>参考请看：<a href=\"http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/\" target=\"_blank\" rel=\"external\">http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/</a></p>\n</blockquote>\n"},{"title":"iOS小经验（一）","date":"2016-02-10T01:53:06.000Z","_content":"#### 1、禁止手机睡眠\n```objectivec\n[UIApplication sharedApplication].idleTimerDisabled = YES;\n```\n\n#### 2、隐藏某行cell\n```objectivec\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n// 如果是你需要隐藏的那一行，返回高度为0\n    if(indexPath.row == YouWantToHideRow)\n        return 0; \n    return 44;\n}\n\n// 然后再你需要隐藏cell的时候调用\n[self.tableView beginUpdates];\n[self.tableView endUpdates];\n```\n\n#### 3、禁用button高亮\n```objectivec\nbutton.adjustsImageWhenHighlighted = NO;\n或者在创建的时候\n UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n```\n\n#### 4、tableview遇到这种报错failed to obtain a cell from its dataSource\n> 是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了\n> 可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你\n> 想要的类型)，这时候需要改下cell的标识\n\n#### 5、cocoa pods报这个错误：unable to access '[https://github.com/facebook/pop.git/](https://github.com/facebook/pop.git/)': Operation timed out after 0 milliseconds with 0 out of 0 bytes received\n> 解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了\n\n#### 6、cocoa pods 出现ERROR: While executing gem ... (Errno::EPERM)\n> [解决办法：https://segmentfault.com/q/1010000002926243](https://segmentfault.com/q/1010000002926243)\n\n#### 7、动画切换window的根控制器\n```objectivec\n// options是动画选项\n[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{\n        BOOL oldState = [UIView areAnimationsEnabled];\n        [UIView setAnimationsEnabled:NO];\n        [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];\n        [UIView setAnimationsEnabled:oldState];\n    } completion:^(BOOL finished) {\n\n    }];\n```\n\n#### 8、去除数组中重复的对象\n```objectivec\nNSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self\"];\n```\n\n#### 9、编译的时候遇到 no such file or directory: ／users／apple／XXX\n> 是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可\n\n#### 10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\n\n#### 11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\n```objectivec\n// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n\n}\n```\n\n#### 12、三个通知\n>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化\nUIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）\n\n\n#### 13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\n\n#### 14、上线前注意：\n> 1）、删掉代码中所有的测试代码\n2）、如果后台有审核模式，提醒后台开启此模式\n3）、主流程再跑一跑\n4）、全局搜索waring，检查所有标记waring的地方\n\n#### 15、跳进app权限设置\n\n```objectivec\n// 跳进app设置\n            if (UIApplicationOpenSettingsURLString != NULL) {\n                UIApplication *application = [UIApplication sharedApplication];\n                NSURL *URL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];\n                if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {\n                    [application openURL:URL options:@{}\n                       completionHandler:nil];\n                } else {\n                    [application openURL:URL];\n                }\n            }\n```\n\n#### 16、给一个view截图\n```objectivec\nUIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n```\n\n#### 17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\n\n#### 18、注意对象为nil的时候，调用此对象分类的方法不会执行\n\n#### 19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\n```objectivec\ncollectionView.alwaysBounceHorizontal = YES;\ncollectionView.alwaysBounceVertical = YES;\n```\n\n#### 20、设置navigationBar上的title颜色和大小\n```objectivec\n    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}]\n```\n\n#### 21、颜色转图片\n```objectivec\n+ (UIImage *)cl_imageWithColor:(UIColor *)color {\n  CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);\n  UIGraphicsBeginImageContext(rect.size);\n  CGContextRef context = UIGraphicsGetCurrentContext();\n\n  CGContextSetFillColorWithColor(context, [color CGColor]);\n  CGContextFillRect(context, rect);\n\n  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n  UIGraphicsEndImageContext();\n\n  return image;\n}\n```\n#### 22、view设置圆角\n\n```objectivec\n#define ViewBorderRadius(View, Radius, Width, Color)\\\n\\\n[View.layer setCornerRadius:(Radius)];\\\n[View.layer setMasksToBounds:YES];\\\n[View.layer setBorderWidth:(Width)];\\\n[View.layer setBorderColor:[Color CGColor]] // view圆角\n```\n\n#### 23、强／弱引用\n```objectivec\n#define WeakSelf(type)  __weak typeof(type) weak##type = type; // weak\n#define StrongSelf(type)  __strong typeof(type) type = weak##type; // strong\n```\n\n24、由角度转换弧度\n```objectivec\n#define DegreesToRadian(x) (M_PI * (x) / 180.0)\n```\n\n25、由弧度转换角度\n```objectivec\n#define RadianToDegrees(radian) (radian*180.0)/(M_PI)\n```\n\n26、获取图片资源\n```objectivec\n#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@\"%@\",imageName]]\n```\n\n27、获取temp\n```objectivec\n#define PathTemp NSTemporaryDirectory()\n```\n\n28、获取沙盒 Document\n```objectivec\n#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]\n```\n\n29、获取沙盒 Cache\n```objectivec\n#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]\n```\n\n30、GCD代码只执行一次\n```objectivec\n#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&onceToken, onceBlock);\n```\n\n","source":"_posts/iOS小经验（一）.md","raw":"---\ntitle: iOS小经验（一）\ndate: 2016-02-10 09:53:06\ncategories: \n\t- iOS小经验\n---\n#### 1、禁止手机睡眠\n```objectivec\n[UIApplication sharedApplication].idleTimerDisabled = YES;\n```\n\n#### 2、隐藏某行cell\n```objectivec\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n// 如果是你需要隐藏的那一行，返回高度为0\n    if(indexPath.row == YouWantToHideRow)\n        return 0; \n    return 44;\n}\n\n// 然后再你需要隐藏cell的时候调用\n[self.tableView beginUpdates];\n[self.tableView endUpdates];\n```\n\n#### 3、禁用button高亮\n```objectivec\nbutton.adjustsImageWhenHighlighted = NO;\n或者在创建的时候\n UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n```\n\n#### 4、tableview遇到这种报错failed to obtain a cell from its dataSource\n> 是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了\n> 可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你\n> 想要的类型)，这时候需要改下cell的标识\n\n#### 5、cocoa pods报这个错误：unable to access '[https://github.com/facebook/pop.git/](https://github.com/facebook/pop.git/)': Operation timed out after 0 milliseconds with 0 out of 0 bytes received\n> 解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了\n\n#### 6、cocoa pods 出现ERROR: While executing gem ... (Errno::EPERM)\n> [解决办法：https://segmentfault.com/q/1010000002926243](https://segmentfault.com/q/1010000002926243)\n\n#### 7、动画切换window的根控制器\n```objectivec\n// options是动画选项\n[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{\n        BOOL oldState = [UIView areAnimationsEnabled];\n        [UIView setAnimationsEnabled:NO];\n        [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];\n        [UIView setAnimationsEnabled:oldState];\n    } completion:^(BOOL finished) {\n\n    }];\n```\n\n#### 8、去除数组中重复的对象\n```objectivec\nNSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self\"];\n```\n\n#### 9、编译的时候遇到 no such file or directory: ／users／apple／XXX\n> 是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可\n\n#### 10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\n\n#### 11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\n```objectivec\n// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n\n}\n```\n\n#### 12、三个通知\n>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化\nUIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）\n\n\n#### 13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\n\n#### 14、上线前注意：\n> 1）、删掉代码中所有的测试代码\n2）、如果后台有审核模式，提醒后台开启此模式\n3）、主流程再跑一跑\n4）、全局搜索waring，检查所有标记waring的地方\n\n#### 15、跳进app权限设置\n\n```objectivec\n// 跳进app设置\n            if (UIApplicationOpenSettingsURLString != NULL) {\n                UIApplication *application = [UIApplication sharedApplication];\n                NSURL *URL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];\n                if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {\n                    [application openURL:URL options:@{}\n                       completionHandler:nil];\n                } else {\n                    [application openURL:URL];\n                }\n            }\n```\n\n#### 16、给一个view截图\n```objectivec\nUIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n```\n\n#### 17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\n\n#### 18、注意对象为nil的时候，调用此对象分类的方法不会执行\n\n#### 19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\n```objectivec\ncollectionView.alwaysBounceHorizontal = YES;\ncollectionView.alwaysBounceVertical = YES;\n```\n\n#### 20、设置navigationBar上的title颜色和大小\n```objectivec\n    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}]\n```\n\n#### 21、颜色转图片\n```objectivec\n+ (UIImage *)cl_imageWithColor:(UIColor *)color {\n  CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);\n  UIGraphicsBeginImageContext(rect.size);\n  CGContextRef context = UIGraphicsGetCurrentContext();\n\n  CGContextSetFillColorWithColor(context, [color CGColor]);\n  CGContextFillRect(context, rect);\n\n  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n  UIGraphicsEndImageContext();\n\n  return image;\n}\n```\n#### 22、view设置圆角\n\n```objectivec\n#define ViewBorderRadius(View, Radius, Width, Color)\\\n\\\n[View.layer setCornerRadius:(Radius)];\\\n[View.layer setMasksToBounds:YES];\\\n[View.layer setBorderWidth:(Width)];\\\n[View.layer setBorderColor:[Color CGColor]] // view圆角\n```\n\n#### 23、强／弱引用\n```objectivec\n#define WeakSelf(type)  __weak typeof(type) weak##type = type; // weak\n#define StrongSelf(type)  __strong typeof(type) type = weak##type; // strong\n```\n\n24、由角度转换弧度\n```objectivec\n#define DegreesToRadian(x) (M_PI * (x) / 180.0)\n```\n\n25、由弧度转换角度\n```objectivec\n#define RadianToDegrees(radian) (radian*180.0)/(M_PI)\n```\n\n26、获取图片资源\n```objectivec\n#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@\"%@\",imageName]]\n```\n\n27、获取temp\n```objectivec\n#define PathTemp NSTemporaryDirectory()\n```\n\n28、获取沙盒 Document\n```objectivec\n#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]\n```\n\n29、获取沙盒 Cache\n```objectivec\n#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]\n```\n\n30、GCD代码只执行一次\n```objectivec\n#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&onceToken, onceBlock);\n```\n\n","slug":"iOS小经验（一）","published":1,"updated":"2017-07-10T10:22:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tw40013znuzfci7lmxr","content":"<h4 id=\"1、禁止手机睡眠\"><a href=\"#1、禁止手机睡眠\" class=\"headerlink\" title=\"1、禁止手机睡眠\"></a>1、禁止手机睡眠</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>idleTimerDisabled <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"2、隐藏某行cell\"><a href=\"#2、隐藏某行cell\" class=\"headerlink\" title=\"2、隐藏某行cell\"></a>2、隐藏某行cell</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>tableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView heightForRowAtIndexPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSIndexPath <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>indexPath\n<span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 如果是你需要隐藏的那一行，返回高度为0</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>indexPath<span class=\"token punctuation\">.</span>row <span class=\"token operator\">==</span> YouWantToHideRow<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">44</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 然后再你需要隐藏cell的时候调用</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView beginUpdates<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>tableView endUpdates<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"3、禁用button高亮\"><a href=\"#3、禁用button高亮\" class=\"headerlink\" title=\"3、禁用button高亮\"></a>3、禁用button高亮</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">button<span class=\"token punctuation\">.</span>adjustsImageWhenHighlighted <span class=\"token operator\">=</span> NO<span class=\"token punctuation\">;</span>\n或者在创建的时候\n UIButton <span class=\"token operator\">*</span>button <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIButton buttonWithType<span class=\"token punctuation\">:</span>UIButtonTypeCustom<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"4、tableview遇到这种报错failed-to-obtain-a-cell-from-its-dataSource\"><a href=\"#4、tableview遇到这种报错failed-to-obtain-a-cell-from-its-dataSource\" class=\"headerlink\" title=\"4、tableview遇到这种报错failed to obtain a cell from its dataSource\"></a>4、tableview遇到这种报错failed to obtain a cell from its dataSource</h4><blockquote>\n<p>是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了<br>可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你<br>想要的类型)，这时候需要改下cell的标识</p>\n</blockquote>\n<h4 id=\"5、cocoa-pods报这个错误：unable-to-access-‘https-github-com-facebook-pop-git-‘-Operation-timed-out-after-0-milliseconds-with-0-out-of-0-bytes-received\"><a href=\"#5、cocoa-pods报这个错误：unable-to-access-‘https-github-com-facebook-pop-git-‘-Operation-timed-out-after-0-milliseconds-with-0-out-of-0-bytes-received\" class=\"headerlink\" title=\"5、cocoa pods报这个错误：unable to access ‘https://github.com/facebook/pop.git/‘: Operation timed out after 0 milliseconds with 0 out of 0 bytes received\"></a>5、cocoa pods报这个错误：unable to access ‘<a href=\"https://github.com/facebook/pop.git/\" target=\"_blank\" rel=\"external\">https://github.com/facebook/pop.git/</a>‘: Operation timed out after 0 milliseconds with 0 out of 0 bytes received</h4><blockquote>\n<p>解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了</p>\n</blockquote>\n<h4 id=\"6、cocoa-pods-出现ERROR-While-executing-gem-…-Errno-EPERM\"><a href=\"#6、cocoa-pods-出现ERROR-While-executing-gem-…-Errno-EPERM\" class=\"headerlink\" title=\"6、cocoa pods 出现ERROR: While executing gem … (Errno::EPERM)\"></a>6、cocoa pods 出现ERROR: While executing gem … (Errno::EPERM)</h4><blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002926243\" target=\"_blank\" rel=\"external\">解决办法：https://segmentfault.com/q/1010000002926243</a></p>\n</blockquote>\n<h4 id=\"7、动画切换window的根控制器\"><a href=\"#7、动画切换window的根控制器\" class=\"headerlink\" title=\"7、动画切换window的根控制器\"></a>7、动画切换window的根控制器</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// options是动画选项</span>\n<span class=\"token punctuation\">[</span>UIView transitionWithView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>keyWindow duration<span class=\"token punctuation\">:</span><span class=\"token number\">0.5f</span> options<span class=\"token punctuation\">:</span>UIViewAnimationOptionTransitionCrossDissolve animations<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        BOOL oldState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIView areAnimationsEnabled<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>UIView setAnimationsEnabled<span class=\"token punctuation\">:</span>NO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>keyWindow<span class=\"token punctuation\">.</span>rootViewController <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>RootViewController new<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>UIView setAnimationsEnabled<span class=\"token punctuation\">:</span>oldState<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> completion<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>BOOL finished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"8、去除数组中重复的对象\"><a href=\"#8、去除数组中重复的对象\" class=\"headerlink\" title=\"8、去除数组中重复的对象\"></a>8、去除数组中重复的对象</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>newArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>oldArr valueForKeyPath<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span>“<span class=\"token operator\">@</span>distinctUnionOfObjects<span class=\"token punctuation\">.</span><span class=\"token keyword\">self</span>\"<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"9、编译的时候遇到-no-such-file-or-directory-／users／apple／XXX\"><a href=\"#9、编译的时候遇到-no-such-file-or-directory-／users／apple／XXX\" class=\"headerlink\" title=\"9、编译的时候遇到 no such file or directory: ／users／apple／XXX\"></a>9、编译的时候遇到 no such file or directory: ／users／apple／XXX</h4><blockquote>\n<p>是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可</p>\n</blockquote>\n<h4 id=\"10、iOS8系统中，tableView最好实现下-tableView-heightForRowAtIndexPath-这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\"><a href=\"#10、iOS8系统中，tableView最好实现下-tableView-heightForRowAtIndexPath-这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\" class=\"headerlink\" title=\"10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\"></a>10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题</h4><h4 id=\"11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\"><a href=\"#11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\" class=\"headerlink\" title=\"11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\"></a>11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>tableView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>tableView commitEditingStyle<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UITableViewCellEditingStyle<span class=\"token punctuation\">)</span>editingStyle forRowAtIndexPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSIndexPath <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>indexPath <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12、三个通知\"><a href=\"#12、三个通知\" class=\"headerlink\" title=\"12、三个通知\"></a>12、三个通知</h4><blockquote>\n<p>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化<br>UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）</p>\n</blockquote>\n<h4 id=\"13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张-所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\"><a href=\"#13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张-所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\" class=\"headerlink\" title=\"13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\"></a>13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。</h4><h4 id=\"14、上线前注意：\"><a href=\"#14、上线前注意：\" class=\"headerlink\" title=\"14、上线前注意：\"></a>14、上线前注意：</h4><blockquote>\n<p>1）、删掉代码中所有的测试代码<br>2）、如果后台有审核模式，提醒后台开启此模式<br>3）、主流程再跑一跑<br>4）、全局搜索waring，检查所有标记waring的地方</p>\n</blockquote>\n<h4 id=\"15、跳进app权限设置\"><a href=\"#15、跳进app权限设置\" class=\"headerlink\" title=\"15、跳进app权限设置\"></a>15、跳进app权限设置</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 跳进app设置</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>UIApplicationOpenSettingsURLString <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                UIApplication <span class=\"token operator\">*</span>application <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                NSURL <span class=\"token operator\">*</span>URL <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSURL URLWithString<span class=\"token punctuation\">:</span>UIApplicationOpenSettingsURLString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>application respondsToSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>openURL<span class=\"token punctuation\">:</span>options<span class=\"token punctuation\">:</span>completionHandler<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">[</span>application openURL<span class=\"token punctuation\">:</span>URL options<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n                       completionHandler<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token punctuation\">[</span>application openURL<span class=\"token punctuation\">:</span>URL<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"16、给一个view截图\"><a href=\"#16、给一个view截图\" class=\"headerlink\" title=\"16、给一个view截图\"></a>16、给一个view截图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">UIGraphicsBeginImageContextWithOptions</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> YES<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>view<span class=\"token punctuation\">.</span>layer renderInContext<span class=\"token punctuation\">:</span><span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>img <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView-tableFooterView-更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\"><a href=\"#17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView-tableFooterView-更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\" class=\"headerlink\" title=\"17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\"></a>17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。</h4><h4 id=\"18、注意对象为nil的时候，调用此对象分类的方法不会执行\"><a href=\"#18、注意对象为nil的时候，调用此对象分类的方法不会执行\" class=\"headerlink\" title=\"18、注意对象为nil的时候，调用此对象分类的方法不会执行\"></a>18、注意对象为nil的时候，调用此对象分类的方法不会执行</h4><h4 id=\"19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\"><a href=\"#19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\" class=\"headerlink\" title=\"19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\"></a>19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">collectionView<span class=\"token punctuation\">.</span>alwaysBounceHorizontal <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\ncollectionView<span class=\"token punctuation\">.</span>alwaysBounceVertical <span class=\"token operator\">=</span> YES<span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"20、设置navigationBar上的title颜色和大小\"><a href=\"#20、设置navigationBar上的title颜色和大小\" class=\"headerlink\" title=\"20、设置navigationBar上的title颜色和大小\"></a>20、设置navigationBar上的title颜色和大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>navigationController<span class=\"token punctuation\">.</span>navigationBar setTitleTextAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>NSForegroundColorAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIColor youColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> NSFontAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">15</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<h4 id=\"21、颜色转图片\"><a href=\"#21、颜色转图片\" class=\"headerlink\" title=\"21、颜色转图片\"></a>21、颜色转图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>cl_imageWithColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>color <span class=\"token punctuation\">{</span>\n  CGRect rect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  CGContextRef context <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">CGContextSetFillColorWithColor</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>color CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">CGContextFillRect</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"22、view设置圆角\"><a href=\"#22、view设置圆角\" class=\"headerlink\" title=\"22、view设置圆角\"></a>22、view设置圆角</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ViewBorderRadius(View, Radius, Width, Color)\\\n\\\n[View.layer setCornerRadius:(Radius)];\\\n[View.layer setMasksToBounds:YES];\\\n[View.layer setBorderWidth:(Width)];\\\n[View.layer setBorderColor:[Color CGColor]] </span><span class=\"token comment\" spellcheck=\"true\">// view圆角</span>\n</code></pre>\n<h4 id=\"23、强／弱引用\"><a href=\"#23、强／弱引用\" class=\"headerlink\" title=\"23、强／弱引用\"></a>23、强／弱引用</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> WeakSelf(type)  __weak typeof(type) weak##type = type; </span><span class=\"token comment\" spellcheck=\"true\">// weak</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> StrongSelf(type)  __strong typeof(type) type = weak##type; </span><span class=\"token comment\" spellcheck=\"true\">// strong</span>\n</code></pre>\n<p>24、由角度转换弧度</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DegreesToRadian(x) (M_PI * (x) / 180.0)</span>\n</code></pre>\n<p>25、由弧度转换角度</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> RadianToDegrees(radian) (radian*180.0)/(M_PI)</span>\n</code></pre>\n<p>26、获取图片资源</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@\"%@\",imageName]]</span>\n</code></pre>\n<p>27、获取temp</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> PathTemp NSTemporaryDirectory()</span>\n</code></pre>\n<p>28、获取沙盒 Document</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]</span>\n</code></pre>\n<p>29、获取沙盒 Cache</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</span>\n</code></pre>\n<p>30、GCD代码只执行一次</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1、禁止手机睡眠\"><a href=\"#1、禁止手机睡眠\" class=\"headerlink\" title=\"1、禁止手机睡眠\"></a>1、禁止手机睡眠</h4><pre><code class=\"objectivec\">[UIApplication sharedApplication].idleTimerDisabled = YES;\n</code></pre>\n<h4 id=\"2、隐藏某行cell\"><a href=\"#2、隐藏某行cell\" class=\"headerlink\" title=\"2、隐藏某行cell\"></a>2、隐藏某行cell</h4><pre><code class=\"objectivec\">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n// 如果是你需要隐藏的那一行，返回高度为0\n    if(indexPath.row == YouWantToHideRow)\n        return 0; \n    return 44;\n}\n\n// 然后再你需要隐藏cell的时候调用\n[self.tableView beginUpdates];\n[self.tableView endUpdates];\n</code></pre>\n<h4 id=\"3、禁用button高亮\"><a href=\"#3、禁用button高亮\" class=\"headerlink\" title=\"3、禁用button高亮\"></a>3、禁用button高亮</h4><pre><code class=\"objectivec\">button.adjustsImageWhenHighlighted = NO;\n或者在创建的时候\n UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n</code></pre>\n<h4 id=\"4、tableview遇到这种报错failed-to-obtain-a-cell-from-its-dataSource\"><a href=\"#4、tableview遇到这种报错failed-to-obtain-a-cell-from-its-dataSource\" class=\"headerlink\" title=\"4、tableview遇到这种报错failed to obtain a cell from its dataSource\"></a>4、tableview遇到这种报错failed to obtain a cell from its dataSource</h4><blockquote>\n<p>是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了<br>可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你<br>想要的类型)，这时候需要改下cell的标识</p>\n</blockquote>\n<h4 id=\"5、cocoa-pods报这个错误：unable-to-access-‘https-github-com-facebook-pop-git-‘-Operation-timed-out-after-0-milliseconds-with-0-out-of-0-bytes-received\"><a href=\"#5、cocoa-pods报这个错误：unable-to-access-‘https-github-com-facebook-pop-git-‘-Operation-timed-out-after-0-milliseconds-with-0-out-of-0-bytes-received\" class=\"headerlink\" title=\"5、cocoa pods报这个错误：unable to access ‘https://github.com/facebook/pop.git/‘: Operation timed out after 0 milliseconds with 0 out of 0 bytes received\"></a>5、cocoa pods报这个错误：unable to access ‘<a href=\"https://github.com/facebook/pop.git/\" target=\"_blank\" rel=\"external\">https://github.com/facebook/pop.git/</a>‘: Operation timed out after 0 milliseconds with 0 out of 0 bytes received</h4><blockquote>\n<p>解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了</p>\n</blockquote>\n<h4 id=\"6、cocoa-pods-出现ERROR-While-executing-gem-…-Errno-EPERM\"><a href=\"#6、cocoa-pods-出现ERROR-While-executing-gem-…-Errno-EPERM\" class=\"headerlink\" title=\"6、cocoa pods 出现ERROR: While executing gem … (Errno::EPERM)\"></a>6、cocoa pods 出现ERROR: While executing gem … (Errno::EPERM)</h4><blockquote>\n<p><a href=\"https://segmentfault.com/q/1010000002926243\" target=\"_blank\" rel=\"external\">解决办法：https://segmentfault.com/q/1010000002926243</a></p>\n</blockquote>\n<h4 id=\"7、动画切换window的根控制器\"><a href=\"#7、动画切换window的根控制器\" class=\"headerlink\" title=\"7、动画切换window的根控制器\"></a>7、动画切换window的根控制器</h4><pre><code class=\"objectivec\">// options是动画选项\n[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{\n        BOOL oldState = [UIView areAnimationsEnabled];\n        [UIView setAnimationsEnabled:NO];\n        [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];\n        [UIView setAnimationsEnabled:oldState];\n    } completion:^(BOOL finished) {\n\n    }];\n</code></pre>\n<h4 id=\"8、去除数组中重复的对象\"><a href=\"#8、去除数组中重复的对象\" class=\"headerlink\" title=\"8、去除数组中重复的对象\"></a>8、去除数组中重复的对象</h4><pre><code class=\"objectivec\">NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self&quot;];\n</code></pre>\n<h4 id=\"9、编译的时候遇到-no-such-file-or-directory-／users／apple／XXX\"><a href=\"#9、编译的时候遇到-no-such-file-or-directory-／users／apple／XXX\" class=\"headerlink\" title=\"9、编译的时候遇到 no such file or directory: ／users／apple／XXX\"></a>9、编译的时候遇到 no such file or directory: ／users／apple／XXX</h4><blockquote>\n<p>是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可</p>\n</blockquote>\n<h4 id=\"10、iOS8系统中，tableView最好实现下-tableView-heightForRowAtIndexPath-这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\"><a href=\"#10、iOS8系统中，tableView最好实现下-tableView-heightForRowAtIndexPath-这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\" class=\"headerlink\" title=\"10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题\"></a>10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题</h4><h4 id=\"11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\"><a href=\"#11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\" class=\"headerlink\" title=\"11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑\"></a>11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑</h4><pre><code class=\"objectivec\">// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n\n}\n</code></pre>\n<h4 id=\"12、三个通知\"><a href=\"#12、三个通知\" class=\"headerlink\" title=\"12、三个通知\"></a>12、三个通知</h4><blockquote>\n<p>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化<br>UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）</p>\n</blockquote>\n<h4 id=\"13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张-所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\"><a href=\"#13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张-所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\" class=\"headerlink\" title=\"13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。\"></a>13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。</h4><h4 id=\"14、上线前注意：\"><a href=\"#14、上线前注意：\" class=\"headerlink\" title=\"14、上线前注意：\"></a>14、上线前注意：</h4><blockquote>\n<p>1）、删掉代码中所有的测试代码<br>2）、如果后台有审核模式，提醒后台开启此模式<br>3）、主流程再跑一跑<br>4）、全局搜索waring，检查所有标记waring的地方</p>\n</blockquote>\n<h4 id=\"15、跳进app权限设置\"><a href=\"#15、跳进app权限设置\" class=\"headerlink\" title=\"15、跳进app权限设置\"></a>15、跳进app权限设置</h4><pre><code class=\"objectivec\">// 跳进app设置\n            if (UIApplicationOpenSettingsURLString != NULL) {\n                UIApplication *application = [UIApplication sharedApplication];\n                NSURL *URL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];\n                if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {\n                    [application openURL:URL options:@{}\n                       completionHandler:nil];\n                } else {\n                    [application openURL:URL];\n                }\n            }\n</code></pre>\n<h4 id=\"16、给一个view截图\"><a href=\"#16、给一个view截图\" class=\"headerlink\" title=\"16、给一个view截图\"></a>16、给一个view截图</h4><pre><code class=\"objectivec\">UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n</code></pre>\n<h4 id=\"17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView-tableFooterView-更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\"><a href=\"#17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView-tableFooterView-更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\" class=\"headerlink\" title=\"17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。\"></a>17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。</h4><h4 id=\"18、注意对象为nil的时候，调用此对象分类的方法不会执行\"><a href=\"#18、注意对象为nil的时候，调用此对象分类的方法不会执行\" class=\"headerlink\" title=\"18、注意对象为nil的时候，调用此对象分类的方法不会执行\"></a>18、注意对象为nil的时候，调用此对象分类的方法不会执行</h4><h4 id=\"19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\"><a href=\"#19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\" class=\"headerlink\" title=\"19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：\"></a>19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：</h4><pre><code class=\"objectivec\">collectionView.alwaysBounceHorizontal = YES;\ncollectionView.alwaysBounceVertical = YES;\n</code></pre>\n<h4 id=\"20、设置navigationBar上的title颜色和大小\"><a href=\"#20、设置navigationBar上的title颜色和大小\" class=\"headerlink\" title=\"20、设置navigationBar上的title颜色和大小\"></a>20、设置navigationBar上的title颜色和大小</h4><pre><code class=\"objectivec\">    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}]\n</code></pre>\n<h4 id=\"21、颜色转图片\"><a href=\"#21、颜色转图片\" class=\"headerlink\" title=\"21、颜色转图片\"></a>21、颜色转图片</h4><pre><code class=\"objectivec\">+ (UIImage *)cl_imageWithColor:(UIColor *)color {\n  CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);\n  UIGraphicsBeginImageContext(rect.size);\n  CGContextRef context = UIGraphicsGetCurrentContext();\n\n  CGContextSetFillColorWithColor(context, [color CGColor]);\n  CGContextFillRect(context, rect);\n\n  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n  UIGraphicsEndImageContext();\n\n  return image;\n}\n</code></pre>\n<h4 id=\"22、view设置圆角\"><a href=\"#22、view设置圆角\" class=\"headerlink\" title=\"22、view设置圆角\"></a>22、view设置圆角</h4><pre><code class=\"objectivec\">#define ViewBorderRadius(View, Radius, Width, Color)\\\n\\\n[View.layer setCornerRadius:(Radius)];\\\n[View.layer setMasksToBounds:YES];\\\n[View.layer setBorderWidth:(Width)];\\\n[View.layer setBorderColor:[Color CGColor]] // view圆角\n</code></pre>\n<h4 id=\"23、强／弱引用\"><a href=\"#23、强／弱引用\" class=\"headerlink\" title=\"23、强／弱引用\"></a>23、强／弱引用</h4><pre><code class=\"objectivec\">#define WeakSelf(type)  __weak typeof(type) weak##type = type; // weak\n#define StrongSelf(type)  __strong typeof(type) type = weak##type; // strong\n</code></pre>\n<p>24、由角度转换弧度</p>\n<pre><code class=\"objectivec\">#define DegreesToRadian(x) (M_PI * (x) / 180.0)\n</code></pre>\n<p>25、由弧度转换角度</p>\n<pre><code class=\"objectivec\">#define RadianToDegrees(radian) (radian*180.0)/(M_PI)\n</code></pre>\n<p>26、获取图片资源</p>\n<pre><code class=\"objectivec\">#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@&quot;,imageName]]\n</code></pre>\n<p>27、获取temp</p>\n<pre><code class=\"objectivec\">#define PathTemp NSTemporaryDirectory()\n</code></pre>\n<p>28、获取沙盒 Document</p>\n<pre><code class=\"objectivec\">#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]\n</code></pre>\n<p>29、获取沙盒 Cache</p>\n<pre><code class=\"objectivec\">#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]\n</code></pre>\n<p>30、GCD代码只执行一次</p>\n<pre><code class=\"objectivec\">#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);\n</code></pre>\n"},{"title":"iOS消息转发机制-- 动态方法解析实现@dynamic","date":"2017-02-02T03:31:09.000Z","_content":"\n> 假设要编写一个类似于“字典”的对象，它里面可以容纳其他对象，只不过开发者要通过属性来存取其中的数据，这个类的设计思路：由开发者来添加属性定义，并将其申明为@dynamic,而类则会自动处理相关属性值的存放和获取操作。\n\n#### 实现代码：\n\n`.h文件`\n\n```objectivec\n#import <Foundation/Foundation.h>\n\n@interface MyDictionary : NSObject\n@property (nonatomic, strong) NSDate *date;\n@end\n```\n\n> 本例中，属性具体设置什么无关紧要，只是掩饰此功能。在类的内部，每个属性的值还会存放在字典中，所以先在类中编写如下代码，并将属性申明为@dynamic,这样编译器就不会为其自动生成实例变量的存取方法了。\n\n\n`.m文件`\n\n```objectivec\n#import \"MyDictionary.h\"\n#import <objc/runtime.h>\n\n@interface MyDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *storeDictionary;\n\n@end\n\n@implementation MyDictionary\n\n@dynamic date;\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        _storeDictionary = [NSMutableDictionary dictionary];\n    }\n    return self;\n}\n\n// 通过消息转移实现运行时动态添加get 和 set 方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    NSString *selectorStr = NSStringFromSelector(sel);\n    if ([selectorStr hasPrefix:@\"set\"]) {\n        \n        class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n        \n    }else{\n        \n        class_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n    }\n    return YES;\n}\n\n// get 方法的实现\nid autoDictionaryGetter(id self, SEL _cmd) {\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n    \n    // the key is simply the selector name\n    NSString *key = NSStringFromSelector(_cmd);\n    \n    // return the value\n    return [backingStore objectForKey:key];\n}\n\n// set 方法的实现\nvoid autoDictionarySetter(id self, SEL _cmd, id value){\n    // get the backstore from the object\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n    \n    // get method name from _cmd\n    NSString *selectorString = NSStringFromSelector(_cmd);\n    NSMutableString *key = [selectorString mutableCopy];\n    \n    // remove \":\" at the end\n    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n    \n    // remove \"set\" at the prefix\n    [key deleteCharactersInRange:NSMakeRange(0, 3)];\n    \n    // lowercase the first charactor\n    NSString *firstLowercaseString = [[key substringToIndex:1] lowercaseString];\n    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:firstLowercaseString];\n    \n    // set value\n    if (value) {\n        \n        [backingStore setObject:value forKey:key];\n    }else{\n        [backingStore removeObjectForKey:key];\n    }\n    \n    \n}\n@end\n```\n\n#### 调用：\n\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    MyDictionary *dic = [[MyDictionary alloc] init];\n    dic.date = [NSDate date];\n    NSLog(@\"date = %@\",dic.date);\n}\n```\n\n#### 输出：\n```objectivec\ndate = 2017-07-02 03:26:08 +0000\n```\n\n","source":"_posts/iOS消息转发机制-动态方法解析.md","raw":"---\ntitle: iOS消息转发机制-- 动态方法解析实现@dynamic\ndate: 2017-02-02 11:31:09\ncategories: \n    - iOS合集\n---\n\n> 假设要编写一个类似于“字典”的对象，它里面可以容纳其他对象，只不过开发者要通过属性来存取其中的数据，这个类的设计思路：由开发者来添加属性定义，并将其申明为@dynamic,而类则会自动处理相关属性值的存放和获取操作。\n\n#### 实现代码：\n\n`.h文件`\n\n```objectivec\n#import <Foundation/Foundation.h>\n\n@interface MyDictionary : NSObject\n@property (nonatomic, strong) NSDate *date;\n@end\n```\n\n> 本例中，属性具体设置什么无关紧要，只是掩饰此功能。在类的内部，每个属性的值还会存放在字典中，所以先在类中编写如下代码，并将属性申明为@dynamic,这样编译器就不会为其自动生成实例变量的存取方法了。\n\n\n`.m文件`\n\n```objectivec\n#import \"MyDictionary.h\"\n#import <objc/runtime.h>\n\n@interface MyDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *storeDictionary;\n\n@end\n\n@implementation MyDictionary\n\n@dynamic date;\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        _storeDictionary = [NSMutableDictionary dictionary];\n    }\n    return self;\n}\n\n// 通过消息转移实现运行时动态添加get 和 set 方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    NSString *selectorStr = NSStringFromSelector(sel);\n    if ([selectorStr hasPrefix:@\"set\"]) {\n        \n        class_addMethod(self, sel, (IMP)autoDictionarySetter, \"v@:@\");\n        \n    }else{\n        \n        class_addMethod(self, sel, (IMP)autoDictionaryGetter, \"@@:\");\n    }\n    return YES;\n}\n\n// get 方法的实现\nid autoDictionaryGetter(id self, SEL _cmd) {\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n    \n    // the key is simply the selector name\n    NSString *key = NSStringFromSelector(_cmd);\n    \n    // return the value\n    return [backingStore objectForKey:key];\n}\n\n// set 方法的实现\nvoid autoDictionarySetter(id self, SEL _cmd, id value){\n    // get the backstore from the object\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n    \n    // get method name from _cmd\n    NSString *selectorString = NSStringFromSelector(_cmd);\n    NSMutableString *key = [selectorString mutableCopy];\n    \n    // remove \":\" at the end\n    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n    \n    // remove \"set\" at the prefix\n    [key deleteCharactersInRange:NSMakeRange(0, 3)];\n    \n    // lowercase the first charactor\n    NSString *firstLowercaseString = [[key substringToIndex:1] lowercaseString];\n    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:firstLowercaseString];\n    \n    // set value\n    if (value) {\n        \n        [backingStore setObject:value forKey:key];\n    }else{\n        [backingStore removeObjectForKey:key];\n    }\n    \n    \n}\n@end\n```\n\n#### 调用：\n\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    MyDictionary *dic = [[MyDictionary alloc] init];\n    dic.date = [NSDate date];\n    NSLog(@\"date = %@\",dic.date);\n}\n```\n\n#### 输出：\n```objectivec\ndate = 2017-07-02 03:26:08 +0000\n```\n\n","slug":"iOS消息转发机制-动态方法解析","published":1,"updated":"2017-07-02T13:33:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tw50015znuz05zt5p21","content":"<blockquote>\n<p>假设要编写一个类似于“字典”的对象，它里面可以容纳其他对象，只不过开发者要通过属性来存取其中的数据，这个类的设计思路：由开发者来添加属性定义，并将其申明为@dynamic,而类则会自动处理相关属性值的存放和获取操作。</p>\n</blockquote>\n<h4 id=\"实现代码：\"><a href=\"#实现代码：\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><p><code>.h文件</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;Foundation/Foundation.h></span>\n\n<span class=\"token keyword\">@interface</span> MyDictionary <span class=\"token punctuation\">:</span> NSObject\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">)</span> NSDate <span class=\"token operator\">*</span>date<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<blockquote>\n<p>本例中，属性具体设置什么无关紧要，只是掩饰此功能。在类的内部，每个属性的值还会存放在字典中，所以先在类中编写如下代码，并将属性申明为@dynamic,这样编译器就不会为其自动生成实例变量的存取方法了。</p>\n</blockquote>\n<p><code>.m文件</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"MyDictionary.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;objc/runtime.h></span>\n\n<span class=\"token keyword\">@interface</span> <span class=\"token function\">MyDictionary</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">)</span> NSMutableDictionary <span class=\"token operator\">*</span>storeDictionary<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> MyDictionary\n\n<span class=\"token keyword\">@dynamic</span> date<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>init\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _storeDictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 通过消息转移实现运行时动态添加get 和 set 方法</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>resolveInstanceMethod<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SEL<span class=\"token punctuation\">)</span>sel\n<span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>selectorStr <span class=\"token operator\">=</span> <span class=\"token function\">NSStringFromSelector</span><span class=\"token punctuation\">(</span>sel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>selectorStr hasPrefix<span class=\"token punctuation\">:</span><span class=\"token string\">@\"set\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token function\">class_addMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> sel<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>IMP<span class=\"token punctuation\">)</span>autoDictionarySetter<span class=\"token punctuation\">,</span> <span class=\"token string\">\"v@:@\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n\n        <span class=\"token function\">class_addMethod</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> sel<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>IMP<span class=\"token punctuation\">)</span>autoDictionaryGetter<span class=\"token punctuation\">,</span> <span class=\"token string\">\"@@:\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// get 方法的实现</span>\nid <span class=\"token function\">autoDictionaryGetter</span><span class=\"token punctuation\">(</span>id <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> SEL _cmd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyDictionary <span class=\"token operator\">*</span>typeSelf <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>MyDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>backingStore <span class=\"token operator\">=</span> typeSelf<span class=\"token punctuation\">.</span>storeDictionary<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// the key is simply the selector name</span>\n    NSString <span class=\"token operator\">*</span>key <span class=\"token operator\">=</span> <span class=\"token function\">NSStringFromSelector</span><span class=\"token punctuation\">(</span>_cmd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// return the value</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>backingStore objectForKey<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// set 方法的实现</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">autoDictionarySetter</span><span class=\"token punctuation\">(</span>id <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> SEL _cmd<span class=\"token punctuation\">,</span> id value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// get the backstore from the object</span>\n    MyDictionary <span class=\"token operator\">*</span>typeSelf <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>MyDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>backingStore <span class=\"token operator\">=</span> typeSelf<span class=\"token punctuation\">.</span>storeDictionary<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// get method name from _cmd</span>\n    NSString <span class=\"token operator\">*</span>selectorString <span class=\"token operator\">=</span> <span class=\"token function\">NSStringFromSelector</span><span class=\"token punctuation\">(</span>_cmd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSMutableString <span class=\"token operator\">*</span>key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>selectorString mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// remove \":\" at the end</span>\n    <span class=\"token punctuation\">[</span>key deleteCharactersInRange<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// remove \"set\" at the prefix</span>\n    <span class=\"token punctuation\">[</span>key deleteCharactersInRange<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// lowercase the first charactor</span>\n    NSString <span class=\"token operator\">*</span>firstLowercaseString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>key substringToIndex<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> lowercaseString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>key replaceCharactersInRange<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> withString<span class=\"token punctuation\">:</span>firstLowercaseString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// set value</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">[</span>backingStore setObject<span class=\"token punctuation\">:</span>value forKey<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">[</span>backingStore removeObjectForKey<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<h4 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLoad<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Do any additional setup after loading the view, typically from a nib.</span>\n    MyDictionary <span class=\"token operator\">*</span>dic <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>MyDictionary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    dic<span class=\"token punctuation\">.</span>date <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSDate date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"date = %@\"</span><span class=\"token punctuation\">,</span>dic<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"输出：\"><a href=\"#输出：\" class=\"headerlink\" title=\"输出：\"></a>输出：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">date <span class=\"token operator\">=</span> <span class=\"token number\">2017</span><span class=\"token operator\">-</span><span class=\"token number\">07</span><span class=\"token operator\">-</span><span class=\"token number\">02</span> <span class=\"token number\">03</span><span class=\"token punctuation\">:</span><span class=\"token number\">26</span><span class=\"token punctuation\">:</span><span class=\"token number\">08</span> <span class=\"token operator\">+</span><span class=\"token number\">0000</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<blockquote>\n<p>假设要编写一个类似于“字典”的对象，它里面可以容纳其他对象，只不过开发者要通过属性来存取其中的数据，这个类的设计思路：由开发者来添加属性定义，并将其申明为@dynamic,而类则会自动处理相关属性值的存放和获取操作。</p>\n</blockquote>\n<h4 id=\"实现代码：\"><a href=\"#实现代码：\" class=\"headerlink\" title=\"实现代码：\"></a>实现代码：</h4><p><code>.h文件</code></p>\n<pre><code class=\"objectivec\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface MyDictionary : NSObject\n@property (nonatomic, strong) NSDate *date;\n@end\n</code></pre>\n<blockquote>\n<p>本例中，属性具体设置什么无关紧要，只是掩饰此功能。在类的内部，每个属性的值还会存放在字典中，所以先在类中编写如下代码，并将属性申明为@dynamic,这样编译器就不会为其自动生成实例变量的存取方法了。</p>\n</blockquote>\n<p><code>.m文件</code></p>\n<pre><code class=\"objectivec\">#import &quot;MyDictionary.h&quot;\n#import &lt;objc/runtime.h&gt;\n\n@interface MyDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *storeDictionary;\n\n@end\n\n@implementation MyDictionary\n\n@dynamic date;\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        _storeDictionary = [NSMutableDictionary dictionary];\n    }\n    return self;\n}\n\n// 通过消息转移实现运行时动态添加get 和 set 方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    NSString *selectorStr = NSStringFromSelector(sel);\n    if ([selectorStr hasPrefix:@&quot;set&quot;]) {\n\n        class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);\n\n    }else{\n\n        class_addMethod(self, sel, (IMP)autoDictionaryGetter, &quot;@@:&quot;);\n    }\n    return YES;\n}\n\n// get 方法的实现\nid autoDictionaryGetter(id self, SEL _cmd) {\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n\n    // the key is simply the selector name\n    NSString *key = NSStringFromSelector(_cmd);\n\n    // return the value\n    return [backingStore objectForKey:key];\n}\n\n// set 方法的实现\nvoid autoDictionarySetter(id self, SEL _cmd, id value){\n    // get the backstore from the object\n    MyDictionary *typeSelf = (MyDictionary *)self;\n    NSMutableDictionary *backingStore = typeSelf.storeDictionary;\n\n    // get method name from _cmd\n    NSString *selectorString = NSStringFromSelector(_cmd);\n    NSMutableString *key = [selectorString mutableCopy];\n\n    // remove &quot;:&quot; at the end\n    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];\n\n    // remove &quot;set&quot; at the prefix\n    [key deleteCharactersInRange:NSMakeRange(0, 3)];\n\n    // lowercase the first charactor\n    NSString *firstLowercaseString = [[key substringToIndex:1] lowercaseString];\n    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:firstLowercaseString];\n\n    // set value\n    if (value) {\n\n        [backingStore setObject:value forKey:key];\n    }else{\n        [backingStore removeObjectForKey:key];\n    }\n\n\n}\n@end\n</code></pre>\n<h4 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre><code class=\"objectivec\">- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    MyDictionary *dic = [[MyDictionary alloc] init];\n    dic.date = [NSDate date];\n    NSLog(@&quot;date = %@&quot;,dic.date);\n}\n</code></pre>\n<h4 id=\"输出：\"><a href=\"#输出：\" class=\"headerlink\" title=\"输出：\"></a>输出：</h4><pre><code class=\"objectivec\">date = 2017-07-02 03:26:08 +0000\n</code></pre>\n"},{"title":"我是不懂浪漫","date":"2017-06-05T14:50:48.000Z","_content":"![一](http://oqepgj2jp.bkt.clouddn.com/1.jpg)\n\n> 1\n\n![二](http://oqepgj2jp.bkt.clouddn.com/2.jpg)\n\n> 2\n\n![三](http://oqepgj2jp.bkt.clouddn.com/3.jpg)\n\n> 3\n\n![四](http://oqepgj2jp.bkt.clouddn.com/4.jpg)\n\n> 4\n\n\n![五](http://oqepgj2jp.bkt.clouddn.com/5.jpg)\n\n> 5\n\n\n![六](http://oqepgj2jp.bkt.clouddn.com/6.jpg)\n\n> 6\n\n\n\n","source":"_posts/我是不懂浪漫.md","raw":"---\ntitle: 我是不懂浪漫\ndate: 2017-06-05 22:50:48\ncategories: \n\t- 自言语\n---\n![一](http://oqepgj2jp.bkt.clouddn.com/1.jpg)\n\n> 1\n\n![二](http://oqepgj2jp.bkt.clouddn.com/2.jpg)\n\n> 2\n\n![三](http://oqepgj2jp.bkt.clouddn.com/3.jpg)\n\n> 3\n\n![四](http://oqepgj2jp.bkt.clouddn.com/4.jpg)\n\n> 4\n\n\n![五](http://oqepgj2jp.bkt.clouddn.com/5.jpg)\n\n> 5\n\n\n![六](http://oqepgj2jp.bkt.clouddn.com/6.jpg)\n\n> 6\n\n\n\n","slug":"我是不懂浪漫","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tw70018znuzisdq0bjz","content":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/1.jpg\" alt=\"一\"></p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/2.jpg\" alt=\"二\"></p>\n<blockquote>\n<p>2</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/3.jpg\" alt=\"三\"></p>\n<blockquote>\n<p>3</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/4.jpg\" alt=\"四\"></p>\n<blockquote>\n<p>4</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/5.jpg\" alt=\"五\"></p>\n<blockquote>\n<p>5</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/6.jpg\" alt=\"六\"></p>\n<blockquote>\n<p>6</p>\n</blockquote>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/1.jpg\" alt=\"一\"></p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/2.jpg\" alt=\"二\"></p>\n<blockquote>\n<p>2</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/3.jpg\" alt=\"三\"></p>\n<blockquote>\n<p>3</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/4.jpg\" alt=\"四\"></p>\n<blockquote>\n<p>4</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/5.jpg\" alt=\"五\"></p>\n<blockquote>\n<p>5</p>\n</blockquote>\n<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/6.jpg\" alt=\"六\"></p>\n<blockquote>\n<p>6</p>\n</blockquote>\n"},{"title":"iOS常用工具方法","date":"2017-06-03T14:47:26.000Z","_content":"####  1. 获取磁盘总空间大小\n\n```objectivec\n//磁盘总空间\n+ (CGFloat)diskOfAllSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@\"error: %@\", error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n```\n\n####  2. 获取磁盘可用空间大小\n\n```objectivec\n//磁盘可用空间\n+ (CGFloat)diskOfFreeSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@\"error: %@\", error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemFreeSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n```\n####  3. 获取指定路径下某个文件的大小\n\n```objectivec\n//获取文件大小\n+ (long long)fileSizeAtPath:(NSString *)filePath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:filePath]) return 0;\n    return [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];\n}\n```\n\n####  4. 获取文件夹下所有文件的大小\n\n```objectivec\n//获取文件夹下所有文件的大小\n+ (long long)folderSizeAtPath:(NSString *)folderPath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:folderPath]) return 0;\n    NSEnumerator *filesEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];\n    NSString *fileName;\n    long long folerSize = 0;\n    while ((fileName = [filesEnumerator nextObject]) != nil) {\n        NSString *filePath = [folderPath stringByAppendingPathComponent:fileName];\n        folerSize += [self fileSizeAtPath:filePath];\n    }\n    return folerSize;\n}\n```\n\n####   5. 获取字符串(或汉字)首字母\n\n```objectivec\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n```\n\n####   5. 获取字符串(或汉字)首字母\n\n```objectivec\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n```\n\n####   6. 将字符串数组按照元素首字母顺序进行排序分组\n\n```objectivec\n//将字符串数组按照元素首字母顺序进行排序分组\n+ (NSDictionary *)dictionaryOrderByCharacterWithOriginalArray:(NSArray *)array{\n    if (array.count == 0) {\n        return nil;\n    }\n    for (id obj in array) {\n        if (![obj isKindOfClass:[NSString class]]) {\n            return nil;\n        }\n    }\n    UILocalizedIndexedCollation *indexedCollation = [UILocalizedIndexedCollation currentCollation];\n    NSMutableArray *objects = [NSMutableArray arrayWithCapacity:indexedCollation.sectionTitles.count];\n    //创建27个分组数组\n    for (int i = 0; i < indexedCollation.sectionTitles.count; i++) {\n        NSMutableArray *obj = [NSMutableArray array];\n        [objects addObject:obj];\n    }\n    NSMutableArray *keys = [NSMutableArray arrayWithCapacity:objects.count];\n    //按字母顺序进行分组\n    NSInteger lastIndex = -1;\n    for (int i = 0; i < array.count; i++) {\n        NSInteger index = [indexedCollation sectionForObject:array[i] collationStringSelector:@selector(uppercaseString)];\n        [[objects objectAtIndex:index] addObject:array[i]];\n        lastIndex = index;\n    }\n    //去掉空数组\n    for (int i = 0; i < objects.count; i++) {\n        NSMutableArray *obj = objects[i];\n        if (obj.count == 0) {\n            [objects removeObject:obj];\n        }\n    }\n    //获取索引字母\n    for (NSMutableArray *obj in objects) {\n        NSString *str = obj[0];\n        NSString *key = [self firstCharacterWithString:str];\n        [keys addObject:key];\n    }\n    NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n    [dic setObject:objects forKey:keys];\n    return dic;\n}\n\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n\n```\n##### 使用如下:\n```objectivec\nNSArray *arr = @[@\"guangzhou\", @\"shanghai\", @\"北京\", @\"henan\", @\"hainan\"];\nNSDictionary *dic = [Utilities dictionaryOrderByCharacterWithOriginalArray:arr];\nNSLog(@\"\\n\\ndic: %@\", dic);\n```\n![结果](http://upload-images.jianshu.io/upload_images/1803339-a63d16ad6cccc312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####  7. 获取当前时间\n\n```objectivec\n//获取当前时间\n//format: @\"yyyy-MM-dd HH:mm:ss\"、@\"yyyy年MM月dd日 HH时mm分ss秒\"\n+ (NSString *)currentDateWithFormat:(NSString *)format{\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n    [dateFormatter setDateFormat:format];\n    return [dateFormatter stringFromDate:[NSDate date]];\n}\n```\n####  8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等\n\n```objectivec\n/**\n *  计算上次日期距离现在多久\n *\n *  @param lastTime    上次日期(需要和格式对应)\n *  @param format1     上次日期格式\n *  @param currentTime 最近日期(需要和格式对应)\n *  @param format2     最近日期格式\n *\n *  @return xx分钟前、xx小时前、xx天前\n */\n+ (NSString *)timeIntervalFromLastTime:(NSString *)lastTime\n                        lastTimeFormat:(NSString *)format1\n                         ToCurrentTime:(NSString *)currentTime\n                     currentTimeFormat:(NSString *)format2{\n    //上次时间\n    NSDateFormatter *dateFormatter1 = [[NSDateFormatter alloc]init];\n    dateFormatter1.dateFormat = format1;\n    NSDate *lastDate = [dateFormatter1 dateFromString:lastTime];\n    //当前时间\n    NSDateFormatter *dateFormatter2 = [[NSDateFormatter alloc]init];\n    dateFormatter2.dateFormat = format2;\n    NSDate *currentDate = [dateFormatter2 dateFromString:currentTime];\n    return [Utilities timeIntervalFromLastTime:lastDate ToCurrentTime:currentDate];\n}\n\n+ (NSString *)timeIntervalFromLastTime:(NSDate *)lastTime ToCurrentTime:(NSDate *)currentTime{\n    NSTimeZone *timeZone = [NSTimeZone systemTimeZone];\n    //上次时间\n    NSDate *lastDate = [lastTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:lastTime]];\n    //当前时间\n    NSDate *currentDate = [currentTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:currentTime]];\n    //时间间隔\n    NSInteger intevalTime = [currentDate timeIntervalSinceReferenceDate] - [lastDate timeIntervalSinceReferenceDate];\n\n    //秒、分、小时、天、月、年\n    NSInteger minutes = intevalTime / 60;\n    NSInteger hours = intevalTime / 60 / 60;\n    NSInteger day = intevalTime / 60 / 60 / 24;\n    NSInteger month = intevalTime / 60 / 60 / 24 / 30;\n    NSInteger yers = intevalTime / 60 / 60 / 24 / 365;\n\n    if (minutes <= 10) {\n        return  @\"刚刚\";\n    }else if (minutes < 60){\n        return [NSString stringWithFormat: @\"%ld分钟前\",(long)minutes];\n    }else if (hours < 24){\n        return [NSString stringWithFormat: @\"%ld小时前\",(long)hours];\n    }else if (day < 30){\n        return [NSString stringWithFormat: @\"%ld天前\",(long)day];\n    }else if (month < 12){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @\"M月d日\";\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }else if (yers >= 1){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @\"yyyy年M月d日\";\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }\n    return @\"\";\n}\n```\n\n#### 使用如下:\n\n```objectivec\nNSLog(@\"\\n\\nresult: %@\", [Utilities timeIntervalFromLastTime:@\"2015年12月8日 15:50\"\n                                           lastTimeFormat:@\"yyyy年MM月dd日 HH:mm\"\n                                            ToCurrentTime:@\"2015/12/08 16:12\"\n                                        currentTimeFormat:@\"yyyy/MM/dd HH:mm\"]);\n```\n\n输出结果如下:\n![结果](http://upload-images.jianshu.io/upload_images/1803339-591e3b7e5982b1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####  9. 判断手机号码格式是否正确\n\n```objectivec\n//判断手机号码格式是否正确\n+ (BOOL)valiMobile:(NSString *)mobile{\n    mobile = [mobile stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\n    if (mobile.length != 11)\n    {\n        return NO;\n    }else{\n        /**\n         * 移动号段正则表达式\n         */\n        NSString *CM_NUM = @\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$\";\n        /**\n         * 联通号段正则表达式\n         */\n        NSString *CU_NUM = @\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$\";\n        /**\n         * 电信号段正则表达式\n         */\n        NSString *CT_NUM = @\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$\";\n        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM_NUM];\n        BOOL isMatch1 = [pred1 evaluateWithObject:mobile];\n        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU_NUM];\n        BOOL isMatch2 = [pred2 evaluateWithObject:mobile];\n        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT_NUM];\n        BOOL isMatch3 = [pred3 evaluateWithObject:mobile];\n\n        if (isMatch1 || isMatch2 || isMatch3) {\n            return YES;\n        }else{\n            return NO;\n        }\n    }\n}\n```\n\n#### 10. 判断邮箱格式是否正确\n\n```objectivec\n//利用正则表达式验证\n+ (BOOL)isAvailableEmail:(NSString *)email {\n    NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\";\n    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex];\n    return [emailTest evaluateWithObject:email];\n}\n```\n\n#### 11. 将十六进制颜色转换为 UIColor 对象\n\n```objectivec\n//将十六进制颜色转换为 UIColor 对象\n+ (UIColor *)colorWithHexString:(NSString *)color{\n    NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];\n    // String should be 6 or 8 characters\n    if ([cString length] < 6) {\n        return [UIColor clearColor];\n    }\n    // strip \"0X\" or \"#\" if it appears\n    if ([cString hasPrefix:@\"0X\"])\n        cString = [cString substringFromIndex:2];\n    if ([cString hasPrefix:@\"#\"])\n        cString = [cString substringFromIndex:1];\n    if ([cString length] != 6)\n        return [UIColor clearColor];\n    // Separate into r, g, b substrings\n    NSRange range;\n    range.location = 0;\n    range.length = 2;\n    //r\n    NSString *rString = [cString substringWithRange:range];\n    //g\n    range.location = 2;\n    NSString *gString = [cString substringWithRange:range];\n    //b\n    range.location = 4;\n    NSString *bString = [cString substringWithRange:range];\n    // Scan values\n    unsigned int r, g, b;\n    [[NSScanner scannerWithString:rString] scanHexInt:&r];\n    [[NSScanner scannerWithString:gString] scanHexInt:&g];\n    [[NSScanner scannerWithString:bString] scanHexInt:&b];\n    return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];\n}\n```\n\n#### 12. 对图片进行滤镜处理\n\n```objectivec\n#pragma mark - 对图片进行滤镜处理\n// 怀旧 --> CIPhotoEffectInstant                         单色 --> CIPhotoEffectMono\n// 黑白 --> CIPhotoEffectNoir                            褪色 --> CIPhotoEffectFade\n// 色调 --> CIPhotoEffectTonal                           冲印 --> CIPhotoEffectProcess\n// 岁月 --> CIPhotoEffectTransfer                        铬黄 --> CIPhotoEffectChrome\n// CILinearToSRGBToneCurve, CISRGBToneCurveToLinear, CIGaussianBlur, CIBoxBlur, CIDiscBlur, CISepiaTone, CIDepthOfField\n+ (UIImage *)filterWithOriginalImage:(UIImage *)image filterName:(NSString *)name{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:name];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n```\n#### 13. 对图片进行模糊处理\n```objectivec\n#pragma mark - 对图片进行模糊处理\n// CIGaussianBlur ---> 高斯模糊\n// CIBoxBlur      ---> 均值模糊(Available in iOS 9.0 and later)\n// CIDiscBlur     ---> 环形卷积模糊(Available in iOS 9.0 and later)\n// CIMedianFilter ---> 中值模糊, 用于消除图像噪点, 无需设置radius(Available in iOS 9.0 and later)\n// CIMotionBlur   ---> 运动模糊, 用于模拟相机移动拍摄时的扫尾效果(Available in iOS 9.0 and later)\n+ (UIImage *)blurWithOriginalImage:(UIImage *)image blurName:(NSString *)name radius:(NSInteger)radius{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter;\n    if (name.length != 0) {\n        filter = [CIFilter filterWithName:name];\n        [filter setValue:inputImage forKey:kCIInputImageKey];\n        if (![name isEqualToString:@\"CIMedianFilter\"]) {\n            [filter setValue:@(radius) forKey:@\"inputRadius\"];\n        }\n        CIImage *result = [filter valueForKey:kCIOutputImageKey];\n        CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n        UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n        CGImageRelease(cgImage);\n        return resultImage;\n    }else{\n        return nil;\n    }\n}\n```\n\n#### 14. 调整图片饱和度、亮度、对比度\n```objectivec\n/**\n *  调整图片饱和度, 亮度, 对比度\n *\n *  @param image      目标图片\n *  @param saturation 饱和度\n *  @param brightness 亮度: -1.0 ~ 1.0\n *  @param contrast   对比度\n *\n */\n+ (UIImage *)colorControlsWithOriginalImage:(UIImage *)image\n                                 saturation:(CGFloat)saturation\n                                 brightness:(CGFloat)brightness\n                                   contrast:(CGFloat)contrast{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:@\"CIColorControls\"];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n\n    [filter setValue:@(saturation) forKey:@\"inputSaturation\"];\n    [filter setValue:@(brightness) forKey:@\"inputBrightness\"];\n    [filter setValue:@(contrast) forKey:@\"inputContrast\"];\n\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n```\n\n#### 15. 创建一张实时模糊效果 View (毛玻璃效果)\n```objectivec\n//Avilable in iOS 8.0 and later\n+ (UIVisualEffectView *)effectViewWithFrame:(CGRect)frame{\n    UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];\n    UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:effect];\n    effectView.frame = frame;\n    return effectView;\n}\n```\n\n#### 16. 全屏截图\n```objectivec\n//全屏截图\n+ (UIImage *)shotScreen{\n    UIWindow *window = [UIApplication sharedApplication].keyWindow;\n    UIGraphicsBeginImageContext(window.bounds.size);\n    [window.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n\n```\n\n#### 17. 截取一张 view 生成图片\n```objectivec\n//截取view生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view{\n    UIGraphicsBeginImageContext(view.bounds.size);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n#### 18. 截取view中某个区域生成一张图片\n```objectivec\n//截取view中某个区域生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view scope:(CGRect)scope{\n    CGImageRef imageRef = CGImageCreateWithImageInRect([self shotWithView:view].CGImage, scope);\n    UIGraphicsBeginImageContext(scope.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGRect rect = CGRectMake(0, 0, scope.size.width, scope.size.height);\n    CGContextTranslateCTM(context, 0, rect.size.height);//下移\n    CGContextScaleCTM(context, 1.0f, -1.0f);//上翻\n    CGContextDrawImage(context, rect, imageRef);\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    CGImageRelease(imageRef);\n    CGContextRelease(context);\n    return image;\n}\n```\n#### 19. 压缩图片到指定尺寸大小\n```objectivec\n//压缩图片到指定尺寸大小\n+ (UIImage *)compressOriginalImage:(UIImage *)image toSize:(CGSize)size{\n    UIImage *resultImage = image;\n    UIGraphicsBeginImageContext(size);\n    [resultImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    UIGraphicsEndImageContext();\n    return resultImage;\n}\n```\n#### 20. 压缩图片到指定文件大小\n```objectivec\n//压缩图片到指定文件大小\n+ (NSData *)compressOriginalImage:(UIImage *)image toMaxDataSizeKBytes:(CGFloat)size{\n    NSData *data = UIImageJPEGRepresentation(image, 1.0);\n    CGFloat dataKBytes = data.length/1000.0;\n    CGFloat maxQuality = 0.9f;\n    CGFloat lastData = dataKBytes;\n    while (dataKBytes > size && maxQuality > 0.01f) {\n        maxQuality = maxQuality - 0.01f;\n        data = UIImageJPEGRepresentation(image, maxQuality);\n        dataKBytes = data.length/1000.0;\n        if (lastData == dataKBytes) {\n            break;\n        }else{\n            lastData = dataKBytes;\n        }\n    }\n    return data;\n}\n```\n\n#### 21. 获取设备 IP 地址\n\n需要先引入下头文件:\n\n`#import <ifaddrs.h>`\n`#import <arpa/inet.h>`\n\n```objectivec\n//获取设备 IP 地址\n+ (NSString *)getIPAddress {\n    NSString *address = @\"error\";\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    success = getifaddrs(&interfaces);\n    if (success == 0) {\n        temp_addr = interfaces;\n        while(temp_addr != NULL) {\n            if(temp_addr->ifa_addr->sa_family == AF_INET) {\n                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@\"en0\"]) {\n                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];\n                }\n            }\n            temp_addr = temp_addr->ifa_next;\n        }\n    }\n    freeifaddrs(interfaces);\n    return address;\n}\n```\n#### 22. 判断字符串中是否含有空格\n\n```objectivec\n+ (BOOL)isHaveSpaceInString:(NSString *)string{\n    NSRange _range = [string rangeOfString:@\" \"];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n```\n\n#### 23. 判断字符串中是否含有某个字符串\n\n\n```objectivec\n+ (BOOL)isHaveString:(NSString *)string1 InString:(NSString *)string2{\n    NSRange _range = [string2 rangeOfString:string1];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n```\n\n#### 24. 判断字符串中是否含有中文\n\n```objectivec\n+ (BOOL)isHaveChineseInString:(NSString *)string{\n    for(NSInteger i = 0; i < [string length]; i++){\n        int a = [string characterAtIndex:i];\n        if (a > 0x4e00 && a < 0x9fff) {\n            return YES;\n        }\n    }\n    return NO;\n}\n```\n\n#### 25. 判断字符串是否全部为数字\n\n```objectivec\n+ (BOOL)isAllNum:(NSString *)string{\n    unichar c;\n    for (int i=0; i<string.length; i++) {\n        c=[string characterAtIndex:i];\n        if (!isdigit(c)) {\n            return NO;\n        }\n    }\n    return YES;\n}\n```\n\n#### 26. 绘制虚线\n\n```objectivec\n/*\n  ** lineFrame:     虚线的 frame\n  ** length:        虚线中短线的宽度\n  ** spacing:       虚线中短线之间的间距\n  ** color:         虚线中短线的颜色\n*/\n+ (UIView *)createDashedLineWithFrame:(CGRect)lineFrame\n                           lineLength:(int)length\n                          lineSpacing:(int)spacing\n                            lineColor:(UIColor *)color{\n    UIView *dashedLine = [[UIView alloc] initWithFrame:lineFrame];\n    dashedLine.backgroundColor = [UIColor clearColor];\n    CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n    [shapeLayer setBounds:dashedLine.bounds];\n    [shapeLayer setPosition:CGPointMake(CGRectGetWidth(dashedLine.frame) / 2, CGRectGetHeight(dashedLine.frame))];\n    [shapeLayer setFillColor:[UIColor clearColor].CGColor];\n    [shapeLayer setStrokeColor:color.CGColor];\n    [shapeLayer setLineWidth:CGRectGetHeight(dashedLine.frame)];\n    [shapeLayer setLineJoin:kCALineJoinRound];\n    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:length], [NSNumber numberWithInt:spacing], nil]];\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathMoveToPoint(path, NULL, 0, 0);\n    CGPathAddLineToPoint(path, NULL, CGRectGetWidth(dashedLine.frame), 0);\n    [shapeLayer setPath:path];\n    CGPathRelease(path);\n    [dashedLine.layer addSublayer:shapeLayer];\n    return dashedLine;\n}\n```\n\n#### 27. 将字典对象转换为 JSON 字符串\n\n```objectivec\n+ (NSString *)jsonPrettyStringEncoded:(NSDictionary *)dictionary{\n    if ([NSJSONSerialization isValidJSONObject:dictionary ]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dictionary options:NSJSONWritingPrettyPrinted error:&error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n```\n\n#### 28.将数组对象转换为 JSON 字符串\n\n```objectivec\n+ (NSString *)jsonPrettyStringEncoded:(NSArray *)array{\n    if ([NSJSONSerialization isValidJSONObject:array]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:array options:NSJSONWritingPrettyPrinted error:&error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n```\n\n#### 29. 获取 WiFi 信息\n\n需要引入头文件:\n\n`#import <SystemConfiguration/CaptiveNetwork.h>`\n\n```objectivec\n//获取 WiFi 信息\n- (NSDictionary *)fetchSSIDInfo {\n    NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();\n    if (!ifs) {\n        return nil;\n    }\n    NSDictionary *info = nil;\n    for (NSString *ifnam in ifs) {\n        info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);\n        if (info && [info count]) { break; }\n    }\n    return info;\n}\n```\n\n#### 30. 获取广播地址、本机地址、子网掩码、端口信息\n需要引入头文件:\n\n`#import <ifaddrs.h>`\n`#import <arpa/inet.h>`\n\n```objectivec\n//获取广播地址、本机地址、子网掩码、端口信息\n- (NSMutableDictionary *)getLocalInfoForCurrentWiFi {\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    // retrieve the current interfaces - returns 0 on success\n    success = getifaddrs(&interfaces);\n    if (success == 0) {\n        // Loop through linked list of interfaces\n        temp_addr = interfaces;\n        //*/\n        while(temp_addr != NULL) {\n            if(temp_addr->ifa_addr->sa_family == AF_INET) {\n                // Check if interface is en0 which is the wifi connection on the iPhone\n                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@\"en0\"]) {\n                    //广播地址\n                    NSString *broadcast = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_dstaddr)->sin_addr)];\n                    if (broadcast) {\n                        [dict setObject:broadcast forKey:@\"broadcast\"];\n                    }\n//                    NSLog(@\"broadcast address--%@\",broadcast);\n                    //本机地址\n                    NSString *localIp = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];\n                    if (localIp) {\n                        [dict setObject:localIp forKey:@\"localIp\"];\n                    }\n//                    NSLog(@\"local device ip--%@\",localIp);\n                    //子网掩码地址\n                    NSString *netmask = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_netmask)->sin_addr)];\n                    if (netmask) {\n                        [dict setObject:netmask forKey:@\"netmask\"];\n                    }\n//                    NSLog(@\"netmask--%@\",netmask);\n                    //--en0 端口地址\n                    NSString *interface = [NSString stringWithUTF8String:temp_addr->ifa_name];\n                    if (interface) {\n                        [dict setObject:interface forKey:@\"interface\"];\n                    }\n//                    NSLog(@\"interface--%@\",interface);\n                    return dict;\n                }\n            }\n            temp_addr = temp_addr->ifa_next;\n        }\n    }\n    // Free memory\n    freeifaddrs(interfaces);\n    return dict;\n}\n```\n\n\n\n\n\n\n","source":"_posts/iOS常用工具方法.md","raw":"---\ntitle: iOS常用工具方法\ndate: 2017-06-03 22:47:26\ncategories: \n\t- iOS合集\n---\n####  1. 获取磁盘总空间大小\n\n```objectivec\n//磁盘总空间\n+ (CGFloat)diskOfAllSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@\"error: %@\", error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n```\n\n####  2. 获取磁盘可用空间大小\n\n```objectivec\n//磁盘可用空间\n+ (CGFloat)diskOfFreeSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@\"error: %@\", error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemFreeSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n```\n####  3. 获取指定路径下某个文件的大小\n\n```objectivec\n//获取文件大小\n+ (long long)fileSizeAtPath:(NSString *)filePath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:filePath]) return 0;\n    return [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];\n}\n```\n\n####  4. 获取文件夹下所有文件的大小\n\n```objectivec\n//获取文件夹下所有文件的大小\n+ (long long)folderSizeAtPath:(NSString *)folderPath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:folderPath]) return 0;\n    NSEnumerator *filesEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];\n    NSString *fileName;\n    long long folerSize = 0;\n    while ((fileName = [filesEnumerator nextObject]) != nil) {\n        NSString *filePath = [folderPath stringByAppendingPathComponent:fileName];\n        folerSize += [self fileSizeAtPath:filePath];\n    }\n    return folerSize;\n}\n```\n\n####   5. 获取字符串(或汉字)首字母\n\n```objectivec\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n```\n\n####   5. 获取字符串(或汉字)首字母\n\n```objectivec\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n```\n\n####   6. 将字符串数组按照元素首字母顺序进行排序分组\n\n```objectivec\n//将字符串数组按照元素首字母顺序进行排序分组\n+ (NSDictionary *)dictionaryOrderByCharacterWithOriginalArray:(NSArray *)array{\n    if (array.count == 0) {\n        return nil;\n    }\n    for (id obj in array) {\n        if (![obj isKindOfClass:[NSString class]]) {\n            return nil;\n        }\n    }\n    UILocalizedIndexedCollation *indexedCollation = [UILocalizedIndexedCollation currentCollation];\n    NSMutableArray *objects = [NSMutableArray arrayWithCapacity:indexedCollation.sectionTitles.count];\n    //创建27个分组数组\n    for (int i = 0; i < indexedCollation.sectionTitles.count; i++) {\n        NSMutableArray *obj = [NSMutableArray array];\n        [objects addObject:obj];\n    }\n    NSMutableArray *keys = [NSMutableArray arrayWithCapacity:objects.count];\n    //按字母顺序进行分组\n    NSInteger lastIndex = -1;\n    for (int i = 0; i < array.count; i++) {\n        NSInteger index = [indexedCollation sectionForObject:array[i] collationStringSelector:@selector(uppercaseString)];\n        [[objects objectAtIndex:index] addObject:array[i]];\n        lastIndex = index;\n    }\n    //去掉空数组\n    for (int i = 0; i < objects.count; i++) {\n        NSMutableArray *obj = objects[i];\n        if (obj.count == 0) {\n            [objects removeObject:obj];\n        }\n    }\n    //获取索引字母\n    for (NSMutableArray *obj in objects) {\n        NSString *str = obj[0];\n        NSString *key = [self firstCharacterWithString:str];\n        [keys addObject:key];\n    }\n    NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n    [dic setObject:objects forKey:keys];\n    return dic;\n}\n\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n\n```\n##### 使用如下:\n```objectivec\nNSArray *arr = @[@\"guangzhou\", @\"shanghai\", @\"北京\", @\"henan\", @\"hainan\"];\nNSDictionary *dic = [Utilities dictionaryOrderByCharacterWithOriginalArray:arr];\nNSLog(@\"\\n\\ndic: %@\", dic);\n```\n![结果](http://upload-images.jianshu.io/upload_images/1803339-a63d16ad6cccc312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####  7. 获取当前时间\n\n```objectivec\n//获取当前时间\n//format: @\"yyyy-MM-dd HH:mm:ss\"、@\"yyyy年MM月dd日 HH时mm分ss秒\"\n+ (NSString *)currentDateWithFormat:(NSString *)format{\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n    [dateFormatter setDateFormat:format];\n    return [dateFormatter stringFromDate:[NSDate date]];\n}\n```\n####  8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等\n\n```objectivec\n/**\n *  计算上次日期距离现在多久\n *\n *  @param lastTime    上次日期(需要和格式对应)\n *  @param format1     上次日期格式\n *  @param currentTime 最近日期(需要和格式对应)\n *  @param format2     最近日期格式\n *\n *  @return xx分钟前、xx小时前、xx天前\n */\n+ (NSString *)timeIntervalFromLastTime:(NSString *)lastTime\n                        lastTimeFormat:(NSString *)format1\n                         ToCurrentTime:(NSString *)currentTime\n                     currentTimeFormat:(NSString *)format2{\n    //上次时间\n    NSDateFormatter *dateFormatter1 = [[NSDateFormatter alloc]init];\n    dateFormatter1.dateFormat = format1;\n    NSDate *lastDate = [dateFormatter1 dateFromString:lastTime];\n    //当前时间\n    NSDateFormatter *dateFormatter2 = [[NSDateFormatter alloc]init];\n    dateFormatter2.dateFormat = format2;\n    NSDate *currentDate = [dateFormatter2 dateFromString:currentTime];\n    return [Utilities timeIntervalFromLastTime:lastDate ToCurrentTime:currentDate];\n}\n\n+ (NSString *)timeIntervalFromLastTime:(NSDate *)lastTime ToCurrentTime:(NSDate *)currentTime{\n    NSTimeZone *timeZone = [NSTimeZone systemTimeZone];\n    //上次时间\n    NSDate *lastDate = [lastTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:lastTime]];\n    //当前时间\n    NSDate *currentDate = [currentTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:currentTime]];\n    //时间间隔\n    NSInteger intevalTime = [currentDate timeIntervalSinceReferenceDate] - [lastDate timeIntervalSinceReferenceDate];\n\n    //秒、分、小时、天、月、年\n    NSInteger minutes = intevalTime / 60;\n    NSInteger hours = intevalTime / 60 / 60;\n    NSInteger day = intevalTime / 60 / 60 / 24;\n    NSInteger month = intevalTime / 60 / 60 / 24 / 30;\n    NSInteger yers = intevalTime / 60 / 60 / 24 / 365;\n\n    if (minutes <= 10) {\n        return  @\"刚刚\";\n    }else if (minutes < 60){\n        return [NSString stringWithFormat: @\"%ld分钟前\",(long)minutes];\n    }else if (hours < 24){\n        return [NSString stringWithFormat: @\"%ld小时前\",(long)hours];\n    }else if (day < 30){\n        return [NSString stringWithFormat: @\"%ld天前\",(long)day];\n    }else if (month < 12){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @\"M月d日\";\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }else if (yers >= 1){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @\"yyyy年M月d日\";\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }\n    return @\"\";\n}\n```\n\n#### 使用如下:\n\n```objectivec\nNSLog(@\"\\n\\nresult: %@\", [Utilities timeIntervalFromLastTime:@\"2015年12月8日 15:50\"\n                                           lastTimeFormat:@\"yyyy年MM月dd日 HH:mm\"\n                                            ToCurrentTime:@\"2015/12/08 16:12\"\n                                        currentTimeFormat:@\"yyyy/MM/dd HH:mm\"]);\n```\n\n输出结果如下:\n![结果](http://upload-images.jianshu.io/upload_images/1803339-591e3b7e5982b1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####  9. 判断手机号码格式是否正确\n\n```objectivec\n//判断手机号码格式是否正确\n+ (BOOL)valiMobile:(NSString *)mobile{\n    mobile = [mobile stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\n    if (mobile.length != 11)\n    {\n        return NO;\n    }else{\n        /**\n         * 移动号段正则表达式\n         */\n        NSString *CM_NUM = @\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$\";\n        /**\n         * 联通号段正则表达式\n         */\n        NSString *CU_NUM = @\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$\";\n        /**\n         * 电信号段正则表达式\n         */\n        NSString *CT_NUM = @\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$\";\n        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM_NUM];\n        BOOL isMatch1 = [pred1 evaluateWithObject:mobile];\n        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU_NUM];\n        BOOL isMatch2 = [pred2 evaluateWithObject:mobile];\n        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT_NUM];\n        BOOL isMatch3 = [pred3 evaluateWithObject:mobile];\n\n        if (isMatch1 || isMatch2 || isMatch3) {\n            return YES;\n        }else{\n            return NO;\n        }\n    }\n}\n```\n\n#### 10. 判断邮箱格式是否正确\n\n```objectivec\n//利用正则表达式验证\n+ (BOOL)isAvailableEmail:(NSString *)email {\n    NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\";\n    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex];\n    return [emailTest evaluateWithObject:email];\n}\n```\n\n#### 11. 将十六进制颜色转换为 UIColor 对象\n\n```objectivec\n//将十六进制颜色转换为 UIColor 对象\n+ (UIColor *)colorWithHexString:(NSString *)color{\n    NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];\n    // String should be 6 or 8 characters\n    if ([cString length] < 6) {\n        return [UIColor clearColor];\n    }\n    // strip \"0X\" or \"#\" if it appears\n    if ([cString hasPrefix:@\"0X\"])\n        cString = [cString substringFromIndex:2];\n    if ([cString hasPrefix:@\"#\"])\n        cString = [cString substringFromIndex:1];\n    if ([cString length] != 6)\n        return [UIColor clearColor];\n    // Separate into r, g, b substrings\n    NSRange range;\n    range.location = 0;\n    range.length = 2;\n    //r\n    NSString *rString = [cString substringWithRange:range];\n    //g\n    range.location = 2;\n    NSString *gString = [cString substringWithRange:range];\n    //b\n    range.location = 4;\n    NSString *bString = [cString substringWithRange:range];\n    // Scan values\n    unsigned int r, g, b;\n    [[NSScanner scannerWithString:rString] scanHexInt:&r];\n    [[NSScanner scannerWithString:gString] scanHexInt:&g];\n    [[NSScanner scannerWithString:bString] scanHexInt:&b];\n    return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];\n}\n```\n\n#### 12. 对图片进行滤镜处理\n\n```objectivec\n#pragma mark - 对图片进行滤镜处理\n// 怀旧 --> CIPhotoEffectInstant                         单色 --> CIPhotoEffectMono\n// 黑白 --> CIPhotoEffectNoir                            褪色 --> CIPhotoEffectFade\n// 色调 --> CIPhotoEffectTonal                           冲印 --> CIPhotoEffectProcess\n// 岁月 --> CIPhotoEffectTransfer                        铬黄 --> CIPhotoEffectChrome\n// CILinearToSRGBToneCurve, CISRGBToneCurveToLinear, CIGaussianBlur, CIBoxBlur, CIDiscBlur, CISepiaTone, CIDepthOfField\n+ (UIImage *)filterWithOriginalImage:(UIImage *)image filterName:(NSString *)name{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:name];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n```\n#### 13. 对图片进行模糊处理\n```objectivec\n#pragma mark - 对图片进行模糊处理\n// CIGaussianBlur ---> 高斯模糊\n// CIBoxBlur      ---> 均值模糊(Available in iOS 9.0 and later)\n// CIDiscBlur     ---> 环形卷积模糊(Available in iOS 9.0 and later)\n// CIMedianFilter ---> 中值模糊, 用于消除图像噪点, 无需设置radius(Available in iOS 9.0 and later)\n// CIMotionBlur   ---> 运动模糊, 用于模拟相机移动拍摄时的扫尾效果(Available in iOS 9.0 and later)\n+ (UIImage *)blurWithOriginalImage:(UIImage *)image blurName:(NSString *)name radius:(NSInteger)radius{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter;\n    if (name.length != 0) {\n        filter = [CIFilter filterWithName:name];\n        [filter setValue:inputImage forKey:kCIInputImageKey];\n        if (![name isEqualToString:@\"CIMedianFilter\"]) {\n            [filter setValue:@(radius) forKey:@\"inputRadius\"];\n        }\n        CIImage *result = [filter valueForKey:kCIOutputImageKey];\n        CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n        UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n        CGImageRelease(cgImage);\n        return resultImage;\n    }else{\n        return nil;\n    }\n}\n```\n\n#### 14. 调整图片饱和度、亮度、对比度\n```objectivec\n/**\n *  调整图片饱和度, 亮度, 对比度\n *\n *  @param image      目标图片\n *  @param saturation 饱和度\n *  @param brightness 亮度: -1.0 ~ 1.0\n *  @param contrast   对比度\n *\n */\n+ (UIImage *)colorControlsWithOriginalImage:(UIImage *)image\n                                 saturation:(CGFloat)saturation\n                                 brightness:(CGFloat)brightness\n                                   contrast:(CGFloat)contrast{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:@\"CIColorControls\"];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n\n    [filter setValue:@(saturation) forKey:@\"inputSaturation\"];\n    [filter setValue:@(brightness) forKey:@\"inputBrightness\"];\n    [filter setValue:@(contrast) forKey:@\"inputContrast\"];\n\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n```\n\n#### 15. 创建一张实时模糊效果 View (毛玻璃效果)\n```objectivec\n//Avilable in iOS 8.0 and later\n+ (UIVisualEffectView *)effectViewWithFrame:(CGRect)frame{\n    UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];\n    UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:effect];\n    effectView.frame = frame;\n    return effectView;\n}\n```\n\n#### 16. 全屏截图\n```objectivec\n//全屏截图\n+ (UIImage *)shotScreen{\n    UIWindow *window = [UIApplication sharedApplication].keyWindow;\n    UIGraphicsBeginImageContext(window.bounds.size);\n    [window.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n\n```\n\n#### 17. 截取一张 view 生成图片\n```objectivec\n//截取view生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view{\n    UIGraphicsBeginImageContext(view.bounds.size);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n```\n#### 18. 截取view中某个区域生成一张图片\n```objectivec\n//截取view中某个区域生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view scope:(CGRect)scope{\n    CGImageRef imageRef = CGImageCreateWithImageInRect([self shotWithView:view].CGImage, scope);\n    UIGraphicsBeginImageContext(scope.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGRect rect = CGRectMake(0, 0, scope.size.width, scope.size.height);\n    CGContextTranslateCTM(context, 0, rect.size.height);//下移\n    CGContextScaleCTM(context, 1.0f, -1.0f);//上翻\n    CGContextDrawImage(context, rect, imageRef);\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    CGImageRelease(imageRef);\n    CGContextRelease(context);\n    return image;\n}\n```\n#### 19. 压缩图片到指定尺寸大小\n```objectivec\n//压缩图片到指定尺寸大小\n+ (UIImage *)compressOriginalImage:(UIImage *)image toSize:(CGSize)size{\n    UIImage *resultImage = image;\n    UIGraphicsBeginImageContext(size);\n    [resultImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    UIGraphicsEndImageContext();\n    return resultImage;\n}\n```\n#### 20. 压缩图片到指定文件大小\n```objectivec\n//压缩图片到指定文件大小\n+ (NSData *)compressOriginalImage:(UIImage *)image toMaxDataSizeKBytes:(CGFloat)size{\n    NSData *data = UIImageJPEGRepresentation(image, 1.0);\n    CGFloat dataKBytes = data.length/1000.0;\n    CGFloat maxQuality = 0.9f;\n    CGFloat lastData = dataKBytes;\n    while (dataKBytes > size && maxQuality > 0.01f) {\n        maxQuality = maxQuality - 0.01f;\n        data = UIImageJPEGRepresentation(image, maxQuality);\n        dataKBytes = data.length/1000.0;\n        if (lastData == dataKBytes) {\n            break;\n        }else{\n            lastData = dataKBytes;\n        }\n    }\n    return data;\n}\n```\n\n#### 21. 获取设备 IP 地址\n\n需要先引入下头文件:\n\n`#import <ifaddrs.h>`\n`#import <arpa/inet.h>`\n\n```objectivec\n//获取设备 IP 地址\n+ (NSString *)getIPAddress {\n    NSString *address = @\"error\";\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    success = getifaddrs(&interfaces);\n    if (success == 0) {\n        temp_addr = interfaces;\n        while(temp_addr != NULL) {\n            if(temp_addr->ifa_addr->sa_family == AF_INET) {\n                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@\"en0\"]) {\n                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];\n                }\n            }\n            temp_addr = temp_addr->ifa_next;\n        }\n    }\n    freeifaddrs(interfaces);\n    return address;\n}\n```\n#### 22. 判断字符串中是否含有空格\n\n```objectivec\n+ (BOOL)isHaveSpaceInString:(NSString *)string{\n    NSRange _range = [string rangeOfString:@\" \"];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n```\n\n#### 23. 判断字符串中是否含有某个字符串\n\n\n```objectivec\n+ (BOOL)isHaveString:(NSString *)string1 InString:(NSString *)string2{\n    NSRange _range = [string2 rangeOfString:string1];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n```\n\n#### 24. 判断字符串中是否含有中文\n\n```objectivec\n+ (BOOL)isHaveChineseInString:(NSString *)string{\n    for(NSInteger i = 0; i < [string length]; i++){\n        int a = [string characterAtIndex:i];\n        if (a > 0x4e00 && a < 0x9fff) {\n            return YES;\n        }\n    }\n    return NO;\n}\n```\n\n#### 25. 判断字符串是否全部为数字\n\n```objectivec\n+ (BOOL)isAllNum:(NSString *)string{\n    unichar c;\n    for (int i=0; i<string.length; i++) {\n        c=[string characterAtIndex:i];\n        if (!isdigit(c)) {\n            return NO;\n        }\n    }\n    return YES;\n}\n```\n\n#### 26. 绘制虚线\n\n```objectivec\n/*\n  ** lineFrame:     虚线的 frame\n  ** length:        虚线中短线的宽度\n  ** spacing:       虚线中短线之间的间距\n  ** color:         虚线中短线的颜色\n*/\n+ (UIView *)createDashedLineWithFrame:(CGRect)lineFrame\n                           lineLength:(int)length\n                          lineSpacing:(int)spacing\n                            lineColor:(UIColor *)color{\n    UIView *dashedLine = [[UIView alloc] initWithFrame:lineFrame];\n    dashedLine.backgroundColor = [UIColor clearColor];\n    CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n    [shapeLayer setBounds:dashedLine.bounds];\n    [shapeLayer setPosition:CGPointMake(CGRectGetWidth(dashedLine.frame) / 2, CGRectGetHeight(dashedLine.frame))];\n    [shapeLayer setFillColor:[UIColor clearColor].CGColor];\n    [shapeLayer setStrokeColor:color.CGColor];\n    [shapeLayer setLineWidth:CGRectGetHeight(dashedLine.frame)];\n    [shapeLayer setLineJoin:kCALineJoinRound];\n    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:length], [NSNumber numberWithInt:spacing], nil]];\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathMoveToPoint(path, NULL, 0, 0);\n    CGPathAddLineToPoint(path, NULL, CGRectGetWidth(dashedLine.frame), 0);\n    [shapeLayer setPath:path];\n    CGPathRelease(path);\n    [dashedLine.layer addSublayer:shapeLayer];\n    return dashedLine;\n}\n```\n\n#### 27. 将字典对象转换为 JSON 字符串\n\n```objectivec\n+ (NSString *)jsonPrettyStringEncoded:(NSDictionary *)dictionary{\n    if ([NSJSONSerialization isValidJSONObject:dictionary ]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dictionary options:NSJSONWritingPrettyPrinted error:&error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n```\n\n#### 28.将数组对象转换为 JSON 字符串\n\n```objectivec\n+ (NSString *)jsonPrettyStringEncoded:(NSArray *)array{\n    if ([NSJSONSerialization isValidJSONObject:array]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:array options:NSJSONWritingPrettyPrinted error:&error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n```\n\n#### 29. 获取 WiFi 信息\n\n需要引入头文件:\n\n`#import <SystemConfiguration/CaptiveNetwork.h>`\n\n```objectivec\n//获取 WiFi 信息\n- (NSDictionary *)fetchSSIDInfo {\n    NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();\n    if (!ifs) {\n        return nil;\n    }\n    NSDictionary *info = nil;\n    for (NSString *ifnam in ifs) {\n        info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);\n        if (info && [info count]) { break; }\n    }\n    return info;\n}\n```\n\n#### 30. 获取广播地址、本机地址、子网掩码、端口信息\n需要引入头文件:\n\n`#import <ifaddrs.h>`\n`#import <arpa/inet.h>`\n\n```objectivec\n//获取广播地址、本机地址、子网掩码、端口信息\n- (NSMutableDictionary *)getLocalInfoForCurrentWiFi {\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    // retrieve the current interfaces - returns 0 on success\n    success = getifaddrs(&interfaces);\n    if (success == 0) {\n        // Loop through linked list of interfaces\n        temp_addr = interfaces;\n        //*/\n        while(temp_addr != NULL) {\n            if(temp_addr->ifa_addr->sa_family == AF_INET) {\n                // Check if interface is en0 which is the wifi connection on the iPhone\n                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@\"en0\"]) {\n                    //广播地址\n                    NSString *broadcast = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_dstaddr)->sin_addr)];\n                    if (broadcast) {\n                        [dict setObject:broadcast forKey:@\"broadcast\"];\n                    }\n//                    NSLog(@\"broadcast address--%@\",broadcast);\n                    //本机地址\n                    NSString *localIp = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];\n                    if (localIp) {\n                        [dict setObject:localIp forKey:@\"localIp\"];\n                    }\n//                    NSLog(@\"local device ip--%@\",localIp);\n                    //子网掩码地址\n                    NSString *netmask = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_netmask)->sin_addr)];\n                    if (netmask) {\n                        [dict setObject:netmask forKey:@\"netmask\"];\n                    }\n//                    NSLog(@\"netmask--%@\",netmask);\n                    //--en0 端口地址\n                    NSString *interface = [NSString stringWithUTF8String:temp_addr->ifa_name];\n                    if (interface) {\n                        [dict setObject:interface forKey:@\"interface\"];\n                    }\n//                    NSLog(@\"interface--%@\",interface);\n                    return dict;\n                }\n            }\n            temp_addr = temp_addr->ifa_next;\n        }\n    }\n    // Free memory\n    freeifaddrs(interfaces);\n    return dict;\n}\n```\n\n\n\n\n\n\n","slug":"iOS常用工具方法","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8tw9001aznuz87k3csti","content":"<h4 id=\"1-获取磁盘总空间大小\"><a href=\"#1-获取磁盘总空间大小\" class=\"headerlink\" title=\"1. 获取磁盘总空间大小\"></a>1. 获取磁盘总空间大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//磁盘总空间</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>diskOfAllSizeMBytes<span class=\"token punctuation\">{</span>\n    CGFloat size <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n    NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\n    NSDictionary <span class=\"token operator\">*</span>dic <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> attributesOfFileSystemForPath<span class=\"token punctuation\">:</span><span class=\"token function\">NSHomeDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> DEBUG</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"error: %@\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">.</span>localizedDescription<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        NSNumber <span class=\"token operator\">*</span>number <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>dic objectForKey<span class=\"token punctuation\">:</span>NSFileSystemSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        size <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>number floatValue<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> size<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"2-获取磁盘可用空间大小\"><a href=\"#2-获取磁盘可用空间大小\" class=\"headerlink\" title=\"2. 获取磁盘可用空间大小\"></a>2. 获取磁盘可用空间大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//磁盘可用空间</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>diskOfFreeSizeMBytes<span class=\"token punctuation\">{</span>\n    CGFloat size <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>\n    NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\n    NSDictionary <span class=\"token operator\">*</span>dic <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span> attributesOfFileSystemForPath<span class=\"token punctuation\">:</span><span class=\"token function\">NSHomeDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> DEBUG</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"error: %@\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">.</span>localizedDescription<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        NSNumber <span class=\"token operator\">*</span>number <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>dic objectForKey<span class=\"token punctuation\">:</span>NSFileSystemFreeSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        size <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>number floatValue<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token operator\">/</span><span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> size<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"3-获取指定路径下某个文件的大小\"><a href=\"#3-获取指定路径下某个文件的大小\" class=\"headerlink\" title=\"3. 获取指定路径下某个文件的大小\"></a>3. 获取指定路径下某个文件的大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取文件大小</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>fileSizeAtPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>filePath<span class=\"token punctuation\">{</span>\n    NSFileManager <span class=\"token operator\">*</span>fileManager <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>fileManager fileExistsAtPath<span class=\"token punctuation\">:</span>filePath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>fileManager attributesOfItemAtPath<span class=\"token punctuation\">:</span>filePath error<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span> fileSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"4-获取文件夹下所有文件的大小\"><a href=\"#4-获取文件夹下所有文件的大小\" class=\"headerlink\" title=\"4. 获取文件夹下所有文件的大小\"></a>4. 获取文件夹下所有文件的大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取文件夹下所有文件的大小</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>folderSizeAtPath<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>folderPath<span class=\"token punctuation\">{</span>\n    NSFileManager <span class=\"token operator\">*</span>fileManager <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSFileManager defaultManager<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>fileManager fileExistsAtPath<span class=\"token punctuation\">:</span>folderPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    NSEnumerator <span class=\"token operator\">*</span>filesEnumerator <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>fileManager subpathsAtPath<span class=\"token punctuation\">:</span>folderPath<span class=\"token punctuation\">]</span> objectEnumerator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>fileName<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> folerSize <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fileName <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>filesEnumerator nextObject<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSString <span class=\"token operator\">*</span>filePath <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>folderPath stringByAppendingPathComponent<span class=\"token punctuation\">:</span>fileName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        folerSize <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> fileSizeAtPath<span class=\"token punctuation\">:</span>filePath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> folerSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"5-获取字符串-或汉字-首字母\"><a href=\"#5-获取字符串-或汉字-首字母\" class=\"headerlink\" title=\"5. 获取字符串(或汉字)首字母\"></a>5. 获取字符串(或汉字)首字母</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取字符串(或汉字)首字母</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstCharacterWithString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    NSMutableString <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformMandarinLatin<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformStripDiacritics<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>pingyin <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>str capitalizedString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>pingyin substringToIndex<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"5-获取字符串-或汉字-首字母-1\"><a href=\"#5-获取字符串-或汉字-首字母-1\" class=\"headerlink\" title=\"5. 获取字符串(或汉字)首字母\"></a>5. 获取字符串(或汉字)首字母</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取字符串(或汉字)首字母</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstCharacterWithString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    NSMutableString <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformMandarinLatin<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformStripDiacritics<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>pingyin <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>str capitalizedString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>pingyin substringToIndex<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"6-将字符串数组按照元素首字母顺序进行排序分组\"><a href=\"#6-将字符串数组按照元素首字母顺序进行排序分组\" class=\"headerlink\" title=\"6. 将字符串数组按照元素首字母顺序进行排序分组\"></a>6. 将字符串数组按照元素首字母顺序进行排序分组</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//将字符串数组按照元素首字母顺序进行排序分组</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>dictionaryOrderByCharacterWithOriginalArray<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSArray <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>array<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">.</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>id obj <span class=\"token keyword\">in</span> array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>obj isKindOfClass<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSString class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    UILocalizedIndexedCollation <span class=\"token operator\">*</span>indexedCollation <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UILocalizedIndexedCollation currentCollation<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSMutableArray <span class=\"token operator\">*</span>objects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithCapacity<span class=\"token punctuation\">:</span>indexedCollation<span class=\"token punctuation\">.</span>sectionTitles<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建27个分组数组</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> indexedCollation<span class=\"token punctuation\">.</span>sectionTitles<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSMutableArray <span class=\"token operator\">*</span>obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray array<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>objects addObject<span class=\"token punctuation\">:</span>obj<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    NSMutableArray <span class=\"token operator\">*</span>keys <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithCapacity<span class=\"token punctuation\">:</span>objects<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//按字母顺序进行分组</span>\n    NSInteger lastIndex <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSInteger index <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>indexedCollation sectionForObject<span class=\"token punctuation\">:</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> collationStringSelector<span class=\"token punctuation\">:</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>uppercaseString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>objects objectAtIndex<span class=\"token punctuation\">:</span>index<span class=\"token punctuation\">]</span> addObject<span class=\"token punctuation\">:</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        lastIndex <span class=\"token operator\">=</span> index<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//去掉空数组</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> objects<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSMutableArray <span class=\"token operator\">*</span>obj <span class=\"token operator\">=</span> objects<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span>objects removeObject<span class=\"token punctuation\">:</span>obj<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取索引字母</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>NSMutableArray <span class=\"token operator\">*</span>obj <span class=\"token keyword\">in</span> objects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSString <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        NSString <span class=\"token operator\">*</span>key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> firstCharacterWithString<span class=\"token punctuation\">:</span>str<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>keys addObject<span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>dic <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>dic setObject<span class=\"token punctuation\">:</span>objects forKey<span class=\"token punctuation\">:</span>keys<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> dic<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//获取字符串(或汉字)首字母</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstCharacterWithString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    NSMutableString <span class=\"token operator\">*</span>str <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span>string<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformMandarinLatin<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFStringTransform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFMutableStringRef<span class=\"token punctuation\">)</span>str<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> kCFStringTransformStripDiacritics<span class=\"token punctuation\">,</span> NO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>pingyin <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>str capitalizedString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>pingyin substringToIndex<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h5 id=\"使用如下\"><a href=\"#使用如下\" class=\"headerlink\" title=\"使用如下:\"></a>使用如下:</h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>arr <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"guangzhou\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"shanghai\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"北京\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"henan\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"hainan\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSDictionary <span class=\"token operator\">*</span>dic <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Utilities dictionaryOrderByCharacterWithOriginalArray<span class=\"token punctuation\">:</span>arr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"\\n\\ndic: %@\"</span><span class=\"token punctuation\">,</span> dic<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-a63d16ad6cccc312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"></p>\n<h4 id=\"7-获取当前时间\"><a href=\"#7-获取当前时间\" class=\"headerlink\" title=\"7. 获取当前时间\"></a>7. 获取当前时间</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取当前时间</span>\n<span class=\"token comment\" spellcheck=\"true\">//format: @\"yyyy-MM-dd HH:mm:ss\"、@\"yyyy年MM月dd日 HH时mm分ss秒\"</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>currentDateWithFormat<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>format<span class=\"token punctuation\">{</span>\n    NSDateFormatter <span class=\"token operator\">*</span>dateFormatter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>dateFormatter setDateFormat<span class=\"token punctuation\">:</span>format<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>dateFormatter stringFromDate<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSDate date<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"8-计算上次日期距离现在多久-如-xx-小时前、xx-分钟前等\"><a href=\"#8-计算上次日期距离现在多久-如-xx-小时前、xx-分钟前等\" class=\"headerlink\" title=\"8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等\"></a>8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/**\n *  计算上次日期距离现在多久\n *\n *  @param lastTime    上次日期(需要和格式对应)\n *  @param format1     上次日期格式\n *  @param currentTime 最近日期(需要和格式对应)\n *  @param format2     最近日期格式\n *\n *  @return xx分钟前、xx小时前、xx天前\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>timeIntervalFromLastTime<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastTime\n                        lastTimeFormat<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>format1\n                         ToCurrentTime<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>currentTime\n                     currentTimeFormat<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>format2<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//上次时间</span>\n    NSDateFormatter <span class=\"token operator\">*</span>dateFormatter1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span>init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    dateFormatter1<span class=\"token punctuation\">.</span>dateFormat <span class=\"token operator\">=</span> format1<span class=\"token punctuation\">;</span>\n    NSDate <span class=\"token operator\">*</span>lastDate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>dateFormatter1 dateFromString<span class=\"token punctuation\">:</span>lastTime<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//当前时间</span>\n    NSDateFormatter <span class=\"token operator\">*</span>dateFormatter2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span>init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    dateFormatter2<span class=\"token punctuation\">.</span>dateFormat <span class=\"token operator\">=</span> format2<span class=\"token punctuation\">;</span>\n    NSDate <span class=\"token operator\">*</span>currentDate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>dateFormatter2 dateFromString<span class=\"token punctuation\">:</span>currentTime<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>Utilities timeIntervalFromLastTime<span class=\"token punctuation\">:</span>lastDate ToCurrentTime<span class=\"token punctuation\">:</span>currentDate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>timeIntervalFromLastTime<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDate <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastTime ToCurrentTime<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDate <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>currentTime<span class=\"token punctuation\">{</span>\n    NSTimeZone <span class=\"token operator\">*</span>timeZone <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSTimeZone systemTimeZone<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//上次时间</span>\n    NSDate <span class=\"token operator\">*</span>lastDate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>lastTime dateByAddingTimeInterval<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>timeZone secondsFromGMTForDate<span class=\"token punctuation\">:</span>lastTime<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//当前时间</span>\n    NSDate <span class=\"token operator\">*</span>currentDate <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>currentTime dateByAddingTimeInterval<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>timeZone secondsFromGMTForDate<span class=\"token punctuation\">:</span>currentTime<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//时间间隔</span>\n    NSInteger intevalTime <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>currentDate timeIntervalSinceReferenceDate<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">[</span>lastDate timeIntervalSinceReferenceDate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//秒、分、小时、天、月、年</span>\n    NSInteger minutes <span class=\"token operator\">=</span> intevalTime <span class=\"token operator\">/</span> <span class=\"token number\">60</span><span class=\"token punctuation\">;</span>\n    NSInteger hours <span class=\"token operator\">=</span> intevalTime <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">60</span><span class=\"token punctuation\">;</span>\n    NSInteger day <span class=\"token operator\">=</span> intevalTime <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">24</span><span class=\"token punctuation\">;</span>\n    NSInteger month <span class=\"token operator\">=</span> intevalTime <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">24</span> <span class=\"token operator\">/</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n    NSInteger yers <span class=\"token operator\">=</span> intevalTime <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">60</span> <span class=\"token operator\">/</span> <span class=\"token number\">24</span> <span class=\"token operator\">/</span> <span class=\"token number\">365</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minutes <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span>  <span class=\"token string\">@\"刚刚\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minutes <span class=\"token operator\">&lt;</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span> <span class=\"token string\">@\"%ld分钟前\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>minutes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hours <span class=\"token operator\">&lt;</span> <span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span> <span class=\"token string\">@\"%ld小时前\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>hours<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>day <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>NSString stringWithFormat<span class=\"token punctuation\">:</span> <span class=\"token string\">@\"%ld天前\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>day<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>month <span class=\"token operator\">&lt;</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        NSDateFormatter <span class=\"token operator\">*</span> df <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span>init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        df<span class=\"token punctuation\">.</span>dateFormat <span class=\"token operator\">=</span> <span class=\"token string\">@\"M月d日\"</span><span class=\"token punctuation\">;</span>\n        NSString <span class=\"token operator\">*</span> time <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>df stringFromDate<span class=\"token punctuation\">:</span>lastDate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> time<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>yers <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        NSDateFormatter <span class=\"token operator\">*</span> df <span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSDateFormatter alloc<span class=\"token punctuation\">]</span>init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        df<span class=\"token punctuation\">.</span>dateFormat <span class=\"token operator\">=</span> <span class=\"token string\">@\"yyyy年M月d日\"</span><span class=\"token punctuation\">;</span>\n        NSString <span class=\"token operator\">*</span> time <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>df stringFromDate<span class=\"token punctuation\">:</span>lastDate<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> time<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">@\"\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"使用如下-1\"><a href=\"#使用如下-1\" class=\"headerlink\" title=\"使用如下:\"></a>使用如下:</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"\\n\\nresult: %@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>Utilities timeIntervalFromLastTime<span class=\"token punctuation\">:</span><span class=\"token string\">@\"2015年12月8日 15:50\"</span>\n                                           lastTimeFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"yyyy年MM月dd日 HH:mm\"</span>\n                                            ToCurrentTime<span class=\"token punctuation\">:</span><span class=\"token string\">@\"2015/12/08 16:12\"</span>\n                                        currentTimeFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"yyyy/MM/dd HH:mm\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>输出结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-591e3b7e5982b1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"></p>\n<h4 id=\"9-判断手机号码格式是否正确\"><a href=\"#9-判断手机号码格式是否正确\" class=\"headerlink\" title=\"9. 判断手机号码格式是否正确\"></a>9. 判断手机号码格式是否正确</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//判断手机号码格式是否正确</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>valiMobile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>mobile<span class=\"token punctuation\">{</span>\n    mobile <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mobile stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\" \"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mobile<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!=</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/**\n         * 移动号段正则表达式\n         */</span>\n        NSString <span class=\"token operator\">*</span>CM_NUM <span class=\"token operator\">=</span> <span class=\"token string\">@\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/**\n         * 联通号段正则表达式\n         */</span>\n        NSString <span class=\"token operator\">*</span>CU_NUM <span class=\"token operator\">=</span> <span class=\"token string\">@\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/**\n         * 电信号段正则表达式\n         */</span>\n        NSString <span class=\"token operator\">*</span>CT_NUM <span class=\"token operator\">=</span> <span class=\"token string\">@\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$\"</span><span class=\"token punctuation\">;</span>\n        NSPredicate <span class=\"token operator\">*</span>pred1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span> CM_NUM<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        BOOL isMatch1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>pred1 evaluateWithObject<span class=\"token punctuation\">:</span>mobile<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        NSPredicate <span class=\"token operator\">*</span>pred2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span> CU_NUM<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        BOOL isMatch2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>pred2 evaluateWithObject<span class=\"token punctuation\">:</span>mobile<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        NSPredicate <span class=\"token operator\">*</span>pred3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span> CT_NUM<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        BOOL isMatch3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>pred3 evaluateWithObject<span class=\"token punctuation\">:</span>mobile<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isMatch1 <span class=\"token operator\">||</span> isMatch2 <span class=\"token operator\">||</span> isMatch3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"10-判断邮箱格式是否正确\"><a href=\"#10-判断邮箱格式是否正确\" class=\"headerlink\" title=\"10. 判断邮箱格式是否正确\"></a>10. 判断邮箱格式是否正确</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//利用正则表达式验证</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isAvailableEmail<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>email <span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>emailRegex <span class=\"token operator\">=</span> <span class=\"token string\">@\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\"</span><span class=\"token punctuation\">;</span>\n    NSPredicate <span class=\"token operator\">*</span>emailTest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSPredicate predicateWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"SELF MATCHES %@\"</span><span class=\"token punctuation\">,</span> emailRegex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>emailTest evaluateWithObject<span class=\"token punctuation\">:</span>email<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"11-将十六进制颜色转换为-UIColor-对象\"><a href=\"#11-将十六进制颜色转换为-UIColor-对象\" class=\"headerlink\" title=\"11. 将十六进制颜色转换为 UIColor 对象\"></a>11. 将十六进制颜色转换为 UIColor 对象</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//将十六进制颜色转换为 UIColor 对象</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>colorWithHexString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>color<span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>cString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>color stringByTrimmingCharactersInSet<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSCharacterSet whitespaceAndNewlineCharacterSet<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> uppercaseString<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// String should be 6 or 8 characters</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>cString length<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// strip \"0X\" or \"#\" if it appears</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>cString hasPrefix<span class=\"token punctuation\">:</span><span class=\"token string\">@\"0X\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        cString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>cString substringFromIndex<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>cString hasPrefix<span class=\"token punctuation\">:</span><span class=\"token string\">@\"#\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        cString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>cString substringFromIndex<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>cString length<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Separate into r, g, b substrings</span>\n    NSRange range<span class=\"token punctuation\">;</span>\n    range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    range<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//r</span>\n    NSString <span class=\"token operator\">*</span>rString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>cString substringWithRange<span class=\"token punctuation\">:</span>range<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//g</span>\n    range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>gString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>cString substringWithRange<span class=\"token punctuation\">:</span>range<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//b</span>\n    range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>bString <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>cString substringWithRange<span class=\"token punctuation\">:</span>range<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Scan values</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSScanner scannerWithString<span class=\"token punctuation\">:</span>rString<span class=\"token punctuation\">]</span> scanHexInt<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSScanner scannerWithString<span class=\"token punctuation\">:</span>gString<span class=\"token punctuation\">]</span> scanHexInt<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>g<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSScanner scannerWithString<span class=\"token punctuation\">:</span>bString<span class=\"token punctuation\">]</span> scanHexInt<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>UIColor colorWithRed<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span> r <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span><span class=\"token punctuation\">)</span> green<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span> g <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span><span class=\"token punctuation\">)</span> blue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span> b <span class=\"token operator\">/</span> <span class=\"token number\">255.0f</span><span class=\"token punctuation\">)</span> alpha<span class=\"token punctuation\">:</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"12-对图片进行滤镜处理\"><a href=\"#12-对图片进行滤镜处理\" class=\"headerlink\" title=\"12. 对图片进行滤镜处理\"></a>12. 对图片进行滤镜处理</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 对图片进行滤镜处理</span>\n<span class=\"token comment\" spellcheck=\"true\">// 怀旧 --> CIPhotoEffectInstant                         单色 --> CIPhotoEffectMono</span>\n<span class=\"token comment\" spellcheck=\"true\">// 黑白 --> CIPhotoEffectNoir                            褪色 --> CIPhotoEffectFade</span>\n<span class=\"token comment\" spellcheck=\"true\">// 色调 --> CIPhotoEffectTonal                           冲印 --> CIPhotoEffectProcess</span>\n<span class=\"token comment\" spellcheck=\"true\">// 岁月 --> CIPhotoEffectTransfer                        铬黄 --> CIPhotoEffectChrome</span>\n<span class=\"token comment\" spellcheck=\"true\">// CILinearToSRGBToneCurve, CISRGBToneCurveToLinear, CIGaussianBlur, CIBoxBlur, CIDiscBlur, CISepiaTone, CIDepthOfField</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>filterWithOriginalImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image filterName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name<span class=\"token punctuation\">{</span>\n    CIContext <span class=\"token operator\">*</span>context <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIContext contextWithOptions<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIImage <span class=\"token operator\">*</span>inputImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>CIImage alloc<span class=\"token punctuation\">]</span> initWithImage<span class=\"token punctuation\">:</span>image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIFilter <span class=\"token operator\">*</span>filter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIFilter filterWithName<span class=\"token punctuation\">:</span>name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span>inputImage forKey<span class=\"token punctuation\">:</span>kCIInputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIImage <span class=\"token operator\">*</span>result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>filter valueForKey<span class=\"token punctuation\">:</span>kCIOutputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CGImageRef cgImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>context createCGImage<span class=\"token punctuation\">:</span>result fromRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>result extent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>resultImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageWithCGImage<span class=\"token punctuation\">:</span>cgImage<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>cgImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> resultImage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"13-对图片进行模糊处理\"><a href=\"#13-对图片进行模糊处理\" class=\"headerlink\" title=\"13. 对图片进行模糊处理\"></a>13. 对图片进行模糊处理</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 对图片进行模糊处理</span>\n<span class=\"token comment\" spellcheck=\"true\">// CIGaussianBlur ---> 高斯模糊</span>\n<span class=\"token comment\" spellcheck=\"true\">// CIBoxBlur      ---> 均值模糊(Available in iOS 9.0 and later)</span>\n<span class=\"token comment\" spellcheck=\"true\">// CIDiscBlur     ---> 环形卷积模糊(Available in iOS 9.0 and later)</span>\n<span class=\"token comment\" spellcheck=\"true\">// CIMedianFilter ---> 中值模糊, 用于消除图像噪点, 无需设置radius(Available in iOS 9.0 and later)</span>\n<span class=\"token comment\" spellcheck=\"true\">// CIMotionBlur   ---> 运动模糊, 用于模拟相机移动拍摄时的扫尾效果(Available in iOS 9.0 and later)</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>blurWithOriginalImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image blurName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name radius<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">)</span>radius<span class=\"token punctuation\">{</span>\n    CIContext <span class=\"token operator\">*</span>context <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIContext contextWithOptions<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIImage <span class=\"token operator\">*</span>inputImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>CIImage alloc<span class=\"token punctuation\">]</span> initWithImage<span class=\"token punctuation\">:</span>image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIFilter <span class=\"token operator\">*</span>filter<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        filter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIFilter filterWithName<span class=\"token punctuation\">:</span>name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span>inputImage forKey<span class=\"token punctuation\">:</span>kCIInputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>name isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CIMedianFilter\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>radius<span class=\"token punctuation\">)</span> forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"inputRadius\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        CIImage <span class=\"token operator\">*</span>result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>filter valueForKey<span class=\"token punctuation\">:</span>kCIOutputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        CGImageRef cgImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>context createCGImage<span class=\"token punctuation\">:</span>result fromRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>result extent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        UIImage <span class=\"token operator\">*</span>resultImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageWithCGImage<span class=\"token punctuation\">:</span>cgImage<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>cgImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> resultImage<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"14-调整图片饱和度、亮度、对比度\"><a href=\"#14-调整图片饱和度、亮度、对比度\" class=\"headerlink\" title=\"14. 调整图片饱和度、亮度、对比度\"></a>14. 调整图片饱和度、亮度、对比度</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/**\n *  调整图片饱和度, 亮度, 对比度\n *\n *  @param image      目标图片\n *  @param saturation 饱和度\n *  @param brightness 亮度: -1.0 ~ 1.0\n *  @param contrast   对比度\n *\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>colorControlsWithOriginalImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image\n                                 saturation<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>saturation\n                                 brightness<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>brightness\n                                   contrast<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>contrast<span class=\"token punctuation\">{</span>\n    CIContext <span class=\"token operator\">*</span>context <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIContext contextWithOptions<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIImage <span class=\"token operator\">*</span>inputImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>CIImage alloc<span class=\"token punctuation\">]</span> initWithImage<span class=\"token punctuation\">:</span>image<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CIFilter <span class=\"token operator\">*</span>filter <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CIFilter filterWithName<span class=\"token punctuation\">:</span><span class=\"token string\">@\"CIColorControls\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span>inputImage forKey<span class=\"token punctuation\">:</span>kCIInputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>saturation<span class=\"token punctuation\">)</span> forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"inputSaturation\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>brightness<span class=\"token punctuation\">)</span> forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"inputBrightness\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>filter setValue<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>contrast<span class=\"token punctuation\">)</span> forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"inputContrast\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    CIImage <span class=\"token operator\">*</span>result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>filter valueForKey<span class=\"token punctuation\">:</span>kCIOutputImageKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CGImageRef cgImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>context createCGImage<span class=\"token punctuation\">:</span>result fromRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>result extent<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>resultImage <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIImage imageWithCGImage<span class=\"token punctuation\">:</span>cgImage<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>cgImage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> resultImage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"15-创建一张实时模糊效果-View-毛玻璃效果\"><a href=\"#15-创建一张实时模糊效果-View-毛玻璃效果\" class=\"headerlink\" title=\"15. 创建一张实时模糊效果 View (毛玻璃效果)\"></a>15. 创建一张实时模糊效果 View (毛玻璃效果)</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//Avilable in iOS 8.0 and later</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIVisualEffectView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>effectViewWithFrame<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>frame<span class=\"token punctuation\">{</span>\n    UIBlurEffect <span class=\"token operator\">*</span>effect <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIBlurEffect effectWithStyle<span class=\"token punctuation\">:</span>UIBlurEffectStyleLight<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIVisualEffectView <span class=\"token operator\">*</span>effectView <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIVisualEffectView alloc<span class=\"token punctuation\">]</span> initWithEffect<span class=\"token punctuation\">:</span>effect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    effectView<span class=\"token punctuation\">.</span>frame <span class=\"token operator\">=</span> frame<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> effectView<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"16-全屏截图\"><a href=\"#16-全屏截图\" class=\"headerlink\" title=\"16. 全屏截图\"></a>16. 全屏截图</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//全屏截图</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>shotScreen<span class=\"token punctuation\">{</span>\n    UIWindow <span class=\"token operator\">*</span>window <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIApplication sharedApplication<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>keyWindow<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>window<span class=\"token punctuation\">.</span>layer renderInContext<span class=\"token punctuation\">:</span><span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"17-截取一张-view-生成图片\"><a href=\"#17-截取一张-view-生成图片\" class=\"headerlink\" title=\"17. 截取一张 view 生成图片\"></a>17. 截取一张 view 生成图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//截取view生成一张图片</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>shotWithView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>view<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>view<span class=\"token punctuation\">.</span>layer renderInContext<span class=\"token punctuation\">:</span><span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"18-截取view中某个区域生成一张图片\"><a href=\"#18-截取view中某个区域生成一张图片\" class=\"headerlink\" title=\"18. 截取view中某个区域生成一张图片\"></a>18. 截取view中某个区域生成一张图片</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//截取view中某个区域生成一张图片</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>shotWithView<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>view scope<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>scope<span class=\"token punctuation\">{</span>\n    CGImageRef imageRef <span class=\"token operator\">=</span> <span class=\"token function\">CGImageCreateWithImageInRect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> shotWithView<span class=\"token punctuation\">:</span>view<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>CGImage<span class=\"token punctuation\">,</span> scope<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>scope<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGContextRef context <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGRect rect <span class=\"token operator\">=</span> <span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> scope<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> scope<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextTranslateCTM</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//下移</span>\n    <span class=\"token function\">CGContextScaleCTM</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//上翻</span>\n    <span class=\"token function\">CGContextDrawImage</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">,</span> imageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    UIImage <span class=\"token operator\">*</span>image <span class=\"token operator\">=</span> <span class=\"token function\">UIGraphicsGetImageFromCurrentImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGImageRelease</span><span class=\"token punctuation\">(</span>imageRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGContextRelease</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> image<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"19-压缩图片到指定尺寸大小\"><a href=\"#19-压缩图片到指定尺寸大小\" class=\"headerlink\" title=\"19. 压缩图片到指定尺寸大小\"></a>19. 压缩图片到指定尺寸大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//压缩图片到指定尺寸大小</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>compressOriginalImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image toSize<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGSize<span class=\"token punctuation\">)</span>size<span class=\"token punctuation\">{</span>\n    UIImage <span class=\"token operator\">*</span>resultImage <span class=\"token operator\">=</span> image<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsBeginImageContext</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>resultImage drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">UIGraphicsEndImageContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> resultImage<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"20-压缩图片到指定文件大小\"><a href=\"#20-压缩图片到指定文件大小\" class=\"headerlink\" title=\"20. 压缩图片到指定文件大小\"></a>20. 压缩图片到指定文件大小</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//压缩图片到指定文件大小</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>compressOriginalImage<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIImage <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>image toMaxDataSizeKBytes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>size<span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">UIImageJPEGRepresentation</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CGFloat dataKBytes <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>length<span class=\"token operator\">/</span><span class=\"token number\">1000.0</span><span class=\"token punctuation\">;</span>\n    CGFloat maxQuality <span class=\"token operator\">=</span> <span class=\"token number\">0.9f</span><span class=\"token punctuation\">;</span>\n    CGFloat lastData <span class=\"token operator\">=</span> dataKBytes<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>dataKBytes <span class=\"token operator\">></span> size <span class=\"token operator\">&amp;&amp;</span> maxQuality <span class=\"token operator\">></span> <span class=\"token number\">0.01f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        maxQuality <span class=\"token operator\">=</span> maxQuality <span class=\"token operator\">-</span> <span class=\"token number\">0.01f</span><span class=\"token punctuation\">;</span>\n        data <span class=\"token operator\">=</span> <span class=\"token function\">UIImageJPEGRepresentation</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> maxQuality<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        dataKBytes <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>length<span class=\"token operator\">/</span><span class=\"token number\">1000.0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastData <span class=\"token operator\">==</span> dataKBytes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            lastData <span class=\"token operator\">=</span> dataKBytes<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"21-获取设备-IP-地址\"><a href=\"#21-获取设备-IP-地址\" class=\"headerlink\" title=\"21. 获取设备 IP 地址\"></a>21. 获取设备 IP 地址</h4><p>需要先引入下头文件:</p>\n<p><code>#import &lt;ifaddrs.h&gt;</code><br><code>#import &lt;arpa/inet.h&gt;</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取设备 IP 地址</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getIPAddress <span class=\"token punctuation\">{</span>\n    NSString <span class=\"token operator\">*</span>address <span class=\"token operator\">=</span> <span class=\"token string\">@\"error\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> ifaddrs <span class=\"token operator\">*</span>interfaces <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> ifaddrs <span class=\"token operator\">*</span>temp_addr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> success <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    success <span class=\"token operator\">=</span> <span class=\"token function\">getifaddrs</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>interfaces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        temp_addr <span class=\"token operator\">=</span> interfaces<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>temp_addr <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp_addr<span class=\"token operator\">-></span>ifa_addr<span class=\"token operator\">-></span>sa_family <span class=\"token operator\">==</span> AF_INET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span>temp_addr<span class=\"token operator\">-></span>ifa_name<span class=\"token punctuation\">]</span> isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"en0\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    address <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span><span class=\"token function\">inet_ntoa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr_in <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>temp_addr<span class=\"token operator\">-></span>ifa_addr<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>sin_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            temp_addr <span class=\"token operator\">=</span> temp_addr<span class=\"token operator\">-></span>ifa_next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">freeifaddrs</span><span class=\"token punctuation\">(</span>interfaces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> address<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"22-判断字符串中是否含有空格\"><a href=\"#22-判断字符串中是否含有空格\" class=\"headerlink\" title=\"22. 判断字符串中是否含有空格\"></a>22. 判断字符串中是否含有空格</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isHaveSpaceInString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    NSRange _range <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>string rangeOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\" \"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"23-判断字符串中是否含有某个字符串\"><a href=\"#23-判断字符串中是否含有某个字符串\" class=\"headerlink\" title=\"23. 判断字符串中是否含有某个字符串\"></a>23. 判断字符串中是否含有某个字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isHaveString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string1 InString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string2<span class=\"token punctuation\">{</span>\n    NSRange _range <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>string2 rangeOfString<span class=\"token punctuation\">:</span>string1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_range<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"24-判断字符串中是否含有中文\"><a href=\"#24-判断字符串中是否含有中文\" class=\"headerlink\" title=\"24. 判断字符串中是否含有中文\"></a>24. 判断字符串中是否含有中文</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isHaveChineseInString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>NSInteger i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">[</span>string length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>string characterAtIndex<span class=\"token punctuation\">:</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> <span class=\"token number\">0x4e00</span> <span class=\"token operator\">&amp;&amp;</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">0x9fff</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"25-判断字符串是否全部为数字\"><a href=\"#25-判断字符串是否全部为数字\" class=\"headerlink\" title=\"25. 判断字符串是否全部为数字\"></a>25. 判断字符串是否全部为数字</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>isAllNum<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>string<span class=\"token punctuation\">{</span>\n    unichar c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        c<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>string characterAtIndex<span class=\"token punctuation\">:</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isdigit</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> NO<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> YES<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"26-绘制虚线\"><a href=\"#26-绘制虚线\" class=\"headerlink\" title=\"26. 绘制虚线\"></a>26. 绘制虚线</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/*\n  ** lineFrame:     虚线的 frame\n  ** length:        虚线中短线的宽度\n  ** spacing:       虚线中短线之间的间距\n  ** color:         虚线中短线的颜色\n*/</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>UIView <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>createDashedLineWithFrame<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>lineFrame\n                           lineLength<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>length\n                          lineSpacing<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>spacing\n                            lineColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>UIColor <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>color<span class=\"token punctuation\">{</span>\n    UIView <span class=\"token operator\">*</span>dashedLine <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>UIView alloc<span class=\"token punctuation\">]</span> initWithFrame<span class=\"token punctuation\">:</span>lineFrame<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    dashedLine<span class=\"token punctuation\">.</span>backgroundColor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CAShapeLayer <span class=\"token operator\">*</span>shapeLayer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>CAShapeLayer layer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setBounds<span class=\"token punctuation\">:</span>dashedLine<span class=\"token punctuation\">.</span>bounds<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setPosition<span class=\"token punctuation\">:</span><span class=\"token function\">CGPointMake</span><span class=\"token punctuation\">(</span><span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>dashedLine<span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetHeight</span><span class=\"token punctuation\">(</span>dashedLine<span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setFillColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor clearColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setStrokeColor<span class=\"token punctuation\">:</span>color<span class=\"token punctuation\">.</span>CGColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setLineWidth<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectGetHeight</span><span class=\"token punctuation\">(</span>dashedLine<span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setLineJoin<span class=\"token punctuation\">:</span>kCALineJoinRound<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setLineDashPattern<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSArray arrayWithObjects<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSNumber numberWithInt<span class=\"token punctuation\">:</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>NSNumber numberWithInt<span class=\"token punctuation\">:</span>spacing<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CGMutablePathRef path <span class=\"token operator\">=</span> <span class=\"token function\">CGPathCreateMutable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGPathMoveToPoint</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGPathAddLineToPoint</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token function\">CGRectGetWidth</span><span class=\"token punctuation\">(</span>dashedLine<span class=\"token punctuation\">.</span>frame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>shapeLayer setPath<span class=\"token punctuation\">:</span>path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CGPathRelease</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>dashedLine<span class=\"token punctuation\">.</span>layer addSublayer<span class=\"token punctuation\">:</span>shapeLayer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> dashedLine<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"27-将字典对象转换为-JSON-字符串\"><a href=\"#27-将字典对象转换为-JSON-字符串\" class=\"headerlink\" title=\"27. 将字典对象转换为 JSON 字符串\"></a>27. 将字典对象转换为 JSON 字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>jsonPrettyStringEncoded<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>dictionary<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>NSJSONSerialization isValidJSONObject<span class=\"token punctuation\">:</span>dictionary <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\n        NSData <span class=\"token operator\">*</span>jsonData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSJSONSerialization dataWithJSONObject<span class=\"token punctuation\">:</span>dictionary options<span class=\"token punctuation\">:</span>NSJSONWritingPrettyPrinted error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSString <span class=\"token operator\">*</span>json <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span>jsonData encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> json<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"28-将数组对象转换为-JSON-字符串\"><a href=\"#28-将数组对象转换为-JSON-字符串\" class=\"headerlink\" title=\"28.将数组对象转换为 JSON 字符串\"></a>28.将数组对象转换为 JSON 字符串</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>jsonPrettyStringEncoded<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSArray <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>array<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>NSJSONSerialization isValidJSONObject<span class=\"token punctuation\">:</span>array<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        NSError <span class=\"token operator\">*</span>error<span class=\"token punctuation\">;</span>\n        NSData <span class=\"token operator\">*</span>jsonData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSJSONSerialization dataWithJSONObject<span class=\"token punctuation\">:</span>array options<span class=\"token punctuation\">:</span>NSJSONWritingPrettyPrinted error<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>error<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            NSString <span class=\"token operator\">*</span>json <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span>jsonData encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> json<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"29-获取-WiFi-信息\"><a href=\"#29-获取-WiFi-信息\" class=\"headerlink\" title=\"29. 获取 WiFi 信息\"></a>29. 获取 WiFi 信息</h4><p>需要引入头文件:</p>\n<p><code>#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取 WiFi 信息</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>fetchSSIDInfo <span class=\"token punctuation\">{</span>\n    NSArray <span class=\"token operator\">*</span>ifs <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>__bridge_transfer NSArray <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">CNCopySupportedInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ifs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    NSDictionary <span class=\"token operator\">*</span>info <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span>ifnam <span class=\"token keyword\">in</span> ifs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        info <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>__bridge_transfer NSDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">CNCopyCurrentNetworkInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFStringRef<span class=\"token punctuation\">)</span>ifnam<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>info <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span>info count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> info<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"30-获取广播地址、本机地址、子网掩码、端口信息\"><a href=\"#30-获取广播地址、本机地址、子网掩码、端口信息\" class=\"headerlink\" title=\"30. 获取广播地址、本机地址、子网掩码、端口信息\"></a>30. 获取广播地址、本机地址、子网掩码、端口信息</h4><p>需要引入头文件:</p>\n<p><code>#import &lt;ifaddrs.h&gt;</code><br><code>#import &lt;arpa/inet.h&gt;</code></p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//获取广播地址、本机地址、子网掩码、端口信息</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSMutableDictionary <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>getLocalInfoForCurrentWiFi <span class=\"token punctuation\">{</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> ifaddrs <span class=\"token operator\">*</span>interfaces <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> ifaddrs <span class=\"token operator\">*</span>temp_addr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> success <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// retrieve the current interfaces - returns 0 on success</span>\n    success <span class=\"token operator\">=</span> <span class=\"token function\">getifaddrs</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>interfaces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Loop through linked list of interfaces</span>\n        temp_addr <span class=\"token operator\">=</span> interfaces<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//*/</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>temp_addr <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp_addr<span class=\"token operator\">-></span>ifa_addr<span class=\"token operator\">-></span>sa_family <span class=\"token operator\">==</span> AF_INET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Check if interface is en0 which is the wifi connection on the iPhone</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span>temp_addr<span class=\"token operator\">-></span>ifa_name<span class=\"token punctuation\">]</span> isEqualToString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"en0\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//广播地址</span>\n                    NSString <span class=\"token operator\">*</span>broadcast <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span><span class=\"token function\">inet_ntoa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr_in <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>temp_addr<span class=\"token operator\">-></span>ifa_dstaddr<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>sin_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>broadcast<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token punctuation\">[</span>dict setObject<span class=\"token punctuation\">:</span>broadcast forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"broadcast\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//                    NSLog(@\"broadcast address--%@\",broadcast);</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//本机地址</span>\n                    NSString <span class=\"token operator\">*</span>localIp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span><span class=\"token function\">inet_ntoa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr_in <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>temp_addr<span class=\"token operator\">-></span>ifa_addr<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>sin_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>localIp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token punctuation\">[</span>dict setObject<span class=\"token punctuation\">:</span>localIp forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"localIp\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//                    NSLog(@\"local device ip--%@\",localIp);</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//子网掩码地址</span>\n                    NSString <span class=\"token operator\">*</span>netmask <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span><span class=\"token function\">inet_ntoa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> sockaddr_in <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>temp_addr<span class=\"token operator\">-></span>ifa_netmask<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>sin_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>netmask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token punctuation\">[</span>dict setObject<span class=\"token punctuation\">:</span>netmask forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"netmask\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//                    NSLog(@\"netmask--%@\",netmask);</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//--en0 端口地址</span>\n                    NSString <span class=\"token operator\">*</span>interface <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSString stringWithUTF8String<span class=\"token punctuation\">:</span>temp_addr<span class=\"token operator\">-></span>ifa_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>interface<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token punctuation\">[</span>dict setObject<span class=\"token punctuation\">:</span>interface forKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"interface\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//                    NSLog(@\"interface--%@\",interface);</span>\n                    <span class=\"token keyword\">return</span> dict<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            temp_addr <span class=\"token operator\">=</span> temp_addr<span class=\"token operator\">-></span>ifa_next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Free memory</span>\n    <span class=\"token function\">freeifaddrs</span><span class=\"token punctuation\">(</span>interfaces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> dict<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1-获取磁盘总空间大小\"><a href=\"#1-获取磁盘总空间大小\" class=\"headerlink\" title=\"1. 获取磁盘总空间大小\"></a>1. 获取磁盘总空间大小</h4><pre><code class=\"objectivec\">//磁盘总空间\n+ (CGFloat)diskOfAllSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@&quot;error: %@&quot;, error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n</code></pre>\n<h4 id=\"2-获取磁盘可用空间大小\"><a href=\"#2-获取磁盘可用空间大小\" class=\"headerlink\" title=\"2. 获取磁盘可用空间大小\"></a>2. 获取磁盘可用空间大小</h4><pre><code class=\"objectivec\">//磁盘可用空间\n+ (CGFloat)diskOfFreeSizeMBytes{\n    CGFloat size = 0.0;\n    NSError *error;\n    NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];\n    if (error) {\n#ifdef DEBUG\n        NSLog(@&quot;error: %@&quot;, error.localizedDescription);\n#endif\n    }else{\n        NSNumber *number = [dic objectForKey:NSFileSystemFreeSize];\n        size = [number floatValue]/1024/1024;\n    }\n    return size;\n}\n</code></pre>\n<h4 id=\"3-获取指定路径下某个文件的大小\"><a href=\"#3-获取指定路径下某个文件的大小\" class=\"headerlink\" title=\"3. 获取指定路径下某个文件的大小\"></a>3. 获取指定路径下某个文件的大小</h4><pre><code class=\"objectivec\">//获取文件大小\n+ (long long)fileSizeAtPath:(NSString *)filePath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:filePath]) return 0;\n    return [[fileManager attributesOfItemAtPath:filePath error:nil] fileSize];\n}\n</code></pre>\n<h4 id=\"4-获取文件夹下所有文件的大小\"><a href=\"#4-获取文件夹下所有文件的大小\" class=\"headerlink\" title=\"4. 获取文件夹下所有文件的大小\"></a>4. 获取文件夹下所有文件的大小</h4><pre><code class=\"objectivec\">//获取文件夹下所有文件的大小\n+ (long long)folderSizeAtPath:(NSString *)folderPath{\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:folderPath]) return 0;\n    NSEnumerator *filesEnumerator = [[fileManager subpathsAtPath:folderPath] objectEnumerator];\n    NSString *fileName;\n    long long folerSize = 0;\n    while ((fileName = [filesEnumerator nextObject]) != nil) {\n        NSString *filePath = [folderPath stringByAppendingPathComponent:fileName];\n        folerSize += [self fileSizeAtPath:filePath];\n    }\n    return folerSize;\n}\n</code></pre>\n<h4 id=\"5-获取字符串-或汉字-首字母\"><a href=\"#5-获取字符串-或汉字-首字母\" class=\"headerlink\" title=\"5. 获取字符串(或汉字)首字母\"></a>5. 获取字符串(或汉字)首字母</h4><pre><code class=\"objectivec\">//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n</code></pre>\n<h4 id=\"5-获取字符串-或汉字-首字母-1\"><a href=\"#5-获取字符串-或汉字-首字母-1\" class=\"headerlink\" title=\"5. 获取字符串(或汉字)首字母\"></a>5. 获取字符串(或汉字)首字母</h4><pre><code class=\"objectivec\">//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n</code></pre>\n<h4 id=\"6-将字符串数组按照元素首字母顺序进行排序分组\"><a href=\"#6-将字符串数组按照元素首字母顺序进行排序分组\" class=\"headerlink\" title=\"6. 将字符串数组按照元素首字母顺序进行排序分组\"></a>6. 将字符串数组按照元素首字母顺序进行排序分组</h4><pre><code class=\"objectivec\">//将字符串数组按照元素首字母顺序进行排序分组\n+ (NSDictionary *)dictionaryOrderByCharacterWithOriginalArray:(NSArray *)array{\n    if (array.count == 0) {\n        return nil;\n    }\n    for (id obj in array) {\n        if (![obj isKindOfClass:[NSString class]]) {\n            return nil;\n        }\n    }\n    UILocalizedIndexedCollation *indexedCollation = [UILocalizedIndexedCollation currentCollation];\n    NSMutableArray *objects = [NSMutableArray arrayWithCapacity:indexedCollation.sectionTitles.count];\n    //创建27个分组数组\n    for (int i = 0; i &lt; indexedCollation.sectionTitles.count; i++) {\n        NSMutableArray *obj = [NSMutableArray array];\n        [objects addObject:obj];\n    }\n    NSMutableArray *keys = [NSMutableArray arrayWithCapacity:objects.count];\n    //按字母顺序进行分组\n    NSInteger lastIndex = -1;\n    for (int i = 0; i &lt; array.count; i++) {\n        NSInteger index = [indexedCollation sectionForObject:array[i] collationStringSelector:@selector(uppercaseString)];\n        [[objects objectAtIndex:index] addObject:array[i]];\n        lastIndex = index;\n    }\n    //去掉空数组\n    for (int i = 0; i &lt; objects.count; i++) {\n        NSMutableArray *obj = objects[i];\n        if (obj.count == 0) {\n            [objects removeObject:obj];\n        }\n    }\n    //获取索引字母\n    for (NSMutableArray *obj in objects) {\n        NSString *str = obj[0];\n        NSString *key = [self firstCharacterWithString:str];\n        [keys addObject:key];\n    }\n    NSMutableDictionary *dic = [NSMutableDictionary dictionary];\n    [dic setObject:objects forKey:keys];\n    return dic;\n}\n\n//获取字符串(或汉字)首字母\n+ (NSString *)firstCharacterWithString:(NSString *)string{\n    NSMutableString *str = [NSMutableString stringWithString:string];\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformMandarinLatin, NO);\n    CFStringTransform((CFMutableStringRef)str, NULL, kCFStringTransformStripDiacritics, NO);\n    NSString *pingyin = [str capitalizedString];\n    return [pingyin substringToIndex:1];\n}\n</code></pre>\n<h5 id=\"使用如下\"><a href=\"#使用如下\" class=\"headerlink\" title=\"使用如下:\"></a>使用如下:</h5><pre><code class=\"objectivec\">NSArray *arr = @[@&quot;guangzhou&quot;, @&quot;shanghai&quot;, @&quot;北京&quot;, @&quot;henan&quot;, @&quot;hainan&quot;];\nNSDictionary *dic = [Utilities dictionaryOrderByCharacterWithOriginalArray:arr];\nNSLog(@&quot;\\n\\ndic: %@&quot;, dic);\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-a63d16ad6cccc312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"></p>\n<h4 id=\"7-获取当前时间\"><a href=\"#7-获取当前时间\" class=\"headerlink\" title=\"7. 获取当前时间\"></a>7. 获取当前时间</h4><pre><code class=\"objectivec\">//获取当前时间\n//format: @&quot;yyyy-MM-dd HH:mm:ss&quot;、@&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;\n+ (NSString *)currentDateWithFormat:(NSString *)format{\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n    [dateFormatter setDateFormat:format];\n    return [dateFormatter stringFromDate:[NSDate date]];\n}\n</code></pre>\n<h4 id=\"8-计算上次日期距离现在多久-如-xx-小时前、xx-分钟前等\"><a href=\"#8-计算上次日期距离现在多久-如-xx-小时前、xx-分钟前等\" class=\"headerlink\" title=\"8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等\"></a>8. 计算上次日期距离现在多久, 如 xx 小时前、xx 分钟前等</h4><pre><code class=\"objectivec\">/**\n *  计算上次日期距离现在多久\n *\n *  @param lastTime    上次日期(需要和格式对应)\n *  @param format1     上次日期格式\n *  @param currentTime 最近日期(需要和格式对应)\n *  @param format2     最近日期格式\n *\n *  @return xx分钟前、xx小时前、xx天前\n */\n+ (NSString *)timeIntervalFromLastTime:(NSString *)lastTime\n                        lastTimeFormat:(NSString *)format1\n                         ToCurrentTime:(NSString *)currentTime\n                     currentTimeFormat:(NSString *)format2{\n    //上次时间\n    NSDateFormatter *dateFormatter1 = [[NSDateFormatter alloc]init];\n    dateFormatter1.dateFormat = format1;\n    NSDate *lastDate = [dateFormatter1 dateFromString:lastTime];\n    //当前时间\n    NSDateFormatter *dateFormatter2 = [[NSDateFormatter alloc]init];\n    dateFormatter2.dateFormat = format2;\n    NSDate *currentDate = [dateFormatter2 dateFromString:currentTime];\n    return [Utilities timeIntervalFromLastTime:lastDate ToCurrentTime:currentDate];\n}\n\n+ (NSString *)timeIntervalFromLastTime:(NSDate *)lastTime ToCurrentTime:(NSDate *)currentTime{\n    NSTimeZone *timeZone = [NSTimeZone systemTimeZone];\n    //上次时间\n    NSDate *lastDate = [lastTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:lastTime]];\n    //当前时间\n    NSDate *currentDate = [currentTime dateByAddingTimeInterval:[timeZone secondsFromGMTForDate:currentTime]];\n    //时间间隔\n    NSInteger intevalTime = [currentDate timeIntervalSinceReferenceDate] - [lastDate timeIntervalSinceReferenceDate];\n\n    //秒、分、小时、天、月、年\n    NSInteger minutes = intevalTime / 60;\n    NSInteger hours = intevalTime / 60 / 60;\n    NSInteger day = intevalTime / 60 / 60 / 24;\n    NSInteger month = intevalTime / 60 / 60 / 24 / 30;\n    NSInteger yers = intevalTime / 60 / 60 / 24 / 365;\n\n    if (minutes &lt;= 10) {\n        return  @&quot;刚刚&quot;;\n    }else if (minutes &lt; 60){\n        return [NSString stringWithFormat: @&quot;%ld分钟前&quot;,(long)minutes];\n    }else if (hours &lt; 24){\n        return [NSString stringWithFormat: @&quot;%ld小时前&quot;,(long)hours];\n    }else if (day &lt; 30){\n        return [NSString stringWithFormat: @&quot;%ld天前&quot;,(long)day];\n    }else if (month &lt; 12){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @&quot;M月d日&quot;;\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }else if (yers &gt;= 1){\n        NSDateFormatter * df =[[NSDateFormatter alloc]init];\n        df.dateFormat = @&quot;yyyy年M月d日&quot;;\n        NSString * time = [df stringFromDate:lastDate];\n        return time;\n    }\n    return @&quot;&quot;;\n}\n</code></pre>\n<h4 id=\"使用如下-1\"><a href=\"#使用如下-1\" class=\"headerlink\" title=\"使用如下:\"></a>使用如下:</h4><pre><code class=\"objectivec\">NSLog(@&quot;\\n\\nresult: %@&quot;, [Utilities timeIntervalFromLastTime:@&quot;2015年12月8日 15:50&quot;\n                                           lastTimeFormat:@&quot;yyyy年MM月dd日 HH:mm&quot;\n                                            ToCurrentTime:@&quot;2015/12/08 16:12&quot;\n                                        currentTimeFormat:@&quot;yyyy/MM/dd HH:mm&quot;]);\n</code></pre>\n<p>输出结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-591e3b7e5982b1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"></p>\n<h4 id=\"9-判断手机号码格式是否正确\"><a href=\"#9-判断手机号码格式是否正确\" class=\"headerlink\" title=\"9. 判断手机号码格式是否正确\"></a>9. 判断手机号码格式是否正确</h4><pre><code class=\"objectivec\">//判断手机号码格式是否正确\n+ (BOOL)valiMobile:(NSString *)mobile{\n    mobile = [mobile stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];\n    if (mobile.length != 11)\n    {\n        return NO;\n    }else{\n        /**\n         * 移动号段正则表达式\n         */\n        NSString *CM_NUM = @&quot;^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$&quot;;\n        /**\n         * 联通号段正则表达式\n         */\n        NSString *CU_NUM = @&quot;^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$&quot;;\n        /**\n         * 电信号段正则表达式\n         */\n        NSString *CT_NUM = @&quot;^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$&quot;;\n        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM_NUM];\n        BOOL isMatch1 = [pred1 evaluateWithObject:mobile];\n        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU_NUM];\n        BOOL isMatch2 = [pred2 evaluateWithObject:mobile];\n        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT_NUM];\n        BOOL isMatch3 = [pred3 evaluateWithObject:mobile];\n\n        if (isMatch1 || isMatch2 || isMatch3) {\n            return YES;\n        }else{\n            return NO;\n        }\n    }\n}\n</code></pre>\n<h4 id=\"10-判断邮箱格式是否正确\"><a href=\"#10-判断邮箱格式是否正确\" class=\"headerlink\" title=\"10. 判断邮箱格式是否正确\"></a>10. 判断邮箱格式是否正确</h4><pre><code class=\"objectivec\">//利用正则表达式验证\n+ (BOOL)isAvailableEmail:(NSString *)email {\n    NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}&quot;;\n    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];\n    return [emailTest evaluateWithObject:email];\n}\n</code></pre>\n<h4 id=\"11-将十六进制颜色转换为-UIColor-对象\"><a href=\"#11-将十六进制颜色转换为-UIColor-对象\" class=\"headerlink\" title=\"11. 将十六进制颜色转换为 UIColor 对象\"></a>11. 将十六进制颜色转换为 UIColor 对象</h4><pre><code class=\"objectivec\">//将十六进制颜色转换为 UIColor 对象\n+ (UIColor *)colorWithHexString:(NSString *)color{\n    NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];\n    // String should be 6 or 8 characters\n    if ([cString length] &lt; 6) {\n        return [UIColor clearColor];\n    }\n    // strip &quot;0X&quot; or &quot;#&quot; if it appears\n    if ([cString hasPrefix:@&quot;0X&quot;])\n        cString = [cString substringFromIndex:2];\n    if ([cString hasPrefix:@&quot;#&quot;])\n        cString = [cString substringFromIndex:1];\n    if ([cString length] != 6)\n        return [UIColor clearColor];\n    // Separate into r, g, b substrings\n    NSRange range;\n    range.location = 0;\n    range.length = 2;\n    //r\n    NSString *rString = [cString substringWithRange:range];\n    //g\n    range.location = 2;\n    NSString *gString = [cString substringWithRange:range];\n    //b\n    range.location = 4;\n    NSString *bString = [cString substringWithRange:range];\n    // Scan values\n    unsigned int r, g, b;\n    [[NSScanner scannerWithString:rString] scanHexInt:&amp;r];\n    [[NSScanner scannerWithString:gString] scanHexInt:&amp;g];\n    [[NSScanner scannerWithString:bString] scanHexInt:&amp;b];\n    return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];\n}\n</code></pre>\n<h4 id=\"12-对图片进行滤镜处理\"><a href=\"#12-对图片进行滤镜处理\" class=\"headerlink\" title=\"12. 对图片进行滤镜处理\"></a>12. 对图片进行滤镜处理</h4><pre><code class=\"objectivec\">#pragma mark - 对图片进行滤镜处理\n// 怀旧 --&gt; CIPhotoEffectInstant                         单色 --&gt; CIPhotoEffectMono\n// 黑白 --&gt; CIPhotoEffectNoir                            褪色 --&gt; CIPhotoEffectFade\n// 色调 --&gt; CIPhotoEffectTonal                           冲印 --&gt; CIPhotoEffectProcess\n// 岁月 --&gt; CIPhotoEffectTransfer                        铬黄 --&gt; CIPhotoEffectChrome\n// CILinearToSRGBToneCurve, CISRGBToneCurveToLinear, CIGaussianBlur, CIBoxBlur, CIDiscBlur, CISepiaTone, CIDepthOfField\n+ (UIImage *)filterWithOriginalImage:(UIImage *)image filterName:(NSString *)name{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:name];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n</code></pre>\n<h4 id=\"13-对图片进行模糊处理\"><a href=\"#13-对图片进行模糊处理\" class=\"headerlink\" title=\"13. 对图片进行模糊处理\"></a>13. 对图片进行模糊处理</h4><pre><code class=\"objectivec\">#pragma mark - 对图片进行模糊处理\n// CIGaussianBlur ---&gt; 高斯模糊\n// CIBoxBlur      ---&gt; 均值模糊(Available in iOS 9.0 and later)\n// CIDiscBlur     ---&gt; 环形卷积模糊(Available in iOS 9.0 and later)\n// CIMedianFilter ---&gt; 中值模糊, 用于消除图像噪点, 无需设置radius(Available in iOS 9.0 and later)\n// CIMotionBlur   ---&gt; 运动模糊, 用于模拟相机移动拍摄时的扫尾效果(Available in iOS 9.0 and later)\n+ (UIImage *)blurWithOriginalImage:(UIImage *)image blurName:(NSString *)name radius:(NSInteger)radius{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter;\n    if (name.length != 0) {\n        filter = [CIFilter filterWithName:name];\n        [filter setValue:inputImage forKey:kCIInputImageKey];\n        if (![name isEqualToString:@&quot;CIMedianFilter&quot;]) {\n            [filter setValue:@(radius) forKey:@&quot;inputRadius&quot;];\n        }\n        CIImage *result = [filter valueForKey:kCIOutputImageKey];\n        CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n        UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n        CGImageRelease(cgImage);\n        return resultImage;\n    }else{\n        return nil;\n    }\n}\n</code></pre>\n<h4 id=\"14-调整图片饱和度、亮度、对比度\"><a href=\"#14-调整图片饱和度、亮度、对比度\" class=\"headerlink\" title=\"14. 调整图片饱和度、亮度、对比度\"></a>14. 调整图片饱和度、亮度、对比度</h4><pre><code class=\"objectivec\">/**\n *  调整图片饱和度, 亮度, 对比度\n *\n *  @param image      目标图片\n *  @param saturation 饱和度\n *  @param brightness 亮度: -1.0 ~ 1.0\n *  @param contrast   对比度\n *\n */\n+ (UIImage *)colorControlsWithOriginalImage:(UIImage *)image\n                                 saturation:(CGFloat)saturation\n                                 brightness:(CGFloat)brightness\n                                   contrast:(CGFloat)contrast{\n    CIContext *context = [CIContext contextWithOptions:nil];\n    CIImage *inputImage = [[CIImage alloc] initWithImage:image];\n    CIFilter *filter = [CIFilter filterWithName:@&quot;CIColorControls&quot;];\n    [filter setValue:inputImage forKey:kCIInputImageKey];\n\n    [filter setValue:@(saturation) forKey:@&quot;inputSaturation&quot;];\n    [filter setValue:@(brightness) forKey:@&quot;inputBrightness&quot;];\n    [filter setValue:@(contrast) forKey:@&quot;inputContrast&quot;];\n\n    CIImage *result = [filter valueForKey:kCIOutputImageKey];\n    CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];\n    UIImage *resultImage = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    return resultImage;\n}\n</code></pre>\n<h4 id=\"15-创建一张实时模糊效果-View-毛玻璃效果\"><a href=\"#15-创建一张实时模糊效果-View-毛玻璃效果\" class=\"headerlink\" title=\"15. 创建一张实时模糊效果 View (毛玻璃效果)\"></a>15. 创建一张实时模糊效果 View (毛玻璃效果)</h4><pre><code class=\"objectivec\">//Avilable in iOS 8.0 and later\n+ (UIVisualEffectView *)effectViewWithFrame:(CGRect)frame{\n    UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];\n    UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:effect];\n    effectView.frame = frame;\n    return effectView;\n}\n</code></pre>\n<h4 id=\"16-全屏截图\"><a href=\"#16-全屏截图\" class=\"headerlink\" title=\"16. 全屏截图\"></a>16. 全屏截图</h4><pre><code class=\"objectivec\">//全屏截图\n+ (UIImage *)shotScreen{\n    UIWindow *window = [UIApplication sharedApplication].keyWindow;\n    UIGraphicsBeginImageContext(window.bounds.size);\n    [window.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre>\n<h4 id=\"17-截取一张-view-生成图片\"><a href=\"#17-截取一张-view-生成图片\" class=\"headerlink\" title=\"17. 截取一张 view 生成图片\"></a>17. 截取一张 view 生成图片</h4><pre><code class=\"objectivec\">//截取view生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view{\n    UIGraphicsBeginImageContext(view.bounds.size);\n    [view.layer renderInContext:UIGraphicsGetCurrentContext()];\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return image;\n}\n</code></pre>\n<h4 id=\"18-截取view中某个区域生成一张图片\"><a href=\"#18-截取view中某个区域生成一张图片\" class=\"headerlink\" title=\"18. 截取view中某个区域生成一张图片\"></a>18. 截取view中某个区域生成一张图片</h4><pre><code class=\"objectivec\">//截取view中某个区域生成一张图片\n+ (UIImage *)shotWithView:(UIView *)view scope:(CGRect)scope{\n    CGImageRef imageRef = CGImageCreateWithImageInRect([self shotWithView:view].CGImage, scope);\n    UIGraphicsBeginImageContext(scope.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGRect rect = CGRectMake(0, 0, scope.size.width, scope.size.height);\n    CGContextTranslateCTM(context, 0, rect.size.height);//下移\n    CGContextScaleCTM(context, 1.0f, -1.0f);//上翻\n    CGContextDrawImage(context, rect, imageRef);\n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    CGImageRelease(imageRef);\n    CGContextRelease(context);\n    return image;\n}\n</code></pre>\n<h4 id=\"19-压缩图片到指定尺寸大小\"><a href=\"#19-压缩图片到指定尺寸大小\" class=\"headerlink\" title=\"19. 压缩图片到指定尺寸大小\"></a>19. 压缩图片到指定尺寸大小</h4><pre><code class=\"objectivec\">//压缩图片到指定尺寸大小\n+ (UIImage *)compressOriginalImage:(UIImage *)image toSize:(CGSize)size{\n    UIImage *resultImage = image;\n    UIGraphicsBeginImageContext(size);\n    [resultImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    UIGraphicsEndImageContext();\n    return resultImage;\n}\n</code></pre>\n<h4 id=\"20-压缩图片到指定文件大小\"><a href=\"#20-压缩图片到指定文件大小\" class=\"headerlink\" title=\"20. 压缩图片到指定文件大小\"></a>20. 压缩图片到指定文件大小</h4><pre><code class=\"objectivec\">//压缩图片到指定文件大小\n+ (NSData *)compressOriginalImage:(UIImage *)image toMaxDataSizeKBytes:(CGFloat)size{\n    NSData *data = UIImageJPEGRepresentation(image, 1.0);\n    CGFloat dataKBytes = data.length/1000.0;\n    CGFloat maxQuality = 0.9f;\n    CGFloat lastData = dataKBytes;\n    while (dataKBytes &gt; size &amp;&amp; maxQuality &gt; 0.01f) {\n        maxQuality = maxQuality - 0.01f;\n        data = UIImageJPEGRepresentation(image, maxQuality);\n        dataKBytes = data.length/1000.0;\n        if (lastData == dataKBytes) {\n            break;\n        }else{\n            lastData = dataKBytes;\n        }\n    }\n    return data;\n}\n</code></pre>\n<h4 id=\"21-获取设备-IP-地址\"><a href=\"#21-获取设备-IP-地址\" class=\"headerlink\" title=\"21. 获取设备 IP 地址\"></a>21. 获取设备 IP 地址</h4><p>需要先引入下头文件:</p>\n<p><code>#import &lt;ifaddrs.h&gt;</code><br><code>#import &lt;arpa/inet.h&gt;</code></p>\n<pre><code class=\"objectivec\">//获取设备 IP 地址\n+ (NSString *)getIPAddress {\n    NSString *address = @&quot;error&quot;;\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    success = getifaddrs(&amp;interfaces);\n    if (success == 0) {\n        temp_addr = interfaces;\n        while(temp_addr != NULL) {\n            if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) {\n                if([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;]) {\n                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];\n                }\n            }\n            temp_addr = temp_addr-&gt;ifa_next;\n        }\n    }\n    freeifaddrs(interfaces);\n    return address;\n}\n</code></pre>\n<h4 id=\"22-判断字符串中是否含有空格\"><a href=\"#22-判断字符串中是否含有空格\" class=\"headerlink\" title=\"22. 判断字符串中是否含有空格\"></a>22. 判断字符串中是否含有空格</h4><pre><code class=\"objectivec\">+ (BOOL)isHaveSpaceInString:(NSString *)string{\n    NSRange _range = [string rangeOfString:@&quot; &quot;];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n</code></pre>\n<h4 id=\"23-判断字符串中是否含有某个字符串\"><a href=\"#23-判断字符串中是否含有某个字符串\" class=\"headerlink\" title=\"23. 判断字符串中是否含有某个字符串\"></a>23. 判断字符串中是否含有某个字符串</h4><pre><code class=\"objectivec\">+ (BOOL)isHaveString:(NSString *)string1 InString:(NSString *)string2{\n    NSRange _range = [string2 rangeOfString:string1];\n    if (_range.location != NSNotFound) {\n        return YES;\n    }else {\n        return NO;\n    }\n}\n</code></pre>\n<h4 id=\"24-判断字符串中是否含有中文\"><a href=\"#24-判断字符串中是否含有中文\" class=\"headerlink\" title=\"24. 判断字符串中是否含有中文\"></a>24. 判断字符串中是否含有中文</h4><pre><code class=\"objectivec\">+ (BOOL)isHaveChineseInString:(NSString *)string{\n    for(NSInteger i = 0; i &lt; [string length]; i++){\n        int a = [string characterAtIndex:i];\n        if (a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) {\n            return YES;\n        }\n    }\n    return NO;\n}\n</code></pre>\n<h4 id=\"25-判断字符串是否全部为数字\"><a href=\"#25-判断字符串是否全部为数字\" class=\"headerlink\" title=\"25. 判断字符串是否全部为数字\"></a>25. 判断字符串是否全部为数字</h4><pre><code class=\"objectivec\">+ (BOOL)isAllNum:(NSString *)string{\n    unichar c;\n    for (int i=0; i&lt;string.length; i++) {\n        c=[string characterAtIndex:i];\n        if (!isdigit(c)) {\n            return NO;\n        }\n    }\n    return YES;\n}\n</code></pre>\n<h4 id=\"26-绘制虚线\"><a href=\"#26-绘制虚线\" class=\"headerlink\" title=\"26. 绘制虚线\"></a>26. 绘制虚线</h4><pre><code class=\"objectivec\">/*\n  ** lineFrame:     虚线的 frame\n  ** length:        虚线中短线的宽度\n  ** spacing:       虚线中短线之间的间距\n  ** color:         虚线中短线的颜色\n*/\n+ (UIView *)createDashedLineWithFrame:(CGRect)lineFrame\n                           lineLength:(int)length\n                          lineSpacing:(int)spacing\n                            lineColor:(UIColor *)color{\n    UIView *dashedLine = [[UIView alloc] initWithFrame:lineFrame];\n    dashedLine.backgroundColor = [UIColor clearColor];\n    CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n    [shapeLayer setBounds:dashedLine.bounds];\n    [shapeLayer setPosition:CGPointMake(CGRectGetWidth(dashedLine.frame) / 2, CGRectGetHeight(dashedLine.frame))];\n    [shapeLayer setFillColor:[UIColor clearColor].CGColor];\n    [shapeLayer setStrokeColor:color.CGColor];\n    [shapeLayer setLineWidth:CGRectGetHeight(dashedLine.frame)];\n    [shapeLayer setLineJoin:kCALineJoinRound];\n    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:length], [NSNumber numberWithInt:spacing], nil]];\n    CGMutablePathRef path = CGPathCreateMutable();\n    CGPathMoveToPoint(path, NULL, 0, 0);\n    CGPathAddLineToPoint(path, NULL, CGRectGetWidth(dashedLine.frame), 0);\n    [shapeLayer setPath:path];\n    CGPathRelease(path);\n    [dashedLine.layer addSublayer:shapeLayer];\n    return dashedLine;\n}\n</code></pre>\n<h4 id=\"27-将字典对象转换为-JSON-字符串\"><a href=\"#27-将字典对象转换为-JSON-字符串\" class=\"headerlink\" title=\"27. 将字典对象转换为 JSON 字符串\"></a>27. 将字典对象转换为 JSON 字符串</h4><pre><code class=\"objectivec\">+ (NSString *)jsonPrettyStringEncoded:(NSDictionary *)dictionary{\n    if ([NSJSONSerialization isValidJSONObject:dictionary ]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dictionary options:NSJSONWritingPrettyPrinted error:&amp;error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n</code></pre>\n<h4 id=\"28-将数组对象转换为-JSON-字符串\"><a href=\"#28-将数组对象转换为-JSON-字符串\" class=\"headerlink\" title=\"28.将数组对象转换为 JSON 字符串\"></a>28.将数组对象转换为 JSON 字符串</h4><pre><code class=\"objectivec\">+ (NSString *)jsonPrettyStringEncoded:(NSArray *)array{\n    if ([NSJSONSerialization isValidJSONObject:array]) {\n        NSError *error;\n        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:array options:NSJSONWritingPrettyPrinted error:&amp;error];\n        if (!error) {\n            NSString *json = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n            return json;\n        }\n    }\n    return nil;\n}\n</code></pre>\n<h4 id=\"29-获取-WiFi-信息\"><a href=\"#29-获取-WiFi-信息\" class=\"headerlink\" title=\"29. 获取 WiFi 信息\"></a>29. 获取 WiFi 信息</h4><p>需要引入头文件:</p>\n<p><code>#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;</code></p>\n<pre><code class=\"objectivec\">//获取 WiFi 信息\n- (NSDictionary *)fetchSSIDInfo {\n    NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();\n    if (!ifs) {\n        return nil;\n    }\n    NSDictionary *info = nil;\n    for (NSString *ifnam in ifs) {\n        info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);\n        if (info &amp;&amp; [info count]) { break; }\n    }\n    return info;\n}\n</code></pre>\n<h4 id=\"30-获取广播地址、本机地址、子网掩码、端口信息\"><a href=\"#30-获取广播地址、本机地址、子网掩码、端口信息\" class=\"headerlink\" title=\"30. 获取广播地址、本机地址、子网掩码、端口信息\"></a>30. 获取广播地址、本机地址、子网掩码、端口信息</h4><p>需要引入头文件:</p>\n<p><code>#import &lt;ifaddrs.h&gt;</code><br><code>#import &lt;arpa/inet.h&gt;</code></p>\n<pre><code class=\"objectivec\">//获取广播地址、本机地址、子网掩码、端口信息\n- (NSMutableDictionary *)getLocalInfoForCurrentWiFi {\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    struct ifaddrs *interfaces = NULL;\n    struct ifaddrs *temp_addr = NULL;\n    int success = 0;\n    // retrieve the current interfaces - returns 0 on success\n    success = getifaddrs(&amp;interfaces);\n    if (success == 0) {\n        // Loop through linked list of interfaces\n        temp_addr = interfaces;\n        //*/\n        while(temp_addr != NULL) {\n            if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) {\n                // Check if interface is en0 which is the wifi connection on the iPhone\n                if([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;]) {\n                    //广播地址\n                    NSString *broadcast = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_dstaddr)-&gt;sin_addr)];\n                    if (broadcast) {\n                        [dict setObject:broadcast forKey:@&quot;broadcast&quot;];\n                    }\n//                    NSLog(@&quot;broadcast address--%@&quot;,broadcast);\n                    //本机地址\n                    NSString *localIp = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];\n                    if (localIp) {\n                        [dict setObject:localIp forKey:@&quot;localIp&quot;];\n                    }\n//                    NSLog(@&quot;local device ip--%@&quot;,localIp);\n                    //子网掩码地址\n                    NSString *netmask = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_netmask)-&gt;sin_addr)];\n                    if (netmask) {\n                        [dict setObject:netmask forKey:@&quot;netmask&quot;];\n                    }\n//                    NSLog(@&quot;netmask--%@&quot;,netmask);\n                    //--en0 端口地址\n                    NSString *interface = [NSString stringWithUTF8String:temp_addr-&gt;ifa_name];\n                    if (interface) {\n                        [dict setObject:interface forKey:@&quot;interface&quot;];\n                    }\n//                    NSLog(@&quot;interface--%@&quot;,interface);\n                    return dict;\n                }\n            }\n            temp_addr = temp_addr-&gt;ifa_next;\n        }\n    }\n    // Free memory\n    freeifaddrs(interfaces);\n    return dict;\n}\n</code></pre>\n"},{"title":"RSA加密小结","date":"2017-05-26T15:06:00.000Z","_content":"在iOS中使用RSA加密解密，需要用到`.der`和`.p12`后缀格式的文件，其中`.der`格式的文件存放的是公钥（Public key）用于加密，`.p12`格式的文件存放的是私钥（Private key）用于解密. 首先需要先生成这些文件，然后再将文件导入工程使用！\n\n# 一、使用openssl生成所需秘钥文件\n生成环境是在mac系统下，使用`openssl`进行生成，首先打开终端，按下面这些步骤依次来做：\n\n##### 1. 生成模长为1024bit的私钥文件`private_key.pem`\n```objectivec\nopenssl genrsa -out private_key.pem 1024\n```\n##### 2. 生成证书请求文件`rsaCertReq.csr`\n```objectivec\nopenssl req -new -key private_key.pem -out rsaCerReq.csr\n```\n**注意：这一步会提示输入国家、省份、mail等信息，可以根据实际情况填写，或者全部不用填写，直接全部敲回车.**\n##### 3. 生成证书`rsaCert.crt`，并设置有效时间为1年\n```objectivec\nopenssl x509 -req -days 3650 -in rsaCerReq.csr -signkey private_key.pem -out rsaCert.crt\n```\n\n##### 4. 生成供iOS使用的公钥文件`public_key.der`\n```objectivec\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n```\n##### 5. 生成供iOS使用的私钥文件`private_key.p12`\n```objectivec\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n```\n**注意：这一步会提示给私钥文件设置密码，直接输入想要设置密码即可，然后敲回车，然后再验证刚才设置的密码，再次输入密码，然后敲回车，完毕！\n在解密时，`private_key.p12`文件需要和这里设置的密码配合使用，因此需要牢记此密码.**\n##### 6. 生成供Java使用的公钥`rsa_public_key.pem`\n```objectivec\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n```\n##### 7. 生成供Java使用的私钥`pkcs8_private_key.pem`\n```objectivec\nopenssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n```\n全部执行成功后，会生成如下文件，其中`public_key.der`和`private_key.p12`就是iOS需要用到的文件，如下图：\n![图1](http://upload-images.jianshu.io/upload_images/1803339-3ef995aa667e40f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 二、将文件导入工程使用\n##### 1.新建工程, 并导入`Security.framework`框架, 如下图:\n![图2](http://upload-images.jianshu.io/upload_images/1803339-37dfec3dba887d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 2.导入秘钥文件\n导入`.der`和`.p12`格式的秘钥文件, 如下图:\n![图2](http://upload-images.jianshu.io/upload_images/1803339-5e13a7e8dc3f7027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法\n\n新建`RSAEncryptor`类, 如下图:\n![图3](http://upload-images.jianshu.io/upload_images/1803339-dba6f10fd9a54973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n下面开始上代码,`RSAEncryptor.h`代码如下:\n\n```objectivec\n#import <Foundation/Foundation.h>\n\n@interface RSAEncryptor : NSObject\n\n/**\n *  加密方法\n *\n *  @param str   需要加密的字符串\n *  @param path  '.der'格式的公钥文件路径\n */\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path;\n\n/**\n *  解密方法\n *\n *  @param str       需要解密的字符串\n *  @param path      '.p12'格式的私钥文件路径\n *  @param password  私钥文件密码\n */\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password;\n\n/**\n *  加密方法\n *\n *  @param str    需要加密的字符串\n *  @param pubKey 公钥字符串\n */\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;\n\n/**\n *  解密方法\n *\n *  @param str     需要解密的字符串\n *  @param privKey 私钥字符串\n */\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;\n\n@end\n```\n`RSAEncryptor.m`代码如下:\n\n```objectivec\n#import \"RSAEncryptor.h\"\n#import <Security/Security.h>\n\n@implementation RSAEncryptor\n\nstatic NSString *base64_encode_data(NSData *data){\n    data = [data base64EncodedDataWithOptions:0];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\nstatic NSData *base64_decode(NSString *str){\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    return data;\n}\n\n#pragma mark - 使用'.der'公钥文件加密\n\n//加密\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path{\n    if (!str || !path)  return nil;\n    return [self encryptString:str publicKeyRef:[self getPublicKeyRefWithContentsOfFile:path]];\n}\n\n//获取公钥\n+ (SecKeyRef)getPublicKeyRefWithContentsOfFile:(NSString *)filePath{\n    NSData *certData = [NSData dataWithContentsOfFile:filePath];\n    if (!certData) {\n        return nil;\n    }\n    SecCertificateRef cert = SecCertificateCreateWithData(NULL, (CFDataRef)certData);\n    SecKeyRef key = NULL;\n    SecTrustRef trust = NULL;\n    SecPolicyRef policy = NULL;\n    if (cert != NULL) {\n        policy = SecPolicyCreateBasicX509();\n        if (policy) {\n            if (SecTrustCreateWithCertificates((CFTypeRef)cert, policy, &trust) == noErr) {\n                SecTrustResultType result;\n                if (SecTrustEvaluate(trust, &result) == noErr) {\n                    key = SecTrustCopyPublicKey(trust);\n                }\n            }\n        }\n    }\n    if (policy) CFRelease(policy);\n    if (trust) CFRelease(trust);\n    if (cert) CFRelease(cert);\n    return key;\n}\n\n+ (NSString *)encryptString:(NSString *)str publicKeyRef:(SecKeyRef)publicKeyRef{\n    if(![str dataUsingEncoding:NSUTF8StringEncoding]){\n        return nil;\n    }\n    if(!publicKeyRef){\n        return nil;\n    }\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] withKeyRef:publicKeyRef];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n#pragma mark - 使用'.12'私钥文件解密\n\n//解密\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password{\n    if (!str || !path) return nil;\n    if (!password) password = @\"\";\n    return [self decryptString:str privateKeyRef:[self getPrivateKeyRefWithContentsOfFile:path password:password]];\n}\n\n//获取私钥\n+ (SecKeyRef)getPrivateKeyRefWithContentsOfFile:(NSString *)filePath password:(NSString*)password{\n\n    NSData *p12Data = [NSData dataWithContentsOfFile:filePath];\n    if (!p12Data) {\n        return nil;\n    }\n    SecKeyRef privateKeyRef = NULL;\n    NSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n    [options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\n    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\n    OSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\n    if (securityError == noErr && CFArrayGetCount(items) > 0) {\n        CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n        SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n        securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n        if (securityError != noErr) {\n            privateKeyRef = NULL;\n        }\n    }\n    CFRelease(items);\n\n    return privateKeyRef;\n}\n\n+ (NSString *)decryptString:(NSString *)str privateKeyRef:(SecKeyRef)privKeyRef{\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    if (!privKeyRef) {\n        return nil;\n    }\n    data = [self decryptData:data withKeyRef:privKeyRef];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n#pragma mark - 使用公钥字符串加密\n\n/* START: Encryption with RSA public key */\n\n//使用公钥字符串加密\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey{\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] publicKey:pubKey];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey{\n    if(!data || !pubKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPublicKey:pubKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self encryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPublicKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@\"-----BEGIN PUBLIC KEY-----\"];\n    NSRange epos = [key rangeOfString:@\"-----END PUBLIC KEY-----\"];\n    if(spos.location != NSNotFound && epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\" \"  withString:@\"\"];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPublicKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @\"RSAUtil_PubKey\";\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *publicKey = [[NSMutableDictionary alloc] init];\n    [publicKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [publicKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)publicKey);\n\n    // Add persistent version of the key to system keychain\n    [publicKey setObject:data forKey:(__bridge id)kSecValueData];\n    [publicKey setObject:(__bridge id) kSecAttrKeyClassPublic forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)publicKey, &persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) && (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [publicKey removeObjectForKey:(__bridge id)kSecValueData];\n    [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPublicKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 public key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 0;\n\n    if (c_key[idx++] != 0x30) return(nil);\n\n    if (c_key[idx] > 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    // PKCS #1 rsaEncryption szOID_RSA_RSA\n    static unsigned char seqiod[] =\n    { 0x30,   0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n        0x01, 0x05, 0x00 };\n    if (memcmp(&c_key[idx], seqiod, 15)) return(nil);\n\n    idx += 15;\n\n    if (c_key[idx++] != 0x03) return(nil);\n\n    if (c_key[idx] > 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    if (c_key[idx++] != '\\0') return(nil);\n\n    // Now make a new NSData from this buffer\n    return ([NSData dataWithBytes:&c_key[idx] length:len - idx]);\n}\n\n+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    void *outbuf = malloc(block_size);\n    size_t src_block_size = block_size - 11;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx<srclen; idx+=src_block_size){\n        //NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len > src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyEncrypt(keyRef,\n                               kSecPaddingPKCS1,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &outlen\n                               );\n        if (status != 0) {\n            NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", status);\n            ret = nil;\n            break;\n        }else{\n            [ret appendBytes:outbuf length:outlen];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Encryption with RSA public key */\n\n#pragma mark - 使用私钥字符串解密\n\n/* START: Decryption with RSA private key */\n\n//使用私钥字符串解密\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey{\n    if (!str) return nil;\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    data = [self decryptData:data privateKey:privKey];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey{\n    if(!data || !privKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPrivateKey:privKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self decryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPrivateKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@\"-----BEGIN RSA PRIVATE KEY-----\"];\n    NSRange epos = [key rangeOfString:@\"-----END RSA PRIVATE KEY-----\"];\n    if(spos.location != NSNotFound && epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\" \"  withString:@\"\"];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPrivateKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @\"RSAUtil_PrivKey\";\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *privateKey = [[NSMutableDictionary alloc] init];\n    [privateKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [privateKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)privateKey);\n\n    // Add persistent version of the key to system keychain\n    [privateKey setObject:data forKey:(__bridge id)kSecValueData];\n    [privateKey setObject:(__bridge id) kSecAttrKeyClassPrivate forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)privateKey, &persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) && (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [privateKey removeObjectForKey:(__bridge id)kSecValueData];\n    [privateKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)privateKey, (CFTypeRef *)&keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 private key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 22; //magic byte at offset 22\n\n    if (0x04 != c_key[idx++]) return nil;\n\n    //calculate length of the key\n    unsigned int c_len = c_key[idx++];\n    int det = c_len & 0x80;\n    if (!det) {\n        c_len = c_len & 0x7f;\n    } else {\n        int byteCount = c_len & 0x7f;\n        if (byteCount + idx > len) {\n            //rsa length field longer than buffer\n            return nil;\n        }\n        unsigned int accum = 0;\n        unsigned char *ptr = &c_key[idx];\n        idx += byteCount;\n        while (byteCount) {\n            accum = (accum << 8) + *ptr;\n            ptr++;\n            byteCount--;\n        }\n        c_len = accum;\n    }\n\n    // Now make a new NSData from this buffer\n    return [d_key subdataWithRange:NSMakeRange(idx, c_len)];\n}\n\n+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    UInt8 *outbuf = malloc(block_size);\n    size_t src_block_size = block_size;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx<srclen; idx+=src_block_size){\n        //NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len > src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyDecrypt(keyRef,\n                               kSecPaddingNone,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &outlen\n                               );\n        if (status != 0) {\n            NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", status);\n            ret = nil;\n            break;\n        }else{\n            //the actual decrypted data is in the middle, locate it!\n            int idxFirstZero = -1;\n            int idxNextZero = (int)outlen;\n            for ( int i = 0; i < outlen; i++ ) {\n                if ( outbuf[i] == 0 ) {\n                    if ( idxFirstZero < 0 ) {\n                        idxFirstZero = i;\n                    } else {\n                        idxNextZero = i;\n                        break;\n                    }\n                }\n            }\n\n            [ret appendBytes:&outbuf[idxFirstZero+1] length:idxNextZero-idxFirstZero-1];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Decryption with RSA private key */\n\n@end\n```\n##### 4. 测试加密、解密\n\n首先先测试使用`.der`和`.p12`秘钥文件进行加密、解密, 在`ViewController.m`中进行测试, 代码如下:\n\n```objectivec\n#import \"ViewController.h\"\n#import \"RSAEncryptor.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @\"这是一段将要使用'.der'文件加密的字符串!\";\n\n    //使用.der和.p12中的公钥私钥加密解密\n    NSString *public_key_path = [[NSBundle mainBundle] pathForResource:@\"public_key.der\" ofType:nil];\n    NSString *private_key_path = [[NSBundle mainBundle] pathForResource:@\"private_key.p12\" ofType:nil];\n\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKeyWithContentsOfFile:public_key_path];\n    NSLog(@\"加密前:%@\", originalString);\n    NSLog(@\"加密后:%@\", encryptStr);\n    NSLog(@\"解密后:%@\", [RSAEncryptor decryptString:encryptStr privateKeyWithContentsOfFile:private_key_path password:@\"123456\"]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n```\n运行后, 输出信息如下:\n![图4](http://upload-images.jianshu.io/upload_images/1803339-837f26af766fc979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看到已经可以成功加密、解密了.\n下面接着测试使用秘钥字符串进行加密、解密, 那么秘钥字符串从哪里来? 可以来这里:[http://web.chacuo.net/netrsakeypair](http://web.chacuo.net/netrsakeypair), 这是一个在线生成RSA秘钥的网站, 生成公钥和秘钥后, 复制出来用于测试. 然后在`ViewController.m`\n中使用`RSAEntryptor.h`\n头文件中对应的加密方法进行加密, `ViewController.m`\n中代码如下:\n\n```objectivec\n#import \"ViewController.h\"\n#import \"RSAEncryptor.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @\"这是一段将要使用'秘钥字符串'进行加密的字符串!\";\n\n    //使用字符串格式的公钥私钥加密解密\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKey:@\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTbZ6cNH9PgdF60aQKveLz3FTalyzHQwbp601y77SzmGHX3F5NoVUZbdK7UMdoCLK4FBziTewYD9DWvAErXZo9BFuI96bAop8wfl1VkZyyHTcznxNJFGSQd/B70/ExMgMBpEwkAAdyUqIjIdVGh1FQK/4acwS39YXwbS+IlHsPSQIDAQAB\"];\n\n    NSLog(@\"加密前:%@\", originalString);\n    NSLog(@\"加密后:%@\", encryptStr);\n    NSLog(@\"解密后:%@\", [RSAEncryptor decryptString:encryptStr privateKey:@\"MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANNtnpw0f0+B0XrRpAq94vPcVNqXLMdDBunrTXLvtLOYYdfcXk2hVRlt0rtQx2gIsrgUHOJN7BgP0Na8AStdmj0EW4j3psCinzB+XVWRnLIdNzOfE0kUZJB38HvT8TEyAwGkTCQAB3JSoiMh1UaHUVAr/hpzBLf1hfBtL4iUew9JAgMBAAECgYA1tGeQmAkqofga8XtwuxEWDoaDS9k0+EKeUoXGxzqoT/GyiihuIafjILFhoUA1ndf/yCQaG973sbTDhtfpMwqFNQq13+JAownslTjWgr7Hwf7qplYW92R7CU0v7wFfjqm1t/2FKU9JkHfaHfb7qqESMIbO/VMjER9o4tEx58uXDQJBAO0O4lnWDVjr1gN02cqvxPOtTY6DgFbQDeaAZF8obb6XqvCqGW/AVms3Bh8nVlUwdQ2K/xte8tHxjW9FtBQTLd8CQQDkUncO35gAqUF9Bhsdzrs7nO1J3VjLrM0ITrepqjqtVEvdXZc+1/UrkWVaIigWAXjQCVfmQzScdbznhYXPz5fXAkEAgB3KMRkhL4yNpmKRjhw+ih+ASeRCCSj6Sjfbhx4XaakYZmbXxnChg+JB+bZNz06YBFC5nLZM7y/n61o1f5/56wJBALw+ZVzE6ly5L34114uG04W9x0HcFgau7MiJphFjgUdAtd/H9xfgE4odMRPUD3q9Me9LlMYK6MiKpfm4c2+3dzcCQQC8y37NPgpNEkd9smMwPpSEjPW41aMlfcKvP4Da3z7G5bGlmuICrva9YDAiaAyDGGCK8LxC8K6HpKrFgYrXkRtt\"]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n\n```\n\n运行后, 输出信息如下:\n![图5](http://upload-images.jianshu.io/upload_images/1803339-4a11ca319806c3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n至此, RSA加密演示完毕!\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/RSA加密小结.md","raw":"---\ntitle: RSA加密小结\ndate: 2017-05-26 23:06:00\ncategories: \n\t- 知识簿\n---\n在iOS中使用RSA加密解密，需要用到`.der`和`.p12`后缀格式的文件，其中`.der`格式的文件存放的是公钥（Public key）用于加密，`.p12`格式的文件存放的是私钥（Private key）用于解密. 首先需要先生成这些文件，然后再将文件导入工程使用！\n\n# 一、使用openssl生成所需秘钥文件\n生成环境是在mac系统下，使用`openssl`进行生成，首先打开终端，按下面这些步骤依次来做：\n\n##### 1. 生成模长为1024bit的私钥文件`private_key.pem`\n```objectivec\nopenssl genrsa -out private_key.pem 1024\n```\n##### 2. 生成证书请求文件`rsaCertReq.csr`\n```objectivec\nopenssl req -new -key private_key.pem -out rsaCerReq.csr\n```\n**注意：这一步会提示输入国家、省份、mail等信息，可以根据实际情况填写，或者全部不用填写，直接全部敲回车.**\n##### 3. 生成证书`rsaCert.crt`，并设置有效时间为1年\n```objectivec\nopenssl x509 -req -days 3650 -in rsaCerReq.csr -signkey private_key.pem -out rsaCert.crt\n```\n\n##### 4. 生成供iOS使用的公钥文件`public_key.der`\n```objectivec\nopenssl x509 -outform der -in rsaCert.crt -out public_key.der\n```\n##### 5. 生成供iOS使用的私钥文件`private_key.p12`\n```objectivec\nopenssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n```\n**注意：这一步会提示给私钥文件设置密码，直接输入想要设置密码即可，然后敲回车，然后再验证刚才设置的密码，再次输入密码，然后敲回车，完毕！\n在解密时，`private_key.p12`文件需要和这里设置的密码配合使用，因此需要牢记此密码.**\n##### 6. 生成供Java使用的公钥`rsa_public_key.pem`\n```objectivec\nopenssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n```\n##### 7. 生成供Java使用的私钥`pkcs8_private_key.pem`\n```objectivec\nopenssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n```\n全部执行成功后，会生成如下文件，其中`public_key.der`和`private_key.p12`就是iOS需要用到的文件，如下图：\n![图1](http://upload-images.jianshu.io/upload_images/1803339-3ef995aa667e40f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 二、将文件导入工程使用\n##### 1.新建工程, 并导入`Security.framework`框架, 如下图:\n![图2](http://upload-images.jianshu.io/upload_images/1803339-37dfec3dba887d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 2.导入秘钥文件\n导入`.der`和`.p12`格式的秘钥文件, 如下图:\n![图2](http://upload-images.jianshu.io/upload_images/1803339-5e13a7e8dc3f7027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法\n\n新建`RSAEncryptor`类, 如下图:\n![图3](http://upload-images.jianshu.io/upload_images/1803339-dba6f10fd9a54973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n下面开始上代码,`RSAEncryptor.h`代码如下:\n\n```objectivec\n#import <Foundation/Foundation.h>\n\n@interface RSAEncryptor : NSObject\n\n/**\n *  加密方法\n *\n *  @param str   需要加密的字符串\n *  @param path  '.der'格式的公钥文件路径\n */\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path;\n\n/**\n *  解密方法\n *\n *  @param str       需要解密的字符串\n *  @param path      '.p12'格式的私钥文件路径\n *  @param password  私钥文件密码\n */\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password;\n\n/**\n *  加密方法\n *\n *  @param str    需要加密的字符串\n *  @param pubKey 公钥字符串\n */\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;\n\n/**\n *  解密方法\n *\n *  @param str     需要解密的字符串\n *  @param privKey 私钥字符串\n */\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;\n\n@end\n```\n`RSAEncryptor.m`代码如下:\n\n```objectivec\n#import \"RSAEncryptor.h\"\n#import <Security/Security.h>\n\n@implementation RSAEncryptor\n\nstatic NSString *base64_encode_data(NSData *data){\n    data = [data base64EncodedDataWithOptions:0];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\nstatic NSData *base64_decode(NSString *str){\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    return data;\n}\n\n#pragma mark - 使用'.der'公钥文件加密\n\n//加密\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path{\n    if (!str || !path)  return nil;\n    return [self encryptString:str publicKeyRef:[self getPublicKeyRefWithContentsOfFile:path]];\n}\n\n//获取公钥\n+ (SecKeyRef)getPublicKeyRefWithContentsOfFile:(NSString *)filePath{\n    NSData *certData = [NSData dataWithContentsOfFile:filePath];\n    if (!certData) {\n        return nil;\n    }\n    SecCertificateRef cert = SecCertificateCreateWithData(NULL, (CFDataRef)certData);\n    SecKeyRef key = NULL;\n    SecTrustRef trust = NULL;\n    SecPolicyRef policy = NULL;\n    if (cert != NULL) {\n        policy = SecPolicyCreateBasicX509();\n        if (policy) {\n            if (SecTrustCreateWithCertificates((CFTypeRef)cert, policy, &trust) == noErr) {\n                SecTrustResultType result;\n                if (SecTrustEvaluate(trust, &result) == noErr) {\n                    key = SecTrustCopyPublicKey(trust);\n                }\n            }\n        }\n    }\n    if (policy) CFRelease(policy);\n    if (trust) CFRelease(trust);\n    if (cert) CFRelease(cert);\n    return key;\n}\n\n+ (NSString *)encryptString:(NSString *)str publicKeyRef:(SecKeyRef)publicKeyRef{\n    if(![str dataUsingEncoding:NSUTF8StringEncoding]){\n        return nil;\n    }\n    if(!publicKeyRef){\n        return nil;\n    }\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] withKeyRef:publicKeyRef];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n#pragma mark - 使用'.12'私钥文件解密\n\n//解密\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password{\n    if (!str || !path) return nil;\n    if (!password) password = @\"\";\n    return [self decryptString:str privateKeyRef:[self getPrivateKeyRefWithContentsOfFile:path password:password]];\n}\n\n//获取私钥\n+ (SecKeyRef)getPrivateKeyRefWithContentsOfFile:(NSString *)filePath password:(NSString*)password{\n\n    NSData *p12Data = [NSData dataWithContentsOfFile:filePath];\n    if (!p12Data) {\n        return nil;\n    }\n    SecKeyRef privateKeyRef = NULL;\n    NSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n    [options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\n    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\n    OSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &items);\n    if (securityError == noErr && CFArrayGetCount(items) > 0) {\n        CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n        SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n        securityError = SecIdentityCopyPrivateKey(identityApp, &privateKeyRef);\n        if (securityError != noErr) {\n            privateKeyRef = NULL;\n        }\n    }\n    CFRelease(items);\n\n    return privateKeyRef;\n}\n\n+ (NSString *)decryptString:(NSString *)str privateKeyRef:(SecKeyRef)privKeyRef{\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    if (!privKeyRef) {\n        return nil;\n    }\n    data = [self decryptData:data withKeyRef:privKeyRef];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n#pragma mark - 使用公钥字符串加密\n\n/* START: Encryption with RSA public key */\n\n//使用公钥字符串加密\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey{\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] publicKey:pubKey];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey{\n    if(!data || !pubKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPublicKey:pubKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self encryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPublicKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@\"-----BEGIN PUBLIC KEY-----\"];\n    NSRange epos = [key rangeOfString:@\"-----END PUBLIC KEY-----\"];\n    if(spos.location != NSNotFound && epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\" \"  withString:@\"\"];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPublicKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @\"RSAUtil_PubKey\";\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *publicKey = [[NSMutableDictionary alloc] init];\n    [publicKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [publicKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)publicKey);\n\n    // Add persistent version of the key to system keychain\n    [publicKey setObject:data forKey:(__bridge id)kSecValueData];\n    [publicKey setObject:(__bridge id) kSecAttrKeyClassPublic forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)publicKey, &persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) && (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [publicKey removeObjectForKey:(__bridge id)kSecValueData];\n    [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPublicKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 public key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 0;\n\n    if (c_key[idx++] != 0x30) return(nil);\n\n    if (c_key[idx] > 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    // PKCS #1 rsaEncryption szOID_RSA_RSA\n    static unsigned char seqiod[] =\n    { 0x30,   0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n        0x01, 0x05, 0x00 };\n    if (memcmp(&c_key[idx], seqiod, 15)) return(nil);\n\n    idx += 15;\n\n    if (c_key[idx++] != 0x03) return(nil);\n\n    if (c_key[idx] > 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    if (c_key[idx++] != '\\0') return(nil);\n\n    // Now make a new NSData from this buffer\n    return ([NSData dataWithBytes:&c_key[idx] length:len - idx]);\n}\n\n+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    void *outbuf = malloc(block_size);\n    size_t src_block_size = block_size - 11;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx<srclen; idx+=src_block_size){\n        //NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len > src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyEncrypt(keyRef,\n                               kSecPaddingPKCS1,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &outlen\n                               );\n        if (status != 0) {\n            NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", status);\n            ret = nil;\n            break;\n        }else{\n            [ret appendBytes:outbuf length:outlen];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Encryption with RSA public key */\n\n#pragma mark - 使用私钥字符串解密\n\n/* START: Decryption with RSA private key */\n\n//使用私钥字符串解密\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey{\n    if (!str) return nil;\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    data = [self decryptData:data privateKey:privKey];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey{\n    if(!data || !privKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPrivateKey:privKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self decryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPrivateKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@\"-----BEGIN RSA PRIVATE KEY-----\"];\n    NSRange epos = [key rangeOfString:@\"-----END RSA PRIVATE KEY-----\"];\n    if(spos.location != NSNotFound && epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@\"\\r\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\n\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\"\\t\" withString:@\"\"];\n    key = [key stringByReplacingOccurrencesOfString:@\" \"  withString:@\"\"];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPrivateKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @\"RSAUtil_PrivKey\";\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *privateKey = [[NSMutableDictionary alloc] init];\n    [privateKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [privateKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)privateKey);\n\n    // Add persistent version of the key to system keychain\n    [privateKey setObject:data forKey:(__bridge id)kSecValueData];\n    [privateKey setObject:(__bridge id) kSecAttrKeyClassPrivate forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)privateKey, &persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) && (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [privateKey removeObjectForKey:(__bridge id)kSecValueData];\n    [privateKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)privateKey, (CFTypeRef *)&keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 private key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 22; //magic byte at offset 22\n\n    if (0x04 != c_key[idx++]) return nil;\n\n    //calculate length of the key\n    unsigned int c_len = c_key[idx++];\n    int det = c_len & 0x80;\n    if (!det) {\n        c_len = c_len & 0x7f;\n    } else {\n        int byteCount = c_len & 0x7f;\n        if (byteCount + idx > len) {\n            //rsa length field longer than buffer\n            return nil;\n        }\n        unsigned int accum = 0;\n        unsigned char *ptr = &c_key[idx];\n        idx += byteCount;\n        while (byteCount) {\n            accum = (accum << 8) + *ptr;\n            ptr++;\n            byteCount--;\n        }\n        c_len = accum;\n    }\n\n    // Now make a new NSData from this buffer\n    return [d_key subdataWithRange:NSMakeRange(idx, c_len)];\n}\n\n+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    UInt8 *outbuf = malloc(block_size);\n    size_t src_block_size = block_size;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx<srclen; idx+=src_block_size){\n        //NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len > src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyDecrypt(keyRef,\n                               kSecPaddingNone,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &outlen\n                               );\n        if (status != 0) {\n            NSLog(@\"SecKeyEncrypt fail. Error Code: %d\", status);\n            ret = nil;\n            break;\n        }else{\n            //the actual decrypted data is in the middle, locate it!\n            int idxFirstZero = -1;\n            int idxNextZero = (int)outlen;\n            for ( int i = 0; i < outlen; i++ ) {\n                if ( outbuf[i] == 0 ) {\n                    if ( idxFirstZero < 0 ) {\n                        idxFirstZero = i;\n                    } else {\n                        idxNextZero = i;\n                        break;\n                    }\n                }\n            }\n\n            [ret appendBytes:&outbuf[idxFirstZero+1] length:idxNextZero-idxFirstZero-1];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Decryption with RSA private key */\n\n@end\n```\n##### 4. 测试加密、解密\n\n首先先测试使用`.der`和`.p12`秘钥文件进行加密、解密, 在`ViewController.m`中进行测试, 代码如下:\n\n```objectivec\n#import \"ViewController.h\"\n#import \"RSAEncryptor.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @\"这是一段将要使用'.der'文件加密的字符串!\";\n\n    //使用.der和.p12中的公钥私钥加密解密\n    NSString *public_key_path = [[NSBundle mainBundle] pathForResource:@\"public_key.der\" ofType:nil];\n    NSString *private_key_path = [[NSBundle mainBundle] pathForResource:@\"private_key.p12\" ofType:nil];\n\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKeyWithContentsOfFile:public_key_path];\n    NSLog(@\"加密前:%@\", originalString);\n    NSLog(@\"加密后:%@\", encryptStr);\n    NSLog(@\"解密后:%@\", [RSAEncryptor decryptString:encryptStr privateKeyWithContentsOfFile:private_key_path password:@\"123456\"]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n```\n运行后, 输出信息如下:\n![图4](http://upload-images.jianshu.io/upload_images/1803339-837f26af766fc979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看到已经可以成功加密、解密了.\n下面接着测试使用秘钥字符串进行加密、解密, 那么秘钥字符串从哪里来? 可以来这里:[http://web.chacuo.net/netrsakeypair](http://web.chacuo.net/netrsakeypair), 这是一个在线生成RSA秘钥的网站, 生成公钥和秘钥后, 复制出来用于测试. 然后在`ViewController.m`\n中使用`RSAEntryptor.h`\n头文件中对应的加密方法进行加密, `ViewController.m`\n中代码如下:\n\n```objectivec\n#import \"ViewController.h\"\n#import \"RSAEncryptor.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @\"这是一段将要使用'秘钥字符串'进行加密的字符串!\";\n\n    //使用字符串格式的公钥私钥加密解密\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKey:@\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTbZ6cNH9PgdF60aQKveLz3FTalyzHQwbp601y77SzmGHX3F5NoVUZbdK7UMdoCLK4FBziTewYD9DWvAErXZo9BFuI96bAop8wfl1VkZyyHTcznxNJFGSQd/B70/ExMgMBpEwkAAdyUqIjIdVGh1FQK/4acwS39YXwbS+IlHsPSQIDAQAB\"];\n\n    NSLog(@\"加密前:%@\", originalString);\n    NSLog(@\"加密后:%@\", encryptStr);\n    NSLog(@\"解密后:%@\", [RSAEncryptor decryptString:encryptStr privateKey:@\"MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANNtnpw0f0+B0XrRpAq94vPcVNqXLMdDBunrTXLvtLOYYdfcXk2hVRlt0rtQx2gIsrgUHOJN7BgP0Na8AStdmj0EW4j3psCinzB+XVWRnLIdNzOfE0kUZJB38HvT8TEyAwGkTCQAB3JSoiMh1UaHUVAr/hpzBLf1hfBtL4iUew9JAgMBAAECgYA1tGeQmAkqofga8XtwuxEWDoaDS9k0+EKeUoXGxzqoT/GyiihuIafjILFhoUA1ndf/yCQaG973sbTDhtfpMwqFNQq13+JAownslTjWgr7Hwf7qplYW92R7CU0v7wFfjqm1t/2FKU9JkHfaHfb7qqESMIbO/VMjER9o4tEx58uXDQJBAO0O4lnWDVjr1gN02cqvxPOtTY6DgFbQDeaAZF8obb6XqvCqGW/AVms3Bh8nVlUwdQ2K/xte8tHxjW9FtBQTLd8CQQDkUncO35gAqUF9Bhsdzrs7nO1J3VjLrM0ITrepqjqtVEvdXZc+1/UrkWVaIigWAXjQCVfmQzScdbznhYXPz5fXAkEAgB3KMRkhL4yNpmKRjhw+ih+ASeRCCSj6Sjfbhx4XaakYZmbXxnChg+JB+bZNz06YBFC5nLZM7y/n61o1f5/56wJBALw+ZVzE6ly5L34114uG04W9x0HcFgau7MiJphFjgUdAtd/H9xfgE4odMRPUD3q9Me9LlMYK6MiKpfm4c2+3dzcCQQC8y37NPgpNEkd9smMwPpSEjPW41aMlfcKvP4Da3z7G5bGlmuICrva9YDAiaAyDGGCK8LxC8K6HpKrFgYrXkRtt\"]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n\n```\n\n运行后, 输出信息如下:\n![图5](http://upload-images.jianshu.io/upload_images/1803339-4a11ca319806c3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n至此, RSA加密演示完毕!\n\n\n\n\n\n\n\n\n\n\n","slug":"RSA加密小结","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twc001dznuzdq85554r","content":"<p>在iOS中使用RSA加密解密，需要用到<code>.der</code>和<code>.p12</code>后缀格式的文件，其中<code>.der</code>格式的文件存放的是公钥（Public key）用于加密，<code>.p12</code>格式的文件存放的是私钥（Private key）用于解密. 首先需要先生成这些文件，然后再将文件导入工程使用！</p>\n<h1 id=\"一、使用openssl生成所需秘钥文件\"><a href=\"#一、使用openssl生成所需秘钥文件\" class=\"headerlink\" title=\"一、使用openssl生成所需秘钥文件\"></a>一、使用openssl生成所需秘钥文件</h1><p>生成环境是在mac系统下，使用<code>openssl</code>进行生成，首先打开终端，按下面这些步骤依次来做：</p>\n<h5 id=\"1-生成模长为1024bit的私钥文件private-key-pem\"><a href=\"#1-生成模长为1024bit的私钥文件private-key-pem\" class=\"headerlink\" title=\"1. 生成模长为1024bit的私钥文件private_key.pem\"></a>1. 生成模长为1024bit的私钥文件<code>private_key.pem</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl genrsa <span class=\"token operator\">-</span>out private_key<span class=\"token punctuation\">.</span>pem <span class=\"token number\">1024</span>\n</code></pre>\n<h5 id=\"2-生成证书请求文件rsaCertReq-csr\"><a href=\"#2-生成证书请求文件rsaCertReq-csr\" class=\"headerlink\" title=\"2. 生成证书请求文件rsaCertReq.csr\"></a>2. 生成证书请求文件<code>rsaCertReq.csr</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl req <span class=\"token operator\">-</span>new <span class=\"token operator\">-</span>key private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>out rsaCerReq<span class=\"token punctuation\">.</span>csr\n</code></pre>\n<p><strong>注意：这一步会提示输入国家、省份、mail等信息，可以根据实际情况填写，或者全部不用填写，直接全部敲回车.</strong></p>\n<h5 id=\"3-生成证书rsaCert-crt，并设置有效时间为1年\"><a href=\"#3-生成证书rsaCert-crt，并设置有效时间为1年\" class=\"headerlink\" title=\"3. 生成证书rsaCert.crt，并设置有效时间为1年\"></a>3. 生成证书<code>rsaCert.crt</code>，并设置有效时间为1年</h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl x509 <span class=\"token operator\">-</span>req <span class=\"token operator\">-</span>days <span class=\"token number\">3650</span> <span class=\"token operator\">-</span><span class=\"token keyword\">in</span> rsaCerReq<span class=\"token punctuation\">.</span>csr <span class=\"token operator\">-</span>signkey private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>out rsaCert<span class=\"token punctuation\">.</span>crt\n</code></pre>\n<h5 id=\"4-生成供iOS使用的公钥文件public-key-der\"><a href=\"#4-生成供iOS使用的公钥文件public-key-der\" class=\"headerlink\" title=\"4. 生成供iOS使用的公钥文件public_key.der\"></a>4. 生成供iOS使用的公钥文件<code>public_key.der</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl x509 <span class=\"token operator\">-</span>outform der <span class=\"token operator\">-</span><span class=\"token keyword\">in</span> rsaCert<span class=\"token punctuation\">.</span>crt <span class=\"token operator\">-</span>out public_key<span class=\"token punctuation\">.</span>der\n</code></pre>\n<h5 id=\"5-生成供iOS使用的私钥文件private-key-p12\"><a href=\"#5-生成供iOS使用的私钥文件private-key-p12\" class=\"headerlink\" title=\"5. 生成供iOS使用的私钥文件private_key.p12\"></a>5. 生成供iOS使用的私钥文件<code>private_key.p12</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl pkcs12 <span class=\"token operator\">-</span>export <span class=\"token operator\">-</span>out private_key<span class=\"token punctuation\">.</span>p12 <span class=\"token operator\">-</span>inkey private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span><span class=\"token keyword\">in</span> rsaCert<span class=\"token punctuation\">.</span>crt\n</code></pre>\n<p><strong>注意：这一步会提示给私钥文件设置密码，直接输入想要设置密码即可，然后敲回车，然后再验证刚才设置的密码，再次输入密码，然后敲回车，完毕！<br>在解密时，<code>private_key.p12</code>文件需要和这里设置的密码配合使用，因此需要牢记此密码.</strong></p>\n<h5 id=\"6-生成供Java使用的公钥rsa-public-key-pem\"><a href=\"#6-生成供Java使用的公钥rsa-public-key-pem\" class=\"headerlink\" title=\"6. 生成供Java使用的公钥rsa_public_key.pem\"></a>6. 生成供Java使用的公钥<code>rsa_public_key.pem</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl rsa <span class=\"token operator\">-</span><span class=\"token keyword\">in</span> private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>out rsa_public_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>pubout\n</code></pre>\n<h5 id=\"7-生成供Java使用的私钥pkcs8-private-key-pem\"><a href=\"#7-生成供Java使用的私钥pkcs8-private-key-pem\" class=\"headerlink\" title=\"7. 生成供Java使用的私钥pkcs8_private_key.pem\"></a>7. 生成供Java使用的私钥<code>pkcs8_private_key.pem</code></h5><pre class=\" language-objectivec\"><code class=\"language-objectivec\">openssl pkcs8 <span class=\"token operator\">-</span>topk8 <span class=\"token operator\">-</span><span class=\"token keyword\">in</span> private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>out pkcs8_private_key<span class=\"token punctuation\">.</span>pem <span class=\"token operator\">-</span>nocrypt\n</code></pre>\n<p>全部执行成功后，会生成如下文件，其中<code>public_key.der</code>和<code>private_key.p12</code>就是iOS需要用到的文件，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-3ef995aa667e40f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<h1 id=\"二、将文件导入工程使用\"><a href=\"#二、将文件导入工程使用\" class=\"headerlink\" title=\"二、将文件导入工程使用\"></a>二、将文件导入工程使用</h1><h5 id=\"1-新建工程-并导入Security-framework框架-如下图\"><a href=\"#1-新建工程-并导入Security-framework框架-如下图\" class=\"headerlink\" title=\"1.新建工程, 并导入Security.framework框架, 如下图:\"></a>1.新建工程, 并导入<code>Security.framework</code>框架, 如下图:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-37dfec3dba887d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<h4 id=\"2-导入秘钥文件\"><a href=\"#2-导入秘钥文件\" class=\"headerlink\" title=\"2.导入秘钥文件\"></a>2.导入秘钥文件</h4><p>导入<code>.der</code>和<code>.p12</code>格式的秘钥文件, 如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-5e13a7e8dc3f7027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<h5 id=\"3-新建用于加密、解密的类RSAEncryptor-并实现相关方法\"><a href=\"#3-新建用于加密、解密的类RSAEncryptor-并实现相关方法\" class=\"headerlink\" title=\"3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法\"></a>3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法</h5><p>新建<code>RSAEncryptor</code>类, 如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-dba6f10fd9a54973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3\"><br>下面开始上代码,<code>RSAEncryptor.h</code>代码如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;Foundation/Foundation.h></span>\n\n<span class=\"token keyword\">@interface</span> RSAEncryptor <span class=\"token punctuation\">:</span> NSObject\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n *  加密方法\n *\n *  @param str   需要加密的字符串\n *  @param path  '.der'格式的公钥文件路径\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str publicKeyWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>path<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n *  解密方法\n *\n *  @param str       需要解密的字符串\n *  @param path      '.p12'格式的私钥文件路径\n *  @param password  私钥文件密码\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str privateKeyWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>path password<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>password<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n *  加密方法\n *\n *  @param str    需要加密的字符串\n *  @param pubKey 公钥字符串\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str publicKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pubKey<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n *  解密方法\n *\n *  @param str     需要解密的字符串\n *  @param privKey 私钥字符串\n */</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str privateKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>privKey<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p><code>RSAEncryptor.m</code>代码如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"RSAEncryptor.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;Security/Security.h></span>\n\n<span class=\"token keyword\">@implementation</span> RSAEncryptor\n\n<span class=\"token keyword\">static</span> NSString <span class=\"token operator\">*</span><span class=\"token function\">base64_encode_data</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>data base64EncodedDataWithOptions<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span>data encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> NSData <span class=\"token operator\">*</span><span class=\"token function\">base64_decode</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSData alloc<span class=\"token punctuation\">]</span> initWithBase64EncodedString<span class=\"token punctuation\">:</span>str options<span class=\"token punctuation\">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 使用'.der'公钥文件加密</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//加密</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str publicKeyWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>path<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>str <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>path<span class=\"token punctuation\">)</span>  <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> encryptString<span class=\"token punctuation\">:</span>str publicKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getPublicKeyRefWithContentsOfFile<span class=\"token punctuation\">:</span>path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//获取公钥</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>getPublicKeyRefWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>filePath<span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>certData <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithContentsOfFile<span class=\"token punctuation\">:</span>filePath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>certData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    SecCertificateRef cert <span class=\"token operator\">=</span> <span class=\"token function\">SecCertificateCreateWithData</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>CFDataRef<span class=\"token punctuation\">)</span>certData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    SecKeyRef key <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    SecTrustRef trust <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    SecPolicyRef policy <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cert <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        policy <span class=\"token operator\">=</span> <span class=\"token function\">SecPolicyCreateBasicX509</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>policy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">SecTrustCreateWithCertificates</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>CFTypeRef<span class=\"token punctuation\">)</span>cert<span class=\"token punctuation\">,</span> policy<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>trust<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                SecTrustResultType result<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">SecTrustEvaluate</span><span class=\"token punctuation\">(</span>trust<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    key <span class=\"token operator\">=</span> <span class=\"token function\">SecTrustCopyPublicKey</span><span class=\"token punctuation\">(</span>trust<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>policy<span class=\"token punctuation\">)</span> <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>policy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>trust<span class=\"token punctuation\">)</span> <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>trust<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cert<span class=\"token punctuation\">)</span> <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>cert<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str publicKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>publicKeyRef<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">[</span>str dataUsingEncoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>publicKeyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> encryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>str dataUsingEncoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span> withKeyRef<span class=\"token punctuation\">:</span>publicKeyRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token function\">base64_encode_data</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 使用'.12'私钥文件解密</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//解密</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str privateKeyWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>path password<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>password<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>str <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>path<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>password<span class=\"token punctuation\">)</span> password <span class=\"token operator\">=</span> <span class=\"token string\">@\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> decryptString<span class=\"token punctuation\">:</span>str privateKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getPrivateKeyRefWithContentsOfFile<span class=\"token punctuation\">:</span>path password<span class=\"token punctuation\">:</span>password<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//获取私钥</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>getPrivateKeyRefWithContentsOfFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>filePath password<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>password<span class=\"token punctuation\">{</span>\n\n    NSData <span class=\"token operator\">*</span>p12Data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithContentsOfFile<span class=\"token punctuation\">:</span>filePath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>p12Data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    SecKeyRef privateKeyRef <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    NSMutableDictionary <span class=\"token operator\">*</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableDictionary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>options setObject<span class=\"token punctuation\">:</span> password forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecImportExportPassphrase<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    CFArrayRef items <span class=\"token operator\">=</span> <span class=\"token function\">CFArrayCreate</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    OSStatus securityError <span class=\"token operator\">=</span> <span class=\"token function\">SecPKCS12Import</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDataRef<span class=\"token punctuation\">)</span> p12Data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>options<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>items<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>securityError <span class=\"token operator\">==</span> noErr <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">CFArrayGetCount</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CFDictionaryRef identityDict <span class=\"token operator\">=</span> <span class=\"token function\">CFArrayGetValueAtIndex</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        SecIdentityRef identityApp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SecIdentityRef<span class=\"token punctuation\">)</span><span class=\"token function\">CFDictionaryGetValue</span><span class=\"token punctuation\">(</span>identityDict<span class=\"token punctuation\">,</span> kSecImportItemIdentity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        securityError <span class=\"token operator\">=</span> <span class=\"token function\">SecIdentityCopyPrivateKey</span><span class=\"token punctuation\">(</span>identityApp<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>privateKeyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>securityError <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            privateKeyRef <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> privateKeyRef<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str privateKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>privKeyRef<span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSData alloc<span class=\"token punctuation\">]</span> initWithBase64EncodedString<span class=\"token punctuation\">:</span>str options<span class=\"token punctuation\">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>privKeyRef<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> decryptData<span class=\"token punctuation\">:</span>data withKeyRef<span class=\"token punctuation\">:</span>privKeyRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span>data encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 使用公钥字符串加密</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* START: Encryption with RSA public key */</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//使用公钥字符串加密</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str publicKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pubKey<span class=\"token punctuation\">{</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> encryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>str dataUsingEncoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span> publicKey<span class=\"token punctuation\">:</span>pubKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token function\">base64_encode_data</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>data publicKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>pubKey<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>pubKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    SecKeyRef keyRef <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> addPublicKey<span class=\"token punctuation\">:</span>pubKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> encryptData<span class=\"token punctuation\">:</span>data withKeyRef<span class=\"token punctuation\">:</span>keyRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>addPublicKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>key<span class=\"token punctuation\">{</span>\n    NSRange spos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key rangeOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"-----BEGIN PUBLIC KEY-----\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSRange epos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key rangeOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"-----END PUBLIC KEY-----\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>spos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound <span class=\"token operator\">&amp;&amp;</span> epos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        NSUInteger s <span class=\"token operator\">=</span> spos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">+</span> spos<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        NSUInteger e <span class=\"token operator\">=</span> epos<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">;</span>\n        NSRange range <span class=\"token operator\">=</span> <span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> e<span class=\"token operator\">-</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key substringWithRange<span class=\"token punctuation\">:</span>range<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\r\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\n\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\t\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\" \"</span>  withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// This will be base64 encoded, decode it.</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">base64_decode</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> stripPublicKeyHeader<span class=\"token punctuation\">:</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//a tag to read/write keychain storage</span>\n    NSString <span class=\"token operator\">*</span>tag <span class=\"token operator\">=</span> <span class=\"token string\">@\"RSAUtil_PubKey\"</span><span class=\"token punctuation\">;</span>\n    NSData <span class=\"token operator\">*</span>d_tag <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithBytes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>tag UTF8String<span class=\"token punctuation\">]</span> length<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>tag length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Delete any old lingering key with the same tag</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>publicKey <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableDictionary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecClassKey forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyTypeRSA forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrKeyType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span>d_tag forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrApplicationTag<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">SecItemDelete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>publicKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Add persistent version of the key to system keychain</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span>data forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecValueData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyClassPublic forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>\n     kSecAttrKeyClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span> forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>\n     kSecReturnPersistentRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    CFTypeRef persistKey <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    OSStatus status <span class=\"token operator\">=</span> <span class=\"token function\">SecItemAdd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>publicKey<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>persistKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>persistKey <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>persistKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> errSecDuplicateItem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">[</span>publicKey removeObjectForKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecValueData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey removeObjectForKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecReturnPersistentRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span> forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecReturnRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>publicKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyTypeRSA forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrKeyType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Now fetch the SecKeyRef version of the key</span>\n    SecKeyRef keyRef <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    status <span class=\"token operator\">=</span> <span class=\"token function\">SecItemCopyMatching</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>publicKey<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>CFTypeRef <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> keyRef<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>stripPublicKeyHeader<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>d_key<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Skip ASN.1 public key header</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d_key <span class=\"token operator\">==</span> nil<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> len <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>d_key length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>len<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>c_key <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>d_key bytes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>  idx     <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0x30</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0x80</span><span class=\"token punctuation\">)</span> idx <span class=\"token operator\">+</span><span class=\"token operator\">=</span> c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">0x80</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> idx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// PKCS #1 rsaEncryption szOID_RSA_RSA</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> seqiod<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token number\">0x30</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">0x0d</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x06</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x09</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x2a</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x86</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x48</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x86</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xf7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x0d</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x01</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x01</span><span class=\"token punctuation\">,</span>\n        <span class=\"token number\">0x01</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x05</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x00</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">memcmp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> seqiod<span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    idx <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0x03</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0x80</span><span class=\"token punctuation\">)</span> idx <span class=\"token operator\">+</span><span class=\"token operator\">=</span> c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">0x80</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> idx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Now make a new NSData from this buffer</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>NSData dataWithBytes<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> length<span class=\"token punctuation\">:</span>len <span class=\"token operator\">-</span> idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>encryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>data withKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span> keyRef<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> uint8_t <span class=\"token operator\">*</span>srcbuf <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> uint8_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>data bytes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    size_t srclen <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>size_t<span class=\"token punctuation\">)</span>data<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    size_t block_size <span class=\"token operator\">=</span> <span class=\"token function\">SecKeyGetBlockSize</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>uint8_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>outbuf <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    size_t src_block_size <span class=\"token operator\">=</span> block_size <span class=\"token operator\">-</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n\n    NSMutableData <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableData alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> idx<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> idx<span class=\"token operator\">&lt;</span>srclen<span class=\"token punctuation\">;</span> idx<span class=\"token operator\">+</span><span class=\"token operator\">=</span>src_block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);</span>\n        size_t data_len <span class=\"token operator\">=</span> srclen <span class=\"token operator\">-</span> idx<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data_len <span class=\"token operator\">></span> src_block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            data_len <span class=\"token operator\">=</span> src_block_size<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        size_t outlen <span class=\"token operator\">=</span> block_size<span class=\"token punctuation\">;</span>\n        OSStatus status <span class=\"token operator\">=</span> noErr<span class=\"token punctuation\">;</span>\n        status <span class=\"token operator\">=</span> <span class=\"token function\">SecKeyEncrypt</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">,</span>\n                               kSecPaddingPKCS1<span class=\"token punctuation\">,</span>\n                               srcbuf <span class=\"token operator\">+</span> idx<span class=\"token punctuation\">,</span>\n                               data_len<span class=\"token punctuation\">,</span>\n                               outbuf<span class=\"token punctuation\">,</span>\n                               <span class=\"token operator\">&amp;</span>outlen\n                               <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"SecKeyEncrypt fail. Error Code: %d\"</span><span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ret <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">[</span>ret appendBytes<span class=\"token punctuation\">:</span>outbuf length<span class=\"token punctuation\">:</span>outlen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>outbuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* END: Encryption with RSA public key */</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> mark - 使用私钥字符串解密</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* START: Decryption with RSA private key */</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//使用私钥字符串解密</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptString<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>str privateKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>privKey<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>str<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSData alloc<span class=\"token punctuation\">]</span> initWithBase64EncodedString<span class=\"token punctuation\">:</span>str options<span class=\"token punctuation\">:</span>NSDataBase64DecodingIgnoreUnknownCharacters<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> decryptData<span class=\"token punctuation\">:</span>data privateKey<span class=\"token punctuation\">:</span>privKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithData<span class=\"token punctuation\">:</span>data encoding<span class=\"token punctuation\">:</span>NSUTF8StringEncoding<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>data privateKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>privKey<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>privKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    SecKeyRef keyRef <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> addPrivateKey<span class=\"token punctuation\">:</span>privKey<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> decryptData<span class=\"token punctuation\">:</span>data withKeyRef<span class=\"token punctuation\">:</span>keyRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span>addPrivateKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>key<span class=\"token punctuation\">{</span>\n    NSRange spos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key rangeOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"-----BEGIN RSA PRIVATE KEY-----\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSRange epos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key rangeOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"-----END RSA PRIVATE KEY-----\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>spos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound <span class=\"token operator\">&amp;&amp;</span> epos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">!=</span> NSNotFound<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        NSUInteger s <span class=\"token operator\">=</span> spos<span class=\"token punctuation\">.</span>location <span class=\"token operator\">+</span> spos<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        NSUInteger e <span class=\"token operator\">=</span> epos<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">;</span>\n        NSRange range <span class=\"token operator\">=</span> <span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> e<span class=\"token operator\">-</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key substringWithRange<span class=\"token punctuation\">:</span>range<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\r\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\n\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\\t\"</span> withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key stringByReplacingOccurrencesOfString<span class=\"token punctuation\">:</span><span class=\"token string\">@\" \"</span>  withString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// This will be base64 encoded, decode it.</span>\n    NSData <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">base64_decode</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> stripPrivateKeyHeader<span class=\"token punctuation\">:</span>data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//a tag to read/write keychain storage</span>\n    NSString <span class=\"token operator\">*</span>tag <span class=\"token operator\">=</span> <span class=\"token string\">@\"RSAUtil_PrivKey\"</span><span class=\"token punctuation\">;</span>\n    NSData <span class=\"token operator\">*</span>d_tag <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSData dataWithBytes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>tag UTF8String<span class=\"token punctuation\">]</span> length<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>tag length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Delete any old lingering key with the same tag</span>\n    NSMutableDictionary <span class=\"token operator\">*</span>privateKey <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableDictionary alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecClassKey forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyTypeRSA forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrKeyType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span>d_tag forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrApplicationTag<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">SecItemDelete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>privateKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Add persistent version of the key to system keychain</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span>data forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecValueData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyClassPrivate forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>\n     kSecAttrKeyClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span> forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>\n     kSecReturnPersistentRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    CFTypeRef persistKey <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    OSStatus status <span class=\"token operator\">=</span> <span class=\"token function\">SecItemAdd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>privateKey<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>persistKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>persistKey <span class=\"token operator\">!=</span> nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>persistKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> errSecDuplicateItem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">[</span>privateKey removeObjectForKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecValueData<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey removeObjectForKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecReturnPersistentRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSNumber numberWithBool<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span> forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecReturnRef<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>privateKey setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span> kSecAttrKeyTypeRSA forKey<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>__bridge id<span class=\"token punctuation\">)</span>kSecAttrKeyType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Now fetch the SecKeyRef version of the key</span>\n    SecKeyRef keyRef <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    status <span class=\"token operator\">=</span> <span class=\"token function\">SecItemCopyMatching</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__bridge CFDictionaryRef<span class=\"token punctuation\">)</span>privateKey<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>CFTypeRef <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> noErr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> keyRef<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>stripPrivateKeyHeader<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>d_key<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Skip ASN.1 private key header</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>d_key <span class=\"token operator\">==</span> nil<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> len <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>d_key length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>len<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>nil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>c_key <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>d_key bytes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>  idx     <span class=\"token operator\">=</span> <span class=\"token number\">22</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//magic byte at offset 22</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0x04</span> <span class=\"token operator\">!=</span> c_key<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//calculate length of the key</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> c_len <span class=\"token operator\">=</span> c_key<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> det <span class=\"token operator\">=</span> c_len <span class=\"token operator\">&amp;</span> <span class=\"token number\">0x80</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>det<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        c_len <span class=\"token operator\">=</span> c_len <span class=\"token operator\">&amp;</span> <span class=\"token number\">0x7f</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> byteCount <span class=\"token operator\">=</span> c_len <span class=\"token operator\">&amp;</span> <span class=\"token number\">0x7f</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>byteCount <span class=\"token operator\">+</span> idx <span class=\"token operator\">></span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//rsa length field longer than buffer</span>\n            <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> accum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>c_key<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        idx <span class=\"token operator\">+</span><span class=\"token operator\">=</span> byteCount<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>byteCount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            accum <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>accum <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span>\n            ptr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            byteCount<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        c_len <span class=\"token operator\">=</span> accum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Now make a new NSData from this buffer</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>d_key subdataWithRange<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">,</span> c_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>decryptData<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSData <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>data withKeyRef<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>SecKeyRef<span class=\"token punctuation\">)</span> keyRef<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> uint8_t <span class=\"token operator\">*</span>srcbuf <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> uint8_t <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>data bytes<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    size_t srclen <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>size_t<span class=\"token punctuation\">)</span>data<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    size_t block_size <span class=\"token operator\">=</span> <span class=\"token function\">SecKeyGetBlockSize</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>uint8_t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    UInt8 <span class=\"token operator\">*</span>outbuf <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    size_t src_block_size <span class=\"token operator\">=</span> block_size<span class=\"token punctuation\">;</span>\n\n    NSMutableData <span class=\"token operator\">*</span>ret <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableData alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> idx<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> idx<span class=\"token operator\">&lt;</span>srclen<span class=\"token punctuation\">;</span> idx<span class=\"token operator\">+</span><span class=\"token operator\">=</span>src_block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//NSLog(@\"%d/%d block_size: %d\", idx, (int)srclen, (int)block_size);</span>\n        size_t data_len <span class=\"token operator\">=</span> srclen <span class=\"token operator\">-</span> idx<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>data_len <span class=\"token operator\">></span> src_block_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            data_len <span class=\"token operator\">=</span> src_block_size<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        size_t outlen <span class=\"token operator\">=</span> block_size<span class=\"token punctuation\">;</span>\n        OSStatus status <span class=\"token operator\">=</span> noErr<span class=\"token punctuation\">;</span>\n        status <span class=\"token operator\">=</span> <span class=\"token function\">SecKeyDecrypt</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">,</span>\n                               kSecPaddingNone<span class=\"token punctuation\">,</span>\n                               srcbuf <span class=\"token operator\">+</span> idx<span class=\"token punctuation\">,</span>\n                               data_len<span class=\"token punctuation\">,</span>\n                               outbuf<span class=\"token punctuation\">,</span>\n                               <span class=\"token operator\">&amp;</span>outlen\n                               <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>status <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"SecKeyEncrypt fail. Error Code: %d\"</span><span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ret <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//the actual decrypted data is in the middle, locate it!</span>\n            <span class=\"token keyword\">int</span> idxFirstZero <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> idxNextZero <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>outlen<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> outlen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> outbuf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> idxFirstZero <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        idxFirstZero <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        idxNextZero <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token punctuation\">[</span>ret appendBytes<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>outbuf<span class=\"token punctuation\">[</span>idxFirstZero<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> length<span class=\"token punctuation\">:</span>idxNextZero<span class=\"token operator\">-</span>idxFirstZero<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>outbuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CFRelease</span><span class=\"token punctuation\">(</span>keyRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* END: Decryption with RSA private key */</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<h5 id=\"4-测试加密、解密\"><a href=\"#4-测试加密、解密\" class=\"headerlink\" title=\"4. 测试加密、解密\"></a>4. 测试加密、解密</h5><p>首先先测试使用<code>.der</code>和<code>.p12</code>秘钥文件进行加密、解密, 在<code>ViewController.m</code>中进行测试, 代码如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"ViewController.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"RSAEncryptor.h\"</span>\n\n<span class=\"token keyword\">@interface</span> <span class=\"token function\">ViewController</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> ViewController\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLoad<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//原始数据</span>\n    NSString <span class=\"token operator\">*</span>originalString <span class=\"token operator\">=</span> <span class=\"token string\">@\"这是一段将要使用'.der'文件加密的字符串!\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//使用.der和.p12中的公钥私钥加密解密</span>\n    NSString <span class=\"token operator\">*</span>public_key_path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span><span class=\"token string\">@\"public_key.der\"</span> ofType<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSString <span class=\"token operator\">*</span>private_key_path <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSBundle mainBundle<span class=\"token punctuation\">]</span> pathForResource<span class=\"token punctuation\">:</span><span class=\"token string\">@\"private_key.p12\"</span> ofType<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    NSString <span class=\"token operator\">*</span>encryptStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>RSAEncryptor encryptString<span class=\"token punctuation\">:</span>originalString publicKeyWithContentsOfFile<span class=\"token punctuation\">:</span>public_key_path<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"加密前:%@\"</span><span class=\"token punctuation\">,</span> originalString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"加密后:%@\"</span><span class=\"token punctuation\">,</span> encryptStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"解密后:%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>RSAEncryptor decryptString<span class=\"token punctuation\">:</span>encryptStr privateKeyWithContentsOfFile<span class=\"token punctuation\">:</span>private_key_path password<span class=\"token punctuation\">:</span><span class=\"token string\">@\"123456\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>didReceiveMemoryWarning <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> didReceiveMemoryWarning<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Dispose of any resources that can be recreated.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>运行后, 输出信息如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-837f26af766fc979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图4\"><br>可以看到已经可以成功加密、解密了.<br>下面接着测试使用秘钥字符串进行加密、解密, 那么秘钥字符串从哪里来? 可以来这里:<a href=\"http://web.chacuo.net/netrsakeypair\" target=\"_blank\" rel=\"external\">http://web.chacuo.net/netrsakeypair</a>, 这是一个在线生成RSA秘钥的网站, 生成公钥和秘钥后, 复制出来用于测试. 然后在<code>ViewController.m</code><br>中使用<code>RSAEntryptor.h</code><br>头文件中对应的加密方法进行加密, <code>ViewController.m</code><br>中代码如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"ViewController.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"RSAEncryptor.h\"</span>\n\n<span class=\"token keyword\">@interface</span> <span class=\"token function\">ViewController</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> ViewController\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>viewDidLoad <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> viewDidLoad<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//原始数据</span>\n    NSString <span class=\"token operator\">*</span>originalString <span class=\"token operator\">=</span> <span class=\"token string\">@\"这是一段将要使用'秘钥字符串'进行加密的字符串!\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//使用字符串格式的公钥私钥加密解密</span>\n    NSString <span class=\"token operator\">*</span>encryptStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>RSAEncryptor encryptString<span class=\"token punctuation\">:</span>originalString publicKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTbZ6cNH9PgdF60aQKveLz3FTalyzHQwbp601y77SzmGHX3F5NoVUZbdK7UMdoCLK4FBziTewYD9DWvAErXZo9BFuI96bAop8wfl1VkZyyHTcznxNJFGSQd/B70/ExMgMBpEwkAAdyUqIjIdVGh1FQK/4acwS39YXwbS+IlHsPSQIDAQAB\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"加密前:%@\"</span><span class=\"token punctuation\">,</span> originalString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"加密后:%@\"</span><span class=\"token punctuation\">,</span> encryptStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"解密后:%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>RSAEncryptor decryptString<span class=\"token punctuation\">:</span>encryptStr privateKey<span class=\"token punctuation\">:</span><span class=\"token string\">@\"MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANNtnpw0f0+B0XrRpAq94vPcVNqXLMdDBunrTXLvtLOYYdfcXk2hVRlt0rtQx2gIsrgUHOJN7BgP0Na8AStdmj0EW4j3psCinzB+XVWRnLIdNzOfE0kUZJB38HvT8TEyAwGkTCQAB3JSoiMh1UaHUVAr/hpzBLf1hfBtL4iUew9JAgMBAAECgYA1tGeQmAkqofga8XtwuxEWDoaDS9k0+EKeUoXGxzqoT/GyiihuIafjILFhoUA1ndf/yCQaG973sbTDhtfpMwqFNQq13+JAownslTjWgr7Hwf7qplYW92R7CU0v7wFfjqm1t/2FKU9JkHfaHfb7qqESMIbO/VMjER9o4tEx58uXDQJBAO0O4lnWDVjr1gN02cqvxPOtTY6DgFbQDeaAZF8obb6XqvCqGW/AVms3Bh8nVlUwdQ2K/xte8tHxjW9FtBQTLd8CQQDkUncO35gAqUF9Bhsdzrs7nO1J3VjLrM0ITrepqjqtVEvdXZc+1/UrkWVaIigWAXjQCVfmQzScdbznhYXPz5fXAkEAgB3KMRkhL4yNpmKRjhw+ih+ASeRCCSj6Sjfbhx4XaakYZmbXxnChg+JB+bZNz06YBFC5nLZM7y/n61o1f5/56wJBALw+ZVzE6ly5L34114uG04W9x0HcFgau7MiJphFjgUdAtd/H9xfgE4odMRPUD3q9Me9LlMYK6MiKpfm4c2+3dzcCQQC8y37NPgpNEkd9smMwPpSEjPW41aMlfcKvP4Da3z7G5bGlmuICrva9YDAiaAyDGGCK8LxC8K6HpKrFgYrXkRtt\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>didReceiveMemoryWarning <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> didReceiveMemoryWarning<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Dispose of any resources that can be recreated.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>运行后, 输出信息如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-4a11ca319806c3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图5\"><br>至此, RSA加密演示完毕!</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p>在iOS中使用RSA加密解密，需要用到<code>.der</code>和<code>.p12</code>后缀格式的文件，其中<code>.der</code>格式的文件存放的是公钥（Public key）用于加密，<code>.p12</code>格式的文件存放的是私钥（Private key）用于解密. 首先需要先生成这些文件，然后再将文件导入工程使用！</p>\n<h1 id=\"一、使用openssl生成所需秘钥文件\"><a href=\"#一、使用openssl生成所需秘钥文件\" class=\"headerlink\" title=\"一、使用openssl生成所需秘钥文件\"></a>一、使用openssl生成所需秘钥文件</h1><p>生成环境是在mac系统下，使用<code>openssl</code>进行生成，首先打开终端，按下面这些步骤依次来做：</p>\n<h5 id=\"1-生成模长为1024bit的私钥文件private-key-pem\"><a href=\"#1-生成模长为1024bit的私钥文件private-key-pem\" class=\"headerlink\" title=\"1. 生成模长为1024bit的私钥文件private_key.pem\"></a>1. 生成模长为1024bit的私钥文件<code>private_key.pem</code></h5><pre><code class=\"objectivec\">openssl genrsa -out private_key.pem 1024\n</code></pre>\n<h5 id=\"2-生成证书请求文件rsaCertReq-csr\"><a href=\"#2-生成证书请求文件rsaCertReq-csr\" class=\"headerlink\" title=\"2. 生成证书请求文件rsaCertReq.csr\"></a>2. 生成证书请求文件<code>rsaCertReq.csr</code></h5><pre><code class=\"objectivec\">openssl req -new -key private_key.pem -out rsaCerReq.csr\n</code></pre>\n<p><strong>注意：这一步会提示输入国家、省份、mail等信息，可以根据实际情况填写，或者全部不用填写，直接全部敲回车.</strong></p>\n<h5 id=\"3-生成证书rsaCert-crt，并设置有效时间为1年\"><a href=\"#3-生成证书rsaCert-crt，并设置有效时间为1年\" class=\"headerlink\" title=\"3. 生成证书rsaCert.crt，并设置有效时间为1年\"></a>3. 生成证书<code>rsaCert.crt</code>，并设置有效时间为1年</h5><pre><code class=\"objectivec\">openssl x509 -req -days 3650 -in rsaCerReq.csr -signkey private_key.pem -out rsaCert.crt\n</code></pre>\n<h5 id=\"4-生成供iOS使用的公钥文件public-key-der\"><a href=\"#4-生成供iOS使用的公钥文件public-key-der\" class=\"headerlink\" title=\"4. 生成供iOS使用的公钥文件public_key.der\"></a>4. 生成供iOS使用的公钥文件<code>public_key.der</code></h5><pre><code class=\"objectivec\">openssl x509 -outform der -in rsaCert.crt -out public_key.der\n</code></pre>\n<h5 id=\"5-生成供iOS使用的私钥文件private-key-p12\"><a href=\"#5-生成供iOS使用的私钥文件private-key-p12\" class=\"headerlink\" title=\"5. 生成供iOS使用的私钥文件private_key.p12\"></a>5. 生成供iOS使用的私钥文件<code>private_key.p12</code></h5><pre><code class=\"objectivec\">openssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt\n</code></pre>\n<p><strong>注意：这一步会提示给私钥文件设置密码，直接输入想要设置密码即可，然后敲回车，然后再验证刚才设置的密码，再次输入密码，然后敲回车，完毕！<br>在解密时，<code>private_key.p12</code>文件需要和这里设置的密码配合使用，因此需要牢记此密码.</strong></p>\n<h5 id=\"6-生成供Java使用的公钥rsa-public-key-pem\"><a href=\"#6-生成供Java使用的公钥rsa-public-key-pem\" class=\"headerlink\" title=\"6. 生成供Java使用的公钥rsa_public_key.pem\"></a>6. 生成供Java使用的公钥<code>rsa_public_key.pem</code></h5><pre><code class=\"objectivec\">openssl rsa -in private_key.pem -out rsa_public_key.pem -pubout\n</code></pre>\n<h5 id=\"7-生成供Java使用的私钥pkcs8-private-key-pem\"><a href=\"#7-生成供Java使用的私钥pkcs8-private-key-pem\" class=\"headerlink\" title=\"7. 生成供Java使用的私钥pkcs8_private_key.pem\"></a>7. 生成供Java使用的私钥<code>pkcs8_private_key.pem</code></h5><pre><code class=\"objectivec\">openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocrypt\n</code></pre>\n<p>全部执行成功后，会生成如下文件，其中<code>public_key.der</code>和<code>private_key.p12</code>就是iOS需要用到的文件，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-3ef995aa667e40f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<h1 id=\"二、将文件导入工程使用\"><a href=\"#二、将文件导入工程使用\" class=\"headerlink\" title=\"二、将文件导入工程使用\"></a>二、将文件导入工程使用</h1><h5 id=\"1-新建工程-并导入Security-framework框架-如下图\"><a href=\"#1-新建工程-并导入Security-framework框架-如下图\" class=\"headerlink\" title=\"1.新建工程, 并导入Security.framework框架, 如下图:\"></a>1.新建工程, 并导入<code>Security.framework</code>框架, 如下图:</h5><p><img src=\"http://upload-images.jianshu.io/upload_images/1803339-37dfec3dba887d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<h4 id=\"2-导入秘钥文件\"><a href=\"#2-导入秘钥文件\" class=\"headerlink\" title=\"2.导入秘钥文件\"></a>2.导入秘钥文件</h4><p>导入<code>.der</code>和<code>.p12</code>格式的秘钥文件, 如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-5e13a7e8dc3f7027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图2\"></p>\n<h5 id=\"3-新建用于加密、解密的类RSAEncryptor-并实现相关方法\"><a href=\"#3-新建用于加密、解密的类RSAEncryptor-并实现相关方法\" class=\"headerlink\" title=\"3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法\"></a>3.新建用于加密、解密的类RSAEncryptor, 并实现相关方法</h5><p>新建<code>RSAEncryptor</code>类, 如下图:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-dba6f10fd9a54973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3\"><br>下面开始上代码,<code>RSAEncryptor.h</code>代码如下:</p>\n<pre><code class=\"objectivec\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface RSAEncryptor : NSObject\n\n/**\n *  加密方法\n *\n *  @param str   需要加密的字符串\n *  @param path  &#39;.der&#39;格式的公钥文件路径\n */\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path;\n\n/**\n *  解密方法\n *\n *  @param str       需要解密的字符串\n *  @param path      &#39;.p12&#39;格式的私钥文件路径\n *  @param password  私钥文件密码\n */\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password;\n\n/**\n *  加密方法\n *\n *  @param str    需要加密的字符串\n *  @param pubKey 公钥字符串\n */\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;\n\n/**\n *  解密方法\n *\n *  @param str     需要解密的字符串\n *  @param privKey 私钥字符串\n */\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;\n\n@end\n</code></pre>\n<p><code>RSAEncryptor.m</code>代码如下:</p>\n<pre><code class=\"objectivec\">#import &quot;RSAEncryptor.h&quot;\n#import &lt;Security/Security.h&gt;\n\n@implementation RSAEncryptor\n\nstatic NSString *base64_encode_data(NSData *data){\n    data = [data base64EncodedDataWithOptions:0];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\nstatic NSData *base64_decode(NSString *str){\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    return data;\n}\n\n#pragma mark - 使用&#39;.der&#39;公钥文件加密\n\n//加密\n+ (NSString *)encryptString:(NSString *)str publicKeyWithContentsOfFile:(NSString *)path{\n    if (!str || !path)  return nil;\n    return [self encryptString:str publicKeyRef:[self getPublicKeyRefWithContentsOfFile:path]];\n}\n\n//获取公钥\n+ (SecKeyRef)getPublicKeyRefWithContentsOfFile:(NSString *)filePath{\n    NSData *certData = [NSData dataWithContentsOfFile:filePath];\n    if (!certData) {\n        return nil;\n    }\n    SecCertificateRef cert = SecCertificateCreateWithData(NULL, (CFDataRef)certData);\n    SecKeyRef key = NULL;\n    SecTrustRef trust = NULL;\n    SecPolicyRef policy = NULL;\n    if (cert != NULL) {\n        policy = SecPolicyCreateBasicX509();\n        if (policy) {\n            if (SecTrustCreateWithCertificates((CFTypeRef)cert, policy, &amp;trust) == noErr) {\n                SecTrustResultType result;\n                if (SecTrustEvaluate(trust, &amp;result) == noErr) {\n                    key = SecTrustCopyPublicKey(trust);\n                }\n            }\n        }\n    }\n    if (policy) CFRelease(policy);\n    if (trust) CFRelease(trust);\n    if (cert) CFRelease(cert);\n    return key;\n}\n\n+ (NSString *)encryptString:(NSString *)str publicKeyRef:(SecKeyRef)publicKeyRef{\n    if(![str dataUsingEncoding:NSUTF8StringEncoding]){\n        return nil;\n    }\n    if(!publicKeyRef){\n        return nil;\n    }\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] withKeyRef:publicKeyRef];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n#pragma mark - 使用&#39;.12&#39;私钥文件解密\n\n//解密\n+ (NSString *)decryptString:(NSString *)str privateKeyWithContentsOfFile:(NSString *)path password:(NSString *)password{\n    if (!str || !path) return nil;\n    if (!password) password = @&quot;&quot;;\n    return [self decryptString:str privateKeyRef:[self getPrivateKeyRefWithContentsOfFile:path password:password]];\n}\n\n//获取私钥\n+ (SecKeyRef)getPrivateKeyRefWithContentsOfFile:(NSString *)filePath password:(NSString*)password{\n\n    NSData *p12Data = [NSData dataWithContentsOfFile:filePath];\n    if (!p12Data) {\n        return nil;\n    }\n    SecKeyRef privateKeyRef = NULL;\n    NSMutableDictionary * options = [[NSMutableDictionary alloc] init];\n    [options setObject: password forKey:(__bridge id)kSecImportExportPassphrase];\n    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);\n    OSStatus securityError = SecPKCS12Import((__bridge CFDataRef) p12Data, (__bridge CFDictionaryRef)options, &amp;items);\n    if (securityError == noErr &amp;&amp; CFArrayGetCount(items) &gt; 0) {\n        CFDictionaryRef identityDict = CFArrayGetValueAtIndex(items, 0);\n        SecIdentityRef identityApp = (SecIdentityRef)CFDictionaryGetValue(identityDict, kSecImportItemIdentity);\n        securityError = SecIdentityCopyPrivateKey(identityApp, &amp;privateKeyRef);\n        if (securityError != noErr) {\n            privateKeyRef = NULL;\n        }\n    }\n    CFRelease(items);\n\n    return privateKeyRef;\n}\n\n+ (NSString *)decryptString:(NSString *)str privateKeyRef:(SecKeyRef)privKeyRef{\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    if (!privKeyRef) {\n        return nil;\n    }\n    data = [self decryptData:data withKeyRef:privKeyRef];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n#pragma mark - 使用公钥字符串加密\n\n/* START: Encryption with RSA public key */\n\n//使用公钥字符串加密\n+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey{\n    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] publicKey:pubKey];\n    NSString *ret = base64_encode_data(data);\n    return ret;\n}\n\n+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey{\n    if(!data || !pubKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPublicKey:pubKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self encryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPublicKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@&quot;-----BEGIN PUBLIC KEY-----&quot;];\n    NSRange epos = [key rangeOfString:@&quot;-----END PUBLIC KEY-----&quot;];\n    if(spos.location != NSNotFound &amp;&amp; epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\r&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\t&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot; &quot;  withString:@&quot;&quot;];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPublicKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @&quot;RSAUtil_PubKey&quot;;\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *publicKey = [[NSMutableDictionary alloc] init];\n    [publicKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [publicKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)publicKey);\n\n    // Add persistent version of the key to system keychain\n    [publicKey setObject:data forKey:(__bridge id)kSecValueData];\n    [publicKey setObject:(__bridge id) kSecAttrKeyClassPublic forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [publicKey removeObjectForKey:(__bridge id)kSecValueData];\n    [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&amp;keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPublicKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 public key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 0;\n\n    if (c_key[idx++] != 0x30) return(nil);\n\n    if (c_key[idx] &gt; 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    // PKCS #1 rsaEncryption szOID_RSA_RSA\n    static unsigned char seqiod[] =\n    { 0x30,   0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n        0x01, 0x05, 0x00 };\n    if (memcmp(&amp;c_key[idx], seqiod, 15)) return(nil);\n\n    idx += 15;\n\n    if (c_key[idx++] != 0x03) return(nil);\n\n    if (c_key[idx] &gt; 0x80) idx += c_key[idx] - 0x80 + 1;\n    else idx++;\n\n    if (c_key[idx++] != &#39;\\0&#39;) return(nil);\n\n    // Now make a new NSData from this buffer\n    return ([NSData dataWithBytes:&amp;c_key[idx] length:len - idx]);\n}\n\n+ (NSData *)encryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    void *outbuf = malloc(block_size);\n    size_t src_block_size = block_size - 11;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx&lt;srclen; idx+=src_block_size){\n        //NSLog(@&quot;%d/%d block_size: %d&quot;, idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len &gt; src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyEncrypt(keyRef,\n                               kSecPaddingPKCS1,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &amp;outlen\n                               );\n        if (status != 0) {\n            NSLog(@&quot;SecKeyEncrypt fail. Error Code: %d&quot;, status);\n            ret = nil;\n            break;\n        }else{\n            [ret appendBytes:outbuf length:outlen];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Encryption with RSA public key */\n\n#pragma mark - 使用私钥字符串解密\n\n/* START: Decryption with RSA private key */\n\n//使用私钥字符串解密\n+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey{\n    if (!str) return nil;\n    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];\n    data = [self decryptData:data privateKey:privKey];\n    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    return ret;\n}\n\n+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey{\n    if(!data || !privKey){\n        return nil;\n    }\n    SecKeyRef keyRef = [self addPrivateKey:privKey];\n    if(!keyRef){\n        return nil;\n    }\n    return [self decryptData:data withKeyRef:keyRef];\n}\n\n+ (SecKeyRef)addPrivateKey:(NSString *)key{\n    NSRange spos = [key rangeOfString:@&quot;-----BEGIN RSA PRIVATE KEY-----&quot;];\n    NSRange epos = [key rangeOfString:@&quot;-----END RSA PRIVATE KEY-----&quot;];\n    if(spos.location != NSNotFound &amp;&amp; epos.location != NSNotFound){\n        NSUInteger s = spos.location + spos.length;\n        NSUInteger e = epos.location;\n        NSRange range = NSMakeRange(s, e-s);\n        key = [key substringWithRange:range];\n    }\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\r&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot;\\t&quot; withString:@&quot;&quot;];\n    key = [key stringByReplacingOccurrencesOfString:@&quot; &quot;  withString:@&quot;&quot;];\n\n    // This will be base64 encoded, decode it.\n    NSData *data = base64_decode(key);\n    data = [self stripPrivateKeyHeader:data];\n    if(!data){\n        return nil;\n    }\n\n    //a tag to read/write keychain storage\n    NSString *tag = @&quot;RSAUtil_PrivKey&quot;;\n    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];\n\n    // Delete any old lingering key with the same tag\n    NSMutableDictionary *privateKey = [[NSMutableDictionary alloc] init];\n    [privateKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n    [privateKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];\n    SecItemDelete((__bridge CFDictionaryRef)privateKey);\n\n    // Add persistent version of the key to system keychain\n    [privateKey setObject:data forKey:(__bridge id)kSecValueData];\n    [privateKey setObject:(__bridge id) kSecAttrKeyClassPrivate forKey:(__bridge id)\n     kSecAttrKeyClass];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)\n     kSecReturnPersistentRef];\n\n    CFTypeRef persistKey = nil;\n    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)privateKey, &amp;persistKey);\n    if (persistKey != nil){\n        CFRelease(persistKey);\n    }\n    if ((status != noErr) &amp;&amp; (status != errSecDuplicateItem)) {\n        return nil;\n    }\n\n    [privateKey removeObjectForKey:(__bridge id)kSecValueData];\n    [privateKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];\n    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];\n    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];\n\n    // Now fetch the SecKeyRef version of the key\n    SecKeyRef keyRef = nil;\n    status = SecItemCopyMatching((__bridge CFDictionaryRef)privateKey, (CFTypeRef *)&amp;keyRef);\n    if(status != noErr){\n        return nil;\n    }\n    return keyRef;\n}\n\n+ (NSData *)stripPrivateKeyHeader:(NSData *)d_key{\n    // Skip ASN.1 private key header\n    if (d_key == nil) return(nil);\n\n    unsigned long len = [d_key length];\n    if (!len) return(nil);\n\n    unsigned char *c_key = (unsigned char *)[d_key bytes];\n    unsigned int  idx     = 22; //magic byte at offset 22\n\n    if (0x04 != c_key[idx++]) return nil;\n\n    //calculate length of the key\n    unsigned int c_len = c_key[idx++];\n    int det = c_len &amp; 0x80;\n    if (!det) {\n        c_len = c_len &amp; 0x7f;\n    } else {\n        int byteCount = c_len &amp; 0x7f;\n        if (byteCount + idx &gt; len) {\n            //rsa length field longer than buffer\n            return nil;\n        }\n        unsigned int accum = 0;\n        unsigned char *ptr = &amp;c_key[idx];\n        idx += byteCount;\n        while (byteCount) {\n            accum = (accum &lt;&lt; 8) + *ptr;\n            ptr++;\n            byteCount--;\n        }\n        c_len = accum;\n    }\n\n    // Now make a new NSData from this buffer\n    return [d_key subdataWithRange:NSMakeRange(idx, c_len)];\n}\n\n+ (NSData *)decryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{\n    const uint8_t *srcbuf = (const uint8_t *)[data bytes];\n    size_t srclen = (size_t)data.length;\n\n    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);\n    UInt8 *outbuf = malloc(block_size);\n    size_t src_block_size = block_size;\n\n    NSMutableData *ret = [[NSMutableData alloc] init];\n    for(int idx=0; idx&lt;srclen; idx+=src_block_size){\n        //NSLog(@&quot;%d/%d block_size: %d&quot;, idx, (int)srclen, (int)block_size);\n        size_t data_len = srclen - idx;\n        if(data_len &gt; src_block_size){\n            data_len = src_block_size;\n        }\n\n        size_t outlen = block_size;\n        OSStatus status = noErr;\n        status = SecKeyDecrypt(keyRef,\n                               kSecPaddingNone,\n                               srcbuf + idx,\n                               data_len,\n                               outbuf,\n                               &amp;outlen\n                               );\n        if (status != 0) {\n            NSLog(@&quot;SecKeyEncrypt fail. Error Code: %d&quot;, status);\n            ret = nil;\n            break;\n        }else{\n            //the actual decrypted data is in the middle, locate it!\n            int idxFirstZero = -1;\n            int idxNextZero = (int)outlen;\n            for ( int i = 0; i &lt; outlen; i++ ) {\n                if ( outbuf[i] == 0 ) {\n                    if ( idxFirstZero &lt; 0 ) {\n                        idxFirstZero = i;\n                    } else {\n                        idxNextZero = i;\n                        break;\n                    }\n                }\n            }\n\n            [ret appendBytes:&amp;outbuf[idxFirstZero+1] length:idxNextZero-idxFirstZero-1];\n        }\n    }\n\n    free(outbuf);\n    CFRelease(keyRef);\n    return ret;\n}\n\n/* END: Decryption with RSA private key */\n\n@end\n</code></pre>\n<h5 id=\"4-测试加密、解密\"><a href=\"#4-测试加密、解密\" class=\"headerlink\" title=\"4. 测试加密、解密\"></a>4. 测试加密、解密</h5><p>首先先测试使用<code>.der</code>和<code>.p12</code>秘钥文件进行加密、解密, 在<code>ViewController.m</code>中进行测试, 代码如下:</p>\n<pre><code class=\"objectivec\">#import &quot;ViewController.h&quot;\n#import &quot;RSAEncryptor.h&quot;\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @&quot;这是一段将要使用&#39;.der&#39;文件加密的字符串!&quot;;\n\n    //使用.der和.p12中的公钥私钥加密解密\n    NSString *public_key_path = [[NSBundle mainBundle] pathForResource:@&quot;public_key.der&quot; ofType:nil];\n    NSString *private_key_path = [[NSBundle mainBundle] pathForResource:@&quot;private_key.p12&quot; ofType:nil];\n\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKeyWithContentsOfFile:public_key_path];\n    NSLog(@&quot;加密前:%@&quot;, originalString);\n    NSLog(@&quot;加密后:%@&quot;, encryptStr);\n    NSLog(@&quot;解密后:%@&quot;, [RSAEncryptor decryptString:encryptStr privateKeyWithContentsOfFile:private_key_path password:@&quot;123456&quot;]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n</code></pre>\n<p>运行后, 输出信息如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-837f26af766fc979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图4\"><br>可以看到已经可以成功加密、解密了.<br>下面接着测试使用秘钥字符串进行加密、解密, 那么秘钥字符串从哪里来? 可以来这里:<a href=\"http://web.chacuo.net/netrsakeypair\" target=\"_blank\" rel=\"external\">http://web.chacuo.net/netrsakeypair</a>, 这是一个在线生成RSA秘钥的网站, 生成公钥和秘钥后, 复制出来用于测试. 然后在<code>ViewController.m</code><br>中使用<code>RSAEntryptor.h</code><br>头文件中对应的加密方法进行加密, <code>ViewController.m</code><br>中代码如下:</p>\n<pre><code class=\"objectivec\">#import &quot;ViewController.h&quot;\n#import &quot;RSAEncryptor.h&quot;\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    //原始数据\n    NSString *originalString = @&quot;这是一段将要使用&#39;秘钥字符串&#39;进行加密的字符串!&quot;;\n\n    //使用字符串格式的公钥私钥加密解密\n    NSString *encryptStr = [RSAEncryptor encryptString:originalString publicKey:@&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTbZ6cNH9PgdF60aQKveLz3FTalyzHQwbp601y77SzmGHX3F5NoVUZbdK7UMdoCLK4FBziTewYD9DWvAErXZo9BFuI96bAop8wfl1VkZyyHTcznxNJFGSQd/B70/ExMgMBpEwkAAdyUqIjIdVGh1FQK/4acwS39YXwbS+IlHsPSQIDAQAB&quot;];\n\n    NSLog(@&quot;加密前:%@&quot;, originalString);\n    NSLog(@&quot;加密后:%@&quot;, encryptStr);\n    NSLog(@&quot;解密后:%@&quot;, [RSAEncryptor decryptString:encryptStr privateKey:@&quot;MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANNtnpw0f0+B0XrRpAq94vPcVNqXLMdDBunrTXLvtLOYYdfcXk2hVRlt0rtQx2gIsrgUHOJN7BgP0Na8AStdmj0EW4j3psCinzB+XVWRnLIdNzOfE0kUZJB38HvT8TEyAwGkTCQAB3JSoiMh1UaHUVAr/hpzBLf1hfBtL4iUew9JAgMBAAECgYA1tGeQmAkqofga8XtwuxEWDoaDS9k0+EKeUoXGxzqoT/GyiihuIafjILFhoUA1ndf/yCQaG973sbTDhtfpMwqFNQq13+JAownslTjWgr7Hwf7qplYW92R7CU0v7wFfjqm1t/2FKU9JkHfaHfb7qqESMIbO/VMjER9o4tEx58uXDQJBAO0O4lnWDVjr1gN02cqvxPOtTY6DgFbQDeaAZF8obb6XqvCqGW/AVms3Bh8nVlUwdQ2K/xte8tHxjW9FtBQTLd8CQQDkUncO35gAqUF9Bhsdzrs7nO1J3VjLrM0ITrepqjqtVEvdXZc+1/UrkWVaIigWAXjQCVfmQzScdbznhYXPz5fXAkEAgB3KMRkhL4yNpmKRjhw+ih+ASeRCCSj6Sjfbhx4XaakYZmbXxnChg+JB+bZNz06YBFC5nLZM7y/n61o1f5/56wJBALw+ZVzE6ly5L34114uG04W9x0HcFgau7MiJphFjgUdAtd/H9xfgE4odMRPUD3q9Me9LlMYK6MiKpfm4c2+3dzcCQQC8y37NPgpNEkd9smMwPpSEjPW41aMlfcKvP4Da3z7G5bGlmuICrva9YDAiaAyDGGCK8LxC8K6HpKrFgYrXkRtt&quot;]);\n\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end\n</code></pre>\n<p>运行后, 输出信息如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/1803339-4a11ca319806c3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图5\"><br>至此, RSA加密演示完毕!</p>\n"},{"title":"指针与数组","date":"2017-06-23T13:56:59.000Z","_content":"#### 指针\n\n指针在 C 语言中是一种类型，就和其他基本数据类型一样。通常在32位机器上面占四个字节，在64位机器上占八个字节。指针用来保存其他变量的地址，请看下面整型指针与整型变量的对比：\n\n```objectivec\nint main()\n{\n    int a = 4;      //定义整型变量 a\n    int b = 10;     //定义整形变量 b\n    int *p = &b;    //定义整型指针 p ，保存变量 b 的地址\n\n    //a 变量和 p 变量的值\n    printf(\"a 变量的值为: %d\\n\", a);\n    printf(\"p 变量的值为: %p\\n\", p);\n\n    //指针变量的特殊操作\n    printf(\"指针所指向变量的值: %d\\n\", *p);\n    *p = 15;\n    printf(\"指针所指向变量的值: %d\\n\", *p);\n    printf(\"b 变量的值为: %d\\n\", b);\n    return 0;\n}\n```\n\n#### 解释：\n在上面的程序中，定义了整型变量 a、整型变量 b 和 整型变量p，让指针变量 p 保存变量 b 的内存地址，也就是说 p 指针\"指向\"变量 b 。程序接着打印 a 变量的值和p 变量的值，分别代表整型变量 a 保存的整数值和指针变量 p 保存的变量 b 的地址值(%p表示用十六进制数字表示地址值)。指针还有特殊的操作：`*操作`，通过`*操作`可以访问指针所指向的变量，在程序中也就是说 `*p` 与变量 b 是等价的，操作变量 `*p` 就是操作变量 b。\n\n| 类型        | 变量           | 值  |特殊操作  |\n| ------------- |:-------------:| -----:|-----:|\n| int      | a | a (使用 %d 打印) |无|\n| int *      | p      |  p (使用 %p 打印) |*p (代表指向的变量) |\n\n#### 数组\n\n数组是一种特殊的数据类型，它把具有相同类型的若干变量按照有序的顺序组织起来，极大的方便了我们的开发。数组名代表数组的首地址，即数组第一个元素的地址，通过下标 `[]`来访问数组里面的元素。\n\n```objectivec\nint main() \n{\n    int a[5] = {1, 2, 3, 4, 5};\n    printf(\"%d\\n\", a[0]);\n    return 0;\n}\n```\n\n上面代码中的 `a[0]` 代表数组中的第一个元素，输出的结果为1;\n\n#### 数组和指针的联系\n\n其实数组的下标 `[]` 操作也是一种特殊操作，与指针的 `*` 操作十分相似。数组名是一个指针：指针常量。它无法改变指向，只能指向数组的首地址，所以a++、a--之类的操作都是错误的(a是数组名)。既然数组名是一个指针，可以使用下标`[]` 操作，那么普通的指针变量是不是也可以使用呢？反过来，普通指针的 `*` 操作是不是也适合数组呢？\n\n```objectivec\nint main()\n{\n    int a[4] = {5, 6, 7, 8};\n    int *p = a;\n    int i;\n    printf(\"输出数组里面的内容：\\n\");\n    for(i = 0; i < 4; i++)\n        printf(\"a[%d] = %d\\t\", i, a[i]);\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"p[%d] = %d\\t\", i, p[i]);\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"*(a+%d)=%d\\t\", i, *(a+i));\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"*(p+%d)=%d\\t\", i, *(p+i));\n    printf(\"\\n\");\n    return 0;\n}\n\n```\n\n运行结果：\n![](http://upload-images.jianshu.io/upload_images/2115041-6d0da66b1f5930d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)运行结果\n\n从结果可以看出，`[]`和 `*` 操作都适用于指针变量，数组也是通过操作指针来实现对元素的查询、修改操作。让我们再深入一点，数组是如何通过下标操作找到对应的元素的呢？\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *p = a;\n    printf(\"%d\\n\", p[2]);\n    printf(\"%d\\n\", *(p+2));\n\n    p = &a[2];\n    printf(\"%d\\n\", p[0]);\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n```\n\n运行一下代码发现，输出的数据都是3，也就是数组中的第三个元素。怎么会这样？\n\n#### 解释：\n程序中当指针 p 指向数组的第三个元素的时候，这时候 `p[0]` 输出的是3，也就是`a[2]` 的值，那么 `p[0]` 的操作结果与 `*p` 的操作结果一致；另外，大家试一试\n输出 `p[1]` 的值，不出所料操作结果应与 `*(p+1)` 的操作结果一致。发现规律没？`[]` 操作其实就是 `*` 操作啊！！！发现新大陆了啊，有没有？\n\n让我们冷静的分析一下： `[]` 操作和 `*` 操作实际上都是偏移操作(内存地址偏移)，通过当前指针指向的内存地址以及常量来进行地址偏移，最后通过指针的类型解析所指向地址的内容。\n\n那么偏移的单位是多少？这个与指针或者数组的类型有关，比如 `int *` 类型的指针一次偏移 `sizeof(int)` 的地址，`double *` 类型的指针一次偏移 `sizeof(double)` 的地址。\n\n#### 指针访问数组的方式\n\n使用 `[]` 访问。例如 `int a;int *p = a`;用 p 表示输出 `a[2]` 的值：p[2] ；如果是这样`int a[5]; int *p = &a[2]`;用 p 表示输出`a[3]` 的值：`p[1]`。\n\n使用 `*` 访问。例如`int a[5]; int *p = a`;用 p 表示输出`a[2]` 的值：`*(p+2)`；如果是这样：`int a[5]; int *p = &a[2]`;用 p 表示输出 a[3] 的值：`*(p+1)`。\n\n#### 思考\n\n第一题：\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n\n    p = &a[2];\n    printf(\"%d\\n\", p[-2]);\n    printf(\"%d\\n\", *(p-2));\n    return 0;\n}\n```\n\n第二题：\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *ptr = (int *)(&a + 1);\n    printf(\"%d %d\\n\", *(a+1), *(ptr-1));\n    return 0;\n}\n```\n第二题注意指针的类型变化哦，自己编写运行一下，看结果与自己想的一样吗？\nps: 竟然还能 `p[-2]`，坑爹有没有...\n\n#### 总结\n\n- 指针和数组都可以使用下标或者 `*` 操作。\n- 下标操作或者` * `操作的本质都是地址偏移，通过指针的类型来解析内存地址里面存储的数据。\n- `void *` 指针可以指向任何地址，但是无法使用` *` 操作，原因就是编译器不知道如何解析`void *` 指针所指向的内存地址的内容。\n\n\n","source":"_posts/指针与数组.md","raw":"---\ntitle: 指针与数组\ndate: 2017-06-23 21:56:59\ncategories: \n\t- 知识簿\n---\n#### 指针\n\n指针在 C 语言中是一种类型，就和其他基本数据类型一样。通常在32位机器上面占四个字节，在64位机器上占八个字节。指针用来保存其他变量的地址，请看下面整型指针与整型变量的对比：\n\n```objectivec\nint main()\n{\n    int a = 4;      //定义整型变量 a\n    int b = 10;     //定义整形变量 b\n    int *p = &b;    //定义整型指针 p ，保存变量 b 的地址\n\n    //a 变量和 p 变量的值\n    printf(\"a 变量的值为: %d\\n\", a);\n    printf(\"p 变量的值为: %p\\n\", p);\n\n    //指针变量的特殊操作\n    printf(\"指针所指向变量的值: %d\\n\", *p);\n    *p = 15;\n    printf(\"指针所指向变量的值: %d\\n\", *p);\n    printf(\"b 变量的值为: %d\\n\", b);\n    return 0;\n}\n```\n\n#### 解释：\n在上面的程序中，定义了整型变量 a、整型变量 b 和 整型变量p，让指针变量 p 保存变量 b 的内存地址，也就是说 p 指针\"指向\"变量 b 。程序接着打印 a 变量的值和p 变量的值，分别代表整型变量 a 保存的整数值和指针变量 p 保存的变量 b 的地址值(%p表示用十六进制数字表示地址值)。指针还有特殊的操作：`*操作`，通过`*操作`可以访问指针所指向的变量，在程序中也就是说 `*p` 与变量 b 是等价的，操作变量 `*p` 就是操作变量 b。\n\n| 类型        | 变量           | 值  |特殊操作  |\n| ------------- |:-------------:| -----:|-----:|\n| int      | a | a (使用 %d 打印) |无|\n| int *      | p      |  p (使用 %p 打印) |*p (代表指向的变量) |\n\n#### 数组\n\n数组是一种特殊的数据类型，它把具有相同类型的若干变量按照有序的顺序组织起来，极大的方便了我们的开发。数组名代表数组的首地址，即数组第一个元素的地址，通过下标 `[]`来访问数组里面的元素。\n\n```objectivec\nint main() \n{\n    int a[5] = {1, 2, 3, 4, 5};\n    printf(\"%d\\n\", a[0]);\n    return 0;\n}\n```\n\n上面代码中的 `a[0]` 代表数组中的第一个元素，输出的结果为1;\n\n#### 数组和指针的联系\n\n其实数组的下标 `[]` 操作也是一种特殊操作，与指针的 `*` 操作十分相似。数组名是一个指针：指针常量。它无法改变指向，只能指向数组的首地址，所以a++、a--之类的操作都是错误的(a是数组名)。既然数组名是一个指针，可以使用下标`[]` 操作，那么普通的指针变量是不是也可以使用呢？反过来，普通指针的 `*` 操作是不是也适合数组呢？\n\n```objectivec\nint main()\n{\n    int a[4] = {5, 6, 7, 8};\n    int *p = a;\n    int i;\n    printf(\"输出数组里面的内容：\\n\");\n    for(i = 0; i < 4; i++)\n        printf(\"a[%d] = %d\\t\", i, a[i]);\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"p[%d] = %d\\t\", i, p[i]);\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"*(a+%d)=%d\\t\", i, *(a+i));\n    printf(\"\\n\");\n\n    for(i = 0; i < 4; i++)\n        printf(\"*(p+%d)=%d\\t\", i, *(p+i));\n    printf(\"\\n\");\n    return 0;\n}\n\n```\n\n运行结果：\n![](http://upload-images.jianshu.io/upload_images/2115041-6d0da66b1f5930d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)运行结果\n\n从结果可以看出，`[]`和 `*` 操作都适用于指针变量，数组也是通过操作指针来实现对元素的查询、修改操作。让我们再深入一点，数组是如何通过下标操作找到对应的元素的呢？\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *p = a;\n    printf(\"%d\\n\", p[2]);\n    printf(\"%d\\n\", *(p+2));\n\n    p = &a[2];\n    printf(\"%d\\n\", p[0]);\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n```\n\n运行一下代码发现，输出的数据都是3，也就是数组中的第三个元素。怎么会这样？\n\n#### 解释：\n程序中当指针 p 指向数组的第三个元素的时候，这时候 `p[0]` 输出的是3，也就是`a[2]` 的值，那么 `p[0]` 的操作结果与 `*p` 的操作结果一致；另外，大家试一试\n输出 `p[1]` 的值，不出所料操作结果应与 `*(p+1)` 的操作结果一致。发现规律没？`[]` 操作其实就是 `*` 操作啊！！！发现新大陆了啊，有没有？\n\n让我们冷静的分析一下： `[]` 操作和 `*` 操作实际上都是偏移操作(内存地址偏移)，通过当前指针指向的内存地址以及常量来进行地址偏移，最后通过指针的类型解析所指向地址的内容。\n\n那么偏移的单位是多少？这个与指针或者数组的类型有关，比如 `int *` 类型的指针一次偏移 `sizeof(int)` 的地址，`double *` 类型的指针一次偏移 `sizeof(double)` 的地址。\n\n#### 指针访问数组的方式\n\n使用 `[]` 访问。例如 `int a;int *p = a`;用 p 表示输出 `a[2]` 的值：p[2] ；如果是这样`int a[5]; int *p = &a[2]`;用 p 表示输出`a[3]` 的值：`p[1]`。\n\n使用 `*` 访问。例如`int a[5]; int *p = a`;用 p 表示输出`a[2]` 的值：`*(p+2)`；如果是这样：`int a[5]; int *p = &a[2]`;用 p 表示输出 a[3] 的值：`*(p+1)`。\n\n#### 思考\n\n第一题：\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n\n    p = &a[2];\n    printf(\"%d\\n\", p[-2]);\n    printf(\"%d\\n\", *(p-2));\n    return 0;\n}\n```\n\n第二题：\n\n```objectivec\nint main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *ptr = (int *)(&a + 1);\n    printf(\"%d %d\\n\", *(a+1), *(ptr-1));\n    return 0;\n}\n```\n第二题注意指针的类型变化哦，自己编写运行一下，看结果与自己想的一样吗？\nps: 竟然还能 `p[-2]`，坑爹有没有...\n\n#### 总结\n\n- 指针和数组都可以使用下标或者 `*` 操作。\n- 下标操作或者` * `操作的本质都是地址偏移，通过指针的类型来解析内存地址里面存储的数据。\n- `void *` 指针可以指向任何地址，但是无法使用` *` 操作，原因就是编译器不知道如何解析`void *` 指针所指向的内存地址的内容。\n\n\n","slug":"指针与数组","published":1,"updated":"2017-06-23T14:17:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twd001fznuz607fa37x","content":"<h4 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h4><p>指针在 C 语言中是一种类型，就和其他基本数据类型一样。通常在32位机器上面占四个字节，在64位机器上占八个字节。指针用来保存其他变量的地址，请看下面整型指针与整型变量的对比：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">//定义整型变量 a</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">//定义整形变量 b</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//定义整型指针 p ，保存变量 b 的地址</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//a 变量和 p 变量的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a 变量的值为: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p 变量的值为: %p\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//指针变量的特殊操作</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"指针所指向变量的值: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"指针所指向变量的值: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b 变量的值为: %d\\n\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h4><p>在上面的程序中，定义了整型变量 a、整型变量 b 和 整型变量p，让指针变量 p 保存变量 b 的内存地址，也就是说 p 指针”指向”变量 b 。程序接着打印 a 变量的值和p 变量的值，分别代表整型变量 a 保存的整数值和指针变量 p 保存的变量 b 的地址值(%p表示用十六进制数字表示地址值)。指针还有特殊的操作：<code>*操作</code>，通过<code>*操作</code>可以访问指针所指向的变量，在程序中也就是说 <code>*p</code> 与变量 b 是等价的，操作变量 <code>*p</code> 就是操作变量 b。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:right\">值</th>\n<th style=\"text-align:right\">特殊操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:right\">a (使用 %d 打印)</td>\n<td style=\"text-align:right\">无</td>\n</tr>\n<tr>\n<td>int *</td>\n<td style=\"text-align:center\">p</td>\n<td style=\"text-align:right\">p (使用 %p 打印)</td>\n<td style=\"text-align:right\">*p (代表指向的变量)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组是一种特殊的数据类型，它把具有相同类型的若干变量按照有序的顺序组织起来，极大的方便了我们的开发。数组名代表数组的首地址，即数组第一个元素的地址，通过下标 <code>[]</code>来访问数组里面的元素。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面代码中的 <code>a[0]</code> 代表数组中的第一个元素，输出的结果为1;</p>\n<h4 id=\"数组和指针的联系\"><a href=\"#数组和指针的联系\" class=\"headerlink\" title=\"数组和指针的联系\"></a>数组和指针的联系</h4><p>其实数组的下标 <code>[]</code> 操作也是一种特殊操作，与指针的 <code>*</code> 操作十分相似。数组名是一个指针：指针常量。它无法改变指向，只能指向数组的首地址，所以a++、a–之类的操作都是错误的(a是数组名)。既然数组名是一个指针，可以使用下标<code>[]</code> 操作，那么普通的指针变量是不是也可以使用呢？反过来，普通指针的 <code>*</code> 操作是不是也适合数组呢？</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"输出数组里面的内容：\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a[%d] = %d\\t\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p[%d] = %d\\t\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*(a+%d)=%d\\t\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*(p+%d)=%d\\t\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>运行结果：<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6d0da66b1f5930d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">运行结果</p>\n<p>从结果可以看出，<code>[]</code>和 <code>*</code> 操作都适用于指针变量，数组也是通过操作指针来实现对元素的查询、修改操作。让我们再深入一点，数组是如何通过下标操作找到对应的元素的呢？</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>运行一下代码发现，输出的数据都是3，也就是数组中的第三个元素。怎么会这样？</p>\n<h4 id=\"解释：-1\"><a href=\"#解释：-1\" class=\"headerlink\" title=\"解释：\"></a>解释：</h4><p>程序中当指针 p 指向数组的第三个元素的时候，这时候 <code>p[0]</code> 输出的是3，也就是<code>a[2]</code> 的值，那么 <code>p[0]</code> 的操作结果与 <code>*p</code> 的操作结果一致；另外，大家试一试<br>输出 <code>p[1]</code> 的值，不出所料操作结果应与 <code>*(p+1)</code> 的操作结果一致。发现规律没？<code>[]</code> 操作其实就是 <code>*</code> 操作啊！！！发现新大陆了啊，有没有？</p>\n<p>让我们冷静的分析一下： <code>[]</code> 操作和 <code>*</code> 操作实际上都是偏移操作(内存地址偏移)，通过当前指针指向的内存地址以及常量来进行地址偏移，最后通过指针的类型解析所指向地址的内容。</p>\n<p>那么偏移的单位是多少？这个与指针或者数组的类型有关，比如 <code>int *</code> 类型的指针一次偏移 <code>sizeof(int)</code> 的地址，<code>double *</code> 类型的指针一次偏移 <code>sizeof(double)</code> 的地址。</p>\n<h4 id=\"指针访问数组的方式\"><a href=\"#指针访问数组的方式\" class=\"headerlink\" title=\"指针访问数组的方式\"></a>指针访问数组的方式</h4><p>使用 <code>[]</code> 访问。例如 <code>int a;int *p = a</code>;用 p 表示输出 <code>a[2]</code> 的值：p[2] ；如果是这样<code>int a[5]; int *p = &amp;a[2]</code>;用 p 表示输出<code>a[3]</code> 的值：<code>p[1]</code>。</p>\n<p>使用 <code>*</code> 访问。例如<code>int a[5]; int *p = a</code>;用 p 表示输出<code>a[2]</code> 的值：<code>*(p+2)</code>；如果是这样：<code>int a[5]; int *p = &amp;a[2]</code>;用 p 表示输出 a[3] 的值：<code>*(p+1)</code>。</p>\n<h4 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h4><p>第一题：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>p<span class=\"token number\">-2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第二题：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>第二题注意指针的类型变化哦，自己编写运行一下，看结果与自己想的一样吗？<br>ps: 竟然还能 <code>p[-2]</code>，坑爹有没有…</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>指针和数组都可以使用下标或者 <code>*</code> 操作。</li>\n<li>下标操作或者<code>*</code>操作的本质都是地址偏移，通过指针的类型来解析内存地址里面存储的数据。</li>\n<li><code>void *</code> 指针可以指向任何地址，但是无法使用<code>*</code> 操作，原因就是编译器不知道如何解析<code>void *</code> 指针所指向的内存地址的内容。</li>\n</ul>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h4><p>指针在 C 语言中是一种类型，就和其他基本数据类型一样。通常在32位机器上面占四个字节，在64位机器上占八个字节。指针用来保存其他变量的地址，请看下面整型指针与整型变量的对比：</p>\n<pre><code class=\"objectivec\">int main()\n{\n    int a = 4;      //定义整型变量 a\n    int b = 10;     //定义整形变量 b\n    int *p = &amp;b;    //定义整型指针 p ，保存变量 b 的地址\n\n    //a 变量和 p 变量的值\n    printf(&quot;a 变量的值为: %d\\n&quot;, a);\n    printf(&quot;p 变量的值为: %p\\n&quot;, p);\n\n    //指针变量的特殊操作\n    printf(&quot;指针所指向变量的值: %d\\n&quot;, *p);\n    *p = 15;\n    printf(&quot;指针所指向变量的值: %d\\n&quot;, *p);\n    printf(&quot;b 变量的值为: %d\\n&quot;, b);\n    return 0;\n}\n</code></pre>\n<h4 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h4><p>在上面的程序中，定义了整型变量 a、整型变量 b 和 整型变量p，让指针变量 p 保存变量 b 的内存地址，也就是说 p 指针”指向”变量 b 。程序接着打印 a 变量的值和p 变量的值，分别代表整型变量 a 保存的整数值和指针变量 p 保存的变量 b 的地址值(%p表示用十六进制数字表示地址值)。指针还有特殊的操作：<code>*操作</code>，通过<code>*操作</code>可以访问指针所指向的变量，在程序中也就是说 <code>*p</code> 与变量 b 是等价的，操作变量 <code>*p</code> 就是操作变量 b。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">变量</th>\n<th style=\"text-align:right\">值</th>\n<th style=\"text-align:right\">特殊操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:right\">a (使用 %d 打印)</td>\n<td style=\"text-align:right\">无</td>\n</tr>\n<tr>\n<td>int *</td>\n<td style=\"text-align:center\">p</td>\n<td style=\"text-align:right\">p (使用 %p 打印)</td>\n<td style=\"text-align:right\">*p (代表指向的变量)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组是一种特殊的数据类型，它把具有相同类型的若干变量按照有序的顺序组织起来，极大的方便了我们的开发。数组名代表数组的首地址，即数组第一个元素的地址，通过下标 <code>[]</code>来访问数组里面的元素。</p>\n<pre><code class=\"objectivec\">int main() \n{\n    int a[5] = {1, 2, 3, 4, 5};\n    printf(&quot;%d\\n&quot;, a[0]);\n    return 0;\n}\n</code></pre>\n<p>上面代码中的 <code>a[0]</code> 代表数组中的第一个元素，输出的结果为1;</p>\n<h4 id=\"数组和指针的联系\"><a href=\"#数组和指针的联系\" class=\"headerlink\" title=\"数组和指针的联系\"></a>数组和指针的联系</h4><p>其实数组的下标 <code>[]</code> 操作也是一种特殊操作，与指针的 <code>*</code> 操作十分相似。数组名是一个指针：指针常量。它无法改变指向，只能指向数组的首地址，所以a++、a–之类的操作都是错误的(a是数组名)。既然数组名是一个指针，可以使用下标<code>[]</code> 操作，那么普通的指针变量是不是也可以使用呢？反过来，普通指针的 <code>*</code> 操作是不是也适合数组呢？</p>\n<pre><code class=\"objectivec\">int main()\n{\n    int a[4] = {5, 6, 7, 8};\n    int *p = a;\n    int i;\n    printf(&quot;输出数组里面的内容：\\n&quot;);\n    for(i = 0; i &lt; 4; i++)\n        printf(&quot;a[%d] = %d\\t&quot;, i, a[i]);\n    printf(&quot;\\n&quot;);\n\n    for(i = 0; i &lt; 4; i++)\n        printf(&quot;p[%d] = %d\\t&quot;, i, p[i]);\n    printf(&quot;\\n&quot;);\n\n    for(i = 0; i &lt; 4; i++)\n        printf(&quot;*(a+%d)=%d\\t&quot;, i, *(a+i));\n    printf(&quot;\\n&quot;);\n\n    for(i = 0; i &lt; 4; i++)\n        printf(&quot;*(p+%d)=%d\\t&quot;, i, *(p+i));\n    printf(&quot;\\n&quot;);\n    return 0;\n}\n</code></pre>\n<p>运行结果：<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6d0da66b1f5930d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\">运行结果</p>\n<p>从结果可以看出，<code>[]</code>和 <code>*</code> 操作都适用于指针变量，数组也是通过操作指针来实现对元素的查询、修改操作。让我们再深入一点，数组是如何通过下标操作找到对应的元素的呢？</p>\n<pre><code class=\"objectivec\">int main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *p = a;\n    printf(&quot;%d\\n&quot;, p[2]);\n    printf(&quot;%d\\n&quot;, *(p+2));\n\n    p = &amp;a[2];\n    printf(&quot;%d\\n&quot;, p[0]);\n    printf(&quot;%d\\n&quot;, *p);\n    return 0;\n}\n</code></pre>\n<p>运行一下代码发现，输出的数据都是3，也就是数组中的第三个元素。怎么会这样？</p>\n<h4 id=\"解释：-1\"><a href=\"#解释：-1\" class=\"headerlink\" title=\"解释：\"></a>解释：</h4><p>程序中当指针 p 指向数组的第三个元素的时候，这时候 <code>p[0]</code> 输出的是3，也就是<code>a[2]</code> 的值，那么 <code>p[0]</code> 的操作结果与 <code>*p</code> 的操作结果一致；另外，大家试一试<br>输出 <code>p[1]</code> 的值，不出所料操作结果应与 <code>*(p+1)</code> 的操作结果一致。发现规律没？<code>[]</code> 操作其实就是 <code>*</code> 操作啊！！！发现新大陆了啊，有没有？</p>\n<p>让我们冷静的分析一下： <code>[]</code> 操作和 <code>*</code> 操作实际上都是偏移操作(内存地址偏移)，通过当前指针指向的内存地址以及常量来进行地址偏移，最后通过指针的类型解析所指向地址的内容。</p>\n<p>那么偏移的单位是多少？这个与指针或者数组的类型有关，比如 <code>int *</code> 类型的指针一次偏移 <code>sizeof(int)</code> 的地址，<code>double *</code> 类型的指针一次偏移 <code>sizeof(double)</code> 的地址。</p>\n<h4 id=\"指针访问数组的方式\"><a href=\"#指针访问数组的方式\" class=\"headerlink\" title=\"指针访问数组的方式\"></a>指针访问数组的方式</h4><p>使用 <code>[]</code> 访问。例如 <code>int a;int *p = a</code>;用 p 表示输出 <code>a[2]</code> 的值：p[2] ；如果是这样<code>int a[5]; int *p = &amp;a[2]</code>;用 p 表示输出<code>a[3]</code> 的值：<code>p[1]</code>。</p>\n<p>使用 <code>*</code> 访问。例如<code>int a[5]; int *p = a</code>;用 p 表示输出<code>a[2]</code> 的值：<code>*(p+2)</code>；如果是这样：<code>int a[5]; int *p = &amp;a[2]</code>;用 p 表示输出 a[3] 的值：<code>*(p+1)</code>。</p>\n<h4 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h4><p>第一题：</p>\n<pre><code class=\"objectivec\">int main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n\n    p = &amp;a[2];\n    printf(&quot;%d\\n&quot;, p[-2]);\n    printf(&quot;%d\\n&quot;, *(p-2));\n    return 0;\n}\n</code></pre>\n<p>第二题：</p>\n<pre><code class=\"objectivec\">int main()\n{\n    int a[5] = {1, 2, 3, 4, 5};\n    int *ptr = (int *)(&amp;a + 1);\n    printf(&quot;%d %d\\n&quot;, *(a+1), *(ptr-1));\n    return 0;\n}\n</code></pre>\n<p>第二题注意指针的类型变化哦，自己编写运行一下，看结果与自己想的一样吗？<br>ps: 竟然还能 <code>p[-2]</code>，坑爹有没有…</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>指针和数组都可以使用下标或者 <code>*</code> 操作。</li>\n<li>下标操作或者<code>*</code>操作的本质都是地址偏移，通过指针的类型来解析内存地址里面存储的数据。</li>\n<li><code>void *</code> 指针可以指向任何地址，但是无法使用<code>*</code> 操作，原因就是编译器不知道如何解析<code>void *</code> 指针所指向的内存地址的内容。</li>\n</ul>\n"},{"title":"排序算法","date":"2017-06-15T15:26:06.000Z","_content":"####  1 、 选择排序算法\n插入排序的理解： 首先,找到数组中最小的那个元素 ,其次,将它和数组的第一个元素位置 (如果第一个元 就是最小元 那么它就和自己 )。再次,在剩下的元素中找到最小的元素, 将它与数组的第二个元素交换位置。如此反复, 到将整个数组排序。这种方法叫做做选择排序,因为它在不断地选择剩余元素之中的最小者。\n解析：对于长度为 N 的数组,选择排序需要大约 N^2/2 次比较和 N 次交换。\n\n#### 图解：\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png)\n\n#### 声明：\n\n```objectivec\n NSMutableArray *selectSort(NSMutableArray *array, int start)\n```\n\n#### 实现：\n\n```objectivec\nNSMutableArray *selectSort(NSMutableArray *array, int start) {\n\n    if (start == array.count ) {\n        return array;\n    }\n\n    int minNum = [array[start] intValue];\n    int minIndex = start;\n    for (int i = start ; i < array.count; i ++) {\n        if (minNum > [array[i] intValue]) {\n            minNum = [array[i] intValue];\n            minIndex = i;\n        }\n    }\n\n    [array exchangeObjectAtIndex:start withObjectAtIndex:minIndex];\n    array = selectSort(array, start + 1);\n    return array;\n}\n```\n\n#### 调用：\n\n```objectivec\n    NSArray *array = @[@(1), @(4), @(8), @(9), @(5), @(7), @(2)];\n    array = selectSort([array mutableCopy], 0);\n```\n\n#### 输出过程：\n\n```objectivec\n第一次：1, 4, 8, 9, 5, 7, 2\n第二次：1, 2, 8, 9, 5, 7, 4\n第三次：1, 2, 4, 9, 5, 7, 8\n第四次：1, 2, 4, 5, 9, 7, 8\n第五次：1, 2, 4, 5, 7, 9, 8\n最后输出： 1, 2, 4, 5, 7, 8, 9\n```\n\n- 选择排序优势：稳定，它的比较次数基本上不会改变，数据移动比较少。\n\n- 选择排序劣势：操作级别了指数级，不会因是否有序数组而改变排序时间，时间只会与数组长度有关系。\n\n\n#### 2、插入排序\n插入排序的理解：由数组的第2个位置开始比较，若果前方位置的元素比较大，则交换位置，若自己元素较大，而继续下一个元素，如此排列，那么被操作的那个元素前方位置的所有元素皆为有序。\n解析：对于随机排列的长度为 N 且主键不重复的数组,平均情况下插入排序需要~ N^2/4 次比较以及~ N^2/4 次交换。最坏情况下需要~ N^2/2 次比较和~ N^2/2 次交换,最好情况下需要 N-1次比较和 0 次交换。\n插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再减一。\n\n#### 图解：\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png)\n\n\n#### 声明：\n\n```objectivec\nNSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start)\n```\n\n#### 实现：\n\n```objectivec\nNSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start) {\n\n    if (start == mArray.count) {\n        return mArray;\n    }\n\n    for (NSInteger i = start; i > 0; i --) {\n        if (mArray[i] < mArray[i-1]) {\n            int temp = [mArray[i] intValue];\n            int k =  (int)(i - 1);\n\n            while (k >= 0 && [mArray[k] intValue] > temp) {\n                mArray[k + 1] = mArray[k];\n                k -= 1;\n            }\n            mArray[k+1] = @(temp);\n        }\n    }\n\n    InsetSort(mArray, start + 1);\n\n    return mArray;\n}\n```\n\n#### 调用：\n\n```objectivec\nNSMutableArray *mArray = [@[@(49),   @(38),   @(65),   @(97),   @(26),   @(13),   @(27),   @(49),   @(55),   @(4)] mutableCopy];\nmArray = InsetSort(mArray, 1);\n```\n\n#### 输出过程：\n\n```objectivec\n第一次：38，49，65，97，26，13，27，49，55，4\n第二次：38，49，65，97，26，13，27，49，55，4\n第三次：38，49，65，97，26，13，27，49，55，4\n第四次：26，38，49，65，97，13，27，49，55，4\n第五次：13，26，38，49，65，97，27，49，55，4\n第六次：13，26，27，38，49，65，97，49，55，4\n第七次：13，26，27，38，49，49，65，97，55，4\n第八次：13，26，27，38，49，49，55，65，97，4\n最后输出：4， 13， 26， 27， 38， 49，49， 55， 65， 97\n```\n\n- 插入排序优势：对于有序数组或部分有序数组，此排序方法是十分高效的，很适合小规模的数组，很多高级的排序算法都会利用到插入排序。\n\n- 插入排序劣势：若果最少的元素都在最后部分的位置，那么该排序方法就会变得非常费劲了，最后的元素都要比较改元素位置减一次。\n\n#### 3、希尔排序\n希尔排序为什么产生：希尔排序是以插入排序为基础的一种快速的排序算法。因为在大规模乱序数组中使用插入排序很慢，因为它只会交换相邻的两个元素，因此，如果越小的元素越是靠后，那么操作的复杂度将会大大提升，所以，人们把插入排序进行了改良，变成了希尔排序。\n希尔排序的思想：希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组为 h 有序数组。换句话说,一个 h 有序数组就是 h 个互相独 的有序数组编织在一起 成的一个数组。在进行排序时,如果 h 很大,我们就能将元素动到很远的地方,为实现更小的 h 有序创造方便。用这种方式,对于任意以 1 结尾的 h 序列,我们都能够将数组排序。这就是希尔排序。\n\n#### 图解：\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png)\n\n最后一个算法，用的C语言。\n\n#### 声明：\n\n```objectivec\n\n    void ShellSort(Array array)\nvoid exchange(Array array, int N, int M) {\n    int temp = array->a[N];\n    array->a[N] = array->a[M];\n    array->a[M] = temp;\n}\n\nstruct ArrayNode {\n    int a[kMaxLimit];\n    int count;\n};\n\nvoid pushNumInArray(Array array, int Num) {\n    if (array->count > 10) {\n        printf(\"数组越界了\");\n        return;\n    }\n\n    array->a[array->count] = Num;\n    array->count += 1;\n}\n\nvoid ShellSort(Array array) {\n    for (int gap = array->count / 2; gap > 0; gap/=2) {\n        for (int i = 0; i < gap; i ++) {\n\n            if (array->a[i + gap] < array->a[i]) {\n                for (int j = i + gap; j < array->count; j += gap) {\n                    if (array->a[j] < array->a[j - gap]) {\n                        // 交换\n                        exchange(array, j, j-gap);\n                    }\n                }\n            }\n\n        }\n    }\n}\n```\n\n\n#### 调用:\n\n```objectivec\n   Array array = malloc(sizeof(struct ArrayNode));\n   array->count = 0;\n\nfor (int i = 0; i < 10; i ++) {\n    pushNumInArray(array, arc4random() % 100);\n }\n\n  // 希尔排序\n  ShellSort(array);\n\n  for (int i = 0; i < array->count; i ++) {\n     printf(\"%d\\n\",array->a[i]);\n }\n```\n\n\n#### 输出过程：\n\n```objectivec\n原数组: 49   38   65   97   26   13   27   49   55   4\n第一次输出：gap = 5 / 2 = 2，数组为： 13   27   49   55   4    49   38   65   97   26\n第二次输出：gap = 2 / 2 = 1，数组为：4   26   13   27   38    49   49   55   97   65\n第三次输出：gap = 1 / 2 = 0，数组为：4   13   26   27   38    49   49   55   65   97\n```\n\n\n- 希尔排序优势：希尔排序优化了插入排序，在性能上比选择排序和插入排序快得多，而这种优势会随着数组越大变得越为明显。而且算法代码短简单，非常容易实现，所以我们基本上所有排序工作一开始都是用希尔排序，若在实际中不够快，我们再改成快速排序等更为高级的算法。\n\n- 希尔排序劣势： 排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。\n\n\n\n","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法\ndate: 2017-06-15 23:26:06\ncategories: \n\t- 知识簿\n---\n####  1 、 选择排序算法\n插入排序的理解： 首先,找到数组中最小的那个元素 ,其次,将它和数组的第一个元素位置 (如果第一个元 就是最小元 那么它就和自己 )。再次,在剩下的元素中找到最小的元素, 将它与数组的第二个元素交换位置。如此反复, 到将整个数组排序。这种方法叫做做选择排序,因为它在不断地选择剩余元素之中的最小者。\n解析：对于长度为 N 的数组,选择排序需要大约 N^2/2 次比较和 N 次交换。\n\n#### 图解：\n![图一](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png)\n\n#### 声明：\n\n```objectivec\n NSMutableArray *selectSort(NSMutableArray *array, int start)\n```\n\n#### 实现：\n\n```objectivec\nNSMutableArray *selectSort(NSMutableArray *array, int start) {\n\n    if (start == array.count ) {\n        return array;\n    }\n\n    int minNum = [array[start] intValue];\n    int minIndex = start;\n    for (int i = start ; i < array.count; i ++) {\n        if (minNum > [array[i] intValue]) {\n            minNum = [array[i] intValue];\n            minIndex = i;\n        }\n    }\n\n    [array exchangeObjectAtIndex:start withObjectAtIndex:minIndex];\n    array = selectSort(array, start + 1);\n    return array;\n}\n```\n\n#### 调用：\n\n```objectivec\n    NSArray *array = @[@(1), @(4), @(8), @(9), @(5), @(7), @(2)];\n    array = selectSort([array mutableCopy], 0);\n```\n\n#### 输出过程：\n\n```objectivec\n第一次：1, 4, 8, 9, 5, 7, 2\n第二次：1, 2, 8, 9, 5, 7, 4\n第三次：1, 2, 4, 9, 5, 7, 8\n第四次：1, 2, 4, 5, 9, 7, 8\n第五次：1, 2, 4, 5, 7, 9, 8\n最后输出： 1, 2, 4, 5, 7, 8, 9\n```\n\n- 选择排序优势：稳定，它的比较次数基本上不会改变，数据移动比较少。\n\n- 选择排序劣势：操作级别了指数级，不会因是否有序数组而改变排序时间，时间只会与数组长度有关系。\n\n\n#### 2、插入排序\n插入排序的理解：由数组的第2个位置开始比较，若果前方位置的元素比较大，则交换位置，若自己元素较大，而继续下一个元素，如此排列，那么被操作的那个元素前方位置的所有元素皆为有序。\n解析：对于随机排列的长度为 N 且主键不重复的数组,平均情况下插入排序需要~ N^2/4 次比较以及~ N^2/4 次交换。最坏情况下需要~ N^2/2 次比较和~ N^2/2 次交换,最好情况下需要 N-1次比较和 0 次交换。\n插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再减一。\n\n#### 图解：\n\n![图二](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png)\n\n\n#### 声明：\n\n```objectivec\nNSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start)\n```\n\n#### 实现：\n\n```objectivec\nNSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start) {\n\n    if (start == mArray.count) {\n        return mArray;\n    }\n\n    for (NSInteger i = start; i > 0; i --) {\n        if (mArray[i] < mArray[i-1]) {\n            int temp = [mArray[i] intValue];\n            int k =  (int)(i - 1);\n\n            while (k >= 0 && [mArray[k] intValue] > temp) {\n                mArray[k + 1] = mArray[k];\n                k -= 1;\n            }\n            mArray[k+1] = @(temp);\n        }\n    }\n\n    InsetSort(mArray, start + 1);\n\n    return mArray;\n}\n```\n\n#### 调用：\n\n```objectivec\nNSMutableArray *mArray = [@[@(49),   @(38),   @(65),   @(97),   @(26),   @(13),   @(27),   @(49),   @(55),   @(4)] mutableCopy];\nmArray = InsetSort(mArray, 1);\n```\n\n#### 输出过程：\n\n```objectivec\n第一次：38，49，65，97，26，13，27，49，55，4\n第二次：38，49，65，97，26，13，27，49，55，4\n第三次：38，49，65，97，26，13，27，49，55，4\n第四次：26，38，49，65，97，13，27，49，55，4\n第五次：13，26，38，49，65，97，27，49，55，4\n第六次：13，26，27，38，49，65，97，49，55，4\n第七次：13，26，27，38，49，49，65，97，55，4\n第八次：13，26，27，38，49，49，55，65，97，4\n最后输出：4， 13， 26， 27， 38， 49，49， 55， 65， 97\n```\n\n- 插入排序优势：对于有序数组或部分有序数组，此排序方法是十分高效的，很适合小规模的数组，很多高级的排序算法都会利用到插入排序。\n\n- 插入排序劣势：若果最少的元素都在最后部分的位置，那么该排序方法就会变得非常费劲了，最后的元素都要比较改元素位置减一次。\n\n#### 3、希尔排序\n希尔排序为什么产生：希尔排序是以插入排序为基础的一种快速的排序算法。因为在大规模乱序数组中使用插入排序很慢，因为它只会交换相邻的两个元素，因此，如果越小的元素越是靠后，那么操作的复杂度将会大大提升，所以，人们把插入排序进行了改良，变成了希尔排序。\n希尔排序的思想：希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组为 h 有序数组。换句话说,一个 h 有序数组就是 h 个互相独 的有序数组编织在一起 成的一个数组。在进行排序时,如果 h 很大,我们就能将元素动到很远的地方,为实现更小的 h 有序创造方便。用这种方式,对于任意以 1 结尾的 h 序列,我们都能够将数组排序。这就是希尔排序。\n\n#### 图解：\n\n![图三](http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png)\n\n最后一个算法，用的C语言。\n\n#### 声明：\n\n```objectivec\n\n    void ShellSort(Array array)\nvoid exchange(Array array, int N, int M) {\n    int temp = array->a[N];\n    array->a[N] = array->a[M];\n    array->a[M] = temp;\n}\n\nstruct ArrayNode {\n    int a[kMaxLimit];\n    int count;\n};\n\nvoid pushNumInArray(Array array, int Num) {\n    if (array->count > 10) {\n        printf(\"数组越界了\");\n        return;\n    }\n\n    array->a[array->count] = Num;\n    array->count += 1;\n}\n\nvoid ShellSort(Array array) {\n    for (int gap = array->count / 2; gap > 0; gap/=2) {\n        for (int i = 0; i < gap; i ++) {\n\n            if (array->a[i + gap] < array->a[i]) {\n                for (int j = i + gap; j < array->count; j += gap) {\n                    if (array->a[j] < array->a[j - gap]) {\n                        // 交换\n                        exchange(array, j, j-gap);\n                    }\n                }\n            }\n\n        }\n    }\n}\n```\n\n\n#### 调用:\n\n```objectivec\n   Array array = malloc(sizeof(struct ArrayNode));\n   array->count = 0;\n\nfor (int i = 0; i < 10; i ++) {\n    pushNumInArray(array, arc4random() % 100);\n }\n\n  // 希尔排序\n  ShellSort(array);\n\n  for (int i = 0; i < array->count; i ++) {\n     printf(\"%d\\n\",array->a[i]);\n }\n```\n\n\n#### 输出过程：\n\n```objectivec\n原数组: 49   38   65   97   26   13   27   49   55   4\n第一次输出：gap = 5 / 2 = 2，数组为： 13   27   49   55   4    49   38   65   97   26\n第二次输出：gap = 2 / 2 = 1，数组为：4   26   13   27   38    49   49   55   97   65\n第三次输出：gap = 1 / 2 = 0，数组为：4   13   26   27   38    49   49   55   65   97\n```\n\n\n- 希尔排序优势：希尔排序优化了插入排序，在性能上比选择排序和插入排序快得多，而这种优势会随着数组越大变得越为明显。而且算法代码短简单，非常容易实现，所以我们基本上所有排序工作一开始都是用希尔排序，若在实际中不够快，我们再改成快速排序等更为高级的算法。\n\n- 希尔排序劣势： 排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。\n\n\n\n","slug":"排序算法","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twf001hznuzabzb6nui","content":"<h4 id=\"1-、-选择排序算法\"><a href=\"#1-、-选择排序算法\" class=\"headerlink\" title=\"1 、 选择排序算法\"></a>1 、 选择排序算法</h4><p>插入排序的理解： 首先,找到数组中最小的那个元素 ,其次,将它和数组的第一个元素位置 (如果第一个元 就是最小元 那么它就和自己 )。再次,在剩下的元素中找到最小的元素, 将它与数组的第二个元素交换位置。如此反复, 到将整个数组排序。这种方法叫做做选择排序,因为它在不断地选择剩余元素之中的最小者。<br>解析：对于长度为 N 的数组,选择排序需要大约 N^2/2 次比较和 N 次交换。</p>\n<h4 id=\"图解：\"><a href=\"#图解：\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png\" alt=\"图一\"></p>\n<h4 id=\"声明：\"><a href=\"#声明：\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\"> NSMutableArray <span class=\"token operator\">*</span><span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span>NSMutableArray <span class=\"token operator\">*</span>array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span>\n</code></pre>\n<h4 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span><span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span>NSMutableArray <span class=\"token operator\">*</span>array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> array<span class=\"token punctuation\">.</span>count <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> minNum <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> intValue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> minIndex <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> start <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>minNum <span class=\"token operator\">></span> <span class=\"token punctuation\">[</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> intValue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            minNum <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> intValue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            minIndex <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">[</span>array exchangeObjectAtIndex<span class=\"token punctuation\">:</span>start withObjectAtIndex<span class=\"token punctuation\">:</span>minIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array <span class=\"token operator\">=</span> <span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    NSArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array <span class=\"token operator\">=</span> <span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>array mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"输出过程：\"><a href=\"#输出过程：\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">第一次：<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span>\n第二次：<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span>\n第三次：<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span>\n第四次：<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span>\n第五次：<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span>\n最后输出： <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span>\n</code></pre>\n<ul>\n<li><p>选择排序优势：稳定，它的比较次数基本上不会改变，数据移动比较少。</p>\n</li>\n<li><p>选择排序劣势：操作级别了指数级，不会因是否有序数组而改变排序时间，时间只会与数组长度有关系。</p>\n</li>\n</ul>\n<h4 id=\"2、插入排序\"><a href=\"#2、插入排序\" class=\"headerlink\" title=\"2、插入排序\"></a>2、插入排序</h4><p>插入排序的理解：由数组的第2个位置开始比较，若果前方位置的元素比较大，则交换位置，若自己元素较大，而继续下一个元素，如此排列，那么被操作的那个元素前方位置的所有元素皆为有序。<br>解析：对于随机排列的长度为 N 且主键不重复的数组,平均情况下插入排序需要~ N^2/4 次比较以及~ N^2/4 次交换。最坏情况下需要~ N^2/2 次比较和~ N^2/2 次交换,最好情况下需要 N-1次比较和 0 次交换。<br>插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再减一。</p>\n<h4 id=\"图解：-1\"><a href=\"#图解：-1\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png\" alt=\"图二\"></p>\n<h4 id=\"声明：-1\"><a href=\"#声明：-1\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span><span class=\"token function\">InsetSort</span><span class=\"token punctuation\">(</span>NSMutableArray <span class=\"token operator\">*</span>mArray<span class=\"token punctuation\">,</span> NSInteger start<span class=\"token punctuation\">)</span>\n</code></pre>\n<h4 id=\"实现：-1\"><a href=\"#实现：-1\" class=\"headerlink\" title=\"实现：\"></a>实现：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span><span class=\"token function\">InsetSort</span><span class=\"token punctuation\">(</span>NSMutableArray <span class=\"token operator\">*</span>mArray<span class=\"token punctuation\">,</span> NSInteger start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> mArray<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> mArray<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>NSInteger i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> mArray<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> intValue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span>mArray<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> intValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> temp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mArray<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mArray<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                k <span class=\"token operator\">-</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            mArray<span class=\"token punctuation\">[</span>k<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">InsetSort</span><span class=\"token punctuation\">(</span>mArray<span class=\"token punctuation\">,</span> start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> mArray<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"调用：-1\"><a href=\"#调用：-1\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span>mArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">49</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">38</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">65</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">97</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">26</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">49</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">55</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">@</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmArray <span class=\"token operator\">=</span> <span class=\"token function\">InsetSort</span><span class=\"token punctuation\">(</span>mArray<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h4 id=\"输出过程：-1\"><a href=\"#输出过程：-1\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">第一次：<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">26</span>，<span class=\"token number\">13</span>，<span class=\"token number\">27</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第二次：<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">26</span>，<span class=\"token number\">13</span>，<span class=\"token number\">27</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第三次：<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">26</span>，<span class=\"token number\">13</span>，<span class=\"token number\">27</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第四次：<span class=\"token number\">26</span>，<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">13</span>，<span class=\"token number\">27</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第五次：<span class=\"token number\">13</span>，<span class=\"token number\">26</span>，<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">27</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第六次：<span class=\"token number\">13</span>，<span class=\"token number\">26</span>，<span class=\"token number\">27</span>，<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第七次：<span class=\"token number\">13</span>，<span class=\"token number\">26</span>，<span class=\"token number\">27</span>，<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">49</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">55</span>，<span class=\"token number\">4</span>\n第八次：<span class=\"token number\">13</span>，<span class=\"token number\">26</span>，<span class=\"token number\">27</span>，<span class=\"token number\">38</span>，<span class=\"token number\">49</span>，<span class=\"token number\">49</span>，<span class=\"token number\">55</span>，<span class=\"token number\">65</span>，<span class=\"token number\">97</span>，<span class=\"token number\">4</span>\n最后输出：<span class=\"token number\">4</span>， <span class=\"token number\">13</span>， <span class=\"token number\">26</span>， <span class=\"token number\">27</span>， <span class=\"token number\">38</span>， <span class=\"token number\">49</span>，<span class=\"token number\">49</span>， <span class=\"token number\">55</span>， <span class=\"token number\">65</span>， <span class=\"token number\">97</span>\n</code></pre>\n<ul>\n<li><p>插入排序优势：对于有序数组或部分有序数组，此排序方法是十分高效的，很适合小规模的数组，很多高级的排序算法都会利用到插入排序。</p>\n</li>\n<li><p>插入排序劣势：若果最少的元素都在最后部分的位置，那么该排序方法就会变得非常费劲了，最后的元素都要比较改元素位置减一次。</p>\n</li>\n</ul>\n<h4 id=\"3、希尔排序\"><a href=\"#3、希尔排序\" class=\"headerlink\" title=\"3、希尔排序\"></a>3、希尔排序</h4><p>希尔排序为什么产生：希尔排序是以插入排序为基础的一种快速的排序算法。因为在大规模乱序数组中使用插入排序很慢，因为它只会交换相邻的两个元素，因此，如果越小的元素越是靠后，那么操作的复杂度将会大大提升，所以，人们把插入排序进行了改良，变成了希尔排序。<br>希尔排序的思想：希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组为 h 有序数组。换句话说,一个 h 有序数组就是 h 个互相独 的有序数组编织在一起 成的一个数组。在进行排序时,如果 h 很大,我们就能将元素动到很远的地方,为实现更小的 h 有序创造方便。用这种方式,对于任意以 1 结尾的 h 序列,我们都能够将数组排序。这就是希尔排序。</p>\n<h4 id=\"图解：-2\"><a href=\"#图解：-2\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png\" alt=\"图三\"></p>\n<p>最后一个算法，用的C语言。</p>\n<h4 id=\"声明：-2\"><a href=\"#声明：-2\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">\n    <span class=\"token keyword\">void</span> <span class=\"token function\">ShellSort</span><span class=\"token punctuation\">(</span>Array array<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">exchange</span><span class=\"token punctuation\">(</span>Array array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> N<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> M<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>M<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> ArrayNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span>kMaxLimit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">pushNumInArray</span><span class=\"token punctuation\">(</span>Array array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> Num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token operator\">-></span>count <span class=\"token operator\">></span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"数组越界了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>array<span class=\"token operator\">-></span>count<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Num<span class=\"token punctuation\">;</span>\n    array<span class=\"token operator\">-></span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">ShellSort</span><span class=\"token punctuation\">(</span>Array array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> array<span class=\"token operator\">-></span>count <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> gap <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> gap<span class=\"token operator\">/</span><span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> gap<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> array<span class=\"token operator\">-></span>count<span class=\"token punctuation\">;</span> j <span class=\"token operator\">+</span><span class=\"token operator\">=</span> gap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// 交换</span>\n                        <span class=\"token function\">exchange</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> j<span class=\"token operator\">-</span>gap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用:\"></a>调用:</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">   Array array <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> ArrayNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   array<span class=\"token operator\">-></span>count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">pushNumInArray</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token function\">arc4random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 希尔排序</span>\n  <span class=\"token function\">ShellSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> array<span class=\"token operator\">-></span>count<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>array<span class=\"token operator\">-></span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"输出过程：-2\"><a href=\"#输出过程：-2\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre class=\" language-objectivec\"><code class=\"language-objectivec\">原数组<span class=\"token punctuation\">:</span> <span class=\"token number\">49</span>   <span class=\"token number\">38</span>   <span class=\"token number\">65</span>   <span class=\"token number\">97</span>   <span class=\"token number\">26</span>   <span class=\"token number\">13</span>   <span class=\"token number\">27</span>   <span class=\"token number\">49</span>   <span class=\"token number\">55</span>   <span class=\"token number\">4</span>\n第一次输出：gap <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span>，数组为： <span class=\"token number\">13</span>   <span class=\"token number\">27</span>   <span class=\"token number\">49</span>   <span class=\"token number\">55</span>   <span class=\"token number\">4</span>    <span class=\"token number\">49</span>   <span class=\"token number\">38</span>   <span class=\"token number\">65</span>   <span class=\"token number\">97</span>   <span class=\"token number\">26</span>\n第二次输出：gap <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>，数组为：<span class=\"token number\">4</span>   <span class=\"token number\">26</span>   <span class=\"token number\">13</span>   <span class=\"token number\">27</span>   <span class=\"token number\">38</span>    <span class=\"token number\">49</span>   <span class=\"token number\">49</span>   <span class=\"token number\">55</span>   <span class=\"token number\">97</span>   <span class=\"token number\">65</span>\n第三次输出：gap <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>，数组为：<span class=\"token number\">4</span>   <span class=\"token number\">13</span>   <span class=\"token number\">26</span>   <span class=\"token number\">27</span>   <span class=\"token number\">38</span>    <span class=\"token number\">49</span>   <span class=\"token number\">49</span>   <span class=\"token number\">55</span>   <span class=\"token number\">65</span>   <span class=\"token number\">97</span>\n</code></pre>\n<ul>\n<li><p>希尔排序优势：希尔排序优化了插入排序，在性能上比选择排序和插入排序快得多，而这种优势会随着数组越大变得越为明显。而且算法代码短简单，非常容易实现，所以我们基本上所有排序工作一开始都是用希尔排序，若在实际中不够快，我们再改成快速排序等更为高级的算法。</p>\n</li>\n<li><p>希尔排序劣势： 排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。</p>\n</li>\n</ul>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1-、-选择排序算法\"><a href=\"#1-、-选择排序算法\" class=\"headerlink\" title=\"1 、 选择排序算法\"></a>1 、 选择排序算法</h4><p>插入排序的理解： 首先,找到数组中最小的那个元素 ,其次,将它和数组的第一个元素位置 (如果第一个元 就是最小元 那么它就和自己 )。再次,在剩下的元素中找到最小的元素, 将它与数组的第二个元素交换位置。如此反复, 到将整个数组排序。这种方法叫做做选择排序,因为它在不断地选择剩余元素之中的最小者。<br>解析：对于长度为 N 的数组,选择排序需要大约 N^2/2 次比较和 N 次交换。</p>\n<h4 id=\"图解：\"><a href=\"#图解：\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951.png\" alt=\"图一\"></p>\n<h4 id=\"声明：\"><a href=\"#声明：\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre><code class=\"objectivec\"> NSMutableArray *selectSort(NSMutableArray *array, int start)\n</code></pre>\n<h4 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h4><pre><code class=\"objectivec\">NSMutableArray *selectSort(NSMutableArray *array, int start) {\n\n    if (start == array.count ) {\n        return array;\n    }\n\n    int minNum = [array[start] intValue];\n    int minIndex = start;\n    for (int i = start ; i &lt; array.count; i ++) {\n        if (minNum &gt; [array[i] intValue]) {\n            minNum = [array[i] intValue];\n            minIndex = i;\n        }\n    }\n\n    [array exchangeObjectAtIndex:start withObjectAtIndex:minIndex];\n    array = selectSort(array, start + 1);\n    return array;\n}\n</code></pre>\n<h4 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre><code class=\"objectivec\">    NSArray *array = @[@(1), @(4), @(8), @(9), @(5), @(7), @(2)];\n    array = selectSort([array mutableCopy], 0);\n</code></pre>\n<h4 id=\"输出过程：\"><a href=\"#输出过程：\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre><code class=\"objectivec\">第一次：1, 4, 8, 9, 5, 7, 2\n第二次：1, 2, 8, 9, 5, 7, 4\n第三次：1, 2, 4, 9, 5, 7, 8\n第四次：1, 2, 4, 5, 9, 7, 8\n第五次：1, 2, 4, 5, 7, 9, 8\n最后输出： 1, 2, 4, 5, 7, 8, 9\n</code></pre>\n<ul>\n<li><p>选择排序优势：稳定，它的比较次数基本上不会改变，数据移动比较少。</p>\n</li>\n<li><p>选择排序劣势：操作级别了指数级，不会因是否有序数组而改变排序时间，时间只会与数组长度有关系。</p>\n</li>\n</ul>\n<h4 id=\"2、插入排序\"><a href=\"#2、插入排序\" class=\"headerlink\" title=\"2、插入排序\"></a>2、插入排序</h4><p>插入排序的理解：由数组的第2个位置开始比较，若果前方位置的元素比较大，则交换位置，若自己元素较大，而继续下一个元素，如此排列，那么被操作的那个元素前方位置的所有元素皆为有序。<br>解析：对于随机排列的长度为 N 且主键不重复的数组,平均情况下插入排序需要~ N^2/4 次比较以及~ N^2/4 次交换。最坏情况下需要~ N^2/2 次比较和~ N^2/2 次交换,最好情况下需要 N-1次比较和 0 次交换。<br>插入排序需要的交换操作和数组中倒置的数量相同,需要的比较次数大于等于倒置的数量,小于等于倒置的数量加上数组的大小再减一。</p>\n<h4 id=\"图解：-1\"><a href=\"#图解：-1\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952.png\" alt=\"图二\"></p>\n<h4 id=\"声明：-1\"><a href=\"#声明：-1\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre><code class=\"objectivec\">NSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start)\n</code></pre>\n<h4 id=\"实现：-1\"><a href=\"#实现：-1\" class=\"headerlink\" title=\"实现：\"></a>实现：</h4><pre><code class=\"objectivec\">NSMutableArray *InsetSort(NSMutableArray *mArray, NSInteger start) {\n\n    if (start == mArray.count) {\n        return mArray;\n    }\n\n    for (NSInteger i = start; i &gt; 0; i --) {\n        if (mArray[i] &lt; mArray[i-1]) {\n            int temp = [mArray[i] intValue];\n            int k =  (int)(i - 1);\n\n            while (k &gt;= 0 &amp;&amp; [mArray[k] intValue] &gt; temp) {\n                mArray[k + 1] = mArray[k];\n                k -= 1;\n            }\n            mArray[k+1] = @(temp);\n        }\n    }\n\n    InsetSort(mArray, start + 1);\n\n    return mArray;\n}\n</code></pre>\n<h4 id=\"调用：-1\"><a href=\"#调用：-1\" class=\"headerlink\" title=\"调用：\"></a>调用：</h4><pre><code class=\"objectivec\">NSMutableArray *mArray = [@[@(49),   @(38),   @(65),   @(97),   @(26),   @(13),   @(27),   @(49),   @(55),   @(4)] mutableCopy];\nmArray = InsetSort(mArray, 1);\n</code></pre>\n<h4 id=\"输出过程：-1\"><a href=\"#输出过程：-1\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre><code class=\"objectivec\">第一次：38，49，65，97，26，13，27，49，55，4\n第二次：38，49，65，97，26，13，27，49，55，4\n第三次：38，49，65，97，26，13，27，49，55，4\n第四次：26，38，49，65，97，13，27，49，55，4\n第五次：13，26，38，49，65，97，27，49，55，4\n第六次：13，26，27，38，49，65，97，49，55，4\n第七次：13，26，27，38，49，49，65，97，55，4\n第八次：13，26，27，38，49，49，55，65，97，4\n最后输出：4， 13， 26， 27， 38， 49，49， 55， 65， 97\n</code></pre>\n<ul>\n<li><p>插入排序优势：对于有序数组或部分有序数组，此排序方法是十分高效的，很适合小规模的数组，很多高级的排序算法都会利用到插入排序。</p>\n</li>\n<li><p>插入排序劣势：若果最少的元素都在最后部分的位置，那么该排序方法就会变得非常费劲了，最后的元素都要比较改元素位置减一次。</p>\n</li>\n</ul>\n<h4 id=\"3、希尔排序\"><a href=\"#3、希尔排序\" class=\"headerlink\" title=\"3、希尔排序\"></a>3、希尔排序</h4><p>希尔排序为什么产生：希尔排序是以插入排序为基础的一种快速的排序算法。因为在大规模乱序数组中使用插入排序很慢，因为它只会交换相邻的两个元素，因此，如果越小的元素越是靠后，那么操作的复杂度将会大大提升，所以，人们把插入排序进行了改良，变成了希尔排序。<br>希尔排序的思想：希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组为 h 有序数组。换句话说,一个 h 有序数组就是 h 个互相独 的有序数组编织在一起 成的一个数组。在进行排序时,如果 h 很大,我们就能将元素动到很远的地方,为实现更小的 h 有序创造方便。用这种方式,对于任意以 1 结尾的 h 序列,我们都能够将数组排序。这就是希尔排序。</p>\n<h4 id=\"图解：-2\"><a href=\"#图解：-2\" class=\"headerlink\" title=\"图解：\"></a>图解：</h4><p><img src=\"http://oqepgj2jp.bkt.clouddn.com/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953.png\" alt=\"图三\"></p>\n<p>最后一个算法，用的C语言。</p>\n<h4 id=\"声明：-2\"><a href=\"#声明：-2\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><pre><code class=\"objectivec\">\n    void ShellSort(Array array)\nvoid exchange(Array array, int N, int M) {\n    int temp = array-&gt;a[N];\n    array-&gt;a[N] = array-&gt;a[M];\n    array-&gt;a[M] = temp;\n}\n\nstruct ArrayNode {\n    int a[kMaxLimit];\n    int count;\n};\n\nvoid pushNumInArray(Array array, int Num) {\n    if (array-&gt;count &gt; 10) {\n        printf(&quot;数组越界了&quot;);\n        return;\n    }\n\n    array-&gt;a[array-&gt;count] = Num;\n    array-&gt;count += 1;\n}\n\nvoid ShellSort(Array array) {\n    for (int gap = array-&gt;count / 2; gap &gt; 0; gap/=2) {\n        for (int i = 0; i &lt; gap; i ++) {\n\n            if (array-&gt;a[i + gap] &lt; array-&gt;a[i]) {\n                for (int j = i + gap; j &lt; array-&gt;count; j += gap) {\n                    if (array-&gt;a[j] &lt; array-&gt;a[j - gap]) {\n                        // 交换\n                        exchange(array, j, j-gap);\n                    }\n                }\n            }\n\n        }\n    }\n}\n</code></pre>\n<h4 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用:\"></a>调用:</h4><pre><code class=\"objectivec\">   Array array = malloc(sizeof(struct ArrayNode));\n   array-&gt;count = 0;\n\nfor (int i = 0; i &lt; 10; i ++) {\n    pushNumInArray(array, arc4random() % 100);\n }\n\n  // 希尔排序\n  ShellSort(array);\n\n  for (int i = 0; i &lt; array-&gt;count; i ++) {\n     printf(&quot;%d\\n&quot;,array-&gt;a[i]);\n }\n</code></pre>\n<h4 id=\"输出过程：-2\"><a href=\"#输出过程：-2\" class=\"headerlink\" title=\"输出过程：\"></a>输出过程：</h4><pre><code class=\"objectivec\">原数组: 49   38   65   97   26   13   27   49   55   4\n第一次输出：gap = 5 / 2 = 2，数组为： 13   27   49   55   4    49   38   65   97   26\n第二次输出：gap = 2 / 2 = 1，数组为：4   26   13   27   38    49   49   55   97   65\n第三次输出：gap = 1 / 2 = 0，数组为：4   13   26   27   38    49   49   55   65   97\n</code></pre>\n<ul>\n<li><p>希尔排序优势：希尔排序优化了插入排序，在性能上比选择排序和插入排序快得多，而这种优势会随着数组越大变得越为明显。而且算法代码短简单，非常容易实现，所以我们基本上所有排序工作一开始都是用希尔排序，若在实际中不够快，我们再改成快速排序等更为高级的算法。</p>\n</li>\n<li><p>希尔排序劣势： 排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。</p>\n</li>\n</ul>\n"},{"title":"深浅拷贝","date":"2017-04-01T05:39:36.000Z","_content":"#### 1. 对非集合类对象的copy操作：\n在非集合类对象中：对 `immutable` 对象进行 `copy` 操作，是指针复制，`mutableCopy` 操作时内容复制；对 `mutable` 对象进行 `copy` 和 `mutableCopy` 都是内容复制。用代码简单表示如下：\n\t•\t[immutableObject copy] // 浅复制\n\t•\t[immutableObject mutableCopy] //深复制\n\t•\t[mutableObject copy] //深复制\n\t•\t[mutableObject mutableCopy] //深复制\n\n\n比如以下代码：\n\n```objectivec\nNSMutableString *string = [NSMutableString stringWithString:@\"origin\"];//copy\nNSString *stringCopy = [string copy];\n```\n\n查看内存，会发现 `string`、`stringCopy` 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：\n\n```objectivec\n[string appendString:@\"origion!\"]\n```\n\n`stringCopy` 的值也不会因此改变，但是如果不使用 `copy`，`stringCopy` 的值就会被改变。 集合类对象以此类推。 所以，\n\n> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n\n#### 2、集合类对象的copy与mutableCopy\n\n集合类对象是指 `NSArray`、`NSDictionary`、`NSSet` ... 之类的对象。下面先看集合类`immutable`对象使用 `copy` 和 `mutableCopy` 的一个例子：\n\n```objectivec\nNSArray *array = @[@[@\"a\", @\"b\"], @[@\"c\", @\"d\"]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n```\n\n查看内容，可以看到 `copyArray` 和 `array` 的地址是一样的，而 `mCopyArray` 和 `array` 的地址是不同的。说明 `copy` 操作进行了指针拷贝，`mutableCopy` 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 `array` 这个对象，`array` 集合内部的元素仍然是指针拷贝。这和上面的非集合 `immutable` 对象的拷贝还是挺相似的，那么`mutable`对象的拷贝会不会类似呢？我们继续往下，看 `mutable` 对象拷贝的例子：\n\n```objectivec\nNSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@\"a\"],@\"b\",@\"c\",nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n```\n\n查看内存，如我们所料，`copyArray`、`mCopyArray`和 `array` 的内存地址都不一样，说明 `copyArray`、`mCopyArray` 都对 `array` 进行了内容拷贝。同样，我们可以得出结论：\n\n在集合类对象中，对 `immutable` 对象进行 `copy`，是指针复制， `mutableCopy` 是内容复制；对 `mutable` 对象进行 `copy` 和 `mutableCopy` 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：\n\n\n```objectivec\n[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n```\n\n这个代码结论和非集合类的非常相似。\n\n\n\n","source":"_posts/深浅拷贝.md","raw":"---\ntitle: 深浅拷贝\ndate: 2017-04-01 13:39:36\ncategories: \n\t- iOS合集\n---\n#### 1. 对非集合类对象的copy操作：\n在非集合类对象中：对 `immutable` 对象进行 `copy` 操作，是指针复制，`mutableCopy` 操作时内容复制；对 `mutable` 对象进行 `copy` 和 `mutableCopy` 都是内容复制。用代码简单表示如下：\n\t•\t[immutableObject copy] // 浅复制\n\t•\t[immutableObject mutableCopy] //深复制\n\t•\t[mutableObject copy] //深复制\n\t•\t[mutableObject mutableCopy] //深复制\n\n\n比如以下代码：\n\n```objectivec\nNSMutableString *string = [NSMutableString stringWithString:@\"origin\"];//copy\nNSString *stringCopy = [string copy];\n```\n\n查看内存，会发现 `string`、`stringCopy` 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：\n\n```objectivec\n[string appendString:@\"origion!\"]\n```\n\n`stringCopy` 的值也不会因此改变，但是如果不使用 `copy`，`stringCopy` 的值就会被改变。 集合类对象以此类推。 所以，\n\n> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n\n#### 2、集合类对象的copy与mutableCopy\n\n集合类对象是指 `NSArray`、`NSDictionary`、`NSSet` ... 之类的对象。下面先看集合类`immutable`对象使用 `copy` 和 `mutableCopy` 的一个例子：\n\n```objectivec\nNSArray *array = @[@[@\"a\", @\"b\"], @[@\"c\", @\"d\"]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n```\n\n查看内容，可以看到 `copyArray` 和 `array` 的地址是一样的，而 `mCopyArray` 和 `array` 的地址是不同的。说明 `copy` 操作进行了指针拷贝，`mutableCopy` 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 `array` 这个对象，`array` 集合内部的元素仍然是指针拷贝。这和上面的非集合 `immutable` 对象的拷贝还是挺相似的，那么`mutable`对象的拷贝会不会类似呢？我们继续往下，看 `mutable` 对象拷贝的例子：\n\n```objectivec\nNSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@\"a\"],@\"b\",@\"c\",nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n```\n\n查看内存，如我们所料，`copyArray`、`mCopyArray`和 `array` 的内存地址都不一样，说明 `copyArray`、`mCopyArray` 都对 `array` 进行了内容拷贝。同样，我们可以得出结论：\n\n在集合类对象中，对 `immutable` 对象进行 `copy`，是指针复制， `mutableCopy` 是内容复制；对 `mutable` 对象进行 `copy` 和 `mutableCopy` 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：\n\n\n```objectivec\n[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n```\n\n这个代码结论和非集合类的非常相似。\n\n\n\n","slug":"深浅拷贝","published":1,"updated":"2017-07-05T11:13:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twg001jznuzopgxhpl9","content":"<h4 id=\"1-对非集合类对象的copy操作：\"><a href=\"#1-对非集合类对象的copy操作：\" class=\"headerlink\" title=\"1. 对非集合类对象的copy操作：\"></a>1. 对非集合类对象的copy操作：</h4><p>在非集合类对象中：对 <code>immutable</code> 对象进行 <code>copy</code> 操作，是指针复制，<code>mutableCopy</code> 操作时内容复制；对 <code>mutable</code> 对象进行 <code>copy</code> 和 <code>mutableCopy</code> 都是内容复制。用代码简单表示如下：<br>    •    [immutableObject copy] // 浅复制<br>    •    [immutableObject mutableCopy] //深复制<br>    •    [mutableObject copy] //深复制<br>    •    [mutableObject mutableCopy] //深复制</p>\n<p>比如以下代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableString <span class=\"token operator\">*</span>string <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"origin\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//copy</span>\nNSString <span class=\"token operator\">*</span>stringCopy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>string copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内存，会发现 <code>string</code>、<code>stringCopy</code> 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>string appendString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"origion!\"</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p><code>stringCopy</code> 的值也不会因此改变，但是如果不使用 <code>copy</code>，<code>stringCopy</code> 的值就会被改变。 集合类对象以此类推。 所以，</p>\n<blockquote>\n<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<h4 id=\"2、集合类对象的copy与mutableCopy\"><a href=\"#2、集合类对象的copy与mutableCopy\" class=\"headerlink\" title=\"2、集合类对象的copy与mutableCopy\"></a>2、集合类对象的copy与mutableCopy</h4><p>集合类对象是指 <code>NSArray</code>、<code>NSDictionary</code>、<code>NSSet</code> … 之类的对象。下面先看集合类<code>immutable</code>对象使用 <code>copy</code> 和 <code>mutableCopy</code> 的一个例子：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"b\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"d\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>copyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>mCopyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内容，可以看到 <code>copyArray</code> 和 <code>array</code> 的地址是一样的，而 <code>mCopyArray</code> 和 <code>array</code> 的地址是不同的。说明 <code>copy</code> 操作进行了指针拷贝，<code>mutableCopy</code> 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 <code>array</code> 这个对象，<code>array</code> 集合内部的元素仍然是指针拷贝。这和上面的非集合 <code>immutable</code> 对象的拷贝还是挺相似的，那么<code>mutable</code>对象的拷贝会不会类似呢？我们继续往下，看 <code>mutable</code> 对象拷贝的例子：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithObjects<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"a\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">@\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">@\"c\"</span><span class=\"token punctuation\">,</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>copyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>mCopyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内存，如我们所料，<code>copyArray</code>、<code>mCopyArray</code>和 <code>array</code> 的内存地址都不一样，说明 <code>copyArray</code>、<code>mCopyArray</code> 都对 <code>array</code> 进行了内容拷贝。同样，我们可以得出结论：</p>\n<p>在集合类对象中，对 <code>immutable</code> 对象进行 <code>copy</code>，是指针复制， <code>mutableCopy</code> 是内容复制；对 <code>mutable</code> 对象进行 <code>copy</code> 和 <code>mutableCopy</code> 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>immutableObject copy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// 浅复制</span>\n<span class=\"token punctuation\">[</span>immutableObject mutableCopy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n<span class=\"token punctuation\">[</span>mutableObject copy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n<span class=\"token punctuation\">[</span>mutableObject mutableCopy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n</code></pre>\n<p>这个代码结论和非集合类的非常相似。</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<h4 id=\"1-对非集合类对象的copy操作：\"><a href=\"#1-对非集合类对象的copy操作：\" class=\"headerlink\" title=\"1. 对非集合类对象的copy操作：\"></a>1. 对非集合类对象的copy操作：</h4><p>在非集合类对象中：对 <code>immutable</code> 对象进行 <code>copy</code> 操作，是指针复制，<code>mutableCopy</code> 操作时内容复制；对 <code>mutable</code> 对象进行 <code>copy</code> 和 <code>mutableCopy</code> 都是内容复制。用代码简单表示如下：<br>    •    [immutableObject copy] // 浅复制<br>    •    [immutableObject mutableCopy] //深复制<br>    •    [mutableObject copy] //深复制<br>    •    [mutableObject mutableCopy] //深复制</p>\n<p>比如以下代码：</p>\n<pre><code class=\"objectivec\">NSMutableString *string = [NSMutableString stringWithString:@&quot;origin&quot;];//copy\nNSString *stringCopy = [string copy];\n</code></pre>\n<p>查看内存，会发现 <code>string</code>、<code>stringCopy</code> 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>\n<pre><code class=\"objectivec\">[string appendString:@&quot;origion!&quot;]\n</code></pre>\n<p><code>stringCopy</code> 的值也不会因此改变，但是如果不使用 <code>copy</code>，<code>stringCopy</code> 的值就会被改变。 集合类对象以此类推。 所以，</p>\n<blockquote>\n<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<h4 id=\"2、集合类对象的copy与mutableCopy\"><a href=\"#2、集合类对象的copy与mutableCopy\" class=\"headerlink\" title=\"2、集合类对象的copy与mutableCopy\"></a>2、集合类对象的copy与mutableCopy</h4><p>集合类对象是指 <code>NSArray</code>、<code>NSDictionary</code>、<code>NSSet</code> … 之类的对象。下面先看集合类<code>immutable</code>对象使用 <code>copy</code> 和 <code>mutableCopy</code> 的一个例子：</p>\n<pre><code class=\"objectivec\">NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n</code></pre>\n<p>查看内容，可以看到 <code>copyArray</code> 和 <code>array</code> 的地址是一样的，而 <code>mCopyArray</code> 和 <code>array</code> 的地址是不同的。说明 <code>copy</code> 操作进行了指针拷贝，<code>mutableCopy</code> 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 <code>array</code> 这个对象，<code>array</code> 集合内部的元素仍然是指针拷贝。这和上面的非集合 <code>immutable</code> 对象的拷贝还是挺相似的，那么<code>mutable</code>对象的拷贝会不会类似呢？我们继续往下，看 <code>mutable</code> 对象拷贝的例子：</p>\n<pre><code class=\"objectivec\">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n</code></pre>\n<p>查看内存，如我们所料，<code>copyArray</code>、<code>mCopyArray</code>和 <code>array</code> 的内存地址都不一样，说明 <code>copyArray</code>、<code>mCopyArray</code> 都对 <code>array</code> 进行了内容拷贝。同样，我们可以得出结论：</p>\n<p>在集合类对象中，对 <code>immutable</code> 对象进行 <code>copy</code>，是指针复制， <code>mutableCopy</code> 是内容复制；对 <code>mutable</code> 对象进行 <code>copy</code> 和 <code>mutableCopy</code> 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>\n<pre><code class=\"objectivec\">[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n</code></pre>\n<p>这个代码结论和非集合类的非常相似。</p>\n"},{"title":"给你","date":"2017-06-22T14:31:02.000Z","_content":"\n![你](http://oqepgj2jp.bkt.clouddn.com/girlFriend.png)\n\n我躲在幽深的夏夜里﻿\n\n摘一朵芙蕖﻿\n\n携清风一缕﻿\n\n送给你﻿﻿\n\n---\n\n我把月光揉成诗句﻿\n\n带着鲜花和故事﻿\n\n带着清酒和嫩绿﻿\n\n送给你﻿\n\n---\n\n我用彩虹吃面的勺子﻿\n\n深入西瓜的腹地﻿\n\n掏出第一口果汁﻿\n\n送给你﻿\n\n---\n\n\n我把蛙鸣哼进歌声里﻿\n\n把芬芳卷到涟漪里﻿\n\n你不必客气﻿\n\n更不要推辞﻿\n\n请在酣然入睡时﻿\n\n把冷饮灌进我的梦里﻿\n\n灌醉所有炙热的因子﻿\n\n直到太阳升起﻿\n\n\n\n","source":"_posts/给你.md","raw":"---\ntitle: 给你\ndate: 2017-06-22 22:31:02\ncategories: \n\t- 自言语\n---\n\n![你](http://oqepgj2jp.bkt.clouddn.com/girlFriend.png)\n\n我躲在幽深的夏夜里﻿\n\n摘一朵芙蕖﻿\n\n携清风一缕﻿\n\n送给你﻿﻿\n\n---\n\n我把月光揉成诗句﻿\n\n带着鲜花和故事﻿\n\n带着清酒和嫩绿﻿\n\n送给你﻿\n\n---\n\n我用彩虹吃面的勺子﻿\n\n深入西瓜的腹地﻿\n\n掏出第一口果汁﻿\n\n送给你﻿\n\n---\n\n\n我把蛙鸣哼进歌声里﻿\n\n把芬芳卷到涟漪里﻿\n\n你不必客气﻿\n\n更不要推辞﻿\n\n请在酣然入睡时﻿\n\n把冷饮灌进我的梦里﻿\n\n灌醉所有炙热的因子﻿\n\n直到太阳升起﻿\n\n\n\n","slug":"给你","published":1,"updated":"2017-06-22T14:35:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twi001lznuzm5eldok4","content":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/girlFriend.png\" alt=\"你\"></p>\n<p>我躲在幽深的夏夜里﻿</p>\n<p>摘一朵芙蕖﻿</p>\n<p>携清风一缕﻿</p>\n<p>送给你﻿﻿</p>\n<hr>\n<p>我把月光揉成诗句﻿</p>\n<p>带着鲜花和故事﻿</p>\n<p>带着清酒和嫩绿﻿</p>\n<p>送给你﻿</p>\n<hr>\n<p>我用彩虹吃面的勺子﻿</p>\n<p>深入西瓜的腹地﻿</p>\n<p>掏出第一口果汁﻿</p>\n<p>送给你﻿</p>\n<hr>\n<p>我把蛙鸣哼进歌声里﻿</p>\n<p>把芬芳卷到涟漪里﻿</p>\n<p>你不必客气﻿</p>\n<p>更不要推辞﻿</p>\n<p>请在酣然入睡时﻿</p>\n<p>把冷饮灌进我的梦里﻿</p>\n<p>灌醉所有炙热的因子﻿</p>\n<p>直到太阳升起﻿</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/girlFriend.png\" alt=\"你\"></p>\n<p>我躲在幽深的夏夜里﻿</p>\n<p>摘一朵芙蕖﻿</p>\n<p>携清风一缕﻿</p>\n<p>送给你﻿﻿</p>\n<hr>\n<p>我把月光揉成诗句﻿</p>\n<p>带着鲜花和故事﻿</p>\n<p>带着清酒和嫩绿﻿</p>\n<p>送给你﻿</p>\n<hr>\n<p>我用彩虹吃面的勺子﻿</p>\n<p>深入西瓜的腹地﻿</p>\n<p>掏出第一口果汁﻿</p>\n<p>送给你﻿</p>\n<hr>\n<p>我把蛙鸣哼进歌声里﻿</p>\n<p>把芬芳卷到涟漪里﻿</p>\n<p>你不必客气﻿</p>\n<p>更不要推辞﻿</p>\n<p>请在酣然入睡时﻿</p>\n<p>把冷饮灌进我的梦里﻿</p>\n<p>灌醉所有炙热的因子﻿</p>\n<p>直到太阳升起﻿</p>\n"},{"title":"玩转iOS中UITextField的placeholder颜色","date":"2017-05-23T05:59:59.000Z","_content":"![珍惜时间](http://oqepgj2jp.bkt.clouddn.com/wallpaper-2572384.jpg)\n>`UITextField`是iOS开发中经常使用到的控件，它有一个`placeholder`属性，也就是占位文字。默认占位文字颜色是` 70% gray`,但有时我们可能需要修改其占位文字的颜色，下文中将为大家介绍三中修改方法,并就动态改变颜色做相关说明（关于动态改变：当UITextField为第一响应者时为一种颜色，取消第一响应者时为另一种颜色）。\n\n##方法1\n- 设置 `attributedPlaceholder`属性\n- 说明：此种方式对于无需动态改变`placeholder`颜色较为方便。\n\n---\n- 代码1（单色）\n\n```objectivec\nNSMutableDictionary *attrs = [NSMutableDictionary dictionary]; // 创建属性字典\n  attrs[NSFontAttributeName] = [UIFont systemFontOfSize:17]; // 设置font\n  attrs[NSForegroundColorAttributeName] = [UIColor greenColor]; // 设置颜色\n  NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@\"夏虫不可以语冰\" attributes:attrs]; // 初始化富文本占位字符串\n  self.textField.attributedPlaceholder = attStr;\n```\n- 效果1\n![单色placeholder](http://upload-images.jianshu.io/upload_images/2115041-b0b505d18f2888a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 代码2（复色）\n\n```objectivec\nNSMutableAttributedString *attStr = [[NSMutableAttributedString alloc] initWithString:@\"夏虫不可以语冰\"];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor redColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(0, 2)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor greenColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:17.0]} range:NSMakeRange(2, 3)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor blueColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(5, 2)];\n    self.textField.attributedPlaceholder = attStr;\n```\n- 效果\n![复色placeholder](http://upload-images.jianshu.io/upload_images/2115041-d9430dd8f3e57343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##方法2\n- 自定义UITextField,重写`- (void)drawPlaceholderInRect:(CGRect)rect;`\n- 说明：此种方式只能设置一次状态,不能动态的改变`placeholder`的颜色,但可以设置`placeholder`所在位置。\n\n---\n- 代码\n\n```objectivec\n- (void)drawPlaceholderInRect:(CGRect)rect\n{\n    [self.placeholder drawInRect:CGRectMake(0, 2, rect.size.width, 25) withAttributes:@{ NSFontAttributeName: [UIFont systemFontOfSize:16.0],\n                                        NSForegroundColorAttributeName : [UIColor blueColor],\n                                     }];\n}\n```\n- 效果\n![placeholder](http://upload-images.jianshu.io/upload_images/2115041-cf46f67c604c2c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##方法3\n- 自定义UITextField,利用runTime找出UITextFiled内部隐藏的成员变量和属性，利用KVC进行修改。\n- 说明：此种方式对于动态改变`placeholder`颜色较为方便。\n\n- **拓展代码**（利用runTime找出成员变量和属性，程序中无需使用，只是帮助我们看清UITextField内部结构，知道其中的相关成员变量和属性，然后赋值即可）。\n\n```objectivec\n#import \"SJTextField.h\"\n#import <objc/runtime.h>\n@implementation SJTextField\n\n// 初始化调用一次 用于查看UITextField中的成员属性和变量\n+ (void)initialize\n{\n    [self getIvars];\n    // [self getProperties];\n}\n\n// 获取所有属性\n+ (void)getProperties\n{\n    unsigned int count = 0;\n    objc_property_t *properties = class_copyPropertyList([UITextField class], &count);\n    for (int i = 0; i<count; i++) {\n        // 取出属性\n        objc_property_t property = properties[i];\n        \n        // 打印属性名字\n        NSLog(@\"%s<---->%s\", property_getName(property), property_getAttributes(property));\n    }\n    free(properties);\n}\n\n// 获取所有成员变量\n+ (void)getIvars\n{\n    unsigned int count = 0;\n    // 拷贝出所有的成员变量列表\n    Ivar *ivars = class_copyIvarList([UITextField class], &count);\n    for (int i = 0; i<count; i++) {\n        // 取出成员变量\n        //        Ivar ivar = *(ivars + i);\n        Ivar ivar = ivars[i];\n        \n        // 打印成员变量名字\n        NSLog(@\"%s %s\", ivar_getName(ivar), ivar_getTypeEncoding(ivar));\n    }\n    // 释放\n    free(ivars);\n}\n@end\n```\n- **拓展点** 可以查到有两个关于`placeholder`的属性和变量，分别是`_placeholderLabel.textColor`和`_placeholderLabel`，故下面就是用来设置动态改变`placeholder`颜色的代码。\n- 代码（在自定义UITextField中）\n\n```objectivec\n#import \"SJTextField.h\"\n#import <objc/runtime.h>\n@implementation SJTextField\nstatic NSString * const SJPlacerholderColorKeyPath = @\"_placeholderLabel.textColor\";\n- (void)awakeFromNib\n{\n// 设置placeholder开始颜色（方式一）\n//    UILabel *placeholderLabel = [self valueForKeyPath:@\"_placeholderLabel\"];\n//    placeholderLabel.textColor = [UIColor redColor];   \n   // 设置placeholder开始颜色（方式二）\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    // 不成为第一响应者\n    [self resignFirstResponder];\n}\n\n/**\n * 当前文本框聚焦时就会调用\n */\n- (BOOL)becomeFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor redColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super becomeFirstResponder];\n}\n\n/**\n * 当前文本框失去焦点时就会调用\n */\n- (BOOL)resignFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super resignFirstResponder];\n}\n@end\n```\n- 效果\n\n\n![未进入编辑状态](http://upload-images.jianshu.io/upload_images/2115041-9c0ca6ff0ec7c261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![进入编辑状态](http://upload-images.jianshu.io/upload_images/2115041-6c9aacd3d30f3655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nEnd.\n\n\n","source":"_posts/玩转iOS中UITextField的placeholder颜色.md","raw":"---\ntitle: 玩转iOS中UITextField的placeholder颜色\ndate: 2017-05-23 13:59:59\ncategories: \n\t- iOS合集\n---\n![珍惜时间](http://oqepgj2jp.bkt.clouddn.com/wallpaper-2572384.jpg)\n>`UITextField`是iOS开发中经常使用到的控件，它有一个`placeholder`属性，也就是占位文字。默认占位文字颜色是` 70% gray`,但有时我们可能需要修改其占位文字的颜色，下文中将为大家介绍三中修改方法,并就动态改变颜色做相关说明（关于动态改变：当UITextField为第一响应者时为一种颜色，取消第一响应者时为另一种颜色）。\n\n##方法1\n- 设置 `attributedPlaceholder`属性\n- 说明：此种方式对于无需动态改变`placeholder`颜色较为方便。\n\n---\n- 代码1（单色）\n\n```objectivec\nNSMutableDictionary *attrs = [NSMutableDictionary dictionary]; // 创建属性字典\n  attrs[NSFontAttributeName] = [UIFont systemFontOfSize:17]; // 设置font\n  attrs[NSForegroundColorAttributeName] = [UIColor greenColor]; // 设置颜色\n  NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@\"夏虫不可以语冰\" attributes:attrs]; // 初始化富文本占位字符串\n  self.textField.attributedPlaceholder = attStr;\n```\n- 效果1\n![单色placeholder](http://upload-images.jianshu.io/upload_images/2115041-b0b505d18f2888a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 代码2（复色）\n\n```objectivec\nNSMutableAttributedString *attStr = [[NSMutableAttributedString alloc] initWithString:@\"夏虫不可以语冰\"];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor redColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(0, 2)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor greenColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:17.0]} range:NSMakeRange(2, 3)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor blueColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(5, 2)];\n    self.textField.attributedPlaceholder = attStr;\n```\n- 效果\n![复色placeholder](http://upload-images.jianshu.io/upload_images/2115041-d9430dd8f3e57343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##方法2\n- 自定义UITextField,重写`- (void)drawPlaceholderInRect:(CGRect)rect;`\n- 说明：此种方式只能设置一次状态,不能动态的改变`placeholder`的颜色,但可以设置`placeholder`所在位置。\n\n---\n- 代码\n\n```objectivec\n- (void)drawPlaceholderInRect:(CGRect)rect\n{\n    [self.placeholder drawInRect:CGRectMake(0, 2, rect.size.width, 25) withAttributes:@{ NSFontAttributeName: [UIFont systemFontOfSize:16.0],\n                                        NSForegroundColorAttributeName : [UIColor blueColor],\n                                     }];\n}\n```\n- 效果\n![placeholder](http://upload-images.jianshu.io/upload_images/2115041-cf46f67c604c2c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##方法3\n- 自定义UITextField,利用runTime找出UITextFiled内部隐藏的成员变量和属性，利用KVC进行修改。\n- 说明：此种方式对于动态改变`placeholder`颜色较为方便。\n\n- **拓展代码**（利用runTime找出成员变量和属性，程序中无需使用，只是帮助我们看清UITextField内部结构，知道其中的相关成员变量和属性，然后赋值即可）。\n\n```objectivec\n#import \"SJTextField.h\"\n#import <objc/runtime.h>\n@implementation SJTextField\n\n// 初始化调用一次 用于查看UITextField中的成员属性和变量\n+ (void)initialize\n{\n    [self getIvars];\n    // [self getProperties];\n}\n\n// 获取所有属性\n+ (void)getProperties\n{\n    unsigned int count = 0;\n    objc_property_t *properties = class_copyPropertyList([UITextField class], &count);\n    for (int i = 0; i<count; i++) {\n        // 取出属性\n        objc_property_t property = properties[i];\n        \n        // 打印属性名字\n        NSLog(@\"%s<---->%s\", property_getName(property), property_getAttributes(property));\n    }\n    free(properties);\n}\n\n// 获取所有成员变量\n+ (void)getIvars\n{\n    unsigned int count = 0;\n    // 拷贝出所有的成员变量列表\n    Ivar *ivars = class_copyIvarList([UITextField class], &count);\n    for (int i = 0; i<count; i++) {\n        // 取出成员变量\n        //        Ivar ivar = *(ivars + i);\n        Ivar ivar = ivars[i];\n        \n        // 打印成员变量名字\n        NSLog(@\"%s %s\", ivar_getName(ivar), ivar_getTypeEncoding(ivar));\n    }\n    // 释放\n    free(ivars);\n}\n@end\n```\n- **拓展点** 可以查到有两个关于`placeholder`的属性和变量，分别是`_placeholderLabel.textColor`和`_placeholderLabel`，故下面就是用来设置动态改变`placeholder`颜色的代码。\n- 代码（在自定义UITextField中）\n\n```objectivec\n#import \"SJTextField.h\"\n#import <objc/runtime.h>\n@implementation SJTextField\nstatic NSString * const SJPlacerholderColorKeyPath = @\"_placeholderLabel.textColor\";\n- (void)awakeFromNib\n{\n// 设置placeholder开始颜色（方式一）\n//    UILabel *placeholderLabel = [self valueForKeyPath:@\"_placeholderLabel\"];\n//    placeholderLabel.textColor = [UIColor redColor];   \n   // 设置placeholder开始颜色（方式二）\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    // 不成为第一响应者\n    [self resignFirstResponder];\n}\n\n/**\n * 当前文本框聚焦时就会调用\n */\n- (BOOL)becomeFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor redColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super becomeFirstResponder];\n}\n\n/**\n * 当前文本框失去焦点时就会调用\n */\n- (BOOL)resignFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super resignFirstResponder];\n}\n@end\n```\n- 效果\n\n\n![未进入编辑状态](http://upload-images.jianshu.io/upload_images/2115041-9c0ca6ff0ec7c261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![进入编辑状态](http://upload-images.jianshu.io/upload_images/2115041-6c9aacd3d30f3655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nEnd.\n\n\n","slug":"玩转iOS中UITextField的placeholder颜色","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twl001nznuz78y79i95","content":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wallpaper-2572384.jpg\" alt=\"珍惜时间\"></p>\n<blockquote>\n<p><code>UITextField</code>是iOS开发中经常使用到的控件，它有一个<code>placeholder</code>属性，也就是占位文字。默认占位文字颜色是<code>70% gray</code>,但有时我们可能需要修改其占位文字的颜色，下文中将为大家介绍三中修改方法,并就动态改变颜色做相关说明（关于动态改变：当UITextField为第一响应者时为一种颜色，取消第一响应者时为另一种颜色）。</p>\n</blockquote>\n<p>##方法1</p>\n<ul>\n<li>设置 <code>attributedPlaceholder</code>属性</li>\n<li>说明：此种方式对于无需动态改变<code>placeholder</code>颜色较为方便。</li>\n</ul>\n<hr>\n<ul>\n<li>代码1（单色）</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableDictionary <span class=\"token operator\">*</span>attrs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableDictionary dictionary<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 创建属性字典</span>\n  attrs<span class=\"token punctuation\">[</span>NSFontAttributeName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">17</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置font</span>\n  attrs<span class=\"token punctuation\">[</span>NSForegroundColorAttributeName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>UIColor greenColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 设置颜色</span>\n  NSAttributedString <span class=\"token operator\">*</span>attStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSAttributedString alloc<span class=\"token punctuation\">]</span> initWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"夏虫不可以语冰\"</span> attributes<span class=\"token punctuation\">:</span>attrs<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化富文本占位字符串</span>\n  <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>textField<span class=\"token punctuation\">.</span>attributedPlaceholder <span class=\"token operator\">=</span> attStr<span class=\"token punctuation\">;</span>\n</code></pre>\n<ul>\n<li><p>效果1<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-b0b505d18f2888a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单色placeholder\"></p>\n</li>\n<li><p>代码2（复色）</p>\n</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableAttributedString <span class=\"token operator\">*</span>attStr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableAttributedString alloc<span class=\"token punctuation\">]</span> initWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"夏虫不可以语冰\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">[</span>attStr setAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>NSForegroundColorAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                            NSFontAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">15.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">[</span>attStr setAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>NSForegroundColorAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIColor greenColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                            NSFontAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">17.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">[</span>attStr setAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span>NSForegroundColorAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIColor blueColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                            NSFontAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">15.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> range<span class=\"token punctuation\">:</span><span class=\"token function\">NSMakeRange</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>textField<span class=\"token punctuation\">.</span>attributedPlaceholder <span class=\"token operator\">=</span> attStr<span class=\"token punctuation\">;</span>\n</code></pre>\n<ul>\n<li>效果<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-d9430dd8f3e57343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"复色placeholder\"></li>\n</ul>\n<p>##方法2</p>\n<ul>\n<li>自定义UITextField,重写<code>- (void)drawPlaceholderInRect:(CGRect)rect;</code></li>\n<li>说明：此种方式只能设置一次状态,不能动态的改变<code>placeholder</code>的颜色,但可以设置<code>placeholder</code>所在位置。</li>\n</ul>\n<hr>\n<ul>\n<li>代码</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>drawPlaceholderInRect<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGRect<span class=\"token punctuation\">)</span>rect\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>placeholder drawInRect<span class=\"token punctuation\">:</span><span class=\"token function\">CGRectMake</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> rect<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">)</span> withAttributes<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token punctuation\">{</span> NSFontAttributeName<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIFont systemFontOfSize<span class=\"token punctuation\">:</span><span class=\"token number\">16.0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                                        NSForegroundColorAttributeName <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>UIColor blueColor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                                     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul>\n<li>效果<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-cf46f67c604c2c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"placeholder\"></li>\n</ul>\n<p>##方法3</p>\n<ul>\n<li>自定义UITextField,利用runTime找出UITextFiled内部隐藏的成员变量和属性，利用KVC进行修改。</li>\n<li><p>说明：此种方式对于动态改变<code>placeholder</code>颜色较为方便。</p>\n</li>\n<li><p><strong>拓展代码</strong>（利用runTime找出成员变量和属性，程序中无需使用，只是帮助我们看清UITextField内部结构，知道其中的相关成员变量和属性，然后赋值即可）。</p>\n</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"SJTextField.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;objc/runtime.h></span>\n<span class=\"token keyword\">@implementation</span> SJTextField\n\n<span class=\"token comment\" spellcheck=\"true\">// 初始化调用一次 用于查看UITextField中的成员属性和变量</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>initialize\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> getIvars<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// [self getProperties];</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 获取所有属性</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>getProperties\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    objc_property_t <span class=\"token operator\">*</span>properties <span class=\"token operator\">=</span> <span class=\"token function\">class_copyPropertyList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>UITextField class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 取出属性</span>\n        objc_property_t property <span class=\"token operator\">=</span> properties<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 打印属性名字</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%s&lt;---->%s\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">property_getName</span><span class=\"token punctuation\">(</span>property<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">property_getAttributes</span><span class=\"token punctuation\">(</span>property<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>properties<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 获取所有成员变量</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>getIvars\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 拷贝出所有的成员变量列表</span>\n    Ivar <span class=\"token operator\">*</span>ivars <span class=\"token operator\">=</span> <span class=\"token function\">class_copyIvarList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>UITextField class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 取出成员变量</span>\n        <span class=\"token comment\" spellcheck=\"true\">//        Ivar ivar = *(ivars + i);</span>\n        Ivar ivar <span class=\"token operator\">=</span> ivars<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 打印成员变量名字</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%s %s\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">ivar_getName</span><span class=\"token punctuation\">(</span>ivar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">ivar_getTypeEncoding</span><span class=\"token punctuation\">(</span>ivar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 释放</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>ivars<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<ul>\n<li><strong>拓展点</strong> 可以查到有两个关于<code>placeholder</code>的属性和变量，分别是<code>_placeholderLabel.textColor</code>和<code>_placeholderLabel</code>，故下面就是用来设置动态改变<code>placeholder</code>颜色的代码。</li>\n<li>代码（在自定义UITextField中）</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"SJTextField.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> &lt;objc/runtime.h></span>\n<span class=\"token keyword\">@implementation</span> SJTextField\n<span class=\"token keyword\">static</span> NSString <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> SJPlacerholderColorKeyPath <span class=\"token operator\">=</span> <span class=\"token string\">@\"_placeholderLabel.textColor\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>awakeFromNib\n<span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 设置placeholder开始颜色（方式一）</span>\n<span class=\"token comment\" spellcheck=\"true\">//    UILabel *placeholderLabel = [self valueForKeyPath:@\"_placeholderLabel\"];</span>\n<span class=\"token comment\" spellcheck=\"true\">//    placeholderLabel.textColor = [UIColor redColor];   </span>\n   <span class=\"token comment\" spellcheck=\"true\">// 设置placeholder开始颜色（方式二）</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setValue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor greenColor<span class=\"token punctuation\">]</span> forKeyPath<span class=\"token punctuation\">:</span>SJPlacerholderColorKeyPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 不成为第一响应者</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> resignFirstResponder<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 当前文本框聚焦时就会调用\n */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>becomeFirstResponder\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 修改占位文字颜色</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setValue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor redColor<span class=\"token punctuation\">]</span> forKeyPath<span class=\"token punctuation\">:</span>SJPlacerholderColorKeyPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> becomeFirstResponder<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 当前文本框失去焦点时就会调用\n */</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>resignFirstResponder\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 修改占位文字颜色</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> setValue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>UIColor greenColor<span class=\"token punctuation\">]</span> forKeyPath<span class=\"token punctuation\">:</span>SJPlacerholderColorKeyPath<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> resignFirstResponder<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<ul>\n<li>效果</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-9c0ca6ff0ec7c261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"未进入编辑状态\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6c9aacd3d30f3655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进入编辑状态\"></p>\n<p>End.</p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><img src=\"http://oqepgj2jp.bkt.clouddn.com/wallpaper-2572384.jpg\" alt=\"珍惜时间\"></p>\n<blockquote>\n<p><code>UITextField</code>是iOS开发中经常使用到的控件，它有一个<code>placeholder</code>属性，也就是占位文字。默认占位文字颜色是<code>70% gray</code>,但有时我们可能需要修改其占位文字的颜色，下文中将为大家介绍三中修改方法,并就动态改变颜色做相关说明（关于动态改变：当UITextField为第一响应者时为一种颜色，取消第一响应者时为另一种颜色）。</p>\n</blockquote>\n<p>##方法1</p>\n<ul>\n<li>设置 <code>attributedPlaceholder</code>属性</li>\n<li>说明：此种方式对于无需动态改变<code>placeholder</code>颜色较为方便。</li>\n</ul>\n<hr>\n<ul>\n<li>代码1（单色）</li>\n</ul>\n<pre><code class=\"objectivec\">NSMutableDictionary *attrs = [NSMutableDictionary dictionary]; // 创建属性字典\n  attrs[NSFontAttributeName] = [UIFont systemFontOfSize:17]; // 设置font\n  attrs[NSForegroundColorAttributeName] = [UIColor greenColor]; // 设置颜色\n  NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@&quot;夏虫不可以语冰&quot; attributes:attrs]; // 初始化富文本占位字符串\n  self.textField.attributedPlaceholder = attStr;\n</code></pre>\n<ul>\n<li><p>效果1<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-b0b505d18f2888a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单色placeholder\"></p>\n</li>\n<li><p>代码2（复色）</p>\n</li>\n</ul>\n<pre><code class=\"objectivec\">NSMutableAttributedString *attStr = [[NSMutableAttributedString alloc] initWithString:@&quot;夏虫不可以语冰&quot;];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor redColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(0, 2)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor greenColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:17.0]} range:NSMakeRange(2, 3)];\n [attStr setAttributes:@{NSForegroundColorAttributeName : [UIColor blueColor],\n                            NSFontAttributeName : [UIFont systemFontOfSize:15.0]} range:NSMakeRange(5, 2)];\n    self.textField.attributedPlaceholder = attStr;\n</code></pre>\n<ul>\n<li>效果<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-d9430dd8f3e57343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"复色placeholder\"></li>\n</ul>\n<p>##方法2</p>\n<ul>\n<li>自定义UITextField,重写<code>- (void)drawPlaceholderInRect:(CGRect)rect;</code></li>\n<li>说明：此种方式只能设置一次状态,不能动态的改变<code>placeholder</code>的颜色,但可以设置<code>placeholder</code>所在位置。</li>\n</ul>\n<hr>\n<ul>\n<li>代码</li>\n</ul>\n<pre><code class=\"objectivec\">- (void)drawPlaceholderInRect:(CGRect)rect\n{\n    [self.placeholder drawInRect:CGRectMake(0, 2, rect.size.width, 25) withAttributes:@{ NSFontAttributeName: [UIFont systemFontOfSize:16.0],\n                                        NSForegroundColorAttributeName : [UIColor blueColor],\n                                     }];\n}\n</code></pre>\n<ul>\n<li>效果<br><img src=\"http://upload-images.jianshu.io/upload_images/2115041-cf46f67c604c2c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"placeholder\"></li>\n</ul>\n<p>##方法3</p>\n<ul>\n<li>自定义UITextField,利用runTime找出UITextFiled内部隐藏的成员变量和属性，利用KVC进行修改。</li>\n<li><p>说明：此种方式对于动态改变<code>placeholder</code>颜色较为方便。</p>\n</li>\n<li><p><strong>拓展代码</strong>（利用runTime找出成员变量和属性，程序中无需使用，只是帮助我们看清UITextField内部结构，知道其中的相关成员变量和属性，然后赋值即可）。</p>\n</li>\n</ul>\n<pre><code class=\"objectivec\">#import &quot;SJTextField.h&quot;\n#import &lt;objc/runtime.h&gt;\n@implementation SJTextField\n\n// 初始化调用一次 用于查看UITextField中的成员属性和变量\n+ (void)initialize\n{\n    [self getIvars];\n    // [self getProperties];\n}\n\n// 获取所有属性\n+ (void)getProperties\n{\n    unsigned int count = 0;\n    objc_property_t *properties = class_copyPropertyList([UITextField class], &amp;count);\n    for (int i = 0; i&lt;count; i++) {\n        // 取出属性\n        objc_property_t property = properties[i];\n\n        // 打印属性名字\n        NSLog(@&quot;%s&lt;----&gt;%s&quot;, property_getName(property), property_getAttributes(property));\n    }\n    free(properties);\n}\n\n// 获取所有成员变量\n+ (void)getIvars\n{\n    unsigned int count = 0;\n    // 拷贝出所有的成员变量列表\n    Ivar *ivars = class_copyIvarList([UITextField class], &amp;count);\n    for (int i = 0; i&lt;count; i++) {\n        // 取出成员变量\n        //        Ivar ivar = *(ivars + i);\n        Ivar ivar = ivars[i];\n\n        // 打印成员变量名字\n        NSLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));\n    }\n    // 释放\n    free(ivars);\n}\n@end\n</code></pre>\n<ul>\n<li><strong>拓展点</strong> 可以查到有两个关于<code>placeholder</code>的属性和变量，分别是<code>_placeholderLabel.textColor</code>和<code>_placeholderLabel</code>，故下面就是用来设置动态改变<code>placeholder</code>颜色的代码。</li>\n<li>代码（在自定义UITextField中）</li>\n</ul>\n<pre><code class=\"objectivec\">#import &quot;SJTextField.h&quot;\n#import &lt;objc/runtime.h&gt;\n@implementation SJTextField\nstatic NSString * const SJPlacerholderColorKeyPath = @&quot;_placeholderLabel.textColor&quot;;\n- (void)awakeFromNib\n{\n// 设置placeholder开始颜色（方式一）\n//    UILabel *placeholderLabel = [self valueForKeyPath:@&quot;_placeholderLabel&quot;];\n//    placeholderLabel.textColor = [UIColor redColor];   \n   // 设置placeholder开始颜色（方式二）\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    // 不成为第一响应者\n    [self resignFirstResponder];\n}\n\n/**\n * 当前文本框聚焦时就会调用\n */\n- (BOOL)becomeFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor redColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super becomeFirstResponder];\n}\n\n/**\n * 当前文本框失去焦点时就会调用\n */\n- (BOOL)resignFirstResponder\n{\n    // 修改占位文字颜色\n    [self setValue:[UIColor greenColor] forKeyPath:SJPlacerholderColorKeyPath];\n    return [super resignFirstResponder];\n}\n@end\n</code></pre>\n<ul>\n<li>效果</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-9c0ca6ff0ec7c261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"未进入编辑状态\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2115041-6c9aacd3d30f3655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进入编辑状态\"></p>\n<p>End.</p>\n"},{"title":"《招聘一个靠谱的iOS》面试题参考答案（下）","date":"2017-05-24T06:59:00.000Z","_content":"\n[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)—参考答案（下）\n\n\n说明：面试题来源是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)的这篇博文：[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)，其中共55题，除第一题为纠错题外，其他54道均为简答题。\n\n出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。\n\n答案为[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)整理，未经出题者校对，如有纰漏，请向[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)指正。\n\n----------\n\n# 索引\n\n\n 1. [ 25. `_objc_msgForward` 函数是做什么的，直接调用它将会发生什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#25-_objc_msgforward函数是做什么的直接调用它将会发生什么)\n 2. [26. runtime如何实现weak变量的自动置nil？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#26-runtime如何实现weak变量的自动置nil)\n 3.  [27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#27-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么) \n 4.  [28. runloop和线程有什么关系？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#28-runloop和线程有什么关系) \n 5.  [29. runloop的mode作用是什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#29-runloop的mode作用是什么) \n 6.  [30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#30-以-scheduledtimerwithtimeinterval的方式触发的timer在滑动页面上的列表时timer会暂定回调为什么如何解决) \n 7.  [31. 猜想runloop内部是如何实现的？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#31-猜想runloop内部是如何实现的) \n 8.  [32. objc使用什么机制管理对象内存？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#32-objc使用什么机制管理对象内存) \n 9.  [33. ARC通过什么方式帮助开发者管理内存？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#33-arc通过什么方式帮助开发者管理内存) \n 10.  [34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#34-不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建) \n 11.  [35. BAD_ACCESS在什么情况下出现？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#35-bad_access在什么情况下出现) \n 12.  [36. 苹果是如何实现autoreleasepool的？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#36-苹果是如何实现autoreleasepool的) \n 13.  [37. 使用block时什么情况会发生引用循环，如何解决？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#37-使用block时什么情况会发生引用循环如何解决)\n 14.  [38. 在block内如何修改block外部变量？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#38-在block内如何修改block外部变量) \n 15.  [39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#39-使用系统的某些block-api如uiview的block版本写动画时是否也考虑引用循环问题) \n 16.  [40. GCD的队列（dispatch_queue_t）分哪两种类型？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#40-gcd的队列dispatch_queue_t分哪两种类型) \n 17.   [41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#41-如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图) \n 18.  [42. dispatch_barrier_async的作用是什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#42-dispatch_barrier_async的作用是什么) \n 19.  [43. 苹果为什么要废弃dispatch_get_current_queue？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#43-苹果为什么要废弃dispatch_get_current_queue) \n 0.  [44. 以下代码运行结果如何？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#44-以下代码运行结果如何) \n\n ```Objective-C\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n ```\n\n 1.  [45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#45-addobserverforkeypathoptionscontext各个参数的作用分别是什么observer中需要实现哪个方法才能获得kvo回调) \n 2.  [46. 如何手动触发一个value的KVO](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo) \n 3.  [47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#47-若一个类有实例变量-nsstring-_foo-调用setvalueforkey时可以以foo还是-_foo-作为key) \n 4.  [48. KVC的keyPath中的集合运算符如何使用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#48-kvc的keypath中的集合运算符如何使用) \n 5.  [49. KVC和KVO的keyPath一定是属性么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#49-kvc和kvo的keypath一定是属性么) \n 6.  [50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#50-如何关闭默认的kvo的默认实现并进入自定义的kvo实现) \n 7.  [51. apple用什么方式实现对一个对象的KVO？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#51-apple用什么方式实现对一个对象的kvo) \n 8.  [52. IBOutlet连出来的视图属性为什么可以被设置成weak?](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#52-iboutlet连出来的视图属性为什么可以被设置成weak) \n 9.  [53. IB中User Defined Runtime Attributes如何使用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#53-ib中user-defined-runtime-attributes如何使用) \n 0.  [54. 如何调试BAD_ACCESS错误](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#54-如何调试bad_access错误) \n 1.  [55. lldb（gdb）常用的调试命令？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#55-lldbgdb常用的调试命令) \n\n\n\n\n\n\n\n\n\n\n----------\n\n\n### 25. `_objc_msgForward`函数是做什么的，直接调用它将会发生什么？\n\n> `_objc_msgForward`是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n我们可以这样创建一个`_objc_msgForward`对象：\n\n    IMP msgForwardIMP = _objc_msgForward;\n\n\n\n在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？》曾提到`objc_msgSend`在“消息传递”中的作用。在“消息传递”过程中，`objc_msgSend`的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用`_objc_msgForward`函数指针代替 IMP 。最后，执行这个 IMP 。\n\n\n\nObjective-C运行时是开源的，所以我们可以看到它的实现。打开[ ***Apple Open Source 里Mac代码里的obj包*** ](http://www.opensource.apple.com/tarballs/objc4/)下载一个最新版本，找到 `objc-runtime-new.mm`，进入之后搜索`_objc_msgForward`。\n\n![enter image description here](http://i.imgur.com/rGBfaoL.png)\n\n里面有对`_objc_msgForward`的功能解释：\n\n![enter image description here](http://i.imgur.com/vcThcdA.png)\n\n\n```Objective-C\n/***********************************************************************\n* lookUpImpOrForward.\n* The standard IMP lookup. \n* initialize==NO tries to avoid +initialize (but sometimes fails)\n* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)\n* Most callers should use initialize==YES and cache==YES.\n* inst is an instance of cls or a subclass thereof, or nil if none is known. \n*   If cls is an un-initialized metaclass then a non-nil inst is faster.\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n*   If you don't want forwarding at all, use lookUpImpOrNil() instead.\n**********************************************************************/\n```\n\n对 `objc-runtime-new.mm`文件里与`_objc_msgForward`有关的三个函数使用伪代码展示下：\n\n```Objective-C\n//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示\n//  Created by https://github.com/ChenYilong\n//  Copyright (c)  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/). All rights reserved.\n//  同时，这也是 obj_msgSend 的实现过程\n\nid objc_msgSend(id self, SEL op, ...) {\n    if (!self) return nil;\n\tIMP imp = class_getMethodImplementation(self->isa, SEL op);\n\timp(self, op, ...); //调用这个函数，伪代码...\n}\n \n//查找IMP\nIMP class_getMethodImplementation(Class cls, SEL sel) {\n    if (!cls || !sel) return nil;\n    IMP imp = lookUpImpOrNil(cls, sel);\n    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发\n    return imp;\n}\n \nIMP lookUpImpOrNil(Class cls, SEL sel) {\n    if (!cls->initialize()) {\n        _class_initialize(cls);\n    }\n \n    Class curClass = cls;\n    IMP imp = nil;\n    do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询\n        if (!curClass) break;\n        if (!curClass->cache) fill_cache(cls, curClass);\n        imp = cache_getImp(curClass, sel);\n        if (imp) break;\n    } while (curClass = curClass->superclass);\n \n    return imp;\n}\n```\n虽然Apple没有公开`_objc_msgForward`的实现源码，但是我们还是能得出结论：\n\n> `_objc_msgForward`是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n\n> 在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？》曾提到`objc_msgSend`在“消息传递”中的作用。在“消息传递”过程中，`objc_msgSend`的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用`_objc_msgForward`函数指针代替 IMP 。最后，执行这个 IMP 。\n\n\n\n为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下`_objc_msgForward`是如何进行转发的。\n\n首先开启调试模式、打印出所有运行时发送的消息：\n可以在代码里执行下面的方法：\n\n```Objective-C\n(void)instrumentObjcMessageSends(YES);\n```\n\n\n或者断点暂停程序运行，并在 gdb 中输入下面的命令：\n\n```Objective-C\ncall (void)instrumentObjcMessageSends(YES)\n```\n\n以第二种为例，操作如下所示：\n\n![enter image description here](http://i.imgur.com/uEwTCC4.png)\n\n\n之后，运行时发送的所有消息都会打印到`/tmp/msgSend-xxxx`文件里了。\n\n终端中输入命令前往：\n\n```Objective-C\nopen /private/tmp\n```\n\n\n\n\n\n![enter image description here](http://i.imgur.com/Fh5hhCw.png)\n\n\n\n可能看到有多条，找到最新生成的，双击打开\n\n\n\n在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：[ ***Can the messages sent to an object in Objective-C be monitored or printed out?*** ](http://stackoverflow.com/a/10750398/3395008)），向一个对象发送一条错误的消息：\n\n\n\n\n```Objective-C\n//\n//  main.m\n//  CYLObjcMsgForwardTest\n//\n//  Created by http://weibo.com/luohanchenyilong/.\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import <UIKit/UIKit.h>\n#import \"AppDelegate.h\"\n#import \"CYLTest.h\"\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOS程序犭袁))];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n```\n\n![enter image description here](http://i.imgur.com/UjbmVvB.png)\n\n\n你可以在`/tmp/msgSend-xxxx`（我这一次是`/tmp/msgSend-9805`）文件里，看到打印出来：\n\n\n\n![enter image description here](http://i.imgur.com/AAERz1T.png)\n\n\n \n```Objective-C\n+ CYLTest NSObject initialize\n+ CYLTest NSObject alloc\n- CYLTest NSObject init\n- CYLTest NSObject performSelector:\n+ CYLTest NSObject resolveInstanceMethod:\n+ CYLTest NSObject resolveInstanceMethod:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject class\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject class\n```\n\n\n\n结合[《NSObject官方文档》](https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11)，排除掉 NSObject 做的事，剩下的就是`_objc_msgForward`消息转发做的几件事：\n\n\n 1. 调用`resolveInstanceMethod:`方法 (或 `resolveClassMethod:`)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始`objc_msgSend`流程。这一次对象会响应这个选择器，一般是因为它已经调用过`class_addMethod`。如果仍没实现，继续下面的动作。\n\n 2. 调用`forwardingTargetForSelector:`方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。\n\n 3. 调用`methodSignatureForSelector:`方法，尝试获得一个方法签名。如果获取不到，则直接调用`doesNotRecognizeSelector`抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给`forwardInvocation:`。\n\n 4. 调用`forwardInvocation:`方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。\n\n 5. 调用`doesNotRecognizeSelector:` ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。\n\n上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的\n\n也就是说`_objc_msgForward`在进行消息转发的过程中会涉及以下这几个方法：\n\n 1. `resolveInstanceMethod:`方法 (或 `resolveClassMethod:`)。\n\n 2. `forwardingTargetForSelector:`方法\n\n 3. `methodSignatureForSelector:`方法\n\n 4. `forwardInvocation:`方法\n\n 5. `doesNotRecognizeSelector:` 方法\n\n为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ `_objc_msgForward_demo` ”,可运行起来看看。\n\n\n下面回答下第二个问题“直接`_objc_msgForward`调用它将会发生什么？”\n\n直接调用`_objc_msgForward`是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。\n\n就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。\n\n正如前文所说：\n\n> `_objc_msgForward`是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n如何调用`_objc_msgForward`？\n`_objc_msgForward`隶属 C 语言，有三个参数 ：\n\n|--| `_objc_msgForward`参数| 类型 |\n-------------|-------------|-------------\n 1.| 所属对象 | id类型\n 2. |方法名 | SEL类型 \n 3. |可变参数 |可变参数类型\n\n\n首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：\n\n为了直观，我们可以通过如下方式定义一个 IMP类型 ：\n\n```Objective-C\ntypedef void (*voidIMP)(id, SEL, ...)\n```\n一旦调用`_objc_msgForward`，将跳过查找 IMP 的过程，直接触发“消息转发”，\n\n如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`：\n\n\n> “我没有在这个对象里找到这个方法的实现”\n\n\n\n想象下`objc_msgSend`会怎么做？通常情况下，下面这张图就是你正常走`objc_msgSend`过程，和直接调用`_objc_msgForward`的前后差别：\n\n![enter image description here](http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif)\n\n有哪些场景需要直接调用`_objc_msgForward`？最常见的场景是：你想获取某方法所对应的`NSInvocation`对象。举例说明：\n\n[JSPatch （Github 链接）](https://github.com/bang590/JSPatch)就是直接调用`_objc_msgForward`来实现其核心功能的：\n\n>  JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。\n\n\n作者的博文[《JSPatch实现原理详解》](http://blog.cnbang.net/tech/2808/)详细记录了实现原理，有兴趣可以看下。\n\n同时 [ ***RAC(ReactiveCocoa)*** ](https://github.com/ReactiveCocoa/ReactiveCocoa) 源码中也用到了该方法。\n\n### 26. runtime如何实现weak变量的自动置nil？\n\n\n> runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《runtime 如何实现 weak 属性》有论述。（注：在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到`__weak`引用的解除时间。）\n\n我们可以设计一个函数（伪代码）来表示上述机制：\n\n`objc_storeWeak(&a, b)`函数：\n\n`objc_storeWeak`函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\n\n你可以把`objc_storeWeak(&a, b)`理解为：`objc_storeWeak(value, key)`，并且当key变nil，将value置nil。\n\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n而如果a是由assign修饰的，则：\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。\n\n\n下面我们将基于`objc_storeWeak(&a, b)`函数，使用伪代码模拟“runtime如何实现weak属性”：\n \n\n\n \n```Objective-C\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&obj1);\n```\n\n下面对用到的两个方法`objc_initWeak`和`objc_destroyWeak`做下解释：\n\n总体说来，作用是：\n通过`objc_initWeak`函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过`objc_destoryWeak`函数释放该变量（obj1）。\n\n下面分别介绍下方法的内部实现：\n\n`objc_initWeak`函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用`objc_storeWeak`函数。\n\n\n\n \n```Objective-C\nobj1 = 0；\nobj_storeWeak(&obj1, obj);\n```\n\n也就是说：\n\n>  weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\n\n\n\n\n然后`obj_destroyWeak`函数将0（nil）作为参数，调用`objc_storeWeak`函数。\n\n`objc_storeWeak(&obj1, 0);`\n\n前面的源代码与下列源代码相同。\n\n\n\n```Objective-C\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&obj1, 0);\n```\n\n\n`objc_storeWeak`函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。\n\n\n\n\n\n### 27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ \n\n - 不能向编译后得到的类中增加实例变量；\n - 能向运行时创建的类中添加实例变量；\n\n解释下：\n\n - 因为编译后的类已经注册在 runtime 中，类结构体中的 `objc_ivar_list` 实例变量的链表 和 `instance_size` 实例变量的内存大小已经确定，同时runtime 会调用 `class_setIvarLayout` 或 `class_setWeakIvarLayout` 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；\n\n - 运行时创建的类是可以添加实例变量，调用 `class_addIvar` 函数。但是得在调用 `objc_allocateClassPair` 之后，`objc_registerClassPair` 之前，原因同上。\n\n\n### 28. runloop和线程有什么关系？\n\n总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。\n\n runloop 和线程的关系：\n\n\n\n\n 1. 主线程的run loop默认是启动的。\n\n iOS的应用程序里面，程序启动后会有一个如下的main()函数\n \n ```Objective-C\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n\n\n\n\n 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。\n\n 2. 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。\n\n 3. 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。\n\n\n ```Objective-C\nNSRunLoop *runloop = [NSRunLoop currentRunLoop];\n```\n\n\n参考链接：[《Objective-C之run loop详解》](http://blog.csdn.net/wzzvictory/article/details/9237973)。\n\n### 29. runloop的mode作用是什么？\n\nmodel 主要是用来指定事件在运行循环中的优先级的，分为：\n\n\n* NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态\n* UITrackingRunLoopMode：ScrollView滑动时\n* UIInitializationRunLoopMode：启动时\n* NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合\n\n苹果公开提供的 Mode 有两个：\n\n 1. NSDefaultRunLoopMode（kCFRunLoopDefaultMode）\n 2. NSRunLoopCommonModes（kCFRunLoopCommonModes）\n\n### 30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\nRunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。\n\n如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,\nScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。\n\n同时因为mode还是可定制的，所以：\n\n Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：\n\n```objective-c\n// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n\n//将timer添加到NSDefaultRunLoopMode中\n[NSTimer scheduledTimerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n//然后再添加到NSRunLoopCommonModes里\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n\n### 31. 猜想runloop内部是如何实现的？\n\n> 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑\n是这样的：\n\n\n\n\n\tfunction loop() {\n\t    initialize();\n\t    do {\n\t        var message = get_next_message();\n\t        process_message(message);\n\t    } while (message != quit);\n\t}\n\n\n或使用伪代码来展示下:\n\n\t// \n\t// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n\t// https://github.com/ChenYilong\n\tint main(int argc, char * argv[]) {\n     //程序一直运行状态\n     while (AppIsRunning) {\n          //睡眠状态，等待唤醒事件\n          id whoWakesMe = SleepForWakingUp();\n          //得到唤醒事件\n          id event = GetEvent(whoWakesMe);\n          //开始处理事件\n          HandleEvent(event);\n     }\n     return 0;\n\t}\n\n参考链接：\n\n 1. [《深入理解RunLoop》](http://blog.ibireme.com/2015/05/18/runloop/#base)\n 2. 摘自博文[***CFRunLoop***](https://github.com/ming1016/study/wiki/CFRunLoop)，原作者是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)\n\n### 32. objc使用什么机制管理对象内存？\n\n通过 retainCount 的机制来决定对象是否需要释放。\n每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。\n\n### 33. ARC通过什么方式帮助开发者管理内存？\n <p><del>编译时根据代码上下文，插入 retain/release\n</del></p>\nARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。\n\n在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】\n###  34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n分两种情况：手动干预释放时机、系统自动去释放。\n\n\n 1. 手动干预释放时机--指定autoreleasepool\n 就是所谓的：当前作用域大括号结束时释放。\n 2. 系统自动去释放--不手动指定autoreleasepool\n\n  Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。\n\n释放的时机总结起来，可以用下图来表示：\n\n![autoreleasepool与 runloop 的关系图](http://i61.tinypic.com/28kodwp.jpg)\n\n下面对这张图进行详细的解释：\n\n\n从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。\n\n我们都知道：\n**所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。**\n\n但是如果每次都放进应用程序的 `main.m` 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？\n\n在一次完整的运行循环结束之前，会被销毁。\n\n那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 \n\n子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。\n\n自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。\n\n但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。\n\n\n@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。\n\n\n\n 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。\n\n\n\n\n\n参考链接：[《黑幕背后的Autorelease》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n\n###  35. BAD_ACCESS在什么情况下出现？\n访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。\n死循环\n###  36. 苹果是如何实现autoreleasepool的？ \n\nautoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.\n\n\n 1. `objc_autoreleasepoolPush`\n 2. `objc_autoreleasepoolPop`\n 3. `objc_autorelease`\n\n看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。\n\n举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：\n\n ![enter image description here](http://i60.tinypic.com/15mfj11.jpg)\n\n### 37. 使用block时什么情况会发生引用循环，如何解决？\n一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。\n\n解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用。\n\n\n\n 1. id weak weakSelf = self;\n\t或者 weak __typeof(&*self)weakSelf = self该方法可以设置宏\n 2. id __block weakSelf = self;\n\n或者将其中一方强制制空 `xxx = nil`。\n\n检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  [***FBRetainCycleDetector***](https://github.com/facebook/FBRetainCycleDetector) 。\n\n### 38. 在block内如何修改block外部变量？\n默认情况下，在block中访问的外部变量是复制过去的，即：**写操作不对原变量生效**。但是你可以加上 `__block` 来让其写操作生效，示例代码如下:\n\n\n ```Objective-C\n\t__block int a = 0;\n\tvoid (^foo)(void) = ^{ \n\t    a = 1; \n\t};\n\tfoo(); \n\t//这里，a的值被修改为1\n ```\n\n\n这是 [微博@唐巧_boy](http://weibo.com/tangqiaoboy)的《iOS开发进阶》中的第11.2.3章节中的描述。你同样可以在面试中这样回答，但你并没有答到“点子上”。真正的原因，并没有书这本书里写的这么“神奇”，而且这种说法也有点牵强。面试官肯定会追问“为什么写操作就生效了？”真正的原因是这样的：\n\n\n > 我们都知道：**Block不允许修改外部变量的值**，这里所说的外部变量的值，指的是栈中指针的内存地址。`__block` 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。\n\n**Block不允许修改外部变量的值**。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。\n\n我们可以打印下内存地址来进行验证：\n\n ```Objective-C\n    __block int a = 0;\n    NSLog(@\"定义前：%p\", &a);         //栈区\n    void (^foo)(void) = ^{\n        a = 1;\n        NSLog(@\"block内部：%p\", &a);    //堆区\n    };\n    NSLog(@\"定义后：%p\", &a);         //堆区\n    foo();\n ```\n\n ```Objective-C\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8\n ```\n \n \n“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。\n \n \n 那么如何证明“block内部”打印的是堆地址？\n \n 把三个16进制的内存地址转成10进制就是：\n \n 1. 定义后前：6171559672\n 2. block内部：5732708296\n 3. 定义后后：5732708296\n \n中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。\n\n这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 `__block` 关键字的真正作用。\n\n `__block` 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16  字节要多一倍）。\n\n理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：\n\n以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。\n      \n ```Objective-C\n    NSMutableString *a = [NSMutableString stringWithString:@\"Tom\"];\n    NSLog(@\"\\n 定以前：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n    void (^foo)(void) = ^{\n        a.string = @\"Jerry\";\n        NSLog(@\"\\n block内部：------------------------------------\\n\\\n         a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n        a = [NSMutableString stringWithString:@\"William\"];\n    };\n    foo();\n    NSLog(@\"\\n 定以后：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n    \n ```\n\n![enter image description here](http://i66.tinypic.com/34euhcy.jpg)\n\n\n 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。\n\n 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。\n\n上文已经说过：**Block不允许修改外部变量的值**，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。\n\n### 39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ \n\n系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：\n\n\n所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：\n\n ```Objective-C\n[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; \n ```\n\n\n\n ```Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; \n ```\n\n\n\n\n ```Objective-C\n[[NSNotificationCenter defaultCenter] addObserverForName:@\"someNotification\" \n                                                  object:nil \n                           queue:[NSOperationQueue mainQueue]\n                                              usingBlock:^(NSNotification * notification) {\n                                                    self.someProperty = xyz; }]; \n ```\n\n这些情况不需要考虑“引用循环”。\n\n\n但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：\n\n ```Objective-C\n__weak __typeof__(self) weakSelf = self;\ndispatch_group_async(_operationsGroup, _operationsQueue, ^\n{\n__typeof__(self) strongSelf = weakSelf;\n[strongSelf doSomething];\n[strongSelf doSomethingElse];\n} );\n ```\n类似的：\n\n ```Objective-C\n  __weak __typeof__(self) weakSelf = self;\n  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"testKey\"\n                                                                object:nil\n                                                                 queue:nil\n                                                            usingBlock:^(NSNotification *note) {\n      __typeof__(self) strongSelf = weakSelf;\n      [strongSelf dismissModalViewControllerAnimated:YES];\n  }];\n ```\nself --> _observer --> block --> self 显然这也是一个循环引用。\n\n检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  [***FBRetainCycleDetector***](https://github.com/facebook/FBRetainCycleDetector) 。\n### 40. GCD的队列（`dispatch_queue_t`）分哪两种类型？\n\n\n 1. 串行队列Serial Dispatch Queue\n 2. 并行队列Concurrent Dispatch Queue\n\n### 41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。\n\n```Objective-C\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, queue, ^{ /*加载图片1 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片2 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 合并图片\n});\n```\n### 42. `dispatch_barrier_async`的作用是什么？\n 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 \n `dispatch_barrier_async` 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 `dispatch_barrier_async` 函数追加的处理，等 `dispatch_barrier_async` 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。\n\n打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 `dispatch_barrier_async` 函数追加的内容就如同 “上完厕所就上高速”这个动作。\n\n（注意：使用 `dispatch_barrier_async` ，该函数只能搭配自定义并行队列 `dispatch_queue_t` 使用。不能使用： `dispatch_get_global_queue` ，否则 `dispatch_barrier_async` 的作用会和 `dispatch_async` 的作用一模一样。 ）\n\n\n### 43. 苹果为什么要废弃`dispatch_get_current_queue`？\n\n`dispatch_get_current_queue`容易造成死锁\n\n\n### 44. 以下代码运行结果如何？\n\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n\n只输出：1 。发生主线程锁死。\n\n\n### 45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n\n```Objective-C\n// 添加键值观察\n/*\n1 观察者，负责处理监听事件的对象\n2 观察的属性\n3 观察的选项\n4 上下文\n*/\n[self.person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@\"Person Name\"];\n```\nobserver中需要实现一下方法：\n\n\n\n```Objective-C\n// 所有的 kvo 监听到事件，都会调用此方法\n/*\n 1. 观察的属性\n 2. 观察的对象\n 3. change 属性变化字典（新／旧）\n 4. 上下文，与监听的时候传递的一致\n */\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;\n```\n\n### 46. 如何手动触发一个value的KVO\n\n所谓的“手动触发”是区别于“自动触发”：\n\n自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。\n\n想知道如何手动触发，必须知道自动触发 KVO 的原理：\n\n键值观察通知依赖于 NSObject 的两个方法:  `willChangeValueForKey:` 和 `didChangevlueForKey:` 。在一个被观察属性发生改变之前，  `willChangeValueForKey:` 一定会被调用，这就\n会记录旧的值。而当改变发生后，  `observeValueForKey:ofObject:change:context:` 会被调用，继而 `didChangeValueForKey:` 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。\n\n那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。\n\n具体做法如下：\n\n\n\n如果这个  `value` 是  表示时间的 `self.now` ，那么代码如下：最后两行代码缺一不可。\n\n相关代码已放在仓库里。\n\n ```Objective-C\n//  .m文件\n//  Created by https://github.com/ChenYilong\n//  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/).\n//  手动触发 value 的KVO，最后两行代码缺一不可。\n\n//@property (nonatomic, strong) NSDate *now;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _now = [NSDate date];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n ```\n\n但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：\n\n\n > 比如调用 `setNow:` 时，系统还会以某种方式在中间插入 `wilChangeValueForKey:` 、  `didChangeValueForKey:` 和 `observeValueForKeyPath:ofObject:change:context:` 的调用。\n\n\n大家可能以为这是因为 `setNow:` 是合成方法，有时候我们也能看到有人这么写代码:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n ```\n\n这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 `willChangeValueForKey:`  ，之后总是调用 `didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。\n\n参考链接： [Manual Change Notification---Apple 官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3) \n\n### 47. 若一个类有实例变量 `NSString *_foo` ，调用setValue:forKey:时，可以以foo还是 `_foo` 作为key？\n都可以。\n### 48. KVC的keyPath中的集合运算符如何使用？\n\n 1. 必须用在集合对象上或普通对象的集合属性上\n 2. 简单集合运算符有@avg， @count ， @max ， @min ，@sum，\n 3. 格式 @\"@sum.age\"或 @\"集合属性.@max.age\"\n\n### 49. KVC和KVO的keyPath一定是属性么？\nKVC 支持实例变量，KVO 只能手动支持[手动设定实例变量的KVO实现监听](https://yq.aliyun.com/articles/30483)\n### 50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n\n\n请参考：\n\n  1. [《如何自己动手实现 KVO》](http://tech.glowing.com/cn/implement-kvo/)\n  2. [**KVO for manually implemented properties**]( http://stackoverflow.com/a/10042641/3395008 ) \n\n### 51. apple用什么方式实现对一个对象的KVO？ \n\n\n\n[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)对 KVO 实现的描述：\n\n > Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...\n\n从[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：\n\n > 当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 ` isa 混写（isa-swizzling）` 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：\n\n![enter image description here](http://i62.tinypic.com/sy57ur.jpg)\n\n KVO 确实有点黑魔法：\n\n\n > Apple 使用了 ` isa 混写（isa-swizzling）`来实现 KVO 。\n\n\n下面做下详细解释：\n\n键值观察通知依赖于 NSObject 的两个方法:  `willChangeValueForKey:` 和 `didChangevlueForKey:` 。在一个被观察属性发生改变之前，  `willChangeValueForKey:` 一定会被调用，这就会记录旧的值。而当改变发生后， `observeValueForKey:ofObject:change:context:` 会被调用，继而  `didChangeValueForKey:` 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。\n\n 比如调用 `setNow:` 时，系统还会以某种方式在中间插入 `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` 的调用。大家可能以为这是因为 `setNow:` 是合成方法，有时候我们也能看到有人这么写代码:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n ```\n\n这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 `willChangeValueForKey:`  ，之后总是调用 `didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 `addObserver:forKeyPath:options:context:` 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"];\n    [super setValue:aDate forKey:@\"now\"];\n    [self didChangeValueForKey:@\"now\"];\n}\n ```\n这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。\n\nKVO 在实现中通过 ` isa 混写（isa-swizzling）` 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)可以得到印证：\n\n > Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...\n\n\n然而 KVO 在实现中使用了 ` isa 混写（ isa-swizzling）` ，这个的确不是很容易发现：Apple 还重写、覆盖了 `-class` 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。\n\n但是，假设“被监听的对象”的类对象是 `MYClass` ，有时候我们能看到对 `NSKVONotifying_MYClass` 的引用而不是对  `MYClass`  的引用。借此我们得以知道 Apple 使用了 ` isa 混写（isa-swizzling）`。具体探究过程可参考[ 这篇博文 ](https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html)。\n\n\n那么 `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` 这三个方法的执行顺序是怎样的呢？\n\n `wilChangeValueForKey:` 、  `didChangeValueForKey:` 很好理解，`observeValueForKeyPath:ofObject:change:context:` 的执行时机是什么时候呢？\n\n 先看一个例子：\n\n代码已放在仓库里。\n\n ```Objective-C\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    NSLog(@\"3\");\n}\n\n ```\n\n![enter image description here](http://i66.tinypic.com/ncm7th.jpg)\n\n\n如果单单从下面这个例子的打印上， \n\n顺序似乎是 `wilChangeValueForKey:` 、 `observeValueForKeyPath:ofObject:change:context:` 、 `didChangeValueForKey:` 。\n\n其实不然，这里有一个 `observeValueForKeyPath:ofObject:change:context:`  , 和 `didChangeValueForKey:` 到底谁先调用的问题：如果 `observeValueForKeyPath:ofObject:change:context:` 是在 `didChangeValueForKey:` 内部触发的操作呢？ 那么顺序就是： `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` \n\n不信你把 `didChangeValueForKey:` 注视掉，看下 `observeValueForKeyPath:ofObject:change:context:` 会不会执行。\n\n了解到这一点很重要，正如  [46. 如何手动触发一个value的KVO](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo)  所说的：\n\n“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。\n\n而“回调的调用时机”就是在你调用 `didChangeValueForKey:` 方法时。\n\n### 52. IBOutlet连出来的视图属性为什么可以被设置成weak?\n\n参考链接：[ ***Should IBOutlets be strong or weak under ARC?*** ](http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc)\n\n文章告诉我们：\n\n> 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。\n\n\n不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系\n\n### 53. IB中User Defined Runtime Attributes如何使用？ \n\n它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller\n\n\n### 54. 如何调试BAD_ACCESS错误\n\n\n 1. 重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object\n 2. 通过 Zombie \n![enter image description here](http://i.stack.imgur.com/ZAdi0.png)\n\n 3. 设置全局断点快速定位问题代码所在行\n 4. Xcode 7 已经集成了BAD_ACCESS捕获功能：**Address Sanitizer**。\n用法如下：在配置中勾选✅Enable Address Sanitizer\n ![enter image description here](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png)\n\n### 55. lldb（gdb）常用的调试命令？\n\n - breakpoint 设置断点定位到某一个函数\n - n 断点指针下一步\n - po打印对象\n\n更多 lldb（gdb） 调试命令可查看\n\n\n 1. [ ***The LLDB Debugger*** ](http://lldb.llvm.org/lldb-gdb.html)；\n 2. 苹果官方文档：[ ***iOS Debugging Magic*** ](https://developer.apple.com/library/ios/technotes/tn2239/_index.html)。\n\n\n----------\n\n\nPosted by [微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)  \n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 3.0](http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)\n\n\n","source":"_posts/《招聘一个靠谱的iOS》面试题参考答案（下）.md","raw":"---\ntitle: 《招聘一个靠谱的iOS》面试题参考答案（下）\ndate: 2017-05-24 14:59:00\ncategories: \n\t- 面试经\n---\n\n[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)—参考答案（下）\n\n\n说明：面试题来源是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)的这篇博文：[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)，其中共55题，除第一题为纠错题外，其他54道均为简答题。\n\n出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。\n\n答案为[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)整理，未经出题者校对，如有纰漏，请向[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)指正。\n\n----------\n\n# 索引\n\n\n 1. [ 25. `_objc_msgForward` 函数是做什么的，直接调用它将会发生什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#25-_objc_msgforward函数是做什么的直接调用它将会发生什么)\n 2. [26. runtime如何实现weak变量的自动置nil？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#26-runtime如何实现weak变量的自动置nil)\n 3.  [27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#27-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么) \n 4.  [28. runloop和线程有什么关系？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#28-runloop和线程有什么关系) \n 5.  [29. runloop的mode作用是什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#29-runloop的mode作用是什么) \n 6.  [30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#30-以-scheduledtimerwithtimeinterval的方式触发的timer在滑动页面上的列表时timer会暂定回调为什么如何解决) \n 7.  [31. 猜想runloop内部是如何实现的？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#31-猜想runloop内部是如何实现的) \n 8.  [32. objc使用什么机制管理对象内存？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#32-objc使用什么机制管理对象内存) \n 9.  [33. ARC通过什么方式帮助开发者管理内存？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#33-arc通过什么方式帮助开发者管理内存) \n 10.  [34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#34-不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建) \n 11.  [35. BAD_ACCESS在什么情况下出现？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#35-bad_access在什么情况下出现) \n 12.  [36. 苹果是如何实现autoreleasepool的？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#36-苹果是如何实现autoreleasepool的) \n 13.  [37. 使用block时什么情况会发生引用循环，如何解决？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#37-使用block时什么情况会发生引用循环如何解决)\n 14.  [38. 在block内如何修改block外部变量？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#38-在block内如何修改block外部变量) \n 15.  [39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#39-使用系统的某些block-api如uiview的block版本写动画时是否也考虑引用循环问题) \n 16.  [40. GCD的队列（dispatch_queue_t）分哪两种类型？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#40-gcd的队列dispatch_queue_t分哪两种类型) \n 17.   [41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#41-如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图) \n 18.  [42. dispatch_barrier_async的作用是什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#42-dispatch_barrier_async的作用是什么) \n 19.  [43. 苹果为什么要废弃dispatch_get_current_queue？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#43-苹果为什么要废弃dispatch_get_current_queue) \n 0.  [44. 以下代码运行结果如何？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#44-以下代码运行结果如何) \n\n ```Objective-C\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@\"1\");\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"2\");\n    });\n    NSLog(@\"3\");\n}\n ```\n\n 1.  [45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#45-addobserverforkeypathoptionscontext各个参数的作用分别是什么observer中需要实现哪个方法才能获得kvo回调) \n 2.  [46. 如何手动触发一个value的KVO](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo) \n 3.  [47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#47-若一个类有实例变量-nsstring-_foo-调用setvalueforkey时可以以foo还是-_foo-作为key) \n 4.  [48. KVC的keyPath中的集合运算符如何使用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#48-kvc的keypath中的集合运算符如何使用) \n 5.  [49. KVC和KVO的keyPath一定是属性么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#49-kvc和kvo的keypath一定是属性么) \n 6.  [50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#50-如何关闭默认的kvo的默认实现并进入自定义的kvo实现) \n 7.  [51. apple用什么方式实现对一个对象的KVO？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#51-apple用什么方式实现对一个对象的kvo) \n 8.  [52. IBOutlet连出来的视图属性为什么可以被设置成weak?](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#52-iboutlet连出来的视图属性为什么可以被设置成weak) \n 9.  [53. IB中User Defined Runtime Attributes如何使用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#53-ib中user-defined-runtime-attributes如何使用) \n 0.  [54. 如何调试BAD_ACCESS错误](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#54-如何调试bad_access错误) \n 1.  [55. lldb（gdb）常用的调试命令？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#55-lldbgdb常用的调试命令) \n\n\n\n\n\n\n\n\n\n\n----------\n\n\n### 25. `_objc_msgForward`函数是做什么的，直接调用它将会发生什么？\n\n> `_objc_msgForward`是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n我们可以这样创建一个`_objc_msgForward`对象：\n\n    IMP msgForwardIMP = _objc_msgForward;\n\n\n\n在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？》曾提到`objc_msgSend`在“消息传递”中的作用。在“消息传递”过程中，`objc_msgSend`的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用`_objc_msgForward`函数指针代替 IMP 。最后，执行这个 IMP 。\n\n\n\nObjective-C运行时是开源的，所以我们可以看到它的实现。打开[ ***Apple Open Source 里Mac代码里的obj包*** ](http://www.opensource.apple.com/tarballs/objc4/)下载一个最新版本，找到 `objc-runtime-new.mm`，进入之后搜索`_objc_msgForward`。\n\n![enter image description here](http://i.imgur.com/rGBfaoL.png)\n\n里面有对`_objc_msgForward`的功能解释：\n\n![enter image description here](http://i.imgur.com/vcThcdA.png)\n\n\n```Objective-C\n/***********************************************************************\n* lookUpImpOrForward.\n* The standard IMP lookup. \n* initialize==NO tries to avoid +initialize (but sometimes fails)\n* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)\n* Most callers should use initialize==YES and cache==YES.\n* inst is an instance of cls or a subclass thereof, or nil if none is known. \n*   If cls is an un-initialized metaclass then a non-nil inst is faster.\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n*   If you don't want forwarding at all, use lookUpImpOrNil() instead.\n**********************************************************************/\n```\n\n对 `objc-runtime-new.mm`文件里与`_objc_msgForward`有关的三个函数使用伪代码展示下：\n\n```Objective-C\n//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示\n//  Created by https://github.com/ChenYilong\n//  Copyright (c)  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/). All rights reserved.\n//  同时，这也是 obj_msgSend 的实现过程\n\nid objc_msgSend(id self, SEL op, ...) {\n    if (!self) return nil;\n\tIMP imp = class_getMethodImplementation(self->isa, SEL op);\n\timp(self, op, ...); //调用这个函数，伪代码...\n}\n \n//查找IMP\nIMP class_getMethodImplementation(Class cls, SEL sel) {\n    if (!cls || !sel) return nil;\n    IMP imp = lookUpImpOrNil(cls, sel);\n    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发\n    return imp;\n}\n \nIMP lookUpImpOrNil(Class cls, SEL sel) {\n    if (!cls->initialize()) {\n        _class_initialize(cls);\n    }\n \n    Class curClass = cls;\n    IMP imp = nil;\n    do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询\n        if (!curClass) break;\n        if (!curClass->cache) fill_cache(cls, curClass);\n        imp = cache_getImp(curClass, sel);\n        if (imp) break;\n    } while (curClass = curClass->superclass);\n \n    return imp;\n}\n```\n虽然Apple没有公开`_objc_msgForward`的实现源码，但是我们还是能得出结论：\n\n> `_objc_msgForward`是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n\n> 在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《objc中向一个对象发送消息`[obj foo]`和`objc_msgSend()`函数之间有什么关系？》曾提到`objc_msgSend`在“消息传递”中的作用。在“消息传递”过程中，`objc_msgSend`的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用`_objc_msgForward`函数指针代替 IMP 。最后，执行这个 IMP 。\n\n\n\n为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下`_objc_msgForward`是如何进行转发的。\n\n首先开启调试模式、打印出所有运行时发送的消息：\n可以在代码里执行下面的方法：\n\n```Objective-C\n(void)instrumentObjcMessageSends(YES);\n```\n\n\n或者断点暂停程序运行，并在 gdb 中输入下面的命令：\n\n```Objective-C\ncall (void)instrumentObjcMessageSends(YES)\n```\n\n以第二种为例，操作如下所示：\n\n![enter image description here](http://i.imgur.com/uEwTCC4.png)\n\n\n之后，运行时发送的所有消息都会打印到`/tmp/msgSend-xxxx`文件里了。\n\n终端中输入命令前往：\n\n```Objective-C\nopen /private/tmp\n```\n\n\n\n\n\n![enter image description here](http://i.imgur.com/Fh5hhCw.png)\n\n\n\n可能看到有多条，找到最新生成的，双击打开\n\n\n\n在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：[ ***Can the messages sent to an object in Objective-C be monitored or printed out?*** ](http://stackoverflow.com/a/10750398/3395008)），向一个对象发送一条错误的消息：\n\n\n\n\n```Objective-C\n//\n//  main.m\n//  CYLObjcMsgForwardTest\n//\n//  Created by http://weibo.com/luohanchenyilong/.\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import <UIKit/UIKit.h>\n#import \"AppDelegate.h\"\n#import \"CYLTest.h\"\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOS程序犭袁))];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n```\n\n![enter image description here](http://i.imgur.com/UjbmVvB.png)\n\n\n你可以在`/tmp/msgSend-xxxx`（我这一次是`/tmp/msgSend-9805`）文件里，看到打印出来：\n\n\n\n![enter image description here](http://i.imgur.com/AAERz1T.png)\n\n\n \n```Objective-C\n+ CYLTest NSObject initialize\n+ CYLTest NSObject alloc\n- CYLTest NSObject init\n- CYLTest NSObject performSelector:\n+ CYLTest NSObject resolveInstanceMethod:\n+ CYLTest NSObject resolveInstanceMethod:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject class\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject class\n```\n\n\n\n结合[《NSObject官方文档》](https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11)，排除掉 NSObject 做的事，剩下的就是`_objc_msgForward`消息转发做的几件事：\n\n\n 1. 调用`resolveInstanceMethod:`方法 (或 `resolveClassMethod:`)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始`objc_msgSend`流程。这一次对象会响应这个选择器，一般是因为它已经调用过`class_addMethod`。如果仍没实现，继续下面的动作。\n\n 2. 调用`forwardingTargetForSelector:`方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。\n\n 3. 调用`methodSignatureForSelector:`方法，尝试获得一个方法签名。如果获取不到，则直接调用`doesNotRecognizeSelector`抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给`forwardInvocation:`。\n\n 4. 调用`forwardInvocation:`方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。\n\n 5. 调用`doesNotRecognizeSelector:` ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。\n\n上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的\n\n也就是说`_objc_msgForward`在进行消息转发的过程中会涉及以下这几个方法：\n\n 1. `resolveInstanceMethod:`方法 (或 `resolveClassMethod:`)。\n\n 2. `forwardingTargetForSelector:`方法\n\n 3. `methodSignatureForSelector:`方法\n\n 4. `forwardInvocation:`方法\n\n 5. `doesNotRecognizeSelector:` 方法\n\n为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ `_objc_msgForward_demo` ”,可运行起来看看。\n\n\n下面回答下第二个问题“直接`_objc_msgForward`调用它将会发生什么？”\n\n直接调用`_objc_msgForward`是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。\n\n就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。\n\n正如前文所说：\n\n> `_objc_msgForward`是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，`_objc_msgForward`会尝试做消息转发。\n\n如何调用`_objc_msgForward`？\n`_objc_msgForward`隶属 C 语言，有三个参数 ：\n\n|--| `_objc_msgForward`参数| 类型 |\n-------------|-------------|-------------\n 1.| 所属对象 | id类型\n 2. |方法名 | SEL类型 \n 3. |可变参数 |可变参数类型\n\n\n首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：\n\n为了直观，我们可以通过如下方式定义一个 IMP类型 ：\n\n```Objective-C\ntypedef void (*voidIMP)(id, SEL, ...)\n```\n一旦调用`_objc_msgForward`，将跳过查找 IMP 的过程，直接触发“消息转发”，\n\n如果调用了`_objc_msgForward`，即使这个对象确实已经实现了这个方法，你也会告诉`objc_msgSend`：\n\n\n> “我没有在这个对象里找到这个方法的实现”\n\n\n\n想象下`objc_msgSend`会怎么做？通常情况下，下面这张图就是你正常走`objc_msgSend`过程，和直接调用`_objc_msgForward`的前后差别：\n\n![enter image description here](http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif)\n\n有哪些场景需要直接调用`_objc_msgForward`？最常见的场景是：你想获取某方法所对应的`NSInvocation`对象。举例说明：\n\n[JSPatch （Github 链接）](https://github.com/bang590/JSPatch)就是直接调用`_objc_msgForward`来实现其核心功能的：\n\n>  JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。\n\n\n作者的博文[《JSPatch实现原理详解》](http://blog.cnbang.net/tech/2808/)详细记录了实现原理，有兴趣可以看下。\n\n同时 [ ***RAC(ReactiveCocoa)*** ](https://github.com/ReactiveCocoa/ReactiveCocoa) 源码中也用到了该方法。\n\n### 26. runtime如何实现weak变量的自动置nil？\n\n\n> runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)中的《runtime 如何实现 weak 属性》有论述。（注：在[上篇](https://github.com/ChenYilong/iOSInterviewQuestions)的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到`__weak`引用的解除时间。）\n\n我们可以设计一个函数（伪代码）来表示上述机制：\n\n`objc_storeWeak(&a, b)`函数：\n\n`objc_storeWeak`函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\n\n你可以把`objc_storeWeak(&a, b)`理解为：`objc_storeWeak(value, key)`，并且当key变nil，将value置nil。\n\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n而如果a是由assign修饰的，则：\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。\n\n\n下面我们将基于`objc_storeWeak(&a, b)`函数，使用伪代码模拟“runtime如何实现weak属性”：\n \n\n\n \n```Objective-C\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&obj1);\n```\n\n下面对用到的两个方法`objc_initWeak`和`objc_destroyWeak`做下解释：\n\n总体说来，作用是：\n通过`objc_initWeak`函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过`objc_destoryWeak`函数释放该变量（obj1）。\n\n下面分别介绍下方法的内部实现：\n\n`objc_initWeak`函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用`objc_storeWeak`函数。\n\n\n\n \n```Objective-C\nobj1 = 0；\nobj_storeWeak(&obj1, obj);\n```\n\n也就是说：\n\n>  weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\n\n\n\n\n然后`obj_destroyWeak`函数将0（nil）作为参数，调用`objc_storeWeak`函数。\n\n`objc_storeWeak(&obj1, 0);`\n\n前面的源代码与下列源代码相同。\n\n\n\n```Objective-C\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&obj1, 0);\n```\n\n\n`objc_storeWeak`函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。\n\n\n\n\n\n### 27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ \n\n - 不能向编译后得到的类中增加实例变量；\n - 能向运行时创建的类中添加实例变量；\n\n解释下：\n\n - 因为编译后的类已经注册在 runtime 中，类结构体中的 `objc_ivar_list` 实例变量的链表 和 `instance_size` 实例变量的内存大小已经确定，同时runtime 会调用 `class_setIvarLayout` 或 `class_setWeakIvarLayout` 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；\n\n - 运行时创建的类是可以添加实例变量，调用 `class_addIvar` 函数。但是得在调用 `objc_allocateClassPair` 之后，`objc_registerClassPair` 之前，原因同上。\n\n\n### 28. runloop和线程有什么关系？\n\n总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。\n\n runloop 和线程的关系：\n\n\n\n\n 1. 主线程的run loop默认是启动的。\n\n iOS的应用程序里面，程序启动后会有一个如下的main()函数\n \n ```Objective-C\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n\n\n\n\n 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。\n\n 2. 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。\n\n 3. 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。\n\n\n ```Objective-C\nNSRunLoop *runloop = [NSRunLoop currentRunLoop];\n```\n\n\n参考链接：[《Objective-C之run loop详解》](http://blog.csdn.net/wzzvictory/article/details/9237973)。\n\n### 29. runloop的mode作用是什么？\n\nmodel 主要是用来指定事件在运行循环中的优先级的，分为：\n\n\n* NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态\n* UITrackingRunLoopMode：ScrollView滑动时\n* UIInitializationRunLoopMode：启动时\n* NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合\n\n苹果公开提供的 Mode 有两个：\n\n 1. NSDefaultRunLoopMode（kCFRunLoopDefaultMode）\n 2. NSRunLoopCommonModes（kCFRunLoopCommonModes）\n\n### 30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\nRunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。\n\n如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,\nScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。\n\n同时因为mode还是可定制的，所以：\n\n Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：\n\n```objective-c\n// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n\n//将timer添加到NSDefaultRunLoopMode中\n[NSTimer scheduledTimerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n//然后再添加到NSRunLoopCommonModes里\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n\n### 31. 猜想runloop内部是如何实现的？\n\n> 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑\n是这样的：\n\n\n\n\n\tfunction loop() {\n\t    initialize();\n\t    do {\n\t        var message = get_next_message();\n\t        process_message(message);\n\t    } while (message != quit);\n\t}\n\n\n或使用伪代码来展示下:\n\n\t// \n\t// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n\t// https://github.com/ChenYilong\n\tint main(int argc, char * argv[]) {\n     //程序一直运行状态\n     while (AppIsRunning) {\n          //睡眠状态，等待唤醒事件\n          id whoWakesMe = SleepForWakingUp();\n          //得到唤醒事件\n          id event = GetEvent(whoWakesMe);\n          //开始处理事件\n          HandleEvent(event);\n     }\n     return 0;\n\t}\n\n参考链接：\n\n 1. [《深入理解RunLoop》](http://blog.ibireme.com/2015/05/18/runloop/#base)\n 2. 摘自博文[***CFRunLoop***](https://github.com/ming1016/study/wiki/CFRunLoop)，原作者是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)\n\n### 32. objc使用什么机制管理对象内存？\n\n通过 retainCount 的机制来决定对象是否需要释放。\n每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。\n\n### 33. ARC通过什么方式帮助开发者管理内存？\n <p><del>编译时根据代码上下文，插入 retain/release\n</del></p>\nARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。\n\n在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】\n###  34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n分两种情况：手动干预释放时机、系统自动去释放。\n\n\n 1. 手动干预释放时机--指定autoreleasepool\n 就是所谓的：当前作用域大括号结束时释放。\n 2. 系统自动去释放--不手动指定autoreleasepool\n\n  Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。\n\n释放的时机总结起来，可以用下图来表示：\n\n![autoreleasepool与 runloop 的关系图](http://i61.tinypic.com/28kodwp.jpg)\n\n下面对这张图进行详细的解释：\n\n\n从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。\n\n我们都知道：\n**所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。**\n\n但是如果每次都放进应用程序的 `main.m` 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？\n\n在一次完整的运行循环结束之前，会被销毁。\n\n那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 \n\n子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。\n\n自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。\n\n但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。\n\n\n@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。\n\n\n\n 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。\n\n\n\n\n\n参考链接：[《黑幕背后的Autorelease》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n\n###  35. BAD_ACCESS在什么情况下出现？\n访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。\n死循环\n###  36. 苹果是如何实现autoreleasepool的？ \n\nautoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.\n\n\n 1. `objc_autoreleasepoolPush`\n 2. `objc_autoreleasepoolPop`\n 3. `objc_autorelease`\n\n看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。\n\n举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：\n\n ![enter image description here](http://i60.tinypic.com/15mfj11.jpg)\n\n### 37. 使用block时什么情况会发生引用循环，如何解决？\n一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。\n\n解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用。\n\n\n\n 1. id weak weakSelf = self;\n\t或者 weak __typeof(&*self)weakSelf = self该方法可以设置宏\n 2. id __block weakSelf = self;\n\n或者将其中一方强制制空 `xxx = nil`。\n\n检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  [***FBRetainCycleDetector***](https://github.com/facebook/FBRetainCycleDetector) 。\n\n### 38. 在block内如何修改block外部变量？\n默认情况下，在block中访问的外部变量是复制过去的，即：**写操作不对原变量生效**。但是你可以加上 `__block` 来让其写操作生效，示例代码如下:\n\n\n ```Objective-C\n\t__block int a = 0;\n\tvoid (^foo)(void) = ^{ \n\t    a = 1; \n\t};\n\tfoo(); \n\t//这里，a的值被修改为1\n ```\n\n\n这是 [微博@唐巧_boy](http://weibo.com/tangqiaoboy)的《iOS开发进阶》中的第11.2.3章节中的描述。你同样可以在面试中这样回答，但你并没有答到“点子上”。真正的原因，并没有书这本书里写的这么“神奇”，而且这种说法也有点牵强。面试官肯定会追问“为什么写操作就生效了？”真正的原因是这样的：\n\n\n > 我们都知道：**Block不允许修改外部变量的值**，这里所说的外部变量的值，指的是栈中指针的内存地址。`__block` 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。\n\n**Block不允许修改外部变量的值**。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。\n\n我们可以打印下内存地址来进行验证：\n\n ```Objective-C\n    __block int a = 0;\n    NSLog(@\"定义前：%p\", &a);         //栈区\n    void (^foo)(void) = ^{\n        a = 1;\n        NSLog(@\"block内部：%p\", &a);    //堆区\n    };\n    NSLog(@\"定义后：%p\", &a);         //堆区\n    foo();\n ```\n\n ```Objective-C\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8\n ```\n \n \n“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。\n \n \n 那么如何证明“block内部”打印的是堆地址？\n \n 把三个16进制的内存地址转成10进制就是：\n \n 1. 定义后前：6171559672\n 2. block内部：5732708296\n 3. 定义后后：5732708296\n \n中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。\n\n这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 `__block` 关键字的真正作用。\n\n `__block` 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16  字节要多一倍）。\n\n理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：\n\n以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。\n      \n ```Objective-C\n    NSMutableString *a = [NSMutableString stringWithString:@\"Tom\"];\n    NSLog(@\"\\n 定以前：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n    void (^foo)(void) = ^{\n        a.string = @\"Jerry\";\n        NSLog(@\"\\n block内部：------------------------------------\\n\\\n         a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n        a = [NSMutableString stringWithString:@\"William\"];\n    };\n    foo();\n    NSLog(@\"\\n 定以后：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n    \n ```\n\n![enter image description here](http://i66.tinypic.com/34euhcy.jpg)\n\n\n 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。\n\n 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。\n\n上文已经说过：**Block不允许修改外部变量的值**，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。\n\n### 39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ \n\n系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：\n\n\n所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：\n\n ```Objective-C\n[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; \n ```\n\n\n\n ```Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; \n ```\n\n\n\n\n ```Objective-C\n[[NSNotificationCenter defaultCenter] addObserverForName:@\"someNotification\" \n                                                  object:nil \n                           queue:[NSOperationQueue mainQueue]\n                                              usingBlock:^(NSNotification * notification) {\n                                                    self.someProperty = xyz; }]; \n ```\n\n这些情况不需要考虑“引用循环”。\n\n\n但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：\n\n ```Objective-C\n__weak __typeof__(self) weakSelf = self;\ndispatch_group_async(_operationsGroup, _operationsQueue, ^\n{\n__typeof__(self) strongSelf = weakSelf;\n[strongSelf doSomething];\n[strongSelf doSomethingElse];\n} );\n ```\n类似的：\n\n ```Objective-C\n  __weak __typeof__(self) weakSelf = self;\n  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"testKey\"\n                                                                object:nil\n                                                                 queue:nil\n                                                            usingBlock:^(NSNotification *note) {\n      __typeof__(self) strongSelf = weakSelf;\n      [strongSelf dismissModalViewControllerAnimated:YES];\n  }];\n ```\nself --> _observer --> block --> self 显然这也是一个循环引用。\n\n检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  [***FBRetainCycleDetector***](https://github.com/facebook/FBRetainCycleDetector) 。\n### 40. GCD的队列（`dispatch_queue_t`）分哪两种类型？\n\n\n 1. 串行队列Serial Dispatch Queue\n 2. 并行队列Concurrent Dispatch Queue\n\n### 41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。\n\n```Objective-C\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, queue, ^{ /*加载图片1 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片2 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 合并图片\n});\n```\n### 42. `dispatch_barrier_async`的作用是什么？\n 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 \n `dispatch_barrier_async` 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 `dispatch_barrier_async` 函数追加的处理，等 `dispatch_barrier_async` 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。\n\n打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 `dispatch_barrier_async` 函数追加的内容就如同 “上完厕所就上高速”这个动作。\n\n（注意：使用 `dispatch_barrier_async` ，该函数只能搭配自定义并行队列 `dispatch_queue_t` 使用。不能使用： `dispatch_get_global_queue` ，否则 `dispatch_barrier_async` 的作用会和 `dispatch_async` 的作用一模一样。 ）\n\n\n### 43. 苹果为什么要废弃`dispatch_get_current_queue`？\n\n`dispatch_get_current_queue`容易造成死锁\n\n\n### 44. 以下代码运行结果如何？\n\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n\n只输出：1 。发生主线程锁死。\n\n\n### 45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n\n```Objective-C\n// 添加键值观察\n/*\n1 观察者，负责处理监听事件的对象\n2 观察的属性\n3 观察的选项\n4 上下文\n*/\n[self.person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@\"Person Name\"];\n```\nobserver中需要实现一下方法：\n\n\n\n```Objective-C\n// 所有的 kvo 监听到事件，都会调用此方法\n/*\n 1. 观察的属性\n 2. 观察的对象\n 3. change 属性变化字典（新／旧）\n 4. 上下文，与监听的时候传递的一致\n */\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;\n```\n\n### 46. 如何手动触发一个value的KVO\n\n所谓的“手动触发”是区别于“自动触发”：\n\n自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。\n\n想知道如何手动触发，必须知道自动触发 KVO 的原理：\n\n键值观察通知依赖于 NSObject 的两个方法:  `willChangeValueForKey:` 和 `didChangevlueForKey:` 。在一个被观察属性发生改变之前，  `willChangeValueForKey:` 一定会被调用，这就\n会记录旧的值。而当改变发生后，  `observeValueForKey:ofObject:change:context:` 会被调用，继而 `didChangeValueForKey:` 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。\n\n那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。\n\n具体做法如下：\n\n\n\n如果这个  `value` 是  表示时间的 `self.now` ，那么代码如下：最后两行代码缺一不可。\n\n相关代码已放在仓库里。\n\n ```Objective-C\n//  .m文件\n//  Created by https://github.com/ChenYilong\n//  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/).\n//  手动触发 value 的KVO，最后两行代码缺一不可。\n\n//@property (nonatomic, strong) NSDate *now;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _now = [NSDate date];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n ```\n\n但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：\n\n\n > 比如调用 `setNow:` 时，系统还会以某种方式在中间插入 `wilChangeValueForKey:` 、  `didChangeValueForKey:` 和 `observeValueForKeyPath:ofObject:change:context:` 的调用。\n\n\n大家可能以为这是因为 `setNow:` 是合成方法，有时候我们也能看到有人这么写代码:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n ```\n\n这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 `willChangeValueForKey:`  ，之后总是调用 `didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。\n\n参考链接： [Manual Change Notification---Apple 官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3) \n\n### 47. 若一个类有实例变量 `NSString *_foo` ，调用setValue:forKey:时，可以以foo还是 `_foo` 作为key？\n都可以。\n### 48. KVC的keyPath中的集合运算符如何使用？\n\n 1. 必须用在集合对象上或普通对象的集合属性上\n 2. 简单集合运算符有@avg， @count ， @max ， @min ，@sum，\n 3. 格式 @\"@sum.age\"或 @\"集合属性.@max.age\"\n\n### 49. KVC和KVO的keyPath一定是属性么？\nKVC 支持实例变量，KVO 只能手动支持[手动设定实例变量的KVO实现监听](https://yq.aliyun.com/articles/30483)\n### 50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n\n\n请参考：\n\n  1. [《如何自己动手实现 KVO》](http://tech.glowing.com/cn/implement-kvo/)\n  2. [**KVO for manually implemented properties**]( http://stackoverflow.com/a/10042641/3395008 ) \n\n### 51. apple用什么方式实现对一个对象的KVO？ \n\n\n\n[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)对 KVO 实现的描述：\n\n > Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...\n\n从[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：\n\n > 当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 ` isa 混写（isa-swizzling）` 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：\n\n![enter image description here](http://i62.tinypic.com/sy57ur.jpg)\n\n KVO 确实有点黑魔法：\n\n\n > Apple 使用了 ` isa 混写（isa-swizzling）`来实现 KVO 。\n\n\n下面做下详细解释：\n\n键值观察通知依赖于 NSObject 的两个方法:  `willChangeValueForKey:` 和 `didChangevlueForKey:` 。在一个被观察属性发生改变之前，  `willChangeValueForKey:` 一定会被调用，这就会记录旧的值。而当改变发生后， `observeValueForKey:ofObject:change:context:` 会被调用，继而  `didChangeValueForKey:` 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。\n\n 比如调用 `setNow:` 时，系统还会以某种方式在中间插入 `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` 的调用。大家可能以为这是因为 `setNow:` 是合成方法，有时候我们也能看到有人这么写代码:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n ```\n\n这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 `willChangeValueForKey:`  ，之后总是调用 `didChangeValueForkey:` 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 `addObserver:forKeyPath:options:context:` 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:\n\n ```Objective-C\n- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"];\n    [super setValue:aDate forKey:@\"now\"];\n    [self didChangeValueForKey:@\"now\"];\n}\n ```\n这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。\n\nKVO 在实现中通过 ` isa 混写（isa-swizzling）` 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在[Apple 的文档](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html)可以得到印证：\n\n > Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...\n\n\n然而 KVO 在实现中使用了 ` isa 混写（ isa-swizzling）` ，这个的确不是很容易发现：Apple 还重写、覆盖了 `-class` 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。\n\n但是，假设“被监听的对象”的类对象是 `MYClass` ，有时候我们能看到对 `NSKVONotifying_MYClass` 的引用而不是对  `MYClass`  的引用。借此我们得以知道 Apple 使用了 ` isa 混写（isa-swizzling）`。具体探究过程可参考[ 这篇博文 ](https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html)。\n\n\n那么 `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` 这三个方法的执行顺序是怎样的呢？\n\n `wilChangeValueForKey:` 、  `didChangeValueForKey:` 很好理解，`observeValueForKeyPath:ofObject:change:context:` 的执行时机是什么时候呢？\n\n 先看一个例子：\n\n代码已放在仓库里。\n\n ```Objective-C\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    NSLog(@\"3\");\n}\n\n ```\n\n![enter image description here](http://i66.tinypic.com/ncm7th.jpg)\n\n\n如果单单从下面这个例子的打印上， \n\n顺序似乎是 `wilChangeValueForKey:` 、 `observeValueForKeyPath:ofObject:change:context:` 、 `didChangeValueForKey:` 。\n\n其实不然，这里有一个 `observeValueForKeyPath:ofObject:change:context:`  , 和 `didChangeValueForKey:` 到底谁先调用的问题：如果 `observeValueForKeyPath:ofObject:change:context:` 是在 `didChangeValueForKey:` 内部触发的操作呢？ 那么顺序就是： `wilChangeValueForKey:` 、  `didChangeValueForKey:`  和 `observeValueForKeyPath:ofObject:change:context:` \n\n不信你把 `didChangeValueForKey:` 注视掉，看下 `observeValueForKeyPath:ofObject:change:context:` 会不会执行。\n\n了解到这一点很重要，正如  [46. 如何手动触发一个value的KVO](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo)  所说的：\n\n“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。\n\n而“回调的调用时机”就是在你调用 `didChangeValueForKey:` 方法时。\n\n### 52. IBOutlet连出来的视图属性为什么可以被设置成weak?\n\n参考链接：[ ***Should IBOutlets be strong or weak under ARC?*** ](http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc)\n\n文章告诉我们：\n\n> 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。\n\n\n不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系\n\n### 53. IB中User Defined Runtime Attributes如何使用？ \n\n它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller\n\n\n### 54. 如何调试BAD_ACCESS错误\n\n\n 1. 重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object\n 2. 通过 Zombie \n![enter image description here](http://i.stack.imgur.com/ZAdi0.png)\n\n 3. 设置全局断点快速定位问题代码所在行\n 4. Xcode 7 已经集成了BAD_ACCESS捕获功能：**Address Sanitizer**。\n用法如下：在配置中勾选✅Enable Address Sanitizer\n ![enter image description here](https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png)\n\n### 55. lldb（gdb）常用的调试命令？\n\n - breakpoint 设置断点定位到某一个函数\n - n 断点指针下一步\n - po打印对象\n\n更多 lldb（gdb） 调试命令可查看\n\n\n 1. [ ***The LLDB Debugger*** ](http://lldb.llvm.org/lldb-gdb.html)；\n 2. 苹果官方文档：[ ***iOS Debugging Magic*** ](https://developer.apple.com/library/ios/technotes/tn2239/_index.html)。\n\n\n----------\n\n\nPosted by [微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)  \n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 3.0](http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)\n\n\n","slug":"《招聘一个靠谱的iOS》面试题参考答案（下）","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8two001pznuzjjk18j15","content":"<p><a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>—参考答案（下）</p>\n<p>说明：面试题来源是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a>的这篇博文：<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>\n<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>\n<p>答案为<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>指正。</p>\n<hr>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#25-_objc_msgforward函数是做什么的直接调用它将会发生什么\" target=\"_blank\" rel=\"external\"> 25. <code>_objc_msgForward</code> 函数是做什么的，直接调用它将会发生什么？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#26-runtime如何实现weak变量的自动置nil\" target=\"_blank\" rel=\"external\">26. runtime如何实现weak变量的自动置nil？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#27-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么\" target=\"_blank\" rel=\"external\">27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#28-runloop和线程有什么关系\" target=\"_blank\" rel=\"external\">28. runloop和线程有什么关系？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#29-runloop的mode作用是什么\" target=\"_blank\" rel=\"external\">29. runloop的mode作用是什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#30-以-scheduledtimerwithtimeinterval的方式触发的timer在滑动页面上的列表时timer会暂定回调为什么如何解决\" target=\"_blank\" rel=\"external\">30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#31-猜想runloop内部是如何实现的\" target=\"_blank\" rel=\"external\">31. 猜想runloop内部是如何实现的？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#32-objc使用什么机制管理对象内存\" target=\"_blank\" rel=\"external\">32. objc使用什么机制管理对象内存？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#33-arc通过什么方式帮助开发者管理内存\" target=\"_blank\" rel=\"external\">33. ARC通过什么方式帮助开发者管理内存？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#34-不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建\" target=\"_blank\" rel=\"external\">34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#35-bad_access在什么情况下出现\" target=\"_blank\" rel=\"external\">35. BAD_ACCESS在什么情况下出现？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#36-苹果是如何实现autoreleasepool的\" target=\"_blank\" rel=\"external\">36. 苹果是如何实现autoreleasepool的？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#37-使用block时什么情况会发生引用循环如何解决\" target=\"_blank\" rel=\"external\">37. 使用block时什么情况会发生引用循环，如何解决？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#38-在block内如何修改block外部变量\" target=\"_blank\" rel=\"external\">38. 在block内如何修改block外部变量？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#39-使用系统的某些block-api如uiview的block版本写动画时是否也考虑引用循环问题\" target=\"_blank\" rel=\"external\">39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#40-gcd的队列dispatch_queue_t分哪两种类型\" target=\"_blank\" rel=\"external\">40. GCD的队列（dispatch_queue_t）分哪两种类型？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#41-如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图\" target=\"_blank\" rel=\"external\">41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#42-dispatch_barrier_async的作用是什么\" target=\"_blank\" rel=\"external\">42. dispatch_barrier_async的作用是什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#43-苹果为什么要废弃dispatch_get_current_queue\" target=\"_blank\" rel=\"external\">43. 苹果为什么要废弃dispatch_get_current_queue？</a> </li>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#44-以下代码运行结果如何\" target=\"_blank\" rel=\"external\">44. 以下代码运行结果如何？</a> </p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">- (void)viewDidLoad\n{\n[super viewDidLoad];\nNSLog(@\"1\");\ndispatch_sync(dispatch_get_main_queue(), ^{\n   NSLog(@\"2\");\n});\nNSLog(@\"3\");\n}\n</code></pre>\n</li>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#45-addobserverforkeypathoptionscontext各个参数的作用分别是什么observer中需要实现哪个方法才能获得kvo回调\" target=\"_blank\" rel=\"external\">45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</a> </p>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo\" target=\"_blank\" rel=\"external\">46. 如何手动触发一个value的KVO</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#47-若一个类有实例变量-nsstring-_foo-调用setvalueforkey时可以以foo还是-_foo-作为key\" target=\"_blank\" rel=\"external\">47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#48-kvc的keypath中的集合运算符如何使用\" target=\"_blank\" rel=\"external\">48. KVC的keyPath中的集合运算符如何使用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#49-kvc和kvo的keypath一定是属性么\" target=\"_blank\" rel=\"external\">49. KVC和KVO的keyPath一定是属性么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#50-如何关闭默认的kvo的默认实现并进入自定义的kvo实现\" target=\"_blank\" rel=\"external\">50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#51-apple用什么方式实现对一个对象的kvo\" target=\"_blank\" rel=\"external\">51. apple用什么方式实现对一个对象的KVO？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#52-iboutlet连出来的视图属性为什么可以被设置成weak\" target=\"_blank\" rel=\"external\">52. IBOutlet连出来的视图属性为什么可以被设置成weak?</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#53-ib中user-defined-runtime-attributes如何使用\" target=\"_blank\" rel=\"external\">53. IB中User Defined Runtime Attributes如何使用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#54-如何调试bad_access错误\" target=\"_blank\" rel=\"external\">54. 如何调试BAD_ACCESS错误</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#55-lldbgdb常用的调试命令\" target=\"_blank\" rel=\"external\">55. lldb（gdb）常用的调试命令？</a> </li>\n</ol>\n<hr>\n<h3 id=\"25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><blockquote>\n<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n</blockquote>\n<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>\n<pre><code>IMP msgForwardIMP = _objc_msgForward;\n</code></pre><p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>\n<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>\n<p><img src=\"http://i.imgur.com/rGBfaoL.png\" alt=\"enter image description here\"></p>\n<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>\n<p><img src=\"http://i.imgur.com/vcThcdA.png\" alt=\"enter image description here\"></p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">/***********************************************************************\n* lookUpImpOrForward.\n* The standard IMP lookup. \n* initialize==NO tries to avoid +initialize (but sometimes fails)\n* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)\n* Most callers should use initialize==YES and cache==YES.\n* inst is an instance of cls or a subclass thereof, or nil if none is known. \n*   If cls is an un-initialized metaclass then a non-nil inst is faster.\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n*   If you don't want forwarding at all, use lookUpImpOrNil() instead.\n**********************************************************************/\n</code></pre>\n<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示\n//  Created by https://github.com/ChenYilong\n//  Copyright (c)  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/). All rights reserved.\n//  同时，这也是 obj_msgSend 的实现过程\n\nid objc_msgSend(id self, SEL op, ...) {\n    if (!self) return nil;\n    IMP imp = class_getMethodImplementation(self->isa, SEL op);\n    imp(self, op, ...); //调用这个函数，伪代码...\n}\n\n//查找IMP\nIMP class_getMethodImplementation(Class cls, SEL sel) {\n    if (!cls || !sel) return nil;\n    IMP imp = lookUpImpOrNil(cls, sel);\n    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发\n    return imp;\n}\n\nIMP lookUpImpOrNil(Class cls, SEL sel) {\n    if (!cls->initialize()) {\n        _class_initialize(cls);\n    }\n\n    Class curClass = cls;\n    IMP imp = nil;\n    do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询\n        if (!curClass) break;\n        if (!curClass->cache) fill_cache(cls, curClass);\n        imp = cache_getImp(curClass, sel);\n        if (imp) break;\n    } while (curClass = curClass->superclass);\n\n    return imp;\n}\n</code></pre>\n<p>虽然Apple没有公开<code>_objc_msgForward</code>的实现源码，但是我们还是能得出结论：</p>\n<blockquote>\n<p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n<p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>\n</blockquote>\n<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>\n<p>首先开启调试模式、打印出所有运行时发送的消息：<br>可以在代码里执行下面的方法：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">(void)instrumentObjcMessageSends(YES);\n</code></pre>\n<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">call (void)instrumentObjcMessageSends(YES)\n</code></pre>\n<p>以第二种为例，操作如下所示：</p>\n<p><img src=\"http://i.imgur.com/uEwTCC4.png\" alt=\"enter image description here\"></p>\n<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>\n<p>终端中输入命令前往：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">open /private/tmp\n</code></pre>\n<p><img src=\"http://i.imgur.com/Fh5hhCw.png\" alt=\"enter image description here\"></p>\n<p>可能看到有多条，找到最新生成的，双击打开</p>\n<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href=\"http://stackoverflow.com/a/10750398/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">//\n//  main.m\n//  CYLObjcMsgForwardTest\n//\n//  Created by http://weibo.com/luohanchenyilong/.\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import <UIKit/UIKit.h>\n#import \"AppDelegate.h\"\n#import \"CYLTest.h\"\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOS程序犭袁))];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n</code></pre>\n<p><img src=\"http://i.imgur.com/UjbmVvB.png\" alt=\"enter image description here\"></p>\n<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>\n<p><img src=\"http://i.imgur.com/AAERz1T.png\" alt=\"enter image description here\"></p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">+ CYLTest NSObject initialize\n+ CYLTest NSObject alloc\n- CYLTest NSObject init\n- CYLTest NSObject performSelector:\n+ CYLTest NSObject resolveInstanceMethod:\n+ CYLTest NSObject resolveInstanceMethod:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject class\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject class\n</code></pre>\n<p>结合<a href=\"https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11\" target=\"_blank\" rel=\"external\">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>\n<ol>\n<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p>\n</li>\n<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p>\n</li>\n<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p>\n</li>\n<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p>\n</li>\n<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p>\n</li>\n</ol>\n<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>\n<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>\n<ol>\n<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p>\n</li>\n<li><p><code>forwardingTargetForSelector:</code>方法</p>\n</li>\n<li><p><code>methodSignatureForSelector:</code>方法</p>\n</li>\n<li><p><code>forwardInvocation:</code>方法</p>\n</li>\n<li><p><code>doesNotRecognizeSelector:</code> 方法</p>\n</li>\n</ol>\n<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>\n<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>\n<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>\n<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>\n<p>正如前文所说：</p>\n<blockquote>\n<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n</blockquote>\n<p>如何调用<code>_objc_msgForward</code>？<br><code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>–</th>\n<th><code>_objc_msgForward</code>参数</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 1.</td>\n<td>所属对象</td>\n<td>id类型</td>\n</tr>\n<tr>\n<td> 2.</td>\n<td>方法名</td>\n<td>SEL类型 </td>\n</tr>\n<tr>\n<td> 3.</td>\n<td>可变参数</td>\n<td>可变参数类型</td>\n</tr>\n</tbody>\n</table>\n<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>\n<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">typedef void (*voidIMP)(id, SEL, ...)\n</code></pre>\n<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>\n<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>\n<blockquote>\n<p>“我没有在这个对象里找到这个方法的实现”</p>\n</blockquote>\n<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>\n<p><img src=\"http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif\" alt=\"enter image description here\"></p>\n<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>\n<p><a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"external\">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>\n<blockquote>\n<p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p>\n</blockquote>\n<p>作者的博文<a href=\"http://blog.cnbang.net/tech/2808/\" target=\"_blank\" rel=\"external\">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>\n<p>同时 <a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa\" target=\"_blank\" rel=\"external\"> <strong><em>RAC(ReactiveCocoa)</em></strong> </a> 源码中也用到了该方法。</p>\n<h3 id=\"26-runtime如何实现weak变量的自动置nil？\"><a href=\"#26-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"26. runtime如何实现weak变量的自动置nil？\"></a>26. runtime如何实现weak变量的自动置nil？</h3><blockquote>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n</blockquote>\n<p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>\n<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由assign修饰的，则：<br>在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>\n<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&obj1);\n</code></pre>\n<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>\n<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">obj1 = 0；\nobj_storeWeak(&obj1, obj);\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>\n</blockquote>\n<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>\n<p>前面的源代码与下列源代码相同。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&obj1, 0);\n</code></pre>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>\n<h3 id=\"27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><ul>\n<li>不能向编译后得到的类中增加实例变量；</li>\n<li>能向运行时创建的类中添加实例变量；</li>\n</ul>\n<p>解释下：</p>\n<ul>\n<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>\n</li>\n<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p>\n</li>\n</ul>\n<h3 id=\"28-runloop和线程有什么关系？\"><a href=\"#28-runloop和线程有什么关系？\" class=\"headerlink\" title=\"28. runloop和线程有什么关系？\"></a>28. runloop和线程有什么关系？</h3><p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>\n<p> runloop 和线程的关系：</p>\n<ol>\n<li><p>主线程的run loop默认是启动的。</p>\n<p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">int main(int argc, char * argv[]) {\n@autoreleasepool {\n    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n}\n}\n</code></pre>\n</li>\n</ol>\n<p> 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>\n<ol>\n<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>\n</li>\n<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>\n</li>\n</ol>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n</code></pre>\n<p>参考链接：<a href=\"http://blog.csdn.net/wzzvictory/article/details/9237973\" target=\"_blank\" rel=\"external\">《Objective-C之run loop详解》</a>。</p>\n<h3 id=\"29-runloop的mode作用是什么？\"><a href=\"#29-runloop的mode作用是什么？\" class=\"headerlink\" title=\"29. runloop的mode作用是什么？\"></a>29. runloop的mode作用是什么？</h3><p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>\n<ul>\n<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>\n<li>UITrackingRunLoopMode：ScrollView滑动时</li>\n<li>UIInitializationRunLoopMode：启动时</li>\n<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>\n</ul>\n<p>苹果公开提供的 Mode 有两个：</p>\n<ol>\n<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>\n<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>\n</ol>\n<h3 id=\"30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。</p>\n<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,<br>ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>\n<p>同时因为mode还是可定制的，所以：</p>\n<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>\n<pre class=\" language-objective-c\"><code class=\"language-objective-c\">// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n\n//将timer添加到NSDefaultRunLoopMode中\n[NSTimer scheduledTimerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n//然后再添加到NSRunLoopCommonModes里\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n</code></pre>\n<h3 id=\"31-猜想runloop内部是如何实现的？\"><a href=\"#31-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"31. 猜想runloop内部是如何实现的？\"></a>31. 猜想runloop内部是如何实现的？</h3><blockquote>\n<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑<br>是这样的：</p>\n</blockquote>\n<pre><code>function loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n</code></pre><p>或使用伪代码来展示下:</p>\n<pre><code>// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\nint main(int argc, char * argv[]) {\n //程序一直运行状态\n while (AppIsRunning) {\n      //睡眠状态，等待唤醒事件\n      id whoWakesMe = SleepForWakingUp();\n      //得到唤醒事件\n      id event = GetEvent(whoWakesMe);\n      //开始处理事件\n      HandleEvent(event);\n }\n return 0;\n}\n</code></pre><p>参考链接：</p>\n<ol>\n<li><a href=\"http://blog.ibireme.com/2015/05/18/runloop/#base\" target=\"_blank\" rel=\"external\">《深入理解RunLoop》</a></li>\n<li>摘自博文<a href=\"https://github.com/ming1016/study/wiki/CFRunLoop\" target=\"_blank\" rel=\"external\"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a></li>\n</ol>\n<h3 id=\"32-objc使用什么机制管理对象内存？\"><a href=\"#32-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"32. objc使用什么机制管理对象内存？\"></a>32. objc使用什么机制管理对象内存？</h3><p>通过 retainCount 的机制来决定对象是否需要释放。<br>每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>\n<h3 id=\"33-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#33-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"33. ARC通过什么方式帮助开发者管理内存？\"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><p> </p><p><del>编译时根据代码上下文，插入 retain/release<br></del></p><br>ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。<p></p>\n<p>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】</p>\n<h3 id=\"34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><p>分两种情况：手动干预释放时机、系统自动去释放。</p>\n<ol>\n<li>手动干预释放时机–指定autoreleasepool<br>就是所谓的：当前作用域大括号结束时释放。</li>\n<li><p>系统自动去释放–不手动指定autoreleasepool</p>\n<p>Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</p>\n</li>\n</ol>\n<p>释放的时机总结起来，可以用下图来表示：</p>\n<p><img src=\"http://i61.tinypic.com/28kodwp.jpg\" alt=\"autoreleasepool与 runloop 的关系图\"></p>\n<p>下面对这张图进行详细的解释：</p>\n<p>从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p>\n<p>我们都知道：<br><strong>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。</strong></p>\n<p>但是如果每次都放进应用程序的 <code>main.m</code> 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？</p>\n<p>在一次完整的运行循环结束之前，会被销毁。</p>\n<p>那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 </p>\n<p>子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。</p>\n<p>自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p>\n<p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p>\n<p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p>\n<p> 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>\n<p>参考链接：<a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"external\">《黑幕背后的Autorelease》</a></p>\n<h3 id=\"35-BAD-ACCESS在什么情况下出现？\"><a href=\"#35-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"35. BAD_ACCESS在什么情况下出现？\"></a>35. BAD_ACCESS在什么情况下出现？</h3><p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。<br>死循环</p>\n<h3 id=\"36-苹果是如何实现autoreleasepool的？\"><a href=\"#36-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"36. 苹果是如何实现autoreleasepool的？\"></a>36. 苹果是如何实现autoreleasepool的？</h3><p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>\n<ol>\n<li><code>objc_autoreleasepoolPush</code></li>\n<li><code>objc_autoreleasepoolPop</code></li>\n<li><code>objc_autorelease</code></li>\n</ol>\n<p>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>\n<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：</p>\n<p> <img src=\"http://i60.tinypic.com/15mfj11.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"37-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#37-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"37. 使用block时什么情况会发生引用循环，如何解决？\"></a>37. 使用block时什么情况会发生引用循环，如何解决？</h3><p>一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。</p>\n<p>解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>\n<ol>\n<li>id weak weakSelf = self;<br>或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>\n<li>id __block weakSelf = self;</li>\n</ol>\n<p>或者将其中一方强制制空 <code>xxx = nil</code>。</p>\n<p>检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  <a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"external\"><strong><em>FBRetainCycleDetector</em></strong></a> 。</p>\n<h3 id=\"38-在block内如何修改block外部变量？\"><a href=\"#38-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"38. 在block内如何修改block外部变量？\"></a>38. 在block内如何修改block外部变量？</h3><p>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上 <code>__block</code> 来让其写操作生效，示例代码如下:</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">    __block int a = 0;\n    void (^foo)(void) = ^{ \n        a = 1; \n    };\n    foo(); \n    //这里，a的值被修改为1\n</code></pre>\n<p>这是 <a href=\"http://weibo.com/tangqiaoboy\" target=\"_blank\" rel=\"external\">微博@唐巧_boy</a>的《iOS开发进阶》中的第11.2.3章节中的描述。你同样可以在面试中这样回答，但你并没有答到“点子上”。真正的原因，并没有书这本书里写的这么“神奇”，而且这种说法也有点牵强。面试官肯定会追问“为什么写操作就生效了？”真正的原因是这样的：</p>\n<blockquote>\n<p>我们都知道：<strong>Block不允许修改外部变量的值</strong>，这里所说的外部变量的值，指的是栈中指针的内存地址。<code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</p>\n</blockquote>\n<p><strong>Block不允许修改外部变量的值</strong>。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。</p>\n<p>我们可以打印下内存地址来进行验证：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">    __block int a = 0;\n    NSLog(@\"定义前：%p\", &a);         //栈区\n    void (^foo)(void) = ^{\n        a = 1;\n        NSLog(@\"block内部：%p\", &a);    //堆区\n    };\n    NSLog(@\"定义后：%p\", &a);         //堆区\n    foo();\n</code></pre>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8\n</code></pre>\n<p>“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。</p>\n<p> 那么如何证明“block内部”打印的是堆地址？</p>\n<p> 把三个16进制的内存地址转成10进制就是：</p>\n<ol>\n<li>定义后前：6171559672</li>\n<li>block内部：5732708296</li>\n<li>定义后后：5732708296</li>\n</ol>\n<p>中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。</p>\n<p>这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。</p>\n<p> <code>__block</code> 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16  字节要多一倍）。</p>\n<p>理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：</p>\n<p>以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">    NSMutableString *a = [NSMutableString stringWithString:@\"Tom\"];\n    NSLog(@\"\\n 定以前：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n    void (^foo)(void) = ^{\n        a.string = @\"Jerry\";\n        NSLog(@\"\\n block内部：------------------------------------\\n\\\n         a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n        a = [NSMutableString stringWithString:@\"William\"];\n    };\n    foo();\n    NSLog(@\"\\n 定以后：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p\", a, &a);               //a在栈区\n</code></pre>\n<p><img src=\"http://i66.tinypic.com/34euhcy.jpg\" alt=\"enter image description here\"></p>\n<p> 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。</p>\n<p> 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。</p>\n<p>上文已经说过：<strong>Block不允许修改外部变量的值</strong>，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。</p>\n<h3 id=\"39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>\n<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];\n</code></pre>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];\n</code></pre>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">[[NSNotificationCenter defaultCenter] addObserverForName:@\"someNotification\" \n                                                  object:nil \n                           queue:[NSOperationQueue mainQueue]\n                                              usingBlock:^(NSNotification * notification) {\n                                                    self.someProperty = xyz; }];\n</code></pre>\n<p>这些情况不需要考虑“引用循环”。</p>\n<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">__weak __typeof__(self) weakSelf = self;\ndispatch_group_async(_operationsGroup, _operationsQueue, ^\n{\n__typeof__(self) strongSelf = weakSelf;\n[strongSelf doSomething];\n[strongSelf doSomethingElse];\n} );\n</code></pre>\n<p>类似的：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">  __weak __typeof__(self) weakSelf = self;\n  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"testKey\"\n                                                                object:nil\n                                                                 queue:nil\n                                                            usingBlock:^(NSNotification *note) {\n      __typeof__(self) strongSelf = weakSelf;\n      [strongSelf dismissModalViewControllerAnimated:YES];\n  }];\n</code></pre>\n<p>self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。</p>\n<p>检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  <a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"external\"><strong><em>FBRetainCycleDetector</em></strong></a> 。</p>\n<h3 id=\"40-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#40-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"40. GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3><ol>\n<li>串行队列Serial Dispatch Queue</li>\n<li>并行队列Concurrent Dispatch Queue</li>\n</ol>\n<h3 id=\"41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, queue, ^{ /*加载图片1 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片2 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 合并图片\n});\n</code></pre>\n<h3 id=\"42-dispatch-barrier-async的作用是什么？\"><a href=\"#42-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"42. dispatch_barrier_async的作用是什么？\"></a>42. <code>dispatch_barrier_async</code>的作用是什么？</h3><p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。<br> <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>\n<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>\n<p>（注意：使用 <code>dispatch_barrier_async</code> ，该函数只能搭配自定义并行队列 <code>dispatch_queue_t</code> 使用。不能使用： <code>dispatch_get_global_queue</code> ，否则 <code>dispatch_barrier_async</code> 的作用会和 <code>dispatch_async</code> 的作用一模一样。 ）</p>\n<h3 id=\"43-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#43-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"43. 苹果为什么要废弃dispatch_get_current_queue？\"></a>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3><p><code>dispatch_get_current_queue</code>容易造成死锁</p>\n<h3 id=\"44-以下代码运行结果如何？\"><a href=\"#44-以下代码运行结果如何？\" class=\"headerlink\" title=\"44. 以下代码运行结果如何？\"></a>44. 以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><p>只输出：1 。发生主线程锁死。</p>\n<h3 id=\"45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">// 添加键值观察\n/*\n1 观察者，负责处理监听事件的对象\n2 观察的属性\n3 观察的选项\n4 上下文\n*/\n[self.person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@\"Person Name\"];\n</code></pre>\n<p>observer中需要实现一下方法：</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">// 所有的 kvo 监听到事件，都会调用此方法\n/*\n 1. 观察的属性\n 2. 观察的对象\n 3. change 属性变化字典（新／旧）\n 4. 上下文，与监听的时候传递的一致\n */\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;\n</code></pre>\n<h3 id=\"46-如何手动触发一个value的KVO\"><a href=\"#46-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"46. 如何手动触发一个value的KVO\"></a>46. 如何手动触发一个value的KVO</h3><p>所谓的“手动触发”是区别于“自动触发”：</p>\n<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>\n<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>\n<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就<br>会记录旧的值。而当改变发生后，  <code>observeValueForKey:ofObject:change:context:</code> 会被调用，继而 <code>didChangeValueForKey:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>\n<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>\n<p>具体做法如下：</p>\n<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>\n<p>相关代码已放在仓库里。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">//  .m文件\n//  Created by https://github.com/ChenYilong\n//  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/).\n//  手动触发 value 的KVO，最后两行代码缺一不可。\n\n//@property (nonatomic, strong) NSDate *now;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _now = [NSDate date];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n</code></pre>\n<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>\n<blockquote>\n<p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code> 和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p>\n</blockquote>\n<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到有人这么写代码:</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n</code></pre>\n<p>这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>\n<p>参考链接： <a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3\" target=\"_blank\" rel=\"external\">Manual Change Notification—Apple 官方文档</a> </p>\n<h3 id=\"47-若一个类有实例变量-NSString-foo-，调用setValue-forKey-时，可以以foo还是-foo-作为key？\"><a href=\"#47-若一个类有实例变量-NSString-foo-，调用setValue-forKey-时，可以以foo还是-foo-作为key？\" class=\"headerlink\" title=\"47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？\"></a>47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？</h3><p>都可以。</p>\n<h3 id=\"48-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#48-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"48. KVC的keyPath中的集合运算符如何使用？\"></a>48. KVC的keyPath中的集合运算符如何使用？</h3><ol>\n<li>必须用在集合对象上或普通对象的集合属性上</li>\n<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>\n<li>格式 @”@sum.age”或 @”集合属性.@max.age”</li>\n</ol>\n<h3 id=\"49-KVC和KVO的keyPath一定是属性么？\"><a href=\"#49-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"49. KVC和KVO的keyPath一定是属性么？\"></a>49. KVC和KVO的keyPath一定是属性么？</h3><p>KVC 支持实例变量，KVO 只能手动支持<a href=\"https://yq.aliyun.com/articles/30483\" target=\"_blank\" rel=\"external\">手动设定实例变量的KVO实现监听</a></p>\n<h3 id=\"50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><p>请参考：</p>\n<ol>\n<li><a href=\"http://tech.glowing.com/cn/implement-kvo/\" target=\"_blank\" rel=\"external\">《如何自己动手实现 KVO》</a></li>\n<li><a href=\"http://stackoverflow.com/a/10042641/3395008\" target=\"_blank\" rel=\"external\"><strong>KVO for manually implemented properties</strong></a> </li>\n</ol>\n<h3 id=\"51-apple用什么方式实现对一个对象的KVO？\"><a href=\"#51-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"51. apple用什么方式实现对一个对象的KVO？\"></a>51. apple用什么方式实现对一个对象的KVO？</h3><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>对 KVO 实现的描述：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>\n</blockquote>\n<p>从<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>\n<blockquote>\n<p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p>\n</blockquote>\n<p><img src=\"http://i62.tinypic.com/sy57ur.jpg\" alt=\"enter image description here\"></p>\n<p> KVO 确实有点黑魔法：</p>\n<blockquote>\n<p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p>\n</blockquote>\n<p>下面做下详细解释：</p>\n<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后， <code>observeValueForKey:ofObject:change:context:</code> 会被调用，继而  <code>didChangeValueForKey:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>\n<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到有人这么写代码:</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@\"now\"];// 没有必要\n}\n</code></pre>\n<p>这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 <code>addObserver:forKeyPath:options:context:</code> 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@\"now\"];\n    [super setValue:aDate forKey:@\"now\"];\n    [self didChangeValueForKey:@\"now\"];\n}\n</code></pre>\n<p>这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>\n<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>可以得到印证：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>\n</blockquote>\n<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>\n<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href=\"https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html\" target=\"_blank\" rel=\"external\"> 这篇博文 </a>。</p>\n<p>那么 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 这三个方法的执行顺序是怎样的呢？</p>\n<p> <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code> 很好理解，<code>observeValueForKeyPath:ofObject:change:context:</code> 的执行时机是什么时候呢？</p>\n<p> 先看一个例子：</p>\n<p>代码已放在仓库里。</p>\n<pre class=\" language-Objective-C\"><code class=\"language-Objective-C\">- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self addObserver:self forKeyPath:@\"now\" options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@\"1\");\n    [self willChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"2\");\n    [self didChangeValueForKey:@\"now\"]; // “手动触发self.now的KVO”，必写。\n    NSLog(@\"4\");\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    NSLog(@\"3\");\n}\n</code></pre>\n<p><img src=\"http://i66.tinypic.com/ncm7th.jpg\" alt=\"enter image description here\"></p>\n<p>如果单单从下面这个例子的打印上， </p>\n<p>顺序似乎是 <code>wilChangeValueForKey:</code> 、 <code>observeValueForKeyPath:ofObject:change:context:</code> 、 <code>didChangeValueForKey:</code> 。</p>\n<p>其实不然，这里有一个 <code>observeValueForKeyPath:ofObject:change:context:</code>  , 和 <code>didChangeValueForKey:</code> 到底谁先调用的问题：如果 <code>observeValueForKeyPath:ofObject:change:context:</code> 是在 <code>didChangeValueForKey:</code> 内部触发的操作呢？ 那么顺序就是： <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> </p>\n<p>不信你把 <code>didChangeValueForKey:</code> 注视掉，看下 <code>observeValueForKeyPath:ofObject:change:context:</code> 会不会执行。</p>\n<p>了解到这一点很重要，正如  <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo\" target=\"_blank\" rel=\"external\">46. 如何手动触发一个value的KVO</a>  所说的：</p>\n<p>“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>\n<p>而“回调的调用时机”就是在你调用 <code>didChangeValueForKey:</code> 方法时。</p>\n<h3 id=\"52-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#52-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"52. IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><p>参考链接：<a href=\"http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc\" target=\"_blank\" rel=\"external\"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>\n<p>文章告诉我们：</p>\n<blockquote>\n<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p>\n</blockquote>\n<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>\n<h3 id=\"53-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#53-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"53. IB中User Defined Runtime Attributes如何使用？\"></a>53. IB中User Defined Runtime Attributes如何使用？</h3><p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>\n<h3 id=\"54-如何调试BAD-ACCESS错误\"><a href=\"#54-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"54. 如何调试BAD_ACCESS错误\"></a>54. 如何调试BAD_ACCESS错误</h3><ol>\n<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>\n<li><p>通过 Zombie<br><img src=\"http://i.stack.imgur.com/ZAdi0.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p>设置全局断点快速定位问题代码所在行</p>\n</li>\n<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。<br>用法如下：在配置中勾选✅Enable Address Sanitizer<br><img src=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png\" alt=\"enter image description here\"></li>\n</ol>\n<h3 id=\"55-lldb（gdb）常用的调试命令？\"><a href=\"#55-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"55. lldb（gdb）常用的调试命令？\"></a>55. lldb（gdb）常用的调试命令？</h3><ul>\n<li>breakpoint 设置断点定位到某一个函数</li>\n<li>n 断点指针下一步</li>\n<li>po打印对象</li>\n</ul>\n<p>更多 lldb（gdb） 调试命令可查看</p>\n<ol>\n<li><a href=\"http://lldb.llvm.org/lldb-gdb.html\" target=\"_blank\" rel=\"external\"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>\n<li>苹果官方文档：<a href=\"https://developer.apple.com/library/ios/technotes/tn2239/_index.html\" target=\"_blank\" rel=\"external\"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>\n</ol>\n<hr>\n<p>Posted by <a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" target=\"_blank\" rel=\"external\">Creative Commons BY-NC-ND 3.0</a></p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>—参考答案（下）</p>\n<p>说明：面试题来源是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a>的这篇博文：<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>\n<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>\n<p>答案为<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>指正。</p>\n<hr>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#25-_objc_msgforward函数是做什么的直接调用它将会发生什么\" target=\"_blank\" rel=\"external\"> 25. <code>_objc_msgForward</code> 函数是做什么的，直接调用它将会发生什么？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#26-runtime如何实现weak变量的自动置nil\" target=\"_blank\" rel=\"external\">26. runtime如何实现weak变量的自动置nil？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#27-能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么\" target=\"_blank\" rel=\"external\">27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#28-runloop和线程有什么关系\" target=\"_blank\" rel=\"external\">28. runloop和线程有什么关系？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#29-runloop的mode作用是什么\" target=\"_blank\" rel=\"external\">29. runloop的mode作用是什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#30-以-scheduledtimerwithtimeinterval的方式触发的timer在滑动页面上的列表时timer会暂定回调为什么如何解决\" target=\"_blank\" rel=\"external\">30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#31-猜想runloop内部是如何实现的\" target=\"_blank\" rel=\"external\">31. 猜想runloop内部是如何实现的？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#32-objc使用什么机制管理对象内存\" target=\"_blank\" rel=\"external\">32. objc使用什么机制管理对象内存？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#33-arc通过什么方式帮助开发者管理内存\" target=\"_blank\" rel=\"external\">33. ARC通过什么方式帮助开发者管理内存？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#34-不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建\" target=\"_blank\" rel=\"external\">34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#35-bad_access在什么情况下出现\" target=\"_blank\" rel=\"external\">35. BAD_ACCESS在什么情况下出现？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#36-苹果是如何实现autoreleasepool的\" target=\"_blank\" rel=\"external\">36. 苹果是如何实现autoreleasepool的？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#37-使用block时什么情况会发生引用循环如何解决\" target=\"_blank\" rel=\"external\">37. 使用block时什么情况会发生引用循环，如何解决？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#38-在block内如何修改block外部变量\" target=\"_blank\" rel=\"external\">38. 在block内如何修改block外部变量？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#39-使用系统的某些block-api如uiview的block版本写动画时是否也考虑引用循环问题\" target=\"_blank\" rel=\"external\">39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#40-gcd的队列dispatch_queue_t分哪两种类型\" target=\"_blank\" rel=\"external\">40. GCD的队列（dispatch_queue_t）分哪两种类型？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#41-如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图\" target=\"_blank\" rel=\"external\">41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#42-dispatch_barrier_async的作用是什么\" target=\"_blank\" rel=\"external\">42. dispatch_barrier_async的作用是什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#43-苹果为什么要废弃dispatch_get_current_queue\" target=\"_blank\" rel=\"external\">43. 苹果为什么要废弃dispatch_get_current_queue？</a> </li>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#44-以下代码运行结果如何\" target=\"_blank\" rel=\"external\">44. 以下代码运行结果如何？</a> </p>\n<pre><code class=\"Objective-C\">- (void)viewDidLoad\n{\n[super viewDidLoad];\nNSLog(@&quot;1&quot;);\ndispatch_sync(dispatch_get_main_queue(), ^{\n   NSLog(@&quot;2&quot;);\n});\nNSLog(@&quot;3&quot;);\n}\n</code></pre>\n</li>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#45-addobserverforkeypathoptionscontext各个参数的作用分别是什么observer中需要实现哪个方法才能获得kvo回调\" target=\"_blank\" rel=\"external\">45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</a> </p>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo\" target=\"_blank\" rel=\"external\">46. 如何手动触发一个value的KVO</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#47-若一个类有实例变量-nsstring-_foo-调用setvalueforkey时可以以foo还是-_foo-作为key\" target=\"_blank\" rel=\"external\">47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#48-kvc的keypath中的集合运算符如何使用\" target=\"_blank\" rel=\"external\">48. KVC的keyPath中的集合运算符如何使用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#49-kvc和kvo的keypath一定是属性么\" target=\"_blank\" rel=\"external\">49. KVC和KVO的keyPath一定是属性么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#50-如何关闭默认的kvo的默认实现并进入自定义的kvo实现\" target=\"_blank\" rel=\"external\">50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#51-apple用什么方式实现对一个对象的kvo\" target=\"_blank\" rel=\"external\">51. apple用什么方式实现对一个对象的KVO？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#52-iboutlet连出来的视图属性为什么可以被设置成weak\" target=\"_blank\" rel=\"external\">52. IBOutlet连出来的视图属性为什么可以被设置成weak?</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#53-ib中user-defined-runtime-attributes如何使用\" target=\"_blank\" rel=\"external\">53. IB中User Defined Runtime Attributes如何使用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#54-如何调试bad_access错误\" target=\"_blank\" rel=\"external\">54. 如何调试BAD_ACCESS错误</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#55-lldbgdb常用的调试命令\" target=\"_blank\" rel=\"external\">55. lldb（gdb）常用的调试命令？</a> </li>\n</ol>\n<hr>\n<h3 id=\"25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><blockquote>\n<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n</blockquote>\n<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>\n<pre><code>IMP msgForwardIMP = _objc_msgForward;\n</code></pre><p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>\n<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href=\"http://www.opensource.apple.com/tarballs/objc4/\" target=\"_blank\" rel=\"external\"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>\n<p><img src=\"http://i.imgur.com/rGBfaoL.png\" alt=\"enter image description here\"></p>\n<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>\n<p><img src=\"http://i.imgur.com/vcThcdA.png\" alt=\"enter image description here\"></p>\n<pre><code class=\"Objective-C\">/***********************************************************************\n* lookUpImpOrForward.\n* The standard IMP lookup. \n* initialize==NO tries to avoid +initialize (but sometimes fails)\n* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)\n* Most callers should use initialize==YES and cache==YES.\n* inst is an instance of cls or a subclass thereof, or nil if none is known. \n*   If cls is an un-initialized metaclass then a non-nil inst is faster.\n* May return _objc_msgForward_impcache. IMPs destined for external use \n*   must be converted to _objc_msgForward or _objc_msgForward_stret.\n*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.\n**********************************************************************/\n</code></pre>\n<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>\n<pre><code class=\"Objective-C\">//  objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示\n//  Created by https://github.com/ChenYilong\n//  Copyright (c)  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/). All rights reserved.\n//  同时，这也是 obj_msgSend 的实现过程\n\nid objc_msgSend(id self, SEL op, ...) {\n    if (!self) return nil;\n    IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);\n    imp(self, op, ...); //调用这个函数，伪代码...\n}\n\n//查找IMP\nIMP class_getMethodImplementation(Class cls, SEL sel) {\n    if (!cls || !sel) return nil;\n    IMP imp = lookUpImpOrNil(cls, sel);\n    if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发\n    return imp;\n}\n\nIMP lookUpImpOrNil(Class cls, SEL sel) {\n    if (!cls-&gt;initialize()) {\n        _class_initialize(cls);\n    }\n\n    Class curClass = cls;\n    IMP imp = nil;\n    do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询\n        if (!curClass) break;\n        if (!curClass-&gt;cache) fill_cache(cls, curClass);\n        imp = cache_getImp(curClass, sel);\n        if (imp) break;\n    } while (curClass = curClass-&gt;superclass);\n\n    return imp;\n}\n</code></pre>\n<p>虽然Apple没有公开<code>_objc_msgForward</code>的实现源码，但是我们还是能得出结论：</p>\n<blockquote>\n<p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n<p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>\n</blockquote>\n<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>\n<p>首先开启调试模式、打印出所有运行时发送的消息：<br>可以在代码里执行下面的方法：</p>\n<pre><code class=\"Objective-C\">(void)instrumentObjcMessageSends(YES);\n</code></pre>\n<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>\n<pre><code class=\"Objective-C\">call (void)instrumentObjcMessageSends(YES)\n</code></pre>\n<p>以第二种为例，操作如下所示：</p>\n<p><img src=\"http://i.imgur.com/uEwTCC4.png\" alt=\"enter image description here\"></p>\n<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>\n<p>终端中输入命令前往：</p>\n<pre><code class=\"Objective-C\">open /private/tmp\n</code></pre>\n<p><img src=\"http://i.imgur.com/Fh5hhCw.png\" alt=\"enter image description here\"></p>\n<p>可能看到有多条，找到最新生成的，双击打开</p>\n<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href=\"http://stackoverflow.com/a/10750398/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>\n<pre><code class=\"Objective-C\">//\n//  main.m\n//  CYLObjcMsgForwardTest\n//\n//  Created by http://weibo.com/luohanchenyilong/.\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import &lt;UIKit/UIKit.h&gt;\n#import &quot;AppDelegate.h&quot;\n#import &quot;CYLTest.h&quot;\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOS程序犭袁))];\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n</code></pre>\n<p><img src=\"http://i.imgur.com/UjbmVvB.png\" alt=\"enter image description here\"></p>\n<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>\n<p><img src=\"http://i.imgur.com/AAERz1T.png\" alt=\"enter image description here\"></p>\n<pre><code class=\"Objective-C\">+ CYLTest NSObject initialize\n+ CYLTest NSObject alloc\n- CYLTest NSObject init\n- CYLTest NSObject performSelector:\n+ CYLTest NSObject resolveInstanceMethod:\n+ CYLTest NSObject resolveInstanceMethod:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject forwardingTargetForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject methodSignatureForSelector:\n- CYLTest NSObject class\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject doesNotRecognizeSelector:\n- CYLTest NSObject class\n</code></pre>\n<p>结合<a href=\"https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11\" target=\"_blank\" rel=\"external\">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>\n<ol>\n<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p>\n</li>\n<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p>\n</li>\n<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p>\n</li>\n<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p>\n</li>\n<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p>\n</li>\n</ol>\n<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>\n<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>\n<ol>\n<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p>\n</li>\n<li><p><code>forwardingTargetForSelector:</code>方法</p>\n</li>\n<li><p><code>methodSignatureForSelector:</code>方法</p>\n</li>\n<li><p><code>forwardInvocation:</code>方法</p>\n</li>\n<li><p><code>doesNotRecognizeSelector:</code> 方法</p>\n</li>\n</ol>\n<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>\n<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>\n<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>\n<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>\n<p>正如前文所说：</p>\n<blockquote>\n<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>\n</blockquote>\n<p>如何调用<code>_objc_msgForward</code>？<br><code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>–</th>\n<th><code>_objc_msgForward</code>参数</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> 1.</td>\n<td>所属对象</td>\n<td>id类型</td>\n</tr>\n<tr>\n<td> 2.</td>\n<td>方法名</td>\n<td>SEL类型 </td>\n</tr>\n<tr>\n<td> 3.</td>\n<td>可变参数</td>\n<td>可变参数类型</td>\n</tr>\n</tbody>\n</table>\n<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>\n<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>\n<pre><code class=\"Objective-C\">typedef void (*voidIMP)(id, SEL, ...)\n</code></pre>\n<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>\n<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>\n<blockquote>\n<p>“我没有在这个对象里找到这个方法的实现”</p>\n</blockquote>\n<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>\n<p><img src=\"http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif\" alt=\"enter image description here\"></p>\n<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>\n<p><a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"external\">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>\n<blockquote>\n<p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p>\n</blockquote>\n<p>作者的博文<a href=\"http://blog.cnbang.net/tech/2808/\" target=\"_blank\" rel=\"external\">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>\n<p>同时 <a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa\" target=\"_blank\" rel=\"external\"> <strong><em>RAC(ReactiveCocoa)</em></strong> </a> 源码中也用到了该方法。</p>\n<h3 id=\"26-runtime如何实现weak变量的自动置nil？\"><a href=\"#26-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"26. runtime如何实现weak变量的自动置nil？\"></a>26. runtime如何实现weak变量的自动置nil？</h3><blockquote>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n</blockquote>\n<p>在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>\n<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由assign修饰的，则：<br>在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>\n<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<pre><code class=\"Objective-C\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&amp;obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&amp;obj1);\n</code></pre>\n<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>\n<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<pre><code class=\"Objective-C\">obj1 = 0；\nobj_storeWeak(&amp;obj1, obj);\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>\n</blockquote>\n<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>\n<p>前面的源代码与下列源代码相同。</p>\n<pre><code class=\"Objective-C\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&amp;obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&amp;obj1, 0);\n</code></pre>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>\n<h3 id=\"27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><ul>\n<li>不能向编译后得到的类中增加实例变量；</li>\n<li>能向运行时创建的类中添加实例变量；</li>\n</ul>\n<p>解释下：</p>\n<ul>\n<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>\n</li>\n<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p>\n</li>\n</ul>\n<h3 id=\"28-runloop和线程有什么关系？\"><a href=\"#28-runloop和线程有什么关系？\" class=\"headerlink\" title=\"28. runloop和线程有什么关系？\"></a>28. runloop和线程有什么关系？</h3><p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>\n<p> runloop 和线程的关系：</p>\n<ol>\n<li><p>主线程的run loop默认是启动的。</p>\n<p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>\n<pre><code class=\"Objective-C\">int main(int argc, char * argv[]) {\n@autoreleasepool {\n    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n}\n}\n</code></pre>\n</li>\n</ol>\n<p> 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>\n<ol>\n<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>\n</li>\n<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>\n</li>\n</ol>\n<pre><code class=\"Objective-C\">NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n</code></pre>\n<p>参考链接：<a href=\"http://blog.csdn.net/wzzvictory/article/details/9237973\" target=\"_blank\" rel=\"external\">《Objective-C之run loop详解》</a>。</p>\n<h3 id=\"29-runloop的mode作用是什么？\"><a href=\"#29-runloop的mode作用是什么？\" class=\"headerlink\" title=\"29. runloop的mode作用是什么？\"></a>29. runloop的mode作用是什么？</h3><p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>\n<ul>\n<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>\n<li>UITrackingRunLoopMode：ScrollView滑动时</li>\n<li>UIInitializationRunLoopMode：启动时</li>\n<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>\n</ul>\n<p>苹果公开提供的 Mode 有两个：</p>\n<ol>\n<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>\n<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>\n</ol>\n<h3 id=\"30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。</p>\n<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,<br>ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>\n<p>同时因为mode还是可定制的，所以：</p>\n<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>\n<pre><code class=\"objective-c\">// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n\n//将timer添加到NSDefaultRunLoopMode中\n[NSTimer scheduledTimerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n//然后再添加到NSRunLoopCommonModes里\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0\n     target:self\n     selector:@selector(timerTick:)\n     userInfo:nil\n     repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n</code></pre>\n<h3 id=\"31-猜想runloop内部是如何实现的？\"><a href=\"#31-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"31. 猜想runloop内部是如何实现的？\"></a>31. 猜想runloop内部是如何实现的？</h3><blockquote>\n<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑<br>是这样的：</p>\n</blockquote>\n<pre><code>function loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n</code></pre><p>或使用伪代码来展示下:</p>\n<pre><code>// \n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\nint main(int argc, char * argv[]) {\n //程序一直运行状态\n while (AppIsRunning) {\n      //睡眠状态，等待唤醒事件\n      id whoWakesMe = SleepForWakingUp();\n      //得到唤醒事件\n      id event = GetEvent(whoWakesMe);\n      //开始处理事件\n      HandleEvent(event);\n }\n return 0;\n}\n</code></pre><p>参考链接：</p>\n<ol>\n<li><a href=\"http://blog.ibireme.com/2015/05/18/runloop/#base\" target=\"_blank\" rel=\"external\">《深入理解RunLoop》</a></li>\n<li>摘自博文<a href=\"https://github.com/ming1016/study/wiki/CFRunLoop\" target=\"_blank\" rel=\"external\"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a></li>\n</ol>\n<h3 id=\"32-objc使用什么机制管理对象内存？\"><a href=\"#32-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"32. objc使用什么机制管理对象内存？\"></a>32. objc使用什么机制管理对象内存？</h3><p>通过 retainCount 的机制来决定对象是否需要释放。<br>每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>\n<h3 id=\"33-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#33-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"33. ARC通过什么方式帮助开发者管理内存？\"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><p> </p><p><del>编译时根据代码上下文，插入 retain/release<br></del></p><br>ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。<p></p>\n<p>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】</p>\n<h3 id=\"34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><p>分两种情况：手动干预释放时机、系统自动去释放。</p>\n<ol>\n<li>手动干预释放时机–指定autoreleasepool<br>就是所谓的：当前作用域大括号结束时释放。</li>\n<li><p>系统自动去释放–不手动指定autoreleasepool</p>\n<p>Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。</p>\n</li>\n</ol>\n<p>释放的时机总结起来，可以用下图来表示：</p>\n<p><img src=\"http://i61.tinypic.com/28kodwp.jpg\" alt=\"autoreleasepool与 runloop 的关系图\"></p>\n<p>下面对这张图进行详细的解释：</p>\n<p>从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p>\n<p>我们都知道：<br><strong>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。</strong></p>\n<p>但是如果每次都放进应用程序的 <code>main.m</code> 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？</p>\n<p>在一次完整的运行循环结束之前，会被销毁。</p>\n<p>那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 </p>\n<p>子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。</p>\n<p>自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p>\n<p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p>\n<p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p>\n<p> 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>\n<p>参考链接：<a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"external\">《黑幕背后的Autorelease》</a></p>\n<h3 id=\"35-BAD-ACCESS在什么情况下出现？\"><a href=\"#35-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"35. BAD_ACCESS在什么情况下出现？\"></a>35. BAD_ACCESS在什么情况下出现？</h3><p>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。<br>死循环</p>\n<h3 id=\"36-苹果是如何实现autoreleasepool的？\"><a href=\"#36-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"36. 苹果是如何实现autoreleasepool的？\"></a>36. 苹果是如何实现autoreleasepool的？</h3><p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>\n<ol>\n<li><code>objc_autoreleasepoolPush</code></li>\n<li><code>objc_autoreleasepoolPop</code></li>\n<li><code>objc_autorelease</code></li>\n</ol>\n<p>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</p>\n<p>举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息：</p>\n<p> <img src=\"http://i60.tinypic.com/15mfj11.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"37-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#37-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"37. 使用block时什么情况会发生引用循环，如何解决？\"></a>37. 使用block时什么情况会发生引用循环，如何解决？</h3><p>一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。</p>\n<p>解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>\n<ol>\n<li>id weak weakSelf = self;<br>或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>\n<li>id __block weakSelf = self;</li>\n</ol>\n<p>或者将其中一方强制制空 <code>xxx = nil</code>。</p>\n<p>检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  <a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"external\"><strong><em>FBRetainCycleDetector</em></strong></a> 。</p>\n<h3 id=\"38-在block内如何修改block外部变量？\"><a href=\"#38-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"38. 在block内如何修改block外部变量？\"></a>38. 在block内如何修改block外部变量？</h3><p>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上 <code>__block</code> 来让其写操作生效，示例代码如下:</p>\n<pre><code class=\"Objective-C\">    __block int a = 0;\n    void (^foo)(void) = ^{ \n        a = 1; \n    };\n    foo(); \n    //这里，a的值被修改为1\n</code></pre>\n<p>这是 <a href=\"http://weibo.com/tangqiaoboy\" target=\"_blank\" rel=\"external\">微博@唐巧_boy</a>的《iOS开发进阶》中的第11.2.3章节中的描述。你同样可以在面试中这样回答，但你并没有答到“点子上”。真正的原因，并没有书这本书里写的这么“神奇”，而且这种说法也有点牵强。面试官肯定会追问“为什么写操作就生效了？”真正的原因是这样的：</p>\n<blockquote>\n<p>我们都知道：<strong>Block不允许修改外部变量的值</strong>，这里所说的外部变量的值，指的是栈中指针的内存地址。<code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</p>\n</blockquote>\n<p><strong>Block不允许修改外部变量的值</strong>。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。</p>\n<p>我们可以打印下内存地址来进行验证：</p>\n<pre><code class=\"Objective-C\">    __block int a = 0;\n    NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区\n    void (^foo)(void) = ^{\n        a = 1;\n        NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区\n    };\n    NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区\n    foo();\n</code></pre>\n<pre><code class=\"Objective-C\">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8\n2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8\n</code></pre>\n<p>“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。</p>\n<p> 那么如何证明“block内部”打印的是堆地址？</p>\n<p> 把三个16进制的内存地址转成10进制就是：</p>\n<ol>\n<li>定义后前：6171559672</li>\n<li>block内部：5732708296</li>\n<li>定义后后：5732708296</li>\n</ol>\n<p>中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。</p>\n<p>这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。</p>\n<p> <code>__block</code> 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16  字节要多一倍）。</p>\n<p>理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：</p>\n<p>以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。</p>\n<pre><code class=\"Objective-C\">    NSMutableString *a = [NSMutableString stringWithString:@&quot;Tom&quot;];\n    NSLog(@&quot;\\n 定以前：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);               //a在栈区\n    void (^foo)(void) = ^{\n        a.string = @&quot;Jerry&quot;;\n        NSLog(@&quot;\\n block内部：------------------------------------\\n\\\n         a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);               //a在栈区\n        a = [NSMutableString stringWithString:@&quot;William&quot;];\n    };\n    foo();\n    NSLog(@&quot;\\n 定以后：------------------------------------\\n\\\n          a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a);               //a在栈区\n</code></pre>\n<p><img src=\"http://i66.tinypic.com/34euhcy.jpg\" alt=\"enter image description here\"></p>\n<p> 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。</p>\n<p> 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。</p>\n<p>上文已经说过：<strong>Block不允许修改外部变量的值</strong>，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。</p>\n<h3 id=\"39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>\n<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>\n<pre><code class=\"Objective-C\">[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];\n</code></pre>\n<pre><code class=\"Objective-C\">[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];\n</code></pre>\n<pre><code class=\"Objective-C\">[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; \n                                                  object:nil \n                           queue:[NSOperationQueue mainQueue]\n                                              usingBlock:^(NSNotification * notification) {\n                                                    self.someProperty = xyz; }];\n</code></pre>\n<p>这些情况不需要考虑“引用循环”。</p>\n<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>\n<pre><code class=\"Objective-C\">__weak __typeof__(self) weakSelf = self;\ndispatch_group_async(_operationsGroup, _operationsQueue, ^\n{\n__typeof__(self) strongSelf = weakSelf;\n[strongSelf doSomething];\n[strongSelf doSomethingElse];\n} );\n</code></pre>\n<p>类似的：</p>\n<pre><code class=\"Objective-C\">  __weak __typeof__(self) weakSelf = self;\n  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot;\n                                                                object:nil\n                                                                 queue:nil\n                                                            usingBlock:^(NSNotification *note) {\n      __typeof__(self) strongSelf = weakSelf;\n      [strongSelf dismissModalViewControllerAnimated:YES];\n  }];\n</code></pre>\n<p>self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。</p>\n<p>检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具  <a href=\"https://github.com/facebook/FBRetainCycleDetector\" target=\"_blank\" rel=\"external\"><strong><em>FBRetainCycleDetector</em></strong></a> 。</p>\n<h3 id=\"40-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#40-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"40. GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3><ol>\n<li>串行队列Serial Dispatch Queue</li>\n<li>并行队列Concurrent Dispatch Queue</li>\n</ol>\n<h3 id=\"41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>\n<pre><code class=\"Objective-C\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\ndispatch_group_async(group, queue, ^{ /*加载图片1 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片2 */ });\ndispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        // 合并图片\n});\n</code></pre>\n<h3 id=\"42-dispatch-barrier-async的作用是什么？\"><a href=\"#42-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"42. dispatch_barrier_async的作用是什么？\"></a>42. <code>dispatch_barrier_async</code>的作用是什么？</h3><p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。<br> <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>\n<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>\n<p>（注意：使用 <code>dispatch_barrier_async</code> ，该函数只能搭配自定义并行队列 <code>dispatch_queue_t</code> 使用。不能使用： <code>dispatch_get_global_queue</code> ，否则 <code>dispatch_barrier_async</code> 的作用会和 <code>dispatch_async</code> 的作用一模一样。 ）</p>\n<h3 id=\"43-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#43-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"43. 苹果为什么要废弃dispatch_get_current_queue？\"></a>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3><p><code>dispatch_get_current_queue</code>容易造成死锁</p>\n<h3 id=\"44-以下代码运行结果如何？\"><a href=\"#44-以下代码运行结果如何？\" class=\"headerlink\" title=\"44. 以下代码运行结果如何？\"></a>44. 以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><p>只输出：1 。发生主线程锁死。</p>\n<h3 id=\"45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><pre><code class=\"Objective-C\">// 添加键值观察\n/*\n1 观察者，负责处理监听事件的对象\n2 观察的属性\n3 观察的选项\n4 上下文\n*/\n[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];\n</code></pre>\n<p>observer中需要实现一下方法：</p>\n<pre><code class=\"Objective-C\">// 所有的 kvo 监听到事件，都会调用此方法\n/*\n 1. 观察的属性\n 2. 观察的对象\n 3. change 属性变化字典（新／旧）\n 4. 上下文，与监听的时候传递的一致\n */\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;\n</code></pre>\n<h3 id=\"46-如何手动触发一个value的KVO\"><a href=\"#46-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"46. 如何手动触发一个value的KVO\"></a>46. 如何手动触发一个value的KVO</h3><p>所谓的“手动触发”是区别于“自动触发”：</p>\n<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>\n<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>\n<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就<br>会记录旧的值。而当改变发生后，  <code>observeValueForKey:ofObject:change:context:</code> 会被调用，继而 <code>didChangeValueForKey:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>\n<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>\n<p>具体做法如下：</p>\n<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>\n<p>相关代码已放在仓库里。</p>\n<pre><code class=\"Objective-C\">//  .m文件\n//  Created by https://github.com/ChenYilong\n//  微博@iOS程序犭袁(http://weibo.com/luohanchenyilong/).\n//  手动触发 value 的KVO，最后两行代码缺一不可。\n\n//@property (nonatomic, strong) NSDate *now;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _now = [NSDate date];\n    [self addObserver:self forKeyPath:@&quot;now&quot; options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@&quot;1&quot;);\n    [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。\n    NSLog(@&quot;2&quot;);\n    [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。\n    NSLog(@&quot;4&quot;);\n}\n</code></pre>\n<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>\n<blockquote>\n<p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code> 和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p>\n</blockquote>\n<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到有人这么写代码:</p>\n<pre><code class=\"Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@&quot;now&quot;]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@&quot;now&quot;];// 没有必要\n}\n</code></pre>\n<p>这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>\n<p>参考链接： <a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3\" target=\"_blank\" rel=\"external\">Manual Change Notification—Apple 官方文档</a> </p>\n<h3 id=\"47-若一个类有实例变量-NSString-foo-，调用setValue-forKey-时，可以以foo还是-foo-作为key？\"><a href=\"#47-若一个类有实例变量-NSString-foo-，调用setValue-forKey-时，可以以foo还是-foo-作为key？\" class=\"headerlink\" title=\"47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？\"></a>47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？</h3><p>都可以。</p>\n<h3 id=\"48-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#48-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"48. KVC的keyPath中的集合运算符如何使用？\"></a>48. KVC的keyPath中的集合运算符如何使用？</h3><ol>\n<li>必须用在集合对象上或普通对象的集合属性上</li>\n<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>\n<li>格式 @”@sum.age”或 @”集合属性.@max.age”</li>\n</ol>\n<h3 id=\"49-KVC和KVO的keyPath一定是属性么？\"><a href=\"#49-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"49. KVC和KVO的keyPath一定是属性么？\"></a>49. KVC和KVO的keyPath一定是属性么？</h3><p>KVC 支持实例变量，KVO 只能手动支持<a href=\"https://yq.aliyun.com/articles/30483\" target=\"_blank\" rel=\"external\">手动设定实例变量的KVO实现监听</a></p>\n<h3 id=\"50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><p>请参考：</p>\n<ol>\n<li><a href=\"http://tech.glowing.com/cn/implement-kvo/\" target=\"_blank\" rel=\"external\">《如何自己动手实现 KVO》</a></li>\n<li><a href=\"http://stackoverflow.com/a/10042641/3395008\" target=\"_blank\" rel=\"external\"><strong>KVO for manually implemented properties</strong></a> </li>\n</ol>\n<h3 id=\"51-apple用什么方式实现对一个对象的KVO？\"><a href=\"#51-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"51. apple用什么方式实现对一个对象的KVO？\"></a>51. apple用什么方式实现对一个对象的KVO？</h3><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>对 KVO 实现的描述：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>\n</blockquote>\n<p>从<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>\n<blockquote>\n<p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p>\n</blockquote>\n<p><img src=\"http://i62.tinypic.com/sy57ur.jpg\" alt=\"enter image description here\"></p>\n<p> KVO 确实有点黑魔法：</p>\n<blockquote>\n<p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p>\n</blockquote>\n<p>下面做下详细解释：</p>\n<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就会记录旧的值。而当改变发生后， <code>observeValueForKey:ofObject:change:context:</code> 会被调用，继而  <code>didChangeValueForKey:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>\n<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到有人这么写代码:</p>\n<pre><code class=\"Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@&quot;now&quot;]; // 没有必要\n    _now = aDate;\n    [self didChangeValueForKey:@&quot;now&quot;];// 没有必要\n}\n</code></pre>\n<p>这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 <code>addObserver:forKeyPath:options:context:</code> 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>\n<pre><code class=\"Objective-C\">- (void)setNow:(NSDate *)aDate {\n    [self willChangeValueForKey:@&quot;now&quot;];\n    [super setValue:aDate forKey:@&quot;now&quot;];\n    [self didChangeValueForKey:@&quot;now&quot;];\n}\n</code></pre>\n<p>这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>\n<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">Apple 的文档</a>可以得到印证：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>\n</blockquote>\n<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>\n<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href=\"https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html\" target=\"_blank\" rel=\"external\"> 这篇博文 </a>。</p>\n<p>那么 <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 这三个方法的执行顺序是怎样的呢？</p>\n<p> <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code> 很好理解，<code>observeValueForKeyPath:ofObject:change:context:</code> 的执行时机是什么时候呢？</p>\n<p> 先看一个例子：</p>\n<p>代码已放在仓库里。</p>\n<pre><code class=\"Objective-C\">- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self addObserver:self forKeyPath:@&quot;now&quot; options:NSKeyValueObservingOptionNew context:nil];\n    NSLog(@&quot;1&quot;);\n    [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。\n    NSLog(@&quot;2&quot;);\n    [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。\n    NSLog(@&quot;4&quot;);\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context {\n    NSLog(@&quot;3&quot;);\n}\n</code></pre>\n<p><img src=\"http://i66.tinypic.com/ncm7th.jpg\" alt=\"enter image description here\"></p>\n<p>如果单单从下面这个例子的打印上， </p>\n<p>顺序似乎是 <code>wilChangeValueForKey:</code> 、 <code>observeValueForKeyPath:ofObject:change:context:</code> 、 <code>didChangeValueForKey:</code> 。</p>\n<p>其实不然，这里有一个 <code>observeValueForKeyPath:ofObject:change:context:</code>  , 和 <code>didChangeValueForKey:</code> 到底谁先调用的问题：如果 <code>observeValueForKeyPath:ofObject:change:context:</code> 是在 <code>didChangeValueForKey:</code> 内部触发的操作呢？ 那么顺序就是： <code>wilChangeValueForKey:</code> 、  <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> </p>\n<p>不信你把 <code>didChangeValueForKey:</code> 注视掉，看下 <code>observeValueForKeyPath:ofObject:change:context:</code> 会不会执行。</p>\n<p>了解到这一点很重要，正如  <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md#46-如何手动触发一个value的kvo\" target=\"_blank\" rel=\"external\">46. 如何手动触发一个value的KVO</a>  所说的：</p>\n<p>“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>\n<p>而“回调的调用时机”就是在你调用 <code>didChangeValueForKey:</code> 方法时。</p>\n<h3 id=\"52-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#52-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"52. IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><p>参考链接：<a href=\"http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc\" target=\"_blank\" rel=\"external\"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>\n<p>文章告诉我们：</p>\n<blockquote>\n<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p>\n</blockquote>\n<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>\n<h3 id=\"53-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#53-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"53. IB中User Defined Runtime Attributes如何使用？\"></a>53. IB中User Defined Runtime Attributes如何使用？</h3><p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>\n<h3 id=\"54-如何调试BAD-ACCESS错误\"><a href=\"#54-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"54. 如何调试BAD_ACCESS错误\"></a>54. 如何调试BAD_ACCESS错误</h3><ol>\n<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>\n<li><p>通过 Zombie<br><img src=\"http://i.stack.imgur.com/ZAdi0.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p>设置全局断点快速定位问题代码所在行</p>\n</li>\n<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。<br>用法如下：在配置中勾选✅Enable Address Sanitizer<br><img src=\"https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png\" alt=\"enter image description here\"></li>\n</ol>\n<h3 id=\"55-lldb（gdb）常用的调试命令？\"><a href=\"#55-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"55. lldb（gdb）常用的调试命令？\"></a>55. lldb（gdb）常用的调试命令？</h3><ul>\n<li>breakpoint 设置断点定位到某一个函数</li>\n<li>n 断点指针下一步</li>\n<li>po打印对象</li>\n</ul>\n<p>更多 lldb（gdb） 调试命令可查看</p>\n<ol>\n<li><a href=\"http://lldb.llvm.org/lldb-gdb.html\" target=\"_blank\" rel=\"external\"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>\n<li>苹果官方文档：<a href=\"https://developer.apple.com/library/ios/technotes/tn2239/_index.html\" target=\"_blank\" rel=\"external\"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>\n</ol>\n<hr>\n<p>Posted by <a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" target=\"_blank\" rel=\"external\">Creative Commons BY-NC-ND 3.0</a></p>\n"},{"title":"《招聘一个靠谱的iOS》面试题参考答案（上）","date":"2017-05-24T06:56:32.000Z","_content":"[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)—参考答案（上）\n\n\n说明：面试题来源是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)的这篇博文：[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)，其中共55题，除第一题为纠错题外，其他54道均为简答题。\n\n\n作者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。\n\n答案为[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)整理，未经出题者校对，如有纰漏，请向[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)指正。\n\n----------\n\n# 索引\n\n 1.  [风格纠错题](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-风格纠错题) \n\n  1.  [优化部分](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#优化部分) \n  2.  [硬伤部分](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#硬伤部分) \n 2.   [什么情况使用 weak 关键字，相比 assign 有什么不同？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2-什么情况使用-weak-关键字相比-assign-有什么不同) \n 3.  [怎么用 copy 关键字？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字) \n 4.  [这个写法会出什么问题： @property (copy) NSMutableArray *array;](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#4-这个写法会出什么问题-property-copy-nsmutablearray-array) \n 5.  [ 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#5-如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter) \n 6.  [@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#6-property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的) \n 7.  [@protocol 和 category 中如何使用 @property](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#7-protocol-和-category-中如何使用-property) \n 8.  [ runtime 如何实现 weak 属性](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#8-runtime-如何实现-weak-属性) \n 9.  [@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#9-property中有哪些属性关键字-property-后面可以有哪些修饰符) \n 10. [ weak属性需要在dealloc中置nil么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#10-weak属性需要在dealloc中置nil么)\n 11.  [@synthesize和@dynamic分别有什么作用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#11-synthesize和dynamic分别有什么作用) \n 12.  [ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#12-arc下不显式指定任何属性关键字时默认的关键字都有哪些) \n 13.  [用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题) \n  1.  [对非集合类对象的copy操作](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-对非集合类对象的copy操作) \n  2.  [集合类对象的copy与mutableCopy](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2集合类对象的copy与mutablecopy) \n 14.  [@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么) \n 15.  [在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景) \n 16.  [objc中向一个nil对象发送消息将会发生什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#16-objc中向一个nil对象发送消息将会发生什么) \n 17.  [objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#17-objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系) \n 18.  [什么时候会报unrecognized selector的异常？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#18-什么时候会报unrecognized-selector的异常) \n 19.  [一个objc对象如何进行内存布局？（考虑有父类的情况）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#19-一个objc对象如何进行内存布局考虑有父类的情况) \n 20. [一个objc对象的isa的指针指向什么？有什么作用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#20-一个objc对象的isa的指针指向什么有什么作用)\n 21.  [下面的代码输出什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么) \n\n\n ```objectivec\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n ```\n\n 22. 22--55题，请看下篇。\n\n### 1. 风格纠错题\n![enter image description here](http://i.imgur.com/O7Zev94.png)\n修改完的代码：\n\n修改方法有很多种，现给出一种做示例：\n\n\n ```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject<NSCopying>\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n@end\n ```\n\n\n\n\n下面对具体修改的地方，分两部分做下介绍：**硬伤部分** 和 **优化部分**\n。因为**硬伤部分**没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看**优化部分**。\n\n\n#### **优化部分**\n\n 1. enum 建议使用 `NS_ENUM` 和 `NS_OPTIONS` 宏来定义枚举类型，参见官方的 [Adopting Modern Objective-C](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html) 一文：\n\n\n ```objectivec\n//定义一个枚举\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n ```\n （仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 [这里](https://github.com/ChenYilong/iOSInterviewQuestions/issues/9) 。）\n \n 2. age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：\n \n ```objectivec\n\tint -> NSInteger\n\tunsigned -> NSUInteger\n\tfloat -> CGFloat\n\t动画时间 -> NSTimeInterval\n```\n同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。\n这样做的是基于64-bit 适配考虑，详情可参考出题者的博文[《64-bit Tips》](http://blog.sunnyxx.com/2014/12/20/64-bit-tips/)。\n\n\n 3. 如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。\n 4. doLogIn方法不应写在该类中： <p><del>虽然`LogIn`的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： [ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）</del></p>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：\n\n\n > 无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。\n\n\n （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： `-logIn` 对应的应当是注册并登录的一个 Button ，出现 `-logIn` 方法也可能是合理的。）\n\n 5.  doLogIn 方法命名不规范：添加了多余的动词前缀。\n请牢记：\n\n  > 如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 `do`，`does` 这种多余的关键字，动词本身的暗示就足够了。\n\n 应为 `-logIn` （注意： `Login` 是名词， `LogIn`  是动词，都表示登陆。  见[ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）\n\n 6. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中不要用 `with` 来连接两个参数: `withAge:` 应当换为`age:`，`age:` 已经足以清晰说明参数的作用，也不建议用 `andAge:` ：通常情况下，即使有类似 `withA:withB:` 的命名需求，也通常是使用`withA:andB:` 这种命名，用来表示方法执行了两个相对独立的操作（*从设计上来说，这时候也可以拆分成两个独立的方法*），它不应该用作阐明有多个参数，比如下面的：\n\n  ```objectivec\n//错误，不要使用\"and\"来连接参数\n- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;\n//错误，不要使用\"and\"来阐明有多个参数\n- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;\n//正确，使用\"and\"来表示两个相对独立的操作\n- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;\n```\n\n 7. 由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？***)\n 8. “性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？\n\n Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：\n\n \n\n \n ```objectivec\n\n    // .m文件\n    // http://weibo.com/luohanchenyilong/\n    // https://github.com/ChenYilong\n    //\n\n    @implementation CYLUser\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age\n                             sex:(CYLSex)sex {\n        if(self = [super init]) {\n            _name = [name copy];\n            _age = age;\n            _sex = sex;\n        }\n        return self;\n    }\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age {\n        return [self initWithName:name age:age sex:nil];\n    }\n\n    @end\n```\n\n\n\n\n\n\n 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。\n\n  因为出题者没有给出 `.m` 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：\n\n\n\n \n ```objectivec\n\n\n\t// .h文件\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t// 第二种修改方法（基于第一种修改方法的基础上）\n\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n\n\t@interface CYLUser : NSObject<NSCopying>\n\n\t@property (nonatomic, readonly, copy) NSString *name;\n\t@property (nonatomic, readonly, assign) NSUInteger age;\n\t@property (nonatomic, readwrite, assign) CYLSex sex;\n\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;\n\t+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n\t@end\n```\n\n\n  `.h` 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳--》 [***《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》***](http://is.gd/OQ49zk)。）\n\n\n   - 按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。\n   - 如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:\n那么在设计对应 `@property` 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样\n\n\n ```objectivec\n        @property (nonatomic, readonly, copy) NSString *name;\n        @property (nonatomic, readonly, assign) NSUInteger age;\n        @property (nonatomic, readonly, assign) CYLSex sex;\n ```\n\n      由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。\n      \n 9. `initUserModelWithUserName` 如果改为 `initWithName` 会更加简洁，而且足够清晰。\n 10. `UserModel` 如果改为 `User` 会更加简洁，而且足够清晰。\n 11. `UserSex`如果改为`Sex` 会更加简洁，而且足够清晰。\n 12. 第二个 `@property` 中 assign 和 nonatomic 调换位置。\n 推荐按照下面的格式来定义属性\n\n ```objectivec\n@property (nonatomic, readwrite, copy) NSString *name;\n ```\n 属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在[《禅与Objective-C编程艺术 >》](https://github.com/oa414/objc-zen-book-cn#属性定义)里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 > 读写权限 >原子操作。\n\n#### ***硬伤部分***\n\n 1. 在-和(void)之间应该有一个空格\n 3. enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。\n 3. enum 左括号前加一个空格，或者将左括号换到下一行\n 4. enum 右括号后加一个空格\n 2. `UserModel :NSObject` 应为`UserModel : NSObject`，也就是`:`右侧少了一个空格。\n 2.  `@interface` 与 `@property` 属性声明中间应当间隔一行。\n 2. 两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。\n 9. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中方法名与参数之间多了空格。而且 `-` 与 `(id)` 之间少了空格。\n 10. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中方法名与参数之间多了空格：`(NSString*)name` 前多了空格。\n 10. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中 `(NSString*)name`,应为 `(NSString *)name`，少了空格。 \n 7.  <p><del>doLogIn方法中的 `LogIn` 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。\n （勘误： `Login` 是名词， `LogIn`  是动词，都表示登陆的意思。见： [ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）</del></p>\n\n### 2. 什么情况使用 weak 关键字，相比 assign 有什么不同？\n什么情况使用 weak 关键字？\n\n\n 1. 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性\n\n 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***\n\n不同点：\n \n 1. `weak` 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，\n然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n而 `assign` 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 \nNSlnteger 等)的简单赋值操作。\n\n 2. assign 可以用非 OC 对象,而 weak 必须用于 OC 对象\n\n### 3. 怎么用 copy 关键字？\n用途：\n\n 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；\n 2. block 也经常使用 copy 关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：\n\n  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？\n\n\n ```objectivec\n @property (nonatomic, copy) NSString *userId;\n\n - (instancetype)initWithUserId:(NSString *)userId {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n    _userId = [userId copy];\n    return self;\n }\n\n ```\n\n\n ![enter image description here](http://i.imgur.com/VlVKl8L.png)\n\n下面做下解释：\n copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。\n当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。\n\n\n> 用 `@property` 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n \n该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***\n\n\n### 4. 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`\n两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； \n\n第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。\n\n比如下面的代码就会发生崩溃\n\n \n \n```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\n@property (nonatomic, copy) NSMutableArray *mutableArray;\n```\n\n\n```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];\nself.mutableArray = array;\n[self.mutableArray removeObjectAtIndex:0];\n```\n\n接下来就会奔溃：\n\n \n```objectivec\n -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460\n```\n\n\n\n第2条原因，如下：\n\n> 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。\n\n在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。\n\n在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。\n\n一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。\n\n因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用\n atomic 属性通常都不会有性能瓶颈。\n\n### 5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n\n> 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 `NSCopying` 与 `NSMutableCopying` 协议。\n\n\n\n\n具体步骤：\n\n 1. 需声明该类遵从 NSCopying 协议\n 2. 实现 NSCopying 协议。该协议只有一个方法: \n\n ```objectivec\n- (id)copyWithZone:(NSZone *)zone;\n```\n注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。\n\n以第一题的代码为例：\n   \n\n ```objectivec\n\t// .h文件\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t// 修改完的代码\n\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n\n\t@interface CYLUser : NSObject<NSCopying>\n\n\t@property (nonatomic, readonly, copy) NSString *name;\n\t@property (nonatomic, readonly, assign) NSUInteger age;\n\t@property (nonatomic, readonly, assign) CYLSex sex;\n\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\t+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n\t@end\n ```\n\n\n然后实现协议中规定的方法：\n\n \n```objectivec\n- (id)copyWithZone:(NSZone *)zone {\n\tCYLUser *copy = [[[self class] allocWithZone:zone] \n\t\t             initWithName:_name\n \t\t\t\t\t\t\t      age:_age\n\t\t\t\t\t\t          sex:_sex];\n\treturn copy;\n}\n```\n但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:\n\n```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 以第一题《风格纠错题》里的代码为例\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject<NSCopying>\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n- (void)addFriend:(CYLUser *)user;\n- (void)removeFriend:(CYLUser *)user;\n\n@end\n```\n\n// .m文件\n\n\n\n ```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n//\n\n@implementation CYLUser {\n    NSMutableSet *_friends;\n}\n\n- (void)setName:(NSString *)name {\n    _name = [name copy];\n}\n\n- (instancetype)initWithName:(NSString *)name\n                         age:(NSUInteger)age\n                         sex:(CYLSex)sex {\n    if(self = [super init]) {\n        _name = [name copy];\n        _age = age;\n        _sex = sex;\n        _friends = [[NSMutableSet alloc] init];\n    }\n    return self;\n}\n\n- (void)addFriend:(CYLUser *)user {\n    [_friends addObject:user];\n}\n\n- (void)removeFriend:(CYLUser *)user {\n    [_friends removeObject:user];\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n    CYLUser *copy = [[[self class] allocWithZone:zone]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [_friends mutableCopy];\n    return copy;\n}\n\n- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n\n@end\n\n ```\n\n以上做法能满足基本的需求，但是也有缺陷：\n\n> 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。\n\n【注：深浅拷贝的概念，在下文中有介绍，详见下文的：***用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？***】\n\n在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:\n\t\n\n ```objectivec\n- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n\n ```\n\n至于***如何重写带 copy 关键字的 setter***这个问题，\n\n\n如果抛开本例来回答的话，如下：\n\n\n \n```objectivec\n- (void)setName:(NSString *)name {\n    //[_name release];\n    _name = [name copy];\n}\n```\n\n不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”\n\n\n ```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) {\n        //[_name release];//MRC\n        _name = [name copy];\n    }\n}\n ```\n\n\n\n这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：\n\n![enter image description here](http://i.imgur.com/UwV9oSn.jpeg)\n\n克强总理这样评价你的代码风格：\n\n![enter image description here](http://i.imgur.com/N77Lkic.png)\n\n我和总理的意见基本一致：\n\n\n> 老百姓 copy 一下，咋就这么难？\n\n\n\n\n你可能会说：\n\n \n之所以在这里做`if判断` 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。\n(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)\n\n\n但是你有没有考虑过代价：\n\n\n> 你每次调用 `setX:` 都会做 if 判断，这会让 `setX:` 变慢，如果你在 `setX:`写了一串复杂的 `if+elseif+elseif+...` 判断，将会更慢。\n\n要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：\n\n```objectivec\n[a setX:x1];\n[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？\n```\n\n或者\n\n\n```objectivec\n[a setX:[a x]];   //队友咆哮道：你在干嘛？！！\n```\n\n> 不要在 setter 里进行像 `if(_obj != newObj)` 这样的判断。（该观点参考链接：[ ***How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure*** ](http://vgable.com/blog/tag/autorelease/)\n）\n\n\n什么情况会在 copy setter 里做 if 判断？\n例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：\n\n \n```objectivec\n-(void)setSpeed:(int)_speed{\n    if(_speed < 0) speed = 0;\n    if(_speed > 300) speed = 300;\n    _speed = speed;\n}\n```\n\n\n\n回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”--copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。\n\n那如何确保 name 被 copy？在初始化方法(initializer)中做：\n\n ```objectivec\n\t- (instancetype)initWithName:(NSString *)name \n\t\t\t\t\t\t\t\t age:(NSUInteger)age \n\t\t\t\t\t\t\t\t sex:(CYLSex)sex {\n\t     if(self = [super init]) {\n\t     \t_name = [name copy];\n\t     \t_age = age;\n\t     \t_sex = sex;\n\t     \t_friends = [[NSMutableSet alloc] init];\n\t     }\n\t     return self;\n\t}\n\n ```\n\n\n\t\n### 6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\n\n**@property 的本质是什么？**\n\n> @property = ivar + getter + setter;\n\n下面解释下：\n\n> “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。\n\n“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 `Objective-C 2.0` 的一部分。\n而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。\n正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:\n\n> 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。\n所以你也可以这么说：\n\n> @property = getter + setter;\n\n例如下面这个类：\n\n\n\n ```objectivec\n@interface Person : NSObject\n@property NSString *firstName;\n@property NSString *lastName;\n@end\n ```\n\n\n上述代码写出来的类与下面这种写法等效：\n\n\n\n ```objectivec\n@interface Person : NSObject\n- (NSString *)firstName;\n- (void)setFirstName:(NSString *)firstName;\n- (NSString *)lastName;\n- (void)setLastName:(NSString *)lastName;\n@end\n ```\n\n**更新**：\n\nproperty在runtime中是`objc_property_t`定义如下:\n\n```objectivec\ntypedef struct objc_property *objc_property_t;\n```\n\n而`objc_property`是一个结构体，包括name和attributes，定义如下：\n\n```objectivec\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n而attributes本质是`objc_property_attribute_t`，定义了property的一些属性，定义如下：\n\n```objectivec\n/// Defines a property attribute\ntypedef struct {\n    const char *name;           /**< The name of the attribute */\n    const char *value;          /**< The value of the attribute (usually empty) */\n} objc_property_attribute_t;\n```\n\n而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。\n\n例如：我们定义一个string的property`@property (nonatomic, copy) NSString *string;`，通过 `property_getAttributes(property)`获取到attributes并打印出来之后的结果为`T@\"NSString\",C,N,V_string`\n\n其中T就代表类型，可参阅[Type Encodings](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。\n\n\n\n**ivar、getter、setter 是如何生成并添加到这个类中的?**\n\n> “自动合成”( autosynthesis)\n\n完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译\n器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为\n `_firstName` 与 `_lastName`。也可以在类的实现代码里通过\n `@synthesize` 语法来指定实例变量的名字.\n\n\n\n ```objectivec\n@implementation Person\n@synthesize firstName = _myFirstName;\n@synthesize lastName = _myLastName;\n@end\n ```\n\n我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西\n\n 1. `OBJC_IVAR_$类名$属性名称` ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。\n 2. setter 与 getter 方法对应的实现函数\n 2. `ivar_list` ：成员变量列表\n 2. `method_list` ：方法列表\n 2. `prop_list` ：属性列表\n\n\n也就是说我们每次在增加一个属性,系统都会在 `ivar_list` 中添加一个成员变量的描述,在 `method_list` 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.\n\n### 7. @protocol 和 category 中如何使用 @property\n\n 1. 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性\n 2. category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：\n\n  1. `objc_setAssociatedObject`\n  2. `objc_getAssociatedObject`\n\n### 8. runtime 如何实现 weak 属性\n\n要实现 weak 属性，首先要搞清楚 weak 属性的特点：\n\n> weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n\n那么 runtime 如何实现 weak 变量的自动置nil？\n\n\n> runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到`__weak`引用的解除时间。）\n\n\n先看下 runtime 里源码的实现：\n\n\n ```objectivec\n/**\n * The internal structure stored in the weak references table. \n * It maintains and stores\n * a hash set of weak references pointing to an object.\n * If out_of_line==0, the set is instead a small inline array.\n */\n#define WEAK_INLINE_COUNT 4\nstruct weak_entry_t {\n    DisguisedPtr<objc_object> referent;\n    union {\n        struct {\n            weak_referrer_t *referrers;\n            uintptr_t        out_of_line : 1;\n            uintptr_t        num_refs : PTR_MINUS_1;\n            uintptr_t        mask;\n            uintptr_t        max_hash_displacement;\n        };\n        struct {\n            // out_of_line=0 is LSB of one of these (don't care which)\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        };\n    };\n};\n\n/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */\nstruct weak_table_t {\n    weak_entry_t *weak_entries;\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\n ```\n\n具体完整实现参照 [objc/objc-weak.h](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h) 。\n\n\n\n我们可以设计一个函数（伪代码）来表示上述机制：\n\n`objc_storeWeak(&a, b)`函数：\n\n`objc_storeWeak`函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\n\n你可以把`objc_storeWeak(&a, b)`理解为：`objc_storeWeak(value, key)`，并且当key变nil，将value置nil。\n\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n而如果a是由 assign 修饰的，则：\n在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。\n\n\n下面我们将基于`objc_storeWeak(&a, b)`函数，使用伪代码模拟“runtime如何实现weak属性”：\n \n\n\n \n```objectivec\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&obj1);\n```\n\n下面对用到的两个方法`objc_initWeak`和`objc_destroyWeak`做下解释：\n\n总体说来，作用是：\n通过`objc_initWeak`函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过`objc_destoryWeak`函数释放该变量（obj1）。\n\n下面分别介绍下方法的内部实现：\n\n`objc_initWeak`函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用`objc_storeWeak`函数。\n\n\n\n \n```objectivec\nobj1 = 0；\nobj_storeWeak(&obj1, obj);\n```\n\n也就是说：\n\n>  weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\n\n\n\n\n然后`obj_destroyWeak`函数将0（nil）作为参数，调用`objc_storeWeak`函数。\n\n`objc_storeWeak(&obj1, 0);`\n\n前面的源代码与下列源代码相同。\n\n\n\n```objectivec\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&obj1, 0);\n```\n\n\n`objc_storeWeak` 函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。\n\n使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：\n\n> 如何让不使用weak修饰的@property，拥有weak的效果。\n\n\n我们从setter方法入手：\n\n（注意以下的 `cyl_runAtDealloc` 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) ）\n\n ```objectivec\n- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n ```\n\n也就是有两个步骤：\n\n 1. 在setter方法中做如下设置：\n\n\n ```objectivec\n        objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n ```\n\n 2. 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：\n \n ```objectivec\n//要销毁的目标对象\nid objectToBeDeallocated;\n//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。\nid objectWeWantToBeReleasedWhenThatHappens;\nobjc_setAssociatedObject(objectToBeDeallocted,\n                         someUniqueKey,\n                         objectWeWantToBeReleasedWhenThatHappens,\n                         OBJC_ASSOCIATION_RETAIN);\n```\n\n知道了思路，我们就开始实现 `cyl_runAtDealloc` 方法，实现过程分两部分：\n\n第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。\n\n// .h文件\n\n ```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\ntypedef void (^voidBlock)(void);\n\n@interface CYLBlockExecutor : NSObject\n\n- (id)initWithBlock:(voidBlock)block;\n\n@end\n ```\n\n// .m文件\n\n ```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\n#import \"CYLBlockExecutor.h\"\n\n@interface CYLBlockExecutor() {\n    voidBlock _block;\n}\n@implementation CYLBlockExecutor\n\n- (id)initWithBlock:(voidBlock)aBlock\n{\n    self = [super init];\n    \n    if (self) {\n        _block = [aBlock copy];\n    }\n    \n    return self;\n}\n\n- (void)dealloc\n{\n    _block ? _block() : nil;\n}\n\n@end\n ```\n\n第二部分：核心代码：利用runtime实现`cyl_runAtDealloc`方法\n\n ```objectivec\n// CYLNSObject+RunAtDealloc.h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import \"CYLBlockExecutor.h\"\n\nconst void *runAtDeallocBlockKey = &runAtDeallocBlockKey;\n\n@interface NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block;\n\n@end\n\n\n// CYLNSObject+RunAtDealloc.m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import \"CYLNSObject+RunAtDealloc.h\"\n#import \"CYLBlockExecutor.h\"\n\n@implementation NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block\n{\n    if (block) {\n        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];\n        \n        objc_setAssociatedObject(self,\n                                 runAtDeallocBlockKey,\n                                 executor,\n                                 OBJC_ASSOCIATION_RETAIN);\n    }\n}\n\n@end\n ```\n\n使用方法：\n导入\n\n\n ```objectivec\n    #import \"CYLNSObject+RunAtDealloc.h\"\n ```\n\n然后就可以使用了：\n\n\n ```objectivec\nNSObject *foo = [[NSObject alloc] init];\n\n[foo cyl_runAtDealloc:^{\n    NSLog(@\"正在释放foo!\");\n}];\n ```\n\n\n如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) \n\n参考博文： [***Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object***](http://stackoverflow.com/a/31560217/3395008)\n\n\n### 9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\n属性可以拥有的特质分为四类:\n \n 1. 原子性--- `nonatomic` 特质\n\n    在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。\n\n 2. 读/写权限---`readwrite(读写)`、`readonly (只读)`\n 3. 内存管理语义---`assign`、`strong`、 `weak`、`unsafe_unretained`、`copy`\n 4. 方法名---`getter=<name>` 、`setter=<name>`\n   \n  `getter=<name>`的样式：\n\n\n ```objectivec\n        @property (nonatomic, getter=isOn) BOOL on;\n ```\n <p><del>（ `setter=<name>`这种不常用，也不推荐使用。故不在这里给出写法。）\n</del></p>\n\n\n `setter=<name>`一般用在特殊的情境下，比如：\n\n\n在数据反序列化、转模型的过程中，服务器返回的字段如果以 `init` 开头，所以你需要定义一个 `init` 开头的属性，但默认生成的 `setter` 与 `getter` 方法也会以 `init` 开头，而编译器会把所有以 `init` 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。\n\n这时你就可以使用下面的方式来避免编译器报错：\n\n\n ```objectivec\n@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;\n\n ```\n\n\n另外也可以用关键字进行特殊说明，来避免编译器报错：\n\n ```objectivec\n@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;\n- (NSString *)initBy __attribute__((objc_method_family(none)));\n ```\n\n 3. 不常用的：`nonnull`,`null_resettable`,`nullable`\n\n\n注意：很多人会认为如果属性具备 nonatomic 特质，则不使用\n“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：\n\n\n ```objectivec\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n{\n    bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);\n    bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n}\n ```\n\n### 10. weak属性需要在dealloc中置nil么？\n不需要。\n\n\n> 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理\n\n即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：\n\n正如上文的：***runtime 如何实现 weak 属性*** 中提到的：\n\n我们模拟下 weak 的 setter 方法，应该如下：\n\n\n ```objectivec\n- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n ```\n\n如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) \n\n\n也即:\n\n> 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n\n\n\n\n\n\n### 11. @synthesize和@dynamic分别有什么作用？\n\n 1. @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是`@syntheszie var = _var;`\n 2. @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。\n 3. @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 `instance.var = someVar`，由于缺 setter 方法会导致程序崩溃；或者当运行到 `someVar = var` 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。\n\n### 12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\n\n 1. 对应基本数据类型默认关键字是\n \n atomic,readwrite,assign\n 2. 对于普通的 Objective-C 对象\n  \n atomic,readwrite,strong\n\n参考链接：\n\n 1. [ ***Objective-C ARC: strong vs retain and weak vs assign*** ](http://stackoverflow.com/a/15541801/3395008)\n\n 2. [ ***Variable property attributes or Modifiers in iOS*** ](http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html)\n\n### 13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\n\n\n 1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.\n 2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.\n\n copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。\n当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。\n\n\n举例说明：\n\n定义一个以 strong 修饰的 array：\n\n ```objectivec\n@property (nonatomic ,readwrite, strong) NSArray *array;\n ```\n\n然后进行下面的操作：\n\n ```objectivec\n    NSMutableArray *mutableArray = [[NSMutableArray alloc] init];\n    NSArray *array = @[ @1, @2, @3, @4 ];\n    self.array = mutableArray;\n    [mutableArray removeAllObjects];;\n    NSLog(@\"%@\",self.array);\n    \n    [mutableArray addObjectsFromArray:array];\n    self.array = [mutableArray copy];\n    [mutableArray removeAllObjects];;\n    NSLog(@\"%@\",self.array);\n ```\n\n打印结果如下所示：\n\n ```objectivec\n2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (\n)\n2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (\n    1,\n    2,\n    3,\n    4\n)\n ```\n\n（详见仓库内附录的 Demo。）\n\n\n为了理解这种做法，首先要知道，两种情况：\n\n\n 1. 对非集合类对象的 copy 与 mutableCopy 操作；\n 2. 对集合类对象的 copy 与 mutableCopy 操作。\n\n#### 1. 对非集合类对象的copy操作：\n\n在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：\n\n - [immutableObject copy] // 浅复制\n - [immutableObject mutableCopy] //深复制\n - [mutableObject copy] //深复制\n - [mutableObject mutableCopy] //深复制\n\t\n比如以下代码：\n\n\n ```objectivec\nNSMutableString *string = [NSMutableString stringWithString:@\"origin\"];//copy\nNSString *stringCopy = [string copy];\n ```\n\n\n查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：\n\n\n ```objectivec\n[string appendString:@\"origion!\"]\n ```\n\nstringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。\n  集合类对象以此类推。\n所以，\n\n> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n\n#### 2、集合类对象的copy与mutableCopy\n\n集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：\n\n ```objectivec\nNSArray *array = @[@[@\"a\", @\"b\"], @[@\"c\", @\"d\"]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n ```\n\n查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：\n\n\n ```objectivec\nNSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@\"a\"],@\"b\",@\"c\",nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n ```\n\n\n查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：\n\n在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：\n\n\n ```objectivec\n[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n ```\n\n\n这个代码结论和非集合类的非常相似。\n\n参考链接：[iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)\n\n### 14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为`_foo`的实例变量，那么还会自动合成新变量么？\n在回答之前先说明下一个概念：\n\n> 实例变量 = 成员变量 ＝ ivar\n\n这些说法，笔者下文中，可能都会用到，指的是一个东西。\n\n\n正如\n[Apple官方文档 ***You Can Customize Synthesized Instance Variable Names***](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6) 所说：\n![enter image description here](http://i.imgur.com/D6d0zGJ.png)\n\n如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。\n\n \n```objectivec\n@interface CYLPerson : NSObject \n@property NSString *firstName; \n@property NSString *lastName; \n@end\n```\n\n\n在上例中，会生成两个实例变量，其名称分别为\n `_firstName` 与 `_lastName`。也可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:\n \n```objectivec\n@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end \n```\n\n\n\n上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName` ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。\n\n总结下 @synthesize 合成实例变量的规则，有以下几点：\n\n\n 1. 如果指定了成员变量的名称,会生成一个指定的名称的成员变量,\n\n 2. 如果这个成员已经存在了就不再生成了.\n 2. 如果是 `@synthesize foo;` 还会生成一个名称为foo的成员变量，也就是说：\n\n > 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,\n\n\n\n 2. 如果是 `@synthesize foo = _foo;` 就不会生成成员变量了.\n\n假如 property 名为 foo，存在一个名为 `_foo` 的实例变量，那么还会自动合成新变量么？\n不会。如下图：\n\n![enter image description here](http://i.imgur.com/t28ge4W.png)\n\n\n### 15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\n\n回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？\n\n 1. 同时重写了 setter 和 getter 时\n 2. 重写了只读属性的 getter 时\n 2. 使用了 @dynamic 时\n 2. 在 @protocol 中定义的所有属性\n 2. 在 category 中定义的所有属性\n 2. 重载的属性 \n \n 当你在子类中重载了父类中的属性，你必须 使用 `@synthesize` 来手动合成ivar。\n\n除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 `@dynamic` 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。\n\n因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 `@synthesize` 来手动合成 ivar。\n\n其实，`@synthesize` 语法还有一个应用场景，但是不太建议大家使用：\n\n可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:\n \n```objectivec\n@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end \n```\n\n\n\n上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。\n\n\n\n举例说明：应用场景：\n\n\n ```objectivec\n\n//\n// .m文件\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 打开第14行和第17行中任意一行，就可编译成功\n\n@import Foundation;\n\n@interface CYLObject : NSObject\n@property (nonatomic, copy) NSString *title;\n@end\n\n@implementation CYLObject {\n    //    NSString *_title;\n}\n\n//@synthesize title = _title;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _title = @\"微博@iOS程序犭袁\";\n    }\n    return self;\n}\n\n- (NSString *)title {\n    return _title;\n}\n\n- (void)setTitle:(NSString *)title {\n    _title = [title copy];\n}\n\n@end\n ```\n\n结果编译器报错：\n![enter image description here](http://i.imgur.com/fAEGHIo.png)\n\n当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：\n\n 1. 要么如第14行：手动创建 ivar\n 2. 要么如第17行：使用`@synthesize foo = _foo;` ，关联 @property 与 ivar。\n\n更多信息，请戳- 》[ ***When should I use @synthesize explicitly?*** ](http://stackoverflow.com/a/19821816/3395008)\n### 16. objc中向一个nil对象发送消息将会发生什么？\n在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:\n\n 1. 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  \n\n \n ```objectivec\nPerson * motherInlaw = [[aPerson spouse] mother];\n```\n\n\n 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。\n 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。\n 2. 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。\n 2. 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。\n\n具体原因如下：\n\n\n> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。\n\n\n那么，为了方便理解这个内容，还是贴一个objc的源代码：\n\n\n \n```objectivec\n// runtime.h（类在runtime中的定义）\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nstruct objc_class {\n  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n  #if !__OBJC2__\n  Class super_class OBJC2_UNAVAILABLE; // 父类\n  const char *name OBJC2_UNAVAILABLE; // 类名\n  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n  #endif\n  } OBJC2_UNAVAILABLE;\n```\n\nobjc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。\n那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。\n\n\n### 17. objc中向一个对象发送消息[obj foo]和`objc_msgSend()`函数之间有什么关系？\n具体原因同上题：该方法编译之后就是`objc_msgSend()`函数调用.\n\n我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和`objc_msgSend()`函数之间有什么关系。\n\n以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，\n\n```objectivec\n//\n//  main.m\n//  http://weibo.com/luohanchenyilong/\n//  https://github.com/ChenYilong\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n\n#import \"CYLTest.h\"\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOSinit))];\n        return 0;\n    }\n}\n```\n\n在终端中输入\n\n```objectivec\nclang -rewrite-objc main.m\n```\n就可以生成一个`main.cpp`的文件，在最低端（10万4千行左右）\n\n![enter image description here](http://i.imgur.com/eAH5YWn.png)\n\n我们可以看到大概是这样的：\n\n \n```objectivec\n((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(\"foo\"));\n```\n\n也就是说：\n\n>  [obj foo];在objc动态编译时，会被转意为：`objc_msgSend(obj, @selector(foo));`。\n\n### 18. 什么时候会报unrecognized selector的异常？\n\n简单来说：\n\n\n> 当调用该对象上某个方法,而该对象上没有实现这个方法的时候，\n可以通过“消息转发”进行解决。\n\n\n\n简单的流程如下，在上一题中也提到过：\n\n\n> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。\n\n\nobjc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：\n\n\n 1. Method resolution\n\n objc运行时会调用`+resolveInstanceMethod:`或者 `+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。\n\n 2. Fast forwarding\n\n 如果目标对象实现了`-forwardingTargetForSelector:`，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。\n只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。\n这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。\n 3. Normal forwarding\n\n 这一步是Runtime最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回nil，Runtime则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送`-forwardInvocation:`消息给目标对象。\n\n为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ `_objc_msgForward_demo` ”,可运行起来看看。\n\n### 19. 一个objc对象如何进行内存布局？（考虑有父类的情况）\n\n - 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.\n - 每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的\n\n\n  1. 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）\n  2. 成员变量的列表,\n  2. 属性列表,\n\n 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。\n\n每个 Objective-C 对象都有相同的结构，如下图所示：\n\n ![enter image description here](http://i.imgur.com/7mJlUj1.png)\n\n翻译过来就是\n\n|  Objective-C 对象的结构图 | \n ------------- |\n ISA指针 |\n 根类的实例变量 |\n 倒数第二层父类的实例变量 |\n ... |\n 父类的实例变量 |\n 类的实例变量 | \n\n\n - 根对象就是NSObject，它的superclass指针指向nil\n\n - 类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。\n\n\n\n如图:\n![enter image description here](http://i.imgur.com/w6tzFxz.png)\n\n### 20. 一个objc对象的isa的指针指向什么？有什么作用？\n\n指向他的类对象,从而可以找到对象上的方法\n\n### 21. 下面的代码输出什么？\n\n\n\n\n ```objectivec\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n ```\n\n\n**答案：**\n\n都输出 Son\n\n\tNSStringFromClass([self class]) = Son\n\tNSStringFromClass([super class]) = Son\n \n\n\n这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。\n \n\n我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？\n\n很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。\n\n\n上面的例子不管调用`[self class]`还是`[super class]`，接受消息的对象都是当前 `Son ＊xxx` 这个对象。\n\n当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。\n\n\n这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ `_iVar` ），而非点语法（ `self.iVar` ）。\n\n点语法（ `self.iVar` ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：\n\n ```objectivec\n//\n//  ChenPerson.m\n//  \n//\n//  Created by https://github.com/ChenYilong on 15/8/30.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import \"ChenPerson.h\"\n\n@implementation ChenPerson\n\n@synthesize lastName = _lastName;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([super class]));\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    //设置方法一：如果setter采用是这种方式，就可能引起崩溃\n//    if (![lastName isEqualToString:@\"陈\"])\n//    {\n//        [NSException raise:NSInvalidArgumentException format:@\"姓不是陈\"];\n//    }\n//    _lastName = lastName;\n    \n    //设置方法二：如果setter采用是这种方式，就可能引起崩溃\n    _lastName = @\"陈\";\n    NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, @\"会调用这个方法,想一下为什么？\");\n\n}\n\n@end\n ```\n\n在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ `self.lastName` ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，\n\n\n为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。\n\n\n如果基类的代码是这样的：\n\n\n ```objectivec\n//\n//  Person.m\n//  nil对象调用点语法\n//\n//  Created by https://github.com/ChenYilong on 15/8/29.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//  \n\n#import \"Person.h\"\n\n@implementation Person\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lastName = @\"\";\n        //NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        //NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, self.lastName);\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, @\"根本不会调用这个方法\");\n    _lastName = @\"炎黄\";\n}\n\n@end\n ```\n\n那么打印结果将会是这样的：\n\n ```objectivec\n 🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？\n 🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson\n 🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson\n ```\n\n我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。\n\n\n接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:\n\n\n ```objectivec\n\t$ clang -rewrite-objc test.m\n ```\n\n将这道题目中给出的代码被转化为:\n\n\n ```objectivec\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"class\"))));\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(\"Son\")) }, sel_registerName(\"class\"))));\n ```\n\n从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 `objc_msgSend`函数。看下函数定义：\n\n\n ```objectivec\n\tid objc_msgSend(id self, SEL op, ...)\n ```\n我们把 self 做为第一个参数传递进去。\n\n而在调用 [super class]时，会转化成 `objc_msgSendSuper`函数。看下函数定义:\n\n\n ```objectivec\n\tid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n ```\n\n第一个参数是 `objc_super` 这样一个结构体，其定义如下:\n\n\n ```objectivec\nstruct objc_super {\n\t   __unsafe_unretained id receiver;\n\t   __unsafe_unretained Class super_class;\n};\n ```\n\n结构体有两个成员，第一个成员是 receiver, 类似于上面的 `objc_msgSend`函数第一个参数self 。第二个成员是记录当前类的父类是什么。\n\n所以，当调用 ［self class] 时，实际先调用的是 `objc_msgSend`函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。\n\nobjc Runtime开源代码对- (Class)class方法的实现:\n\n\n ```objectivec\n- (Class)class {\n    return object_getClass(self);\n}\n ```\n\n而当调用 `[super class]`时，会转换成`objc_msgSendSuper函数`。第一步先构造 `objc_super` 结构体，结构体第一个成员就是 `self` 。\n第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))` , 实际该函数输出结果为 Father。\n\n第二步是去 Father这个类里去找 `- (Class)class`，没有，然后去NSObject类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))`去调用，\n\n此时已经和`[self class]`调用相同了，故上述输出结果仍然返回 Son。\n\n\n参考链接：[微博@Chun_iOS](http://weibo.com/junbbcom)的博文[刨根问底Objective－C Runtime（1）－ Self & Super](http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/)\n\n\n### 22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n\n每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.\n\n### 23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\n\n - 在ARC下不需要。\n - <p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要\n\n> 无论在MRC下还是ARC下均不需要。\n\n\n[ ***2011年版本的Apple API 官方文档 - Associative References***  ](https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html) 一节中有一个MRC环境下的例子：\n\n\n \n```objectivec\n// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 摘自2011年版本的Apple API 官方文档 - Associative References \n\nstatic char overviewKey;\n \nNSArray *array =\n    [[NSArray alloc] initWithObjects:@\"One\", @\"Two\", @\"Three\", nil];\n// For the purposes of illustration, use initWithFormat: to ensure\n// the string can be deallocated\nNSString *overview =\n    [[NSString alloc] initWithFormat:@\"%@\", @\"First three numbers\"];\n \nobjc_setAssociatedObject (\n    array,\n    &overviewKey,\n    overview,\n    OBJC_ASSOCIATION_RETAIN\n);\n \n[overview release];\n// (1) overview valid\n[array release];\n// (2) overview invalid\n```\n文档指出 \n\n> At point 1, the string `overview` is still valid because the `OBJC_ASSOCIATION_RETAIN` policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), `overview` is released and so in this case also deallocated.\n\n我们可以看到，在`[array release];`之后，overview就会被release释放掉了。\n\n既然会被销毁，那么具体在什么时间点？\n\n\n> 根据[ ***WWDC 2011, Session 322 (第36分22秒)*** ](https://developer.apple.com/videos/wwdc/2011/#322-video)中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。\n\n对象的内存销毁时间表，分四个步骤：\n\n\t// 对象的内存销毁时间表\n\t// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n\t// https://github.com/ChenYilong\n    // 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 \n\n     1. 调用 -release ：引用计数变为零\n         * 对象正在被销毁，生命周期即将结束.\n         * 不能再有新的 __weak 弱引用， 否则将指向 nil.\n         * 调用 [self dealloc] \n     2. 子类 调用 -dealloc\n         * 继承关系中最底层的子类 在调用 -dealloc\n         * 如果是 MRC 代码 则会手动释放实例变量们（iVars）\n         * 继承关系中每一层的父类 都在调用 -dealloc\n     3. NSObject 调 -dealloc\n         * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法\n     4. 调用 object_dispose()\n         * 为 C++ 的实例变量们（iVars）调用 destructors \n         * 为 ARC 状态下的 实例变量们（iVars） 调用 -release \n         * 解除所有使用 runtime Associate方法关联的对象\n         * 解除所有 __weak 引用\n         * 调用 free()\n\n\n对象的内存销毁时间表：[参考链接](http://stackoverflow.com/a/10843510/3395008)。\n\n\n\n\n\n### 24. objc中的类方法和实例方法有什么本质区别和联系？\n\n类方法：\n\n 1. 类方法是属于类对象的\n 2. 类方法只能通过类对象调用\n 2. 类方法中的self是类对象\n 2. 类方法可以调用其他的类方法\n 2. 类方法中不能访问成员变量\n 2. 类方法中不能直接调用对象方法\n\n实例方法：\n\n 1. 实例方法是属于实例对象的\n 2. 实例方法只能通过实例对象调用\n 2. 实例方法中的self是实例对象\n 2. 实例方法中可以访问成员变量\n 2. 实例方法中直接调用实例方法\n 2. 实例方法中也可以调用类方法(通过类名)\n\n\n下一篇文章将发布在[这里](https://github.com/ChenYilong/iOSInterviewQuestions)，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)\n----------\n@property部分主要参考\n[Apple官方文档：Properties Encapsulate an Object’s Values](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2)\nruntime部分主要参考[Apple官方文档：Declared Properties](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)\n\n\n### 25. `_objc_msgForward`函数是做什么的，直接调用它将会发生什么？\n\n### 26. runtime如何实现weak变量的自动置nil？\n\n### 27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ \n\n### 28. runloop和线程有什么关系？\n\n\n### 29. runloop的mode作用是什么？\n\n### 30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\n### 31. 猜想runloop内部是如何实现的？\n### 32. objc使用什么机制管理对象内存？\n### 33. ARC通过什么方式帮助开发者管理内存？\n### 34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n### 35. `BAD_ACCESS`在什么情况下出现？\n### 36. 苹果是如何实现autoreleasepool的？ \n### 37. 使用block时什么情况会发生引用循环，如何解决？\n### 38. 在block内如何修改block外部变量？\n### 39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ \n### 40. GCD的队列（`dispatch_queue_t`）分哪两种类型？\n### 41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n### 42. `dispatch_barrier_async`的作用是什么？\n### 43. 苹果为什么要废弃`dispatch_get_current_queue`？\n### 44. 以下代码运行结果如何？\n\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n\n### 45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n### 46. 如何手动触发一个value的KVO\n### 47. 若一个类有实例变量`NSString *_foo`，调用setValue:forKey:时，可以以foo还是`_foo`作为key？\n### 48. KVC的keyPath中的集合运算符如何使用？\n### 49. KVC和KVO的keyPath一定是属性么？\n### 50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n### 51. apple用什么方式实现对一个对象的KVO？ \n### 52. IBOutlet连出来的视图属性为什么可以被设置成weak?\n### 53. IB中User Defined Runtime Attributes如何使用？ \n### 54. 如何调试`BAD_ACCESS`错误\n### 55. lldb（gdb）常用的调试命令？\n\n\n\n----------\n\n\nPosted by [微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)  \n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 3.0](http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)\n\n\n","source":"_posts/《招聘一个靠谱的iOS》面试题参考答案（上）.md","raw":"---\ntitle: 《招聘一个靠谱的iOS》面试题参考答案（上）\ndate: 2017-05-24 14:56:32\ncategories: \n\t- 面试经\n---\n[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)—参考答案（上）\n\n\n说明：面试题来源是[微博@我就叫Sunny怎么了](http://weibo.com/u/1364395395)的这篇博文：[《招聘一个靠谱的 iOS》](http://blog.sunnyxx.com/2015/07/04/ios-interview/)，其中共55题，除第一题为纠错题外，其他54道均为简答题。\n\n\n作者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。\n\n答案为[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)整理，未经出题者校对，如有纰漏，请向[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)指正。\n\n----------\n\n# 索引\n\n 1.  [风格纠错题](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-风格纠错题) \n\n  1.  [优化部分](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#优化部分) \n  2.  [硬伤部分](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#硬伤部分) \n 2.   [什么情况使用 weak 关键字，相比 assign 有什么不同？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2-什么情况使用-weak-关键字相比-assign-有什么不同) \n 3.  [怎么用 copy 关键字？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字) \n 4.  [这个写法会出什么问题： @property (copy) NSMutableArray *array;](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#4-这个写法会出什么问题-property-copy-nsmutablearray-array) \n 5.  [ 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#5-如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter) \n 6.  [@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#6-property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的) \n 7.  [@protocol 和 category 中如何使用 @property](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#7-protocol-和-category-中如何使用-property) \n 8.  [ runtime 如何实现 weak 属性](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#8-runtime-如何实现-weak-属性) \n 9.  [@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#9-property中有哪些属性关键字-property-后面可以有哪些修饰符) \n 10. [ weak属性需要在dealloc中置nil么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#10-weak属性需要在dealloc中置nil么)\n 11.  [@synthesize和@dynamic分别有什么作用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#11-synthesize和dynamic分别有什么作用) \n 12.  [ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#12-arc下不显式指定任何属性关键字时默认的关键字都有哪些) \n 13.  [用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题) \n  1.  [对非集合类对象的copy操作](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-对非集合类对象的copy操作) \n  2.  [集合类对象的copy与mutableCopy](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2集合类对象的copy与mutablecopy) \n 14.  [@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么) \n 15.  [在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景) \n 16.  [objc中向一个nil对象发送消息将会发生什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#16-objc中向一个nil对象发送消息将会发生什么) \n 17.  [objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#17-objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系) \n 18.  [什么时候会报unrecognized selector的异常？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#18-什么时候会报unrecognized-selector的异常) \n 19.  [一个objc对象如何进行内存布局？（考虑有父类的情况）](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#19-一个objc对象如何进行内存布局考虑有父类的情况) \n 20. [一个objc对象的isa的指针指向什么？有什么作用？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#20-一个objc对象的isa的指针指向什么有什么作用)\n 21.  [下面的代码输出什么？](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么) \n\n\n ```objectivec\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n ```\n\n 22. 22--55题，请看下篇。\n\n### 1. 风格纠错题\n![enter image description here](http://i.imgur.com/O7Zev94.png)\n修改完的代码：\n\n修改方法有很多种，现给出一种做示例：\n\n\n ```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject<NSCopying>\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n@end\n ```\n\n\n\n\n下面对具体修改的地方，分两部分做下介绍：**硬伤部分** 和 **优化部分**\n。因为**硬伤部分**没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看**优化部分**。\n\n\n#### **优化部分**\n\n 1. enum 建议使用 `NS_ENUM` 和 `NS_OPTIONS` 宏来定义枚举类型，参见官方的 [Adopting Modern Objective-C](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html) 一文：\n\n\n ```objectivec\n//定义一个枚举\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n ```\n （仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 [这里](https://github.com/ChenYilong/iOSInterviewQuestions/issues/9) 。）\n \n 2. age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：\n \n ```objectivec\n\tint -> NSInteger\n\tunsigned -> NSUInteger\n\tfloat -> CGFloat\n\t动画时间 -> NSTimeInterval\n```\n同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。\n这样做的是基于64-bit 适配考虑，详情可参考出题者的博文[《64-bit Tips》](http://blog.sunnyxx.com/2014/12/20/64-bit-tips/)。\n\n\n 3. 如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。\n 4. doLogIn方法不应写在该类中： <p><del>虽然`LogIn`的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： [ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）</del></p>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：\n\n\n > 无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。\n\n\n （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： `-logIn` 对应的应当是注册并登录的一个 Button ，出现 `-logIn` 方法也可能是合理的。）\n\n 5.  doLogIn 方法命名不规范：添加了多余的动词前缀。\n请牢记：\n\n  > 如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 `do`，`does` 这种多余的关键字，动词本身的暗示就足够了。\n\n 应为 `-logIn` （注意： `Login` 是名词， `LogIn`  是动词，都表示登陆。  见[ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）\n\n 6. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;`方法中不要用 `with` 来连接两个参数: `withAge:` 应当换为`age:`，`age:` 已经足以清晰说明参数的作用，也不建议用 `andAge:` ：通常情况下，即使有类似 `withA:withB:` 的命名需求，也通常是使用`withA:andB:` 这种命名，用来表示方法执行了两个相对独立的操作（*从设计上来说，这时候也可以拆分成两个独立的方法*），它不应该用作阐明有多个参数，比如下面的：\n\n  ```objectivec\n//错误，不要使用\"and\"来连接参数\n- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;\n//错误，不要使用\"and\"来阐明有多个参数\n- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;\n//正确，使用\"and\"来表示两个相对独立的操作\n- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;\n```\n\n 7. 由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？***)\n 8. “性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？\n\n Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：\n\n \n\n \n ```objectivec\n\n    // .m文件\n    // http://weibo.com/luohanchenyilong/\n    // https://github.com/ChenYilong\n    //\n\n    @implementation CYLUser\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age\n                             sex:(CYLSex)sex {\n        if(self = [super init]) {\n            _name = [name copy];\n            _age = age;\n            _sex = sex;\n        }\n        return self;\n    }\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age {\n        return [self initWithName:name age:age sex:nil];\n    }\n\n    @end\n```\n\n\n\n\n\n\n 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。\n\n  因为出题者没有给出 `.m` 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：\n\n\n\n \n ```objectivec\n\n\n\t// .h文件\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t// 第二种修改方法（基于第一种修改方法的基础上）\n\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n\n\t@interface CYLUser : NSObject<NSCopying>\n\n\t@property (nonatomic, readonly, copy) NSString *name;\n\t@property (nonatomic, readonly, assign) NSUInteger age;\n\t@property (nonatomic, readwrite, assign) CYLSex sex;\n\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;\n\t+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n\t@end\n```\n\n\n  `.h` 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳--》 [***《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》***](http://is.gd/OQ49zk)。）\n\n\n   - 按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。\n   - 如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:\n那么在设计对应 `@property` 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样\n\n\n ```objectivec\n        @property (nonatomic, readonly, copy) NSString *name;\n        @property (nonatomic, readonly, assign) NSUInteger age;\n        @property (nonatomic, readonly, assign) CYLSex sex;\n ```\n\n      由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。\n      \n 9. `initUserModelWithUserName` 如果改为 `initWithName` 会更加简洁，而且足够清晰。\n 10. `UserModel` 如果改为 `User` 会更加简洁，而且足够清晰。\n 11. `UserSex`如果改为`Sex` 会更加简洁，而且足够清晰。\n 12. 第二个 `@property` 中 assign 和 nonatomic 调换位置。\n 推荐按照下面的格式来定义属性\n\n ```objectivec\n@property (nonatomic, readwrite, copy) NSString *name;\n ```\n 属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在[《禅与Objective-C编程艺术 >》](https://github.com/oa414/objc-zen-book-cn#属性定义)里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 > 读写权限 >原子操作。\n\n#### ***硬伤部分***\n\n 1. 在-和(void)之间应该有一个空格\n 3. enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。\n 3. enum 左括号前加一个空格，或者将左括号换到下一行\n 4. enum 右括号后加一个空格\n 2. `UserModel :NSObject` 应为`UserModel : NSObject`，也就是`:`右侧少了一个空格。\n 2.  `@interface` 与 `@property` 属性声明中间应当间隔一行。\n 2. 两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。\n 9. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中方法名与参数之间多了空格。而且 `-` 与 `(id)` 之间少了空格。\n 10. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中方法名与参数之间多了空格：`(NSString*)name` 前多了空格。\n 10. `-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;` 方法中 `(NSString*)name`,应为 `(NSString *)name`，少了空格。 \n 7.  <p><del>doLogIn方法中的 `LogIn` 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。\n （勘误： `Login` 是名词， `LogIn`  是动词，都表示登陆的意思。见： [ ***Log in vs. login*** ](http://grammarist.com/spelling/log-in-login/)）</del></p>\n\n### 2. 什么情况使用 weak 关键字，相比 assign 有什么不同？\n什么情况使用 weak 关键字？\n\n\n 1. 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性\n\n 2. 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***\n\n不同点：\n \n 1. `weak` 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，\n然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n而 `assign` 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 \nNSlnteger 等)的简单赋值操作。\n\n 2. assign 可以用非 OC 对象,而 weak 必须用于 OC 对象\n\n### 3. 怎么用 copy 关键字？\n用途：\n\n 1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；\n 2. block 也经常使用 copy 关键字，具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：\n\n  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？\n\n\n ```objectivec\n @property (nonatomic, copy) NSString *userId;\n\n - (instancetype)initWithUserId:(NSString *)userId {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n    _userId = [userId copy];\n    return self;\n }\n\n ```\n\n\n ![enter image description here](http://i.imgur.com/VlVKl8L.png)\n\n下面做下解释：\n copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。\n当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。\n\n\n> 用 `@property` 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n \n该问题在下文中也有论述：***用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？***\n\n\n### 4. 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`\n两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； \n\n第1条的相关原因在下文中有论述***《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》*** 以及上文***《怎么用 copy 关键字？》***也有论述。\n\n比如下面的代码就会发生崩溃\n\n \n \n```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\n@property (nonatomic, copy) NSMutableArray *mutableArray;\n```\n\n\n```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];\nself.mutableArray = array;\n[self.mutableArray removeObjectAtIndex:0];\n```\n\n接下来就会奔溃：\n\n \n```objectivec\n -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460\n```\n\n\n\n第2条原因，如下：\n\n> 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。\n\n在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。\n\n在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。\n\n一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。\n\n因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用\n atomic 属性通常都不会有性能瓶颈。\n\n### 5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\n\n\n> 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 `NSCopying` 与 `NSMutableCopying` 协议。\n\n\n\n\n具体步骤：\n\n 1. 需声明该类遵从 NSCopying 协议\n 2. 实现 NSCopying 协议。该协议只有一个方法: \n\n ```objectivec\n- (id)copyWithZone:(NSZone *)zone;\n```\n注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。\n\n以第一题的代码为例：\n   \n\n ```objectivec\n\t// .h文件\n\t// http://weibo.com/luohanchenyilong/\n\t// https://github.com/ChenYilong\n\t// 修改完的代码\n\n\ttypedef NS_ENUM(NSInteger, CYLSex) {\n\t    CYLSexMan,\n\t    CYLSexWoman\n\t};\n\n\t@interface CYLUser : NSObject<NSCopying>\n\n\t@property (nonatomic, readonly, copy) NSString *name;\n\t@property (nonatomic, readonly, assign) NSUInteger age;\n\t@property (nonatomic, readonly, assign) CYLSex sex;\n\n\t- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\t+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n\t@end\n ```\n\n\n然后实现协议中规定的方法：\n\n \n```objectivec\n- (id)copyWithZone:(NSZone *)zone {\n\tCYLUser *copy = [[[self class] allocWithZone:zone] \n\t\t             initWithName:_name\n \t\t\t\t\t\t\t      age:_age\n\t\t\t\t\t\t          sex:_sex];\n\treturn copy;\n}\n```\n但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:\n\n```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 以第一题《风格纠错题》里的代码为例\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject<NSCopying>\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n- (void)addFriend:(CYLUser *)user;\n- (void)removeFriend:(CYLUser *)user;\n\n@end\n```\n\n// .m文件\n\n\n\n ```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n//\n\n@implementation CYLUser {\n    NSMutableSet *_friends;\n}\n\n- (void)setName:(NSString *)name {\n    _name = [name copy];\n}\n\n- (instancetype)initWithName:(NSString *)name\n                         age:(NSUInteger)age\n                         sex:(CYLSex)sex {\n    if(self = [super init]) {\n        _name = [name copy];\n        _age = age;\n        _sex = sex;\n        _friends = [[NSMutableSet alloc] init];\n    }\n    return self;\n}\n\n- (void)addFriend:(CYLUser *)user {\n    [_friends addObject:user];\n}\n\n- (void)removeFriend:(CYLUser *)user {\n    [_friends removeObject:user];\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n    CYLUser *copy = [[[self class] allocWithZone:zone]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [_friends mutableCopy];\n    return copy;\n}\n\n- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n\n@end\n\n ```\n\n以上做法能满足基本的需求，但是也有缺陷：\n\n> 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。\n\n【注：深浅拷贝的概念，在下文中有介绍，详见下文的：***用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？***】\n\n在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:\n\t\n\n ```objectivec\n- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n\n ```\n\n至于***如何重写带 copy 关键字的 setter***这个问题，\n\n\n如果抛开本例来回答的话，如下：\n\n\n \n```objectivec\n- (void)setName:(NSString *)name {\n    //[_name release];\n    _name = [name copy];\n}\n```\n\n不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”\n\n\n ```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) {\n        //[_name release];//MRC\n        _name = [name copy];\n    }\n}\n ```\n\n\n\n这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：\n\n![enter image description here](http://i.imgur.com/UwV9oSn.jpeg)\n\n克强总理这样评价你的代码风格：\n\n![enter image description here](http://i.imgur.com/N77Lkic.png)\n\n我和总理的意见基本一致：\n\n\n> 老百姓 copy 一下，咋就这么难？\n\n\n\n\n你可能会说：\n\n \n之所以在这里做`if判断` 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。\n(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)\n\n\n但是你有没有考虑过代价：\n\n\n> 你每次调用 `setX:` 都会做 if 判断，这会让 `setX:` 变慢，如果你在 `setX:`写了一串复杂的 `if+elseif+elseif+...` 判断，将会更慢。\n\n要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：\n\n```objectivec\n[a setX:x1];\n[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？\n```\n\n或者\n\n\n```objectivec\n[a setX:[a x]];   //队友咆哮道：你在干嘛？！！\n```\n\n> 不要在 setter 里进行像 `if(_obj != newObj)` 这样的判断。（该观点参考链接：[ ***How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure*** ](http://vgable.com/blog/tag/autorelease/)\n）\n\n\n什么情况会在 copy setter 里做 if 判断？\n例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：\n\n \n```objectivec\n-(void)setSpeed:(int)_speed{\n    if(_speed < 0) speed = 0;\n    if(_speed > 300) speed = 300;\n    _speed = speed;\n}\n```\n\n\n\n回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”--copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。\n\n那如何确保 name 被 copy？在初始化方法(initializer)中做：\n\n ```objectivec\n\t- (instancetype)initWithName:(NSString *)name \n\t\t\t\t\t\t\t\t age:(NSUInteger)age \n\t\t\t\t\t\t\t\t sex:(CYLSex)sex {\n\t     if(self = [super init]) {\n\t     \t_name = [name copy];\n\t     \t_age = age;\n\t     \t_sex = sex;\n\t     \t_friends = [[NSMutableSet alloc] init];\n\t     }\n\t     return self;\n\t}\n\n ```\n\n\n\t\n### 6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\n\n**@property 的本质是什么？**\n\n> @property = ivar + getter + setter;\n\n下面解释下：\n\n> “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。\n\n“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 `Objective-C 2.0` 的一部分。\n而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。\n正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:\n\n> 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。\n所以你也可以这么说：\n\n> @property = getter + setter;\n\n例如下面这个类：\n\n\n\n ```objectivec\n@interface Person : NSObject\n@property NSString *firstName;\n@property NSString *lastName;\n@end\n ```\n\n\n上述代码写出来的类与下面这种写法等效：\n\n\n\n ```objectivec\n@interface Person : NSObject\n- (NSString *)firstName;\n- (void)setFirstName:(NSString *)firstName;\n- (NSString *)lastName;\n- (void)setLastName:(NSString *)lastName;\n@end\n ```\n\n**更新**：\n\nproperty在runtime中是`objc_property_t`定义如下:\n\n```objectivec\ntypedef struct objc_property *objc_property_t;\n```\n\n而`objc_property`是一个结构体，包括name和attributes，定义如下：\n\n```objectivec\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n而attributes本质是`objc_property_attribute_t`，定义了property的一些属性，定义如下：\n\n```objectivec\n/// Defines a property attribute\ntypedef struct {\n    const char *name;           /**< The name of the attribute */\n    const char *value;          /**< The value of the attribute (usually empty) */\n} objc_property_attribute_t;\n```\n\n而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。\n\n例如：我们定义一个string的property`@property (nonatomic, copy) NSString *string;`，通过 `property_getAttributes(property)`获取到attributes并打印出来之后的结果为`T@\"NSString\",C,N,V_string`\n\n其中T就代表类型，可参阅[Type Encodings](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。\n\n\n\n**ivar、getter、setter 是如何生成并添加到这个类中的?**\n\n> “自动合成”( autosynthesis)\n\n完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译\n器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为\n `_firstName` 与 `_lastName`。也可以在类的实现代码里通过\n `@synthesize` 语法来指定实例变量的名字.\n\n\n\n ```objectivec\n@implementation Person\n@synthesize firstName = _myFirstName;\n@synthesize lastName = _myLastName;\n@end\n ```\n\n我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西\n\n 1. `OBJC_IVAR_$类名$属性名称` ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。\n 2. setter 与 getter 方法对应的实现函数\n 2. `ivar_list` ：成员变量列表\n 2. `method_list` ：方法列表\n 2. `prop_list` ：属性列表\n\n\n也就是说我们每次在增加一个属性,系统都会在 `ivar_list` 中添加一个成员变量的描述,在 `method_list` 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.\n\n### 7. @protocol 和 category 中如何使用 @property\n\n 1. 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性\n 2. category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：\n\n  1. `objc_setAssociatedObject`\n  2. `objc_getAssociatedObject`\n\n### 8. runtime 如何实现 weak 属性\n\n要实现 weak 属性，首先要搞清楚 weak 属性的特点：\n\n> weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n\n那么 runtime 如何实现 weak 变量的自动置nil？\n\n\n> runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到`__weak`引用的解除时间。）\n\n\n先看下 runtime 里源码的实现：\n\n\n ```objectivec\n/**\n * The internal structure stored in the weak references table. \n * It maintains and stores\n * a hash set of weak references pointing to an object.\n * If out_of_line==0, the set is instead a small inline array.\n */\n#define WEAK_INLINE_COUNT 4\nstruct weak_entry_t {\n    DisguisedPtr<objc_object> referent;\n    union {\n        struct {\n            weak_referrer_t *referrers;\n            uintptr_t        out_of_line : 1;\n            uintptr_t        num_refs : PTR_MINUS_1;\n            uintptr_t        mask;\n            uintptr_t        max_hash_displacement;\n        };\n        struct {\n            // out_of_line=0 is LSB of one of these (don't care which)\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        };\n    };\n};\n\n/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */\nstruct weak_table_t {\n    weak_entry_t *weak_entries;\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\n ```\n\n具体完整实现参照 [objc/objc-weak.h](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h) 。\n\n\n\n我们可以设计一个函数（伪代码）来表示上述机制：\n\n`objc_storeWeak(&a, b)`函数：\n\n`objc_storeWeak`函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\n\n你可以把`objc_storeWeak(&a, b)`理解为：`objc_storeWeak(value, key)`，并且当key变nil，将value置nil。\n\n在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n而如果a是由 assign 修饰的，则：\n在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。\n\n\n下面我们将基于`objc_storeWeak(&a, b)`函数，使用伪代码模拟“runtime如何实现weak属性”：\n \n\n\n \n```objectivec\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&obj1);\n```\n\n下面对用到的两个方法`objc_initWeak`和`objc_destroyWeak`做下解释：\n\n总体说来，作用是：\n通过`objc_initWeak`函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过`objc_destoryWeak`函数释放该变量（obj1）。\n\n下面分别介绍下方法的内部实现：\n\n`objc_initWeak`函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用`objc_storeWeak`函数。\n\n\n\n \n```objectivec\nobj1 = 0；\nobj_storeWeak(&obj1, obj);\n```\n\n也就是说：\n\n>  weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\n\n\n\n\n然后`obj_destroyWeak`函数将0（nil）作为参数，调用`objc_storeWeak`函数。\n\n`objc_storeWeak(&obj1, 0);`\n\n前面的源代码与下列源代码相同。\n\n\n\n```objectivec\n// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&obj1, 0);\n```\n\n\n`objc_storeWeak` 函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。\n\n使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：\n\n> 如何让不使用weak修饰的@property，拥有weak的效果。\n\n\n我们从setter方法入手：\n\n（注意以下的 `cyl_runAtDealloc` 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) ）\n\n ```objectivec\n- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n ```\n\n也就是有两个步骤：\n\n 1. 在setter方法中做如下设置：\n\n\n ```objectivec\n        objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n ```\n\n 2. 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：\n \n ```objectivec\n//要销毁的目标对象\nid objectToBeDeallocated;\n//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。\nid objectWeWantToBeReleasedWhenThatHappens;\nobjc_setAssociatedObject(objectToBeDeallocted,\n                         someUniqueKey,\n                         objectWeWantToBeReleasedWhenThatHappens,\n                         OBJC_ASSOCIATION_RETAIN);\n```\n\n知道了思路，我们就开始实现 `cyl_runAtDealloc` 方法，实现过程分两部分：\n\n第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。\n\n// .h文件\n\n ```objectivec\n// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\ntypedef void (^voidBlock)(void);\n\n@interface CYLBlockExecutor : NSObject\n\n- (id)initWithBlock:(voidBlock)block;\n\n@end\n ```\n\n// .m文件\n\n ```objectivec\n// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\n#import \"CYLBlockExecutor.h\"\n\n@interface CYLBlockExecutor() {\n    voidBlock _block;\n}\n@implementation CYLBlockExecutor\n\n- (id)initWithBlock:(voidBlock)aBlock\n{\n    self = [super init];\n    \n    if (self) {\n        _block = [aBlock copy];\n    }\n    \n    return self;\n}\n\n- (void)dealloc\n{\n    _block ? _block() : nil;\n}\n\n@end\n ```\n\n第二部分：核心代码：利用runtime实现`cyl_runAtDealloc`方法\n\n ```objectivec\n// CYLNSObject+RunAtDealloc.h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import \"CYLBlockExecutor.h\"\n\nconst void *runAtDeallocBlockKey = &runAtDeallocBlockKey;\n\n@interface NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block;\n\n@end\n\n\n// CYLNSObject+RunAtDealloc.m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import \"CYLNSObject+RunAtDealloc.h\"\n#import \"CYLBlockExecutor.h\"\n\n@implementation NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block\n{\n    if (block) {\n        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];\n        \n        objc_setAssociatedObject(self,\n                                 runAtDeallocBlockKey,\n                                 executor,\n                                 OBJC_ASSOCIATION_RETAIN);\n    }\n}\n\n@end\n ```\n\n使用方法：\n导入\n\n\n ```objectivec\n    #import \"CYLNSObject+RunAtDealloc.h\"\n ```\n\n然后就可以使用了：\n\n\n ```objectivec\nNSObject *foo = [[NSObject alloc] init];\n\n[foo cyl_runAtDealloc:^{\n    NSLog(@\"正在释放foo!\");\n}];\n ```\n\n\n如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) \n\n参考博文： [***Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object***](http://stackoverflow.com/a/31560217/3395008)\n\n\n### 9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\n属性可以拥有的特质分为四类:\n \n 1. 原子性--- `nonatomic` 特质\n\n    在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。\n\n 2. 读/写权限---`readwrite(读写)`、`readonly (只读)`\n 3. 内存管理语义---`assign`、`strong`、 `weak`、`unsafe_unretained`、`copy`\n 4. 方法名---`getter=<name>` 、`setter=<name>`\n   \n  `getter=<name>`的样式：\n\n\n ```objectivec\n        @property (nonatomic, getter=isOn) BOOL on;\n ```\n <p><del>（ `setter=<name>`这种不常用，也不推荐使用。故不在这里给出写法。）\n</del></p>\n\n\n `setter=<name>`一般用在特殊的情境下，比如：\n\n\n在数据反序列化、转模型的过程中，服务器返回的字段如果以 `init` 开头，所以你需要定义一个 `init` 开头的属性，但默认生成的 `setter` 与 `getter` 方法也会以 `init` 开头，而编译器会把所有以 `init` 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。\n\n这时你就可以使用下面的方式来避免编译器报错：\n\n\n ```objectivec\n@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;\n\n ```\n\n\n另外也可以用关键字进行特殊说明，来避免编译器报错：\n\n ```objectivec\n@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;\n- (NSString *)initBy __attribute__((objc_method_family(none)));\n ```\n\n 3. 不常用的：`nonnull`,`null_resettable`,`nullable`\n\n\n注意：很多人会认为如果属性具备 nonatomic 特质，则不使用\n“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：\n\n\n ```objectivec\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n{\n    bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);\n    bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n}\n ```\n\n### 10. weak属性需要在dealloc中置nil么？\n不需要。\n\n\n> 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理\n\n即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：\n\n正如上文的：***runtime 如何实现 weak 属性*** 中提到的：\n\n我们模拟下 weak 的 setter 方法，应该如下：\n\n\n ```objectivec\n- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, \"object\", object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n ```\n\n如果对 `cyl_runAtDealloc` 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： [CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor) \n\n\n也即:\n\n> 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。\n\n\n\n\n\n\n### 11. @synthesize和@dynamic分别有什么作用？\n\n 1. @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是`@syntheszie var = _var;`\n 2. @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。\n 3. @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 `instance.var = someVar`，由于缺 setter 方法会导致程序崩溃；或者当运行到 `someVar = var` 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。\n\n### 12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\n\n 1. 对应基本数据类型默认关键字是\n \n atomic,readwrite,assign\n 2. 对于普通的 Objective-C 对象\n  \n atomic,readwrite,strong\n\n参考链接：\n\n 1. [ ***Objective-C ARC: strong vs retain and weak vs assign*** ](http://stackoverflow.com/a/15541801/3395008)\n\n 2. [ ***Variable property attributes or Modifiers in iOS*** ](http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html)\n\n### 13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\n\n\n 1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.\n 2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.\n\n copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。\n当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。\n\n\n举例说明：\n\n定义一个以 strong 修饰的 array：\n\n ```objectivec\n@property (nonatomic ,readwrite, strong) NSArray *array;\n ```\n\n然后进行下面的操作：\n\n ```objectivec\n    NSMutableArray *mutableArray = [[NSMutableArray alloc] init];\n    NSArray *array = @[ @1, @2, @3, @4 ];\n    self.array = mutableArray;\n    [mutableArray removeAllObjects];;\n    NSLog(@\"%@\",self.array);\n    \n    [mutableArray addObjectsFromArray:array];\n    self.array = [mutableArray copy];\n    [mutableArray removeAllObjects];;\n    NSLog(@\"%@\",self.array);\n ```\n\n打印结果如下所示：\n\n ```objectivec\n2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (\n)\n2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (\n    1,\n    2,\n    3,\n    4\n)\n ```\n\n（详见仓库内附录的 Demo。）\n\n\n为了理解这种做法，首先要知道，两种情况：\n\n\n 1. 对非集合类对象的 copy 与 mutableCopy 操作；\n 2. 对集合类对象的 copy 与 mutableCopy 操作。\n\n#### 1. 对非集合类对象的copy操作：\n\n在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：\n\n - [immutableObject copy] // 浅复制\n - [immutableObject mutableCopy] //深复制\n - [mutableObject copy] //深复制\n - [mutableObject mutableCopy] //深复制\n\t\n比如以下代码：\n\n\n ```objectivec\nNSMutableString *string = [NSMutableString stringWithString:@\"origin\"];//copy\nNSString *stringCopy = [string copy];\n ```\n\n\n查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：\n\n\n ```objectivec\n[string appendString:@\"origion!\"]\n ```\n\nstringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。\n  集合类对象以此类推。\n所以，\n\n> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n\n#### 2、集合类对象的copy与mutableCopy\n\n集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：\n\n ```objectivec\nNSArray *array = @[@[@\"a\", @\"b\"], @[@\"c\", @\"d\"]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n ```\n\n查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：\n\n\n ```objectivec\nNSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@\"a\"],@\"b\",@\"c\",nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n ```\n\n\n查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：\n\n在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：\n\n\n ```objectivec\n[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n ```\n\n\n这个代码结论和非集合类的非常相似。\n\n参考链接：[iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)\n\n### 14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为`_foo`的实例变量，那么还会自动合成新变量么？\n在回答之前先说明下一个概念：\n\n> 实例变量 = 成员变量 ＝ ivar\n\n这些说法，笔者下文中，可能都会用到，指的是一个东西。\n\n\n正如\n[Apple官方文档 ***You Can Customize Synthesized Instance Variable Names***](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6) 所说：\n![enter image description here](http://i.imgur.com/D6d0zGJ.png)\n\n如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。\n\n \n```objectivec\n@interface CYLPerson : NSObject \n@property NSString *firstName; \n@property NSString *lastName; \n@end\n```\n\n\n在上例中，会生成两个实例变量，其名称分别为\n `_firstName` 与 `_lastName`。也可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:\n \n```objectivec\n@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end \n```\n\n\n\n上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName` ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。\n\n总结下 @synthesize 合成实例变量的规则，有以下几点：\n\n\n 1. 如果指定了成员变量的名称,会生成一个指定的名称的成员变量,\n\n 2. 如果这个成员已经存在了就不再生成了.\n 2. 如果是 `@synthesize foo;` 还会生成一个名称为foo的成员变量，也就是说：\n\n > 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,\n\n\n\n 2. 如果是 `@synthesize foo = _foo;` 就不会生成成员变量了.\n\n假如 property 名为 foo，存在一个名为 `_foo` 的实例变量，那么还会自动合成新变量么？\n不会。如下图：\n\n![enter image description here](http://i.imgur.com/t28ge4W.png)\n\n\n### 15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\n\n回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？\n\n 1. 同时重写了 setter 和 getter 时\n 2. 重写了只读属性的 getter 时\n 2. 使用了 @dynamic 时\n 2. 在 @protocol 中定义的所有属性\n 2. 在 category 中定义的所有属性\n 2. 重载的属性 \n \n 当你在子类中重载了父类中的属性，你必须 使用 `@synthesize` 来手动合成ivar。\n\n除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 `@dynamic` 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。\n\n因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 `@synthesize` 来手动合成 ivar。\n\n其实，`@synthesize` 语法还有一个应用场景，但是不太建议大家使用：\n\n可以在类的实现代码里通过 `@synthesize` 语法来指定实例变量的名字:\n \n```objectivec\n@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end \n```\n\n\n\n上述语法会将生成的实例变量命名为 `_myFirstName` 与 `_myLastName`，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。\n\n\n\n举例说明：应用场景：\n\n\n ```objectivec\n\n//\n// .m文件\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 打开第14行和第17行中任意一行，就可编译成功\n\n@import Foundation;\n\n@interface CYLObject : NSObject\n@property (nonatomic, copy) NSString *title;\n@end\n\n@implementation CYLObject {\n    //    NSString *_title;\n}\n\n//@synthesize title = _title;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _title = @\"微博@iOS程序犭袁\";\n    }\n    return self;\n}\n\n- (NSString *)title {\n    return _title;\n}\n\n- (void)setTitle:(NSString *)title {\n    _title = [title copy];\n}\n\n@end\n ```\n\n结果编译器报错：\n![enter image description here](http://i.imgur.com/fAEGHIo.png)\n\n当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：\n\n 1. 要么如第14行：手动创建 ivar\n 2. 要么如第17行：使用`@synthesize foo = _foo;` ，关联 @property 与 ivar。\n\n更多信息，请戳- 》[ ***When should I use @synthesize explicitly?*** ](http://stackoverflow.com/a/19821816/3395008)\n### 16. objc中向一个nil对象发送消息将会发生什么？\n在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:\n\n 1. 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  \n\n \n ```objectivec\nPerson * motherInlaw = [[aPerson spouse] mother];\n```\n\n\n 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。\n 2. 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。\n 2. 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。\n 2. 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。\n\n具体原因如下：\n\n\n> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。\n\n\n那么，为了方便理解这个内容，还是贴一个objc的源代码：\n\n\n \n```objectivec\n// runtime.h（类在runtime中的定义）\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nstruct objc_class {\n  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n  #if !__OBJC2__\n  Class super_class OBJC2_UNAVAILABLE; // 父类\n  const char *name OBJC2_UNAVAILABLE; // 类名\n  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n  #endif\n  } OBJC2_UNAVAILABLE;\n```\n\nobjc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。\n那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。\n\n\n### 17. objc中向一个对象发送消息[obj foo]和`objc_msgSend()`函数之间有什么关系？\n具体原因同上题：该方法编译之后就是`objc_msgSend()`函数调用.\n\n我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和`objc_msgSend()`函数之间有什么关系。\n\n以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，\n\n```objectivec\n//\n//  main.m\n//  http://weibo.com/luohanchenyilong/\n//  https://github.com/ChenYilong\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n\n#import \"CYLTest.h\"\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOSinit))];\n        return 0;\n    }\n}\n```\n\n在终端中输入\n\n```objectivec\nclang -rewrite-objc main.m\n```\n就可以生成一个`main.cpp`的文件，在最低端（10万4千行左右）\n\n![enter image description here](http://i.imgur.com/eAH5YWn.png)\n\n我们可以看到大概是这样的：\n\n \n```objectivec\n((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(\"foo\"));\n```\n\n也就是说：\n\n>  [obj foo];在objc动态编译时，会被转意为：`objc_msgSend(obj, @selector(foo));`。\n\n### 18. 什么时候会报unrecognized selector的异常？\n\n简单来说：\n\n\n> 当调用该对象上某个方法,而该对象上没有实现这个方法的时候，\n可以通过“消息转发”进行解决。\n\n\n\n简单的流程如下，在上一题中也提到过：\n\n\n> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。\n\n\nobjc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：\n\n\n 1. Method resolution\n\n objc运行时会调用`+resolveInstanceMethod:`或者 `+resolveClassMethod:`，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。\n\n 2. Fast forwarding\n\n 如果目标对象实现了`-forwardingTargetForSelector:`，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。\n只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。\n这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。\n 3. Normal forwarding\n\n 这一步是Runtime最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回nil，Runtime则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送`-forwardInvocation:`消息给目标对象。\n\n为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ `_objc_msgForward_demo` ”,可运行起来看看。\n\n### 19. 一个objc对象如何进行内存布局？（考虑有父类的情况）\n\n - 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.\n - 每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的\n\n\n  1. 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）\n  2. 成员变量的列表,\n  2. 属性列表,\n\n 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。\n\n每个 Objective-C 对象都有相同的结构，如下图所示：\n\n ![enter image description here](http://i.imgur.com/7mJlUj1.png)\n\n翻译过来就是\n\n|  Objective-C 对象的结构图 | \n ------------- |\n ISA指针 |\n 根类的实例变量 |\n 倒数第二层父类的实例变量 |\n ... |\n 父类的实例变量 |\n 类的实例变量 | \n\n\n - 根对象就是NSObject，它的superclass指针指向nil\n\n - 类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。\n\n\n\n如图:\n![enter image description here](http://i.imgur.com/w6tzFxz.png)\n\n### 20. 一个objc对象的isa的指针指向什么？有什么作用？\n\n指向他的类对象,从而可以找到对象上的方法\n\n### 21. 下面的代码输出什么？\n\n\n\n\n ```objectivec\n\t@implementation Son : Father\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        NSLog(@\"%@\", NSStringFromClass([self class]));\n\t        NSLog(@\"%@\", NSStringFromClass([super class]));\n\t    }\n\t    return self;\n\t}\n\t@end\n ```\n\n\n**答案：**\n\n都输出 Son\n\n\tNSStringFromClass([self class]) = Son\n\tNSStringFromClass([super class]) = Son\n \n\n\n这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。\n \n\n我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？\n\n很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。\n\n\n上面的例子不管调用`[self class]`还是`[super class]`，接受消息的对象都是当前 `Son ＊xxx` 这个对象。\n\n当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。\n\n\n这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ `_iVar` ），而非点语法（ `self.iVar` ）。\n\n点语法（ `self.iVar` ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：\n\n ```objectivec\n//\n//  ChenPerson.m\n//  \n//\n//  Created by https://github.com/ChenYilong on 15/8/30.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import \"ChenPerson.h\"\n\n@implementation ChenPerson\n\n@synthesize lastName = _lastName;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([super class]));\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    //设置方法一：如果setter采用是这种方式，就可能引起崩溃\n//    if (![lastName isEqualToString:@\"陈\"])\n//    {\n//        [NSException raise:NSInvalidArgumentException format:@\"姓不是陈\"];\n//    }\n//    _lastName = lastName;\n    \n    //设置方法二：如果setter采用是这种方式，就可能引起崩溃\n    _lastName = @\"陈\";\n    NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, @\"会调用这个方法,想一下为什么？\");\n\n}\n\n@end\n ```\n\n在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ `self.lastName` ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，\n\n\n为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。\n\n\n如果基类的代码是这样的：\n\n\n ```objectivec\n//\n//  Person.m\n//  nil对象调用点语法\n//\n//  Created by https://github.com/ChenYilong on 15/8/29.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//  \n\n#import \"Person.h\"\n\n@implementation Person\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lastName = @\"\";\n        //NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        //NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, self.lastName);\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, @\"根本不会调用这个方法\");\n    _lastName = @\"炎黄\";\n}\n\n@end\n ```\n\n那么打印结果将会是这样的：\n\n ```objectivec\n 🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？\n 🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson\n 🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson\n ```\n\n我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。\n\n\n接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:\n\n\n ```objectivec\n\t$ clang -rewrite-objc test.m\n ```\n\n将这道题目中给出的代码被转化为:\n\n\n ```objectivec\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"class\"))));\n\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(\"Son\")) }, sel_registerName(\"class\"))));\n ```\n\n从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 `objc_msgSend`函数。看下函数定义：\n\n\n ```objectivec\n\tid objc_msgSend(id self, SEL op, ...)\n ```\n我们把 self 做为第一个参数传递进去。\n\n而在调用 [super class]时，会转化成 `objc_msgSendSuper`函数。看下函数定义:\n\n\n ```objectivec\n\tid objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n ```\n\n第一个参数是 `objc_super` 这样一个结构体，其定义如下:\n\n\n ```objectivec\nstruct objc_super {\n\t   __unsafe_unretained id receiver;\n\t   __unsafe_unretained Class super_class;\n};\n ```\n\n结构体有两个成员，第一个成员是 receiver, 类似于上面的 `objc_msgSend`函数第一个参数self 。第二个成员是记录当前类的父类是什么。\n\n所以，当调用 ［self class] 时，实际先调用的是 `objc_msgSend`函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。\n\nobjc Runtime开源代码对- (Class)class方法的实现:\n\n\n ```objectivec\n- (Class)class {\n    return object_getClass(self);\n}\n ```\n\n而当调用 `[super class]`时，会转换成`objc_msgSendSuper函数`。第一步先构造 `objc_super` 结构体，结构体第一个成员就是 `self` 。\n第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))` , 实际该函数输出结果为 Father。\n\n第二步是去 Father这个类里去找 `- (Class)class`，没有，然后去NSObject类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))`去调用，\n\n此时已经和`[self class]`调用相同了，故上述输出结果仍然返回 Son。\n\n\n参考链接：[微博@Chun_iOS](http://weibo.com/junbbcom)的博文[刨根问底Objective－C Runtime（1）－ Self & Super](http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/)\n\n\n### 22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n\n每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.\n\n### 23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\n\n - 在ARC下不需要。\n - <p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要\n\n> 无论在MRC下还是ARC下均不需要。\n\n\n[ ***2011年版本的Apple API 官方文档 - Associative References***  ](https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html) 一节中有一个MRC环境下的例子：\n\n\n \n```objectivec\n// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 摘自2011年版本的Apple API 官方文档 - Associative References \n\nstatic char overviewKey;\n \nNSArray *array =\n    [[NSArray alloc] initWithObjects:@\"One\", @\"Two\", @\"Three\", nil];\n// For the purposes of illustration, use initWithFormat: to ensure\n// the string can be deallocated\nNSString *overview =\n    [[NSString alloc] initWithFormat:@\"%@\", @\"First three numbers\"];\n \nobjc_setAssociatedObject (\n    array,\n    &overviewKey,\n    overview,\n    OBJC_ASSOCIATION_RETAIN\n);\n \n[overview release];\n// (1) overview valid\n[array release];\n// (2) overview invalid\n```\n文档指出 \n\n> At point 1, the string `overview` is still valid because the `OBJC_ASSOCIATION_RETAIN` policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), `overview` is released and so in this case also deallocated.\n\n我们可以看到，在`[array release];`之后，overview就会被release释放掉了。\n\n既然会被销毁，那么具体在什么时间点？\n\n\n> 根据[ ***WWDC 2011, Session 322 (第36分22秒)*** ](https://developer.apple.com/videos/wwdc/2011/#322-video)中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。\n\n对象的内存销毁时间表，分四个步骤：\n\n\t// 对象的内存销毁时间表\n\t// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n\t// https://github.com/ChenYilong\n    // 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 \n\n     1. 调用 -release ：引用计数变为零\n         * 对象正在被销毁，生命周期即将结束.\n         * 不能再有新的 __weak 弱引用， 否则将指向 nil.\n         * 调用 [self dealloc] \n     2. 子类 调用 -dealloc\n         * 继承关系中最底层的子类 在调用 -dealloc\n         * 如果是 MRC 代码 则会手动释放实例变量们（iVars）\n         * 继承关系中每一层的父类 都在调用 -dealloc\n     3. NSObject 调 -dealloc\n         * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法\n     4. 调用 object_dispose()\n         * 为 C++ 的实例变量们（iVars）调用 destructors \n         * 为 ARC 状态下的 实例变量们（iVars） 调用 -release \n         * 解除所有使用 runtime Associate方法关联的对象\n         * 解除所有 __weak 引用\n         * 调用 free()\n\n\n对象的内存销毁时间表：[参考链接](http://stackoverflow.com/a/10843510/3395008)。\n\n\n\n\n\n### 24. objc中的类方法和实例方法有什么本质区别和联系？\n\n类方法：\n\n 1. 类方法是属于类对象的\n 2. 类方法只能通过类对象调用\n 2. 类方法中的self是类对象\n 2. 类方法可以调用其他的类方法\n 2. 类方法中不能访问成员变量\n 2. 类方法中不能直接调用对象方法\n\n实例方法：\n\n 1. 实例方法是属于实例对象的\n 2. 实例方法只能通过实例对象调用\n 2. 实例方法中的self是实例对象\n 2. 实例方法中可以访问成员变量\n 2. 实例方法中直接调用实例方法\n 2. 实例方法中也可以调用类方法(通过类名)\n\n\n下一篇文章将发布在[这里](https://github.com/ChenYilong/iOSInterviewQuestions)，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注[微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)\n----------\n@property部分主要参考\n[Apple官方文档：Properties Encapsulate an Object’s Values](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2)\nruntime部分主要参考[Apple官方文档：Declared Properties](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)\n\n\n### 25. `_objc_msgForward`函数是做什么的，直接调用它将会发生什么？\n\n### 26. runtime如何实现weak变量的自动置nil？\n\n### 27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ \n\n### 28. runloop和线程有什么关系？\n\n\n### 29. runloop的mode作用是什么？\n\n### 30. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\n\n### 31. 猜想runloop内部是如何实现的？\n### 32. objc使用什么机制管理对象内存？\n### 33. ARC通过什么方式帮助开发者管理内存？\n### 34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\n### 35. `BAD_ACCESS`在什么情况下出现？\n### 36. 苹果是如何实现autoreleasepool的？ \n### 37. 使用block时什么情况会发生引用循环，如何解决？\n### 38. 在block内如何修改block外部变量？\n### 39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ \n### 40. GCD的队列（`dispatch_queue_t`）分哪两种类型？\n### 41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n### 42. `dispatch_barrier_async`的作用是什么？\n### 43. 苹果为什么要废弃`dispatch_get_current_queue`？\n### 44. 以下代码运行结果如何？\n\n\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t    NSLog(@\"1\");\n\t    dispatch_sync(dispatch_get_main_queue(), ^{\n\t        NSLog(@\"2\");\n\t    });\n\t    NSLog(@\"3\");\n\t}\n\n### 45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\n### 46. 如何手动触发一个value的KVO\n### 47. 若一个类有实例变量`NSString *_foo`，调用setValue:forKey:时，可以以foo还是`_foo`作为key？\n### 48. KVC的keyPath中的集合运算符如何使用？\n### 49. KVC和KVO的keyPath一定是属性么？\n### 50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\n### 51. apple用什么方式实现对一个对象的KVO？ \n### 52. IBOutlet连出来的视图属性为什么可以被设置成weak?\n### 53. IB中User Defined Runtime Attributes如何使用？ \n### 54. 如何调试`BAD_ACCESS`错误\n### 55. lldb（gdb）常用的调试命令？\n\n\n\n----------\n\n\nPosted by [微博@iOS程序犭袁](http://weibo.com/luohanchenyilong/)  \n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | [Creative Commons BY-NC-ND 3.0](http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)\n\n\n","slug":"《招聘一个靠谱的iOS》面试题参考答案（上）","published":1,"updated":"2017-06-17T14:59:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj56u8twu001zznuz9ibr687f","content":"<p><a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>\n<p>说明：面试题来源是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a>的这篇博文：<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>\n<p>作者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>\n<p>答案为<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>指正。</p>\n<hr>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><ol>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-风格纠错题\" target=\"_blank\" rel=\"external\">风格纠错题</a> </p>\n<ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#优化部分\" target=\"_blank\" rel=\"external\">优化部分</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#硬伤部分\" target=\"_blank\" rel=\"external\">硬伤部分</a> </li>\n</ol>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2-什么情况使用-weak-关键字相比-assign-有什么不同\" target=\"_blank\" rel=\"external\">什么情况使用 weak 关键字，相比 assign 有什么不同？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字\" target=\"_blank\" rel=\"external\">怎么用 copy 关键字？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#4-这个写法会出什么问题-property-copy-nsmutablearray-array\" target=\"_blank\" rel=\"external\">这个写法会出什么问题： @property (copy) NSMutableArray *array;</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#5-如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter\" target=\"_blank\" rel=\"external\"> 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#6-property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的\" target=\"_blank\" rel=\"external\">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#7-protocol-和-category-中如何使用-property\" target=\"_blank\" rel=\"external\">@protocol 和 category 中如何使用 @property</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#8-runtime-如何实现-weak-属性\" target=\"_blank\" rel=\"external\"> runtime 如何实现 weak 属性</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#9-property中有哪些属性关键字-property-后面可以有哪些修饰符\" target=\"_blank\" rel=\"external\">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#10-weak属性需要在dealloc中置nil么\" target=\"_blank\" rel=\"external\"> weak属性需要在dealloc中置nil么？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#11-synthesize和dynamic分别有什么作用\" target=\"_blank\" rel=\"external\">@synthesize和@dynamic分别有什么作用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#12-arc下不显式指定任何属性关键字时默认的关键字都有哪些\" target=\"_blank\" rel=\"external\">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题\" target=\"_blank\" rel=\"external\">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</a> <ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-对非集合类对象的copy操作\" target=\"_blank\" rel=\"external\">对非集合类对象的copy操作</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2集合类对象的copy与mutablecopy\" target=\"_blank\" rel=\"external\">集合类对象的copy与mutableCopy</a> </li>\n</ol>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么\" target=\"_blank\" rel=\"external\">@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景\" target=\"_blank\" rel=\"external\">在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#16-objc中向一个nil对象发送消息将会发生什么\" target=\"_blank\" rel=\"external\">objc中向一个nil对象发送消息将会发生什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#17-objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系\" target=\"_blank\" rel=\"external\">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#18-什么时候会报unrecognized-selector的异常\" target=\"_blank\" rel=\"external\">什么时候会报unrecognized selector的异常？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#19-一个objc对象如何进行内存布局考虑有父类的情况\" target=\"_blank\" rel=\"external\">一个objc对象如何进行内存布局？（考虑有父类的情况）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#20-一个objc对象的isa的指针指向什么有什么作用\" target=\"_blank\" rel=\"external\">一个objc对象的isa的指针指向什么？有什么作用？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么\" target=\"_blank\" rel=\"external\">下面的代码输出什么？</a> </li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token keyword\">@implementation</span> Son <span class=\"token punctuation\">:</span> Father\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>init\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">@end</span>\n</code></pre>\n<ol>\n<li>22–55题，请看下篇。</li>\n</ol>\n<h3 id=\"1-风格纠错题\"><a href=\"#1-风格纠错题\" class=\"headerlink\" title=\"1. 风格纠错题\"></a>1. 风格纠错题</h3><p><img src=\"http://i.imgur.com/O7Zev94.png\" alt=\"enter image description here\"><br>修改完的代码：</p>\n<p>修改方法有很多种，现给出一种做示例：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token function\">NS_ENUM</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">,</span> CYLSex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CYLSexMan<span class=\"token punctuation\">,</span>\n    CYLSexWoman\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@interface</span> CYLUser <span class=\"token punctuation\">:</span> NSObject<span class=\"token operator\">&lt;</span>NSCopying<span class=\"token operator\">></span>\n\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger age<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> CYLSex sex<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>userWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>下面对具体修改的地方，分两部分做下介绍：<strong>硬伤部分</strong> 和 <strong>优化部分</strong><br>。因为<strong>硬伤部分</strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong>优化部分</strong>。</p>\n<h4 id=\"优化部分\"><a href=\"#优化部分\" class=\"headerlink\" title=\"优化部分\"></a><strong>优化部分</strong></h4><ol>\n<li>enum 建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href=\"https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html\" target=\"_blank\" rel=\"external\">Adopting Modern Objective-C</a> 一文：</li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//定义一个枚举</span>\n    <span class=\"token keyword\">typedef</span> <span class=\"token function\">NS_ENUM</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">,</span> CYLSex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CYLSexMan<span class=\"token punctuation\">,</span>\n        CYLSexWoman\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p> （仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/issues/9\" target=\"_blank\" rel=\"external\">这里</a> 。）</p>\n<ol>\n<li><p>age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">int</span> <span class=\"token operator\">-></span> NSInteger\n<span class=\"token keyword\">unsigned</span> <span class=\"token operator\">-></span> NSUInteger\n<span class=\"token keyword\">float</span> <span class=\"token operator\">-></span> CGFloat\n动画时间 <span class=\"token operator\">-></span> NSTimeInterval\n</code></pre>\n<p>同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。<br>这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href=\"http://blog.sunnyxx.com/2014/12/20/64-bit-tips/\" target=\"_blank\" rel=\"external\">《64-bit Tips》</a>。</p>\n</li>\n</ol>\n<ol>\n<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>\n<li>doLogIn方法不应写在该类中： <p><del>虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： <a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>\n</ol>\n<blockquote>\n<p>无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。</p>\n</blockquote>\n<p> （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： <code>-logIn</code> 对应的应当是注册并登录的一个 Button ，出现 <code>-logIn</code> 方法也可能是合理的。）</p>\n<ol>\n<li><p>doLogIn 方法命名不规范：添加了多余的动词前缀。<br>请牢记：</p>\n<blockquote>\n<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 <code>do</code>，<code>does</code> 这种多余的关键字，动词本身的暗示就足够了。</p>\n</blockquote>\n<p>应为 <code>-logIn</code> （注意： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆。  见<a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</p>\n</li>\n<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用 <code>with</code> 来连接两个参数: <code>withAge:</code> 应当换为<code>age:</code>，<code>age:</code> 已经足以清晰说明参数的作用，也不建议用 <code>andAge:</code> ：通常情况下，即使有类似 <code>withA:withB:</code> 的命名需求，也通常是使用<code>withA:andB:</code> 这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//错误，不要使用\"and\"来连接参数</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>runModalForDirectory<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>path andFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name andTypes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSArray <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>fileTypes<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//错误，不要使用\"and\"来阐明有多个参数</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>width andAge<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CGFloat<span class=\"token punctuation\">)</span>height<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//正确，使用\"and\"来表示两个相对独立的操作</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>openFile<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>fullPath withApplication<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>appName andDeactivate<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>BOOL<span class=\"token punctuation\">)</span>flag<span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n<li><p>由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？</em></strong>)</p>\n</li>\n<li><p>“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</p>\n<p>Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：</p>\n</li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">\n    <span class=\"token comment\" spellcheck=\"true\">// .m文件</span>\n    <span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n    <span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n\n    <span class=\"token keyword\">@implementation</span> CYLUser\n\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name\n                             age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age\n                             sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            _age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n            _sex <span class=\"token operator\">=</span> sex<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name\n                             age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> initWithName<span class=\"token punctuation\">:</span>name age<span class=\"token punctuation\">:</span>age sex<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">@end</span>\n</code></pre>\n<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>\n<p>  因为出题者没有给出 <code>.m</code> 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">\n\n    <span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n    <span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n    <span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 第二种修改方法（基于第一种修改方法的基础上）</span>\n\n    <span class=\"token keyword\">typedef</span> <span class=\"token function\">NS_ENUM</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">,</span> CYLSex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CYLSexMan<span class=\"token punctuation\">,</span>\n        CYLSexWoman\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">@interface</span> CYLUser <span class=\"token punctuation\">:</span> NSObject<span class=\"token operator\">&lt;</span>NSCopying<span class=\"token operator\">></span>\n\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readwrite<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> CYLSex sex<span class=\"token punctuation\">;</span>\n\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>userWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">@end</span>\n</code></pre>\n<p>  <code>.h</code> 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳–》 <a href=\"http://is.gd/OQ49zk\" target=\"_blank\" rel=\"external\"><strong><em>《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》</em></strong></a>。）</p>\n<ul>\n<li>按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。</li>\n<li>如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:<br>那么在设计对应 <code>@property</code> 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样</li>\n</ul>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">        <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger age<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> CYLSex sex<span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code>  由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。\n</code></pre><ol>\n<li><code>initUserModelWithUserName</code> 如果改为 <code>initWithName</code> 会更加简洁，而且足够清晰。</li>\n<li><code>UserModel</code> 如果改为 <code>User</code> 会更加简洁，而且足够清晰。</li>\n<li><code>UserSex</code>如果改为<code>Sex</code> 会更加简洁，而且足够清晰。</li>\n<li><p>第二个 <code>@property</code> 中 assign 和 nonatomic 调换位置。<br>推荐按照下面的格式来定义属性</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readwrite<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在<a href=\"https://github.com/oa414/objc-zen-book-cn#属性定义\" target=\"_blank\" rel=\"external\">《禅与Objective-C编程艺术 &gt;》</a>里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。</p>\n</li>\n</ol>\n<h4 id=\"硬伤部分\"><a href=\"#硬伤部分\" class=\"headerlink\" title=\"硬伤部分\"></a><strong><em>硬伤部分</em></strong></h4><ol>\n<li>在-和(void)之间应该有一个空格</li>\n<li>enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。</li>\n<li>enum 左括号前加一个空格，或者将左括号换到下一行</li>\n<li>enum 右括号后加一个空格</li>\n<li><code>UserModel :NSObject</code> 应为<code>UserModel : NSObject</code>，也就是<code>:</code>右侧少了一个空格。</li>\n<li><code>@interface</code> 与 <code>@property</code> 属性声明中间应当间隔一行。</li>\n<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中方法名与参数之间多了空格。而且 <code>-</code> 与 <code>(id)</code> 之间少了空格。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中方法名与参数之间多了空格：<code>(NSString*)name</code> 前多了空格。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中 <code>(NSString*)name</code>,应为 <code>(NSString *)name</code>，少了空格。 </li>\n<li><p><del>doLogIn方法中的 <code>LogIn</code> 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。<br>（勘误： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆的意思。见： <a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>\n\n</li>\n</ol>\n<h3 id=\"2-什么情况使用-weak-关键字，相比-assign-有什么不同？\"><a href=\"#2-什么情况使用-weak-关键字，相比-assign-有什么不同？\" class=\"headerlink\" title=\"2. 什么情况使用 weak 关键字，相比 assign 有什么不同？\"></a>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><p>什么情况使用 weak 关键字？</p>\n<ol>\n<li><p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</p>\n</li>\n<li><p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></p>\n</li>\n</ol>\n<p>不同点：</p>\n<ol>\n<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，<br>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。<br>而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或<br>NSlnteger 等)的简单赋值操作。</p>\n</li>\n<li><p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p>\n</li>\n</ol>\n<h3 id=\"3-怎么用-copy-关键字？\"><a href=\"#3-怎么用-copy-关键字？\" class=\"headerlink\" title=\"3. 怎么用 copy 关键字？\"></a>3. 怎么用 copy 关键字？</h3><p>用途：</p>\n<ol>\n<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>\n<li><p>block 也经常使用 copy 关键字，具体原因见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12\" target=\"_blank\" rel=\"external\">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</p>\n<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p>\n</li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"> <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>userId<span class=\"token punctuation\">;</span>\n\n <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithUserId<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>userId <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    _userId <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>userId copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<p> <img src=\"http://i.imgur.com/VlVKl8L.png\" alt=\"enter image description here\"></p>\n<p>下面做下解释：<br> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>\n<blockquote>\n<p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<p>该问题在下文中也有论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong></p>\n<h3 id=\"4-这个写法会出什么问题：-property-copy-NSMutableArray-array\"><a href=\"#4-这个写法会出什么问题：-property-copy-NSMutableArray-array\" class=\"headerlink\" title=\"4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;\"></a>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3><p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； </p>\n<p>第1条的相关原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>\n<p>比如下面的代码就会发生崩溃</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 下面的代码就会发生崩溃</span>\n\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSMutableArray <span class=\"token operator\">*</span>mutableArray<span class=\"token punctuation\">;</span>\n</code></pre>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .m文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 下面的代码就会发生崩溃</span>\n\nNSMutableArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithObjects<span class=\"token punctuation\">:</span><span class=\"token operator\">@</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token operator\">@</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mutableArray <span class=\"token operator\">=</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>mutableArray removeObjectAtIndex<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>接下来就会奔溃：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"> <span class=\"token operator\">-</span><span class=\"token punctuation\">[</span>__NSArrayI removeObjectAtIndex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> unrecognized selector sent to instance <span class=\"token number\">0x7fcd1bc30460</span>\n</code></pre>\n<p>第2条原因，如下：</p>\n<blockquote>\n<p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p>\n</blockquote>\n<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>\n<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>\n<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>\n<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用<br> atomic 属性通常都不会有性能瓶颈。</p>\n<h3 id=\"5-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\"><a href=\"#5-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\" class=\"headerlink\" title=\"5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\"></a>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><blockquote>\n<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p>\n</blockquote>\n<p>具体步骤：</p>\n<ol>\n<li>需声明该类遵从 NSCopying 协议</li>\n<li><p>实现 NSCopying 协议。该协议只有一个方法: </p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>copyWithZone<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSZone <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>zone<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>\n</li>\n</ol>\n<p>以第一题的代码为例：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n    <span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n    <span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 修改完的代码</span>\n\n    <span class=\"token keyword\">typedef</span> <span class=\"token function\">NS_ENUM</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">,</span> CYLSex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CYLSexMan<span class=\"token punctuation\">,</span>\n        CYLSexWoman\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">@interface</span> CYLUser <span class=\"token punctuation\">:</span> NSObject<span class=\"token operator\">&lt;</span>NSCopying<span class=\"token operator\">></span>\n\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> CYLSex sex<span class=\"token punctuation\">;</span>\n\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>userWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">@end</span>\n</code></pre>\n<p>然后实现协议中规定的方法：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>copyWithZone<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSZone <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>zone <span class=\"token punctuation\">{</span>\n    CYLUser <span class=\"token operator\">*</span>copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span> allocWithZone<span class=\"token punctuation\">:</span>zone<span class=\"token punctuation\">]</span> \n                     initWithName<span class=\"token punctuation\">:</span>_name\n                                   age<span class=\"token punctuation\">:</span>_age\n                                  sex<span class=\"token punctuation\">:</span>_sex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> copy<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 以第一题《风格纠错题》里的代码为例</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token function\">NS_ENUM</span><span class=\"token punctuation\">(</span>NSInteger<span class=\"token punctuation\">,</span> CYLSex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CYLSexMan<span class=\"token punctuation\">,</span>\n    CYLSexWoman\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@interface</span> CYLUser <span class=\"token punctuation\">:</span> NSObject<span class=\"token operator\">&lt;</span>NSCopying<span class=\"token operator\">></span>\n\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> NSUInteger age<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readonly<span class=\"token punctuation\">,</span> assign<span class=\"token punctuation\">)</span> CYLSex sex<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>userWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>addFriend<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLUser <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>user<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>removeFriend<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLUser <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>user<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>// .m文件</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .m文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n\n<span class=\"token keyword\">@implementation</span> CYLUser <span class=\"token punctuation\">{</span>\n    NSMutableSet <span class=\"token operator\">*</span>_friends<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name <span class=\"token punctuation\">{</span>\n    _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name\n                         age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age\n                         sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        _age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        _sex <span class=\"token operator\">=</span> sex<span class=\"token punctuation\">;</span>\n        _friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableSet alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>addFriend<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLUser <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>user <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>_friends addObject<span class=\"token punctuation\">:</span>user<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>removeFriend<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLUser <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>user <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>_friends removeObject<span class=\"token punctuation\">:</span>user<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>copyWithZone<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSZone <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>zone <span class=\"token punctuation\">{</span>\n    CYLUser <span class=\"token operator\">*</span>copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span> allocWithZone<span class=\"token punctuation\">:</span>zone<span class=\"token punctuation\">]</span>\n                     initWithName<span class=\"token punctuation\">:</span>_name\n                     age<span class=\"token punctuation\">:</span>_age\n                     sex<span class=\"token punctuation\">:</span>_sex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    copy<span class=\"token operator\">-></span>_friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>_friends mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> copy<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>deepCopy <span class=\"token punctuation\">{</span>\n    CYLUser <span class=\"token operator\">*</span>copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span> alloc<span class=\"token punctuation\">]</span>\n                     initWithName<span class=\"token punctuation\">:</span>_name\n                     age<span class=\"token punctuation\">:</span>_age\n                     sex<span class=\"token punctuation\">:</span>_sex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    copy<span class=\"token operator\">-></span>_friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableSet alloc<span class=\"token punctuation\">]</span> initWithSet<span class=\"token punctuation\">:</span>_friends\n                                             copyItems<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> copy<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>以上做法能满足基本的需求，但是也有缺陷：</p>\n<blockquote>\n<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>\n</blockquote>\n<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>\n<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>deepCopy <span class=\"token punctuation\">{</span>\n    CYLUser <span class=\"token operator\">*</span>copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span> alloc<span class=\"token punctuation\">]</span>\n                     initWithName<span class=\"token punctuation\">:</span>_name\n                     age<span class=\"token punctuation\">:</span>_age\n                     sex<span class=\"token punctuation\">:</span>_sex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    copy<span class=\"token operator\">-></span>_friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableSet alloc<span class=\"token punctuation\">]</span> initWithSet<span class=\"token punctuation\">:</span>_friends\n                                             copyItems<span class=\"token punctuation\">:</span>YES<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> copy<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>\n<p>如果抛开本例来回答的话，如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//[_name release];</span>\n    _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_name <span class=\"token operator\">!=</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//[_name release];//MRC</span>\n        _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>\n<p><img src=\"http://i.imgur.com/UwV9oSn.jpeg\" alt=\"enter image description here\"></p>\n<p>克强总理这样评价你的代码风格：</p>\n<p><img src=\"http://i.imgur.com/N77Lkic.png\" alt=\"enter image description here\"></p>\n<p>我和总理的意见基本一致：</p>\n<blockquote>\n<p>老百姓 copy 一下，咋就这么难？</p>\n</blockquote>\n<p>你可能会说：</p>\n<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。<br>(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>\n<p>但是你有没有考虑过代价：</p>\n<blockquote>\n<p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p>\n</blockquote>\n<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>a setX<span class=\"token punctuation\">:</span>x1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">[</span>a setX<span class=\"token punctuation\">:</span>x1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//你确定你要这么干？与其在setter中判断，为什么不把代码写好？</span>\n</code></pre>\n<p>或者</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>a setX<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>a x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//队友咆哮道：你在干嘛？！！</span>\n</code></pre>\n<blockquote>\n<p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href=\"http://vgable.com/blog/tag/autorelease/\" target=\"_blank\" rel=\"external\"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a><br>）</p>\n</blockquote>\n<p>什么情况会在 copy setter 里做 if 判断？<br>例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setSpeed<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>_speed<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>_speed <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> speed <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>_speed <span class=\"token operator\">></span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span> speed <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n    _speed <span class=\"token operator\">=</span> speed<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>\n<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>initWithName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>name \n                                 age<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSUInteger<span class=\"token punctuation\">)</span>age \n                                 sex<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>CYLSex<span class=\"token punctuation\">)</span>sex <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             _name <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>name copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n             _age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n             _sex <span class=\"token operator\">=</span> sex<span class=\"token punctuation\">;</span>\n             _friends <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableSet alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n         <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\"></a>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><p><strong>@property 的本质是什么？</strong></p>\n<blockquote>\n<p>@property = ivar + getter + setter;</p>\n</blockquote>\n<p>下面解释下：</p>\n<blockquote>\n<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n</blockquote>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>Objective-C 2.0</code> 的一部分。<br>而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。<br>正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n<blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。<br>所以你也可以这么说：</p>\n<p>@property = getter + setter;</p>\n</blockquote>\n<p>例如下面这个类：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@interface</span> Person <span class=\"token punctuation\">:</span> NSObject\n<span class=\"token keyword\">@property</span> NSString <span class=\"token operator\">*</span>firstName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@property</span> NSString <span class=\"token operator\">*</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>上述代码写出来的类与下面这种写法等效：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@interface</span> Person <span class=\"token punctuation\">:</span> NSObject\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstName<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setFirstName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>firstName<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setLastName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p><strong>更新</strong>：</p>\n<p>property在runtime中是<code>objc_property_t</code>定义如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> objc_property <span class=\"token operator\">*</span>objc_property_t<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>而<code>objc_property</code>是一个结构体，包括name和attributes，定义如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">struct</span> property_t <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>attributes<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>而attributes本质是<code>objc_property_attribute_t</code>，定义了property的一些属性，定义如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/// Defines a property attribute</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>           <span class=\"token comment\" spellcheck=\"true\">/**&lt; The name of the attribute */</span>\n    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>value<span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">/**&lt; The value of the attribute (usually empty) */</span>\n<span class=\"token punctuation\">}</span> objc_property_attribute_t<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>\n<p>例如：我们定义一个string的property<code>@property (nonatomic, copy) NSString *string;</code>，通过 <code>property_getAttributes(property)</code>获取到attributes并打印出来之后的结果为<code>T@&quot;NSString&quot;,C,N,V_string</code></p>\n<p>其中T就代表类型，可参阅<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1\" target=\"_blank\" rel=\"external\">Type Encodings</a>，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p>\n<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>\n<blockquote>\n<p>“自动合成”( autosynthesis)</p>\n</blockquote>\n<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译<br>器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过<br> <code>@synthesize</code> 语法来指定实例变量的名字.</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@implementation</span> Person\n<span class=\"token keyword\">@synthesize</span> firstName <span class=\"token operator\">=</span> _myFirstName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@synthesize</span> lastName <span class=\"token operator\">=</span> _myLastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>\n<ol>\n<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>\n<li>setter 与 getter 方法对应的实现函数</li>\n<li><code>ivar_list</code> ：成员变量列表</li>\n<li><code>method_list</code> ：方法列表</li>\n<li><code>prop_list</code> ：属性列表</li>\n</ol>\n<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>\n<h3 id=\"7-protocol-和-category-中如何使用-property\"><a href=\"#7-protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"7. @protocol 和 category 中如何使用 @property\"></a>7. @protocol 和 category 中如何使用 @property</h3><ol>\n<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>\n<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p>\n<ol>\n<li><code>objc_setAssociatedObject</code></li>\n<li><code>objc_getAssociatedObject</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"8-runtime-如何实现-weak-属性\"><a href=\"#8-runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"8. runtime 如何实现 weak 属性\"></a>8. runtime 如何实现 weak 属性</h3><p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>\n<blockquote>\n<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>\n</blockquote>\n<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>\n<blockquote>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n</blockquote>\n<p>（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>\n<p>先看下 runtime 里源码的实现：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">/**\n * The internal structure stored in the weak references table. \n * It maintains and stores\n * a hash set of weak references pointing to an object.\n * If out_of_line==0, the set is instead a small inline array.\n */</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> WEAK_INLINE_COUNT 4</span>\n<span class=\"token keyword\">struct</span> weak_entry_t <span class=\"token punctuation\">{</span>\n    DisguisedPtr<span class=\"token operator\">&lt;</span>objc_object<span class=\"token operator\">></span> referent<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n            weak_referrer_t <span class=\"token operator\">*</span>referrers<span class=\"token punctuation\">;</span>\n            uintptr_t        out_of_line <span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            uintptr_t        num_refs <span class=\"token punctuation\">:</span> PTR_MINUS_1<span class=\"token punctuation\">;</span>\n            uintptr_t        mask<span class=\"token punctuation\">;</span>\n            uintptr_t        max_hash_displacement<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// out_of_line=0 is LSB of one of these (don't care which)</span>\n            weak_referrer_t  inline_referrers<span class=\"token punctuation\">[</span>WEAK_INLINE_COUNT<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */</span>\n<span class=\"token keyword\">struct</span> weak_table_t <span class=\"token punctuation\">{</span>\n    weak_entry_t <span class=\"token operator\">*</span>weak_entries<span class=\"token punctuation\">;</span>\n    size_t    num_entries<span class=\"token punctuation\">;</span>\n    uintptr_t mask<span class=\"token punctuation\">;</span>\n    uintptr_t max_hash_displacement<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>具体完整实现参照 <a href=\"https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h\" target=\"_blank\" rel=\"external\">objc/objc-weak.h</a> 。</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>\n<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由 assign 修饰的，则：<br>在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。</p>\n<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 使用伪代码模拟：runtime如何实现weak属性</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n\n id obj1<span class=\"token punctuation\">;</span>\n <span class=\"token function\">objc_initWeak</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>obj1<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/*obj引用计数变为0，变量作用域结束*/</span>\n <span class=\"token function\">objc_destroyWeak</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>obj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>\n<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">obj1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>；\n<span class=\"token function\">obj_storeWeak</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>obj1<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>\n</blockquote>\n<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>\n<p>前面的源代码与下列源代码相同。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 使用伪代码模拟：runtime如何实现weak属性</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n\nid obj1<span class=\"token punctuation\">;</span>\nobj1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">objc_storeWeak</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>obj1<span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/* ... obj的引用计数变为0，被置nil ... */</span>\n<span class=\"token function\">objc_storeWeak</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>obj1<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>objc_storeWeak</code> 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。</p>\n<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>\n<blockquote>\n<p>如何让不使用weak修饰的@property，拥有weak的效果。</p>\n</blockquote>\n<p>我们从setter方法入手：</p>\n<p>（注意以下的 <code>cyl_runAtDealloc</code> 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> ）</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>object\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">,</span> object<span class=\"token punctuation\">,</span> OBJC_ASSOCIATION_ASSIGN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>object cyl_runAtDealloc<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        _object <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>也就是有两个步骤：</p>\n<ol>\n<li>在setter方法中做如下设置：</li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">        <span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">,</span> object<span class=\"token punctuation\">,</span> OBJC_ASSOCIATION_ASSIGN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol>\n<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//要销毁的目标对象</span>\nid objectToBeDeallocated<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。</span>\nid objectWeWantToBeReleasedWhenThatHappens<span class=\"token punctuation\">;</span>\n<span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span>objectToBeDeallocted<span class=\"token punctuation\">,</span>\n                     someUniqueKey<span class=\"token punctuation\">,</span>\n                     objectWeWantToBeReleasedWhenThatHappens<span class=\"token punctuation\">,</span>\n                     OBJC_ASSOCIATION_RETAIN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n</ol>\n<p>知道了思路，我们就开始实现 <code>cyl_runAtDealloc</code> 方法，实现过程分两部分：</p>\n<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。</p>\n<p>// .h文件</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .h文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">^</span>voidBlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@interface</span> CYLBlockExecutor <span class=\"token punctuation\">:</span> NSObject\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>initWithBlock<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>voidBlock<span class=\"token punctuation\">)</span>block<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>// .m文件</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// .m文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLBlockExecutor.h\"</span>\n\n<span class=\"token keyword\">@interface</span> <span class=\"token function\">CYLBlockExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    voidBlock _block<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">@implementation</span> CYLBlockExecutor\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>initWithBlock<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>voidBlock<span class=\"token punctuation\">)</span>aBlock\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _block <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>aBlock copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>dealloc\n<span class=\"token punctuation\">{</span>\n    _block <span class=\"token operator\">?</span> <span class=\"token function\">_block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> nil<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// CYLNSObject+RunAtDealloc.h文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 利用runtime实现cyl_runAtDealloc方法</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLBlockExecutor.h\"</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>runAtDeallocBlockKey <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>runAtDeallocBlockKey<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@interface</span> <span class=\"token function\">NSObject</span> <span class=\"token punctuation\">(</span>CYLRunAtDealloc<span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>cyl_runAtDealloc<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>voidBlock<span class=\"token punctuation\">)</span>block<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@end</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// CYLNSObject+RunAtDealloc.m文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 利用runtime实现cyl_runAtDealloc方法</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLNSObject+RunAtDealloc.h\"</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLBlockExecutor.h\"</span>\n\n<span class=\"token keyword\">@implementation</span> <span class=\"token function\">NSObject</span> <span class=\"token punctuation\">(</span>CYLRunAtDealloc<span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>cyl_runAtDealloc<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>voidBlock<span class=\"token punctuation\">)</span>block\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>block<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CYLBlockExecutor <span class=\"token operator\">*</span>executor <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>CYLBlockExecutor alloc<span class=\"token punctuation\">]</span> initWithBlock<span class=\"token punctuation\">:</span>block<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span>\n                                 runAtDeallocBlockKey<span class=\"token punctuation\">,</span>\n                                 executor<span class=\"token punctuation\">,</span>\n                                 OBJC_ASSOCIATION_RETAIN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>使用方法：<br>导入</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLNSObject+RunAtDealloc.h\"</span>\n</code></pre>\n<p>然后就可以使用了：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSObject <span class=\"token operator\">*</span>foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSObject alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>foo cyl_runAtDealloc<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"正在释放foo!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> </p>\n<p>参考博文： <a href=\"http://stackoverflow.com/a/31560217/3395008\" target=\"_blank\" rel=\"external\"><strong><em>Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</em></strong></a></p>\n<h3 id=\"9-property中有哪些属性关键字？-property-后面可以有哪些修饰符？\"><a href=\"#9-property中有哪些属性关键字？-property-后面可以有哪些修饰符？\" class=\"headerlink\" title=\"9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\"></a>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3><p>属性可以拥有的特质分为四类:</p>\n<ol>\n<li><p>原子性— <code>nonatomic</code> 特质</p>\n<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>\n</li>\n<li><p>读/写权限—<code>readwrite(读写)</code>、<code>readonly (只读)</code></p>\n</li>\n<li>内存管理语义—<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>\n<li><p>方法名—<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></p>\n<p><code>getter=&lt;name&gt;</code>的样式：</p>\n</li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">        <span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> getter<span class=\"token operator\">=</span>isOn<span class=\"token punctuation\">)</span> BOOL on<span class=\"token punctuation\">;</span>\n</code></pre>\n <p><del>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）<br></del></p>\n\n\n<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>\n<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>\n<p>这时你就可以使用下面的方式来避免编译器报错：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@property</span><span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">,</span> getter<span class=\"token operator\">=</span>p_initBy<span class=\"token punctuation\">,</span> setter<span class=\"token operator\">=</span>setP_initBy<span class=\"token punctuation\">:</span><span class=\"token punctuation\">)</span>NSString <span class=\"token operator\">*</span>initBy<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@property</span><span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> readwrite<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">,</span> null_resettable<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>initBy<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>initBy <span class=\"token function\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">objc_method_family</span><span class=\"token punctuation\">(</span>none<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol>\n<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>\n</ol>\n<p>注意：很多人会认为如果属性具备 nonatomic 特质，则不使用<br>“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reallySetProperty</span><span class=\"token punctuation\">(</span>id <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> SEL _cmd<span class=\"token punctuation\">,</span> id newValue<span class=\"token punctuation\">,</span> ptrdiff_t offset<span class=\"token punctuation\">,</span> bool atomic<span class=\"token punctuation\">,</span> bool copy<span class=\"token punctuation\">,</span> bool mutableCopy<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>offset <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">object_setClass</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    id oldValue<span class=\"token punctuation\">;</span>\n    id <span class=\"token operator\">*</span>slot <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>id<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">self</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>copy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        newValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>newValue copyWithZone<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mutableCopy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        newValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>newValue mutableCopyWithZone<span class=\"token punctuation\">:</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>slot <span class=\"token operator\">==</span> newValue<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        newValue <span class=\"token operator\">=</span> <span class=\"token function\">objc_retain</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>atomic<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        oldValue <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>slot<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>slot <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        spinlock_t<span class=\"token operator\">&amp;</span> slotlock <span class=\"token operator\">=</span> PropertyLocks<span class=\"token punctuation\">[</span>slot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        slotlock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        oldValue <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>slot<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>slot <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>        \n        slotlock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">objc_release</span><span class=\"token punctuation\">(</span>oldValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">objc_setProperty</span><span class=\"token punctuation\">(</span>id <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> SEL _cmd<span class=\"token punctuation\">,</span> ptrdiff_t offset<span class=\"token punctuation\">,</span> id newValue<span class=\"token punctuation\">,</span> BOOL atomic<span class=\"token punctuation\">,</span> <span class=\"token keyword\">signed</span> <span class=\"token keyword\">char</span> shouldCopy<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{</span>\n    bool copy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>shouldCopy <span class=\"token operator\">&amp;&amp;</span> shouldCopy <span class=\"token operator\">!=</span> MUTABLE_COPY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    bool mutableCopy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>shouldCopy <span class=\"token operator\">==</span> MUTABLE_COPY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reallySetProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> _cmd<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> atomic<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">,</span> mutableCopy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"10-weak属性需要在dealloc中置nil么？\"><a href=\"#10-weak属性需要在dealloc中置nil么？\" class=\"headerlink\" title=\"10. weak属性需要在dealloc中置nil么？\"></a>10. weak属性需要在dealloc中置nil么？</h3><p>不需要。</p>\n<blockquote>\n<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p>\n</blockquote>\n<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>\n<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>\n<p>我们模拟下 weak 的 setter 方法，应该如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setObject<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>object\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">objc_setAssociatedObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">,</span> object<span class=\"token punctuation\">,</span> OBJC_ASSOCIATION_ASSIGN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>object cyl_runAtDealloc<span class=\"token punctuation\">:</span><span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>\n        _object <span class=\"token operator\">=</span> nil<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> </p>\n<p>也即:</p>\n<blockquote>\n<p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>\n</blockquote>\n<h3 id=\"11-synthesize和-dynamic分别有什么作用？\"><a href=\"#11-synthesize和-dynamic分别有什么作用？\" class=\"headerlink\" title=\"11. @synthesize和@dynamic分别有什么作用？\"></a>11. @synthesize和@dynamic分别有什么作用？</h3><ol>\n<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>\n<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>\n<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>\n</ol>\n<h3 id=\"12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"><a href=\"#12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\" class=\"headerlink\" title=\"12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"></a>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><ol>\n<li><p>对应基本数据类型默认关键字是</p>\n<p>atomic,readwrite,assign</p>\n</li>\n<li><p>对于普通的 Objective-C 对象</p>\n<p>atomic,readwrite,strong</p>\n</li>\n</ol>\n<p>参考链接：</p>\n<ol>\n<li><p><a href=\"http://stackoverflow.com/a/15541801/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>Objective-C ARC: strong vs retain and weak vs assign</em></strong> </a></p>\n</li>\n<li><p><a href=\"http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html\" target=\"_blank\" rel=\"external\"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p>\n</li>\n</ol>\n<h3 id=\"13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"><a href=\"#13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\" class=\"headerlink\" title=\"13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"></a>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><ol>\n<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>\n<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>\n<p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>\n</li>\n</ol>\n<p>举例说明：</p>\n<p>定义一个以 strong 修饰的 array：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic <span class=\"token punctuation\">,</span>readwrite<span class=\"token punctuation\">,</span> strong<span class=\"token punctuation\">)</span> NSArray <span class=\"token operator\">*</span>array<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>然后进行下面的操作：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    NSMutableArray <span class=\"token operator\">*</span>mutableArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSMutableArray alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    NSArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span> <span class=\"token operator\">@</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token number\">4</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>array <span class=\"token operator\">=</span> mutableArray<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>mutableArray removeAllObjects<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">[</span>mutableArray addObjectsFromArray<span class=\"token punctuation\">:</span>array<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>mutableArray copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span>mutableArray removeAllObjects<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>打印结果如下所示：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token number\">2015</span><span class=\"token operator\">-</span><span class=\"token number\">09</span><span class=\"token operator\">-</span><span class=\"token number\">27</span> <span class=\"token number\">19</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span><span class=\"token punctuation\">:</span><span class=\"token number\">32.523</span> CYLArrayCopyDmo<span class=\"token punctuation\">[</span><span class=\"token number\">10681</span><span class=\"token punctuation\">:</span><span class=\"token number\">713670</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token number\">2015</span><span class=\"token operator\">-</span><span class=\"token number\">09</span><span class=\"token operator\">-</span><span class=\"token number\">27</span> <span class=\"token number\">19</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span><span class=\"token punctuation\">:</span><span class=\"token number\">32.524</span> CYLArrayCopyDmo<span class=\"token punctuation\">[</span><span class=\"token number\">10681</span><span class=\"token punctuation\">:</span><span class=\"token number\">713670</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">4</span>\n<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>（详见仓库内附录的 Demo。）</p>\n<p>为了理解这种做法，首先要知道，两种情况：</p>\n<ol>\n<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>\n<li>对集合类对象的 copy 与 mutableCopy 操作。</li>\n</ol>\n<h4 id=\"1-对非集合类对象的copy操作：\"><a href=\"#1-对非集合类对象的copy操作：\" class=\"headerlink\" title=\"1. 对非集合类对象的copy操作：\"></a>1. 对非集合类对象的copy操作：</h4><p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>\n<ul>\n<li>[immutableObject copy] // 浅复制</li>\n<li>[immutableObject mutableCopy] //深复制</li>\n<li>[mutableObject copy] //深复制</li>\n<li>[mutableObject mutableCopy] //深复制</li>\n</ul>\n<p>比如以下代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableString <span class=\"token operator\">*</span>string <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"origin\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//copy</span>\nNSString <span class=\"token operator\">*</span>stringCopy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>string copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>string appendString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"origion!\"</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。<br>  集合类对象以此类推。<br>所以，</p>\n<blockquote>\n<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<h4 id=\"2、集合类对象的copy与mutableCopy\"><a href=\"#2、集合类对象的copy与mutableCopy\" class=\"headerlink\" title=\"2、集合类对象的copy与mutableCopy\"></a>2、集合类对象的copy与mutableCopy</h4><p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"b\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">@</span><span class=\"token punctuation\">[</span><span class=\"token string\">@\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"d\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>copyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>mCopyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">NSMutableArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>NSMutableArray arrayWithObjects<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>NSMutableString stringWithString<span class=\"token punctuation\">:</span><span class=\"token string\">@\"a\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">@\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">@\"c\"</span><span class=\"token punctuation\">,</span>nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSArray <span class=\"token operator\">*</span>copyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nNSMutableArray <span class=\"token operator\">*</span>mCopyArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>array mutableCopy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>\n<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">[</span>immutableObject copy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">// 浅复制</span>\n<span class=\"token punctuation\">[</span>immutableObject mutableCopy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n<span class=\"token punctuation\">[</span>mutableObject copy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n<span class=\"token punctuation\">[</span>mutableObject mutableCopy<span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">//单层深复制</span>\n</code></pre>\n<p>这个代码结论和非集合类的非常相似。</p>\n<p>参考链接：<a href=\"https://www.zybuluo.com/MicroCai/note/50592\" target=\"_blank\" rel=\"external\">iOS 集合的深复制与浅复制</a></p>\n<h3 id=\"14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\"><a href=\"#14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\" class=\"headerlink\" title=\"14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\"></a>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3><p>在回答之前先说明下一个概念：</p>\n<blockquote>\n<p>实例变量 = 成员变量 ＝ ivar</p>\n</blockquote>\n<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>\n<p>正如<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6\" target=\"_blank\" rel=\"external\">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：<br><img src=\"http://i.imgur.com/D6d0zGJ.png\" alt=\"enter image description here\"></p>\n<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@interface</span> CYLPerson <span class=\"token punctuation\">:</span> NSObject \n<span class=\"token keyword\">@property</span> NSString <span class=\"token operator\">*</span>firstName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@property</span> NSString <span class=\"token operator\">*</span>lastName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>在上例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@implementation</span> CYLPerson \n<span class=\"token keyword\">@synthesize</span> firstName <span class=\"token operator\">=</span> _myFirstName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@synthesize</span> lastName <span class=\"token operator\">=</span> _myLastName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>\n<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>\n<ol>\n<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p>\n</li>\n<li><p>如果这个成员已经存在了就不再生成了.</p>\n</li>\n<li><p>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</p>\n<blockquote>\n<p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>\n</ol>\n<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？<br>不会。如下图：</p>\n<p><img src=\"http://i.imgur.com/t28ge4W.png\" alt=\"enter image description here\"></p>\n<h3 id=\"15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\"><a href=\"#15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\" class=\"headerlink\" title=\"15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\"></a>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>\n<ol>\n<li>同时重写了 setter 和 getter 时</li>\n<li>重写了只读属性的 getter 时</li>\n<li>使用了 @dynamic 时</li>\n<li>在 @protocol 中定义的所有属性</li>\n<li>在 category 中定义的所有属性</li>\n<li><p>重载的属性 </p>\n<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>\n</li>\n</ol>\n<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>\n<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>\n<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>\n<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">@implementation</span> CYLPerson \n<span class=\"token keyword\">@synthesize</span> firstName <span class=\"token operator\">=</span> _myFirstName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@synthesize</span> lastName <span class=\"token operator\">=</span> _myLastName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>\n<p>举例说明：应用场景：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">// .m文件</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 打开第14行和第17行中任意一行，就可编译成功</span>\n\n<span class=\"token operator\">@</span>import Foundation<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">@interface</span> CYLObject <span class=\"token punctuation\">:</span> NSObject\n<span class=\"token keyword\">@property</span> <span class=\"token punctuation\">(</span>nonatomic<span class=\"token punctuation\">,</span> copy<span class=\"token punctuation\">)</span> NSString <span class=\"token operator\">*</span>title<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">@end</span>\n\n<span class=\"token keyword\">@implementation</span> CYLObject <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//    NSString *_title;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//@synthesize title = _title;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>init\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _title <span class=\"token operator\">=</span> <span class=\"token string\">@\"微博@iOS程序犭袁\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>title <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> _title<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setTitle<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>title <span class=\"token punctuation\">{</span>\n    _title <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>title copy<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>结果编译器报错：<br><img src=\"http://i.imgur.com/fAEGHIo.png\" alt=\"enter image description here\"></p>\n<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>\n<ol>\n<li>要么如第14行：手动创建 ivar</li>\n<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>\n</ol>\n<p>更多信息，请戳- 》<a href=\"http://stackoverflow.com/a/19821816/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>\n<h3 id=\"16-objc中向一个nil对象发送消息将会发生什么？\"><a href=\"#16-objc中向一个nil对象发送消息将会发生什么？\" class=\"headerlink\" title=\"16. objc中向一个nil对象发送消息将会发生什么？\"></a>16. objc中向一个nil对象发送消息将会发生什么？</h3><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>\n<ol>\n<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  </li>\n</ol>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">Person <span class=\"token operator\">*</span> motherInlaw <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>aPerson spouse<span class=\"token punctuation\">]</span> mother<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。</p>\n<ol>\n<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。</li>\n<li>如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。</li>\n<li>如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</li>\n</ol>\n<p>具体原因如下：</p>\n<blockquote>\n<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>\n</blockquote>\n<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// runtime.h（类在runtime中的定义）</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n\n<span class=\"token keyword\">struct</span> objc_class <span class=\"token punctuation\">{</span>\n  Class isa OBJC_ISA_AVAILABILITY<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span>\n  <span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> !__OBJC2__</span>\n  Class super_class OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 父类</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 类名</span>\n  <span class=\"token keyword\">long</span> version OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 类的版本信息，默认为0</span>\n  <span class=\"token keyword\">long</span> info OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 类信息，供运行期使用的一些位标识</span>\n  <span class=\"token keyword\">long</span> instance_size OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 该类的实例变量大小</span>\n  <span class=\"token keyword\">struct</span> objc_ivar_list <span class=\"token operator\">*</span>ivars OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 该类的成员变量链表</span>\n  <span class=\"token keyword\">struct</span> objc_method_list <span class=\"token operator\">*</span><span class=\"token operator\">*</span>methodLists OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 方法定义的链表</span>\n  <span class=\"token keyword\">struct</span> objc_cache <span class=\"token operator\">*</span>cache OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span>\n  <span class=\"token keyword\">struct</span> objc_protocol_list <span class=\"token operator\">*</span>protocols OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 协议链表</span>\n  <span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n  <span class=\"token punctuation\">}</span> OBJC2_UNAVAILABLE<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。<br>那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>\n<h3 id=\"17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\"><a href=\"#17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\" class=\"headerlink\" title=\"17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\"></a>17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？</h3><p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>\n<p>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>\n<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">//  main.m</span>\n<span class=\"token comment\" spellcheck=\"true\">//  http://weibo.com/luohanchenyilong/</span>\n<span class=\"token comment\" spellcheck=\"true\">//  https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.</span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"CYLTest.h\"</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">@</span>autoreleasepool <span class=\"token punctuation\">{</span>\n        CYLTest <span class=\"token operator\">*</span>test <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>CYLTest alloc<span class=\"token punctuation\">]</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">[</span>test performSelector<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">@selector</span><span class=\"token punctuation\">(</span>iOSinit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在终端中输入</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">clang <span class=\"token operator\">-</span>rewrite<span class=\"token operator\">-</span>objc main<span class=\"token punctuation\">.</span>m\n</code></pre>\n<p>就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>\n<p><img src=\"http://i.imgur.com/eAH5YWn.png\" alt=\"enter image description here\"></p>\n<p>我们可以看到大概是这样的：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> SEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">)</span>objc_msgSend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>obj<span class=\"token punctuation\">,</span> <span class=\"token function\">sel_registerName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p>\n</blockquote>\n<h3 id=\"18-什么时候会报unrecognized-selector的异常？\"><a href=\"#18-什么时候会报unrecognized-selector的异常？\" class=\"headerlink\" title=\"18. 什么时候会报unrecognized selector的异常？\"></a>18. 什么时候会报unrecognized selector的异常？</h3><p>简单来说：</p>\n<blockquote>\n<p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，<br>可以通过“消息转发”进行解决。</p>\n</blockquote>\n<p>简单的流程如下，在上一题中也提到过：</p>\n<blockquote>\n<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>\n</blockquote>\n<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>\n<ol>\n<li><p>Method resolution</p>\n<p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>\n</li>\n<li><p>Fast forwarding</p>\n<p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。<br>只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。<br>这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>\n</li>\n<li><p>Normal forwarding</p>\n<p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>\n</li>\n</ol>\n<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>\n<h3 id=\"19-一个objc对象如何进行内存布局？（考虑有父类的情况）\"><a href=\"#19-一个objc对象如何进行内存布局？（考虑有父类的情况）\" class=\"headerlink\" title=\"19. 一个objc对象如何进行内存布局？（考虑有父类的情况）\"></a>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>\n<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>\n<li>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</li>\n</ul>\n<ol>\n<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>\n<li>成员变量的列表,</li>\n<li><p>属性列表,</p>\n<p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>\n</li>\n</ol>\n<p>每个 Objective-C 对象都有相同的结构，如下图所示：</p>\n<p> <img src=\"http://i.imgur.com/7mJlUj1.png\" alt=\"enter image description here\"></p>\n<p>翻译过来就是</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Objective-C 对象的结构图</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> ISA指针</td>\n<td></td>\n</tr>\n<tr>\n<td> 根类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> 倒数第二层父类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> …</td>\n<td></td>\n</tr>\n<tr>\n<td> 父类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> 类的实例变量</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>根对象就是NSObject，它的superclass指针指向nil</p>\n</li>\n<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p>\n</li>\n</ul>\n<p>如图:<br><img src=\"http://i.imgur.com/w6tzFxz.png\" alt=\"enter image description here\"></p>\n<h3 id=\"20-一个objc对象的isa的指针指向什么？有什么作用？\"><a href=\"#20-一个objc对象的isa的指针指向什么？有什么作用？\" class=\"headerlink\" title=\"20. 一个objc对象的isa的指针指向什么？有什么作用？\"></a>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向他的类对象,从而可以找到对象上的方法</p>\n<h3 id=\"21-下面的代码输出什么？\"><a href=\"#21-下面的代码输出什么？\" class=\"headerlink\" title=\"21. 下面的代码输出什么？\"></a>21. 下面的代码输出什么？</h3><pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token keyword\">@implementation</span> Son <span class=\"token punctuation\">:</span> Father\n    <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>init\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">@end</span>\n</code></pre>\n<p><strong>答案：</strong></p>\n<p>都输出 Son</p>\n<pre><code>NSStringFromClass([self class]) = Son\nNSStringFromClass([super class]) = Son\n</code></pre><p>这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。</p>\n<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>\n<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>\n<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>\n<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>\n<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>\n<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">//  ChenPerson.m</span>\n<span class=\"token comment\" spellcheck=\"true\">//  </span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Created by https://github.com/ChenYilong on 15/8/30.</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"ChenPerson.h\"</span>\n\n<span class=\"token keyword\">@implementation</span> ChenPerson\n\n<span class=\"token keyword\">@synthesize</span> lastName <span class=\"token operator\">=</span> _lastName<span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>init\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"🔴类名与方法名：%s（在第%d行），描述：%@\"</span><span class=\"token punctuation\">,</span> __PRETTY_FUNCTION__<span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"🔴类名与方法名：%s（在第%d行），描述：%@\"</span><span class=\"token punctuation\">,</span> __PRETTY_FUNCTION__<span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> class<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setLastName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastName\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//设置方法一：如果setter采用是这种方式，就可能引起崩溃</span>\n<span class=\"token comment\" spellcheck=\"true\">//    if (![lastName isEqualToString:@\"陈\"])</span>\n<span class=\"token comment\" spellcheck=\"true\">//    {</span>\n<span class=\"token comment\" spellcheck=\"true\">//        [NSException raise:NSInvalidArgumentException format:@\"姓不是陈\"];</span>\n<span class=\"token comment\" spellcheck=\"true\">//    }</span>\n<span class=\"token comment\" spellcheck=\"true\">//    _lastName = lastName;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//设置方法二：如果setter采用是这种方式，就可能引起崩溃</span>\n    _lastName <span class=\"token operator\">=</span> <span class=\"token string\">@\"陈\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"🔴类名与方法名：%s（在第%d行），描述：%@\"</span><span class=\"token punctuation\">,</span> __PRETTY_FUNCTION__<span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"会调用这个方法,想一下为什么？\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>\n<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>\n<p>如果基类的代码是这样的：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Person.m</span>\n<span class=\"token comment\" spellcheck=\"true\">//  nil对象调用点语法</span>\n<span class=\"token comment\" spellcheck=\"true\">//</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Created by https://github.com/ChenYilong on 15/8/29.</span>\n<span class=\"token comment\" spellcheck=\"true\">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</span>\n<span class=\"token comment\" spellcheck=\"true\">//  </span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">import</span> \"Person.h\"</span>\n\n<span class=\"token keyword\">@implementation</span> Person\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>instancetype<span class=\"token punctuation\">)</span>init\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">super</span> init<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>lastName <span class=\"token operator\">=</span> <span class=\"token string\">@\"\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));</span>\n        <span class=\"token comment\" spellcheck=\"true\">//NSLog(@\"🔴类名与方法名：%s（在第%d行），描述：%@\", __PRETTY_FUNCTION__, __LINE__, self.lastName);</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>setLastName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>NSString<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>lastName\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token string\">@\"🔴类名与方法名：%s（在第%d行），描述：%@\"</span><span class=\"token punctuation\">,</span> __PRETTY_FUNCTION__<span class=\"token punctuation\">,</span> <span class=\"token constant\">__LINE__</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"根本不会调用这个方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    _lastName <span class=\"token operator\">=</span> <span class=\"token string\">@\"炎黄\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">@end</span>\n</code></pre>\n<p>那么打印结果将会是这样的：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"> 🔴类名与方法名：<span class=\"token operator\">-</span><span class=\"token punctuation\">[</span>ChenPerson setLastName<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>（在第<span class=\"token number\">36</span>行），描述：会调用这个方法<span class=\"token punctuation\">,</span>想一下为什么？\n 🔴类名与方法名：<span class=\"token operator\">-</span><span class=\"token punctuation\">[</span>ChenPerson init<span class=\"token punctuation\">]</span>（在第<span class=\"token number\">19</span>行），描述：ChenPerson\n 🔴类名与方法名：<span class=\"token operator\">-</span><span class=\"token punctuation\">[</span>ChenPerson init<span class=\"token punctuation\">]</span>（在第<span class=\"token number\">20</span>行），描述：ChenPerson\n</code></pre>\n<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo<em>21题</em>下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>\n<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    $ clang <span class=\"token operator\">-</span>rewrite<span class=\"token operator\">-</span>objc test<span class=\"token punctuation\">.</span>m\n</code></pre>\n<p>将这道题目中给出的代码被转化为:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0<span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">Class</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span> SEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>objc_msgSend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token function\">sel_registerName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">NSLog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>NSString <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1<span class=\"token punctuation\">,</span> <span class=\"token function\">NSStringFromClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">Class</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>__rw_objc_super <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> SEL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>objc_msgSendSuper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>__rw_objc_super<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token function\">class_getSuperclass</span><span class=\"token punctuation\">(</span><span class=\"token function\">objc_getClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Son\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token function\">sel_registerName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    id <span class=\"token function\">objc_msgSend</span><span class=\"token punctuation\">(</span>id <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> SEL op<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>我们把 self 做为第一个参数传递进去。</p>\n<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\">    id <span class=\"token function\">objc_msgSendSuper</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> objc_super <span class=\"token operator\">*</span><span class=\"token keyword\">super</span><span class=\"token punctuation\">,</span> SEL op<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token keyword\">struct</span> objc_super <span class=\"token punctuation\">{</span>\n       __unsafe_unretained id receiver<span class=\"token punctuation\">;</span>\n       __unsafe_unretained Class super_class<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>\n<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>\n<p>objc Runtime开源代码对- (Class)class方法的实现:</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>Class<span class=\"token punctuation\">)</span>class <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">object_getClass</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。<br>第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>\n<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>\n<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>\n<p>参考链接：<a href=\"http://weibo.com/junbbcom\" target=\"_blank\" rel=\"external\">微博@Chun_iOS</a>的博文<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1\" target=\"_blank\" rel=\"external\">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>\n<h3 id=\"22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"><a href=\"#22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\" class=\"headerlink\" title=\"22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"></a>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>\n<h3 id=\"23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"><a href=\"#23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\" class=\"headerlink\" title=\"23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"></a>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><ul>\n<li>在ARC下不需要。</li>\n<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>\n</ul>\n<blockquote>\n<p>无论在MRC下还是ARC下均不需要。</p>\n</blockquote>\n<p><a href=\"https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html\" target=\"_blank\" rel=\"external\"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>\n<pre class=\" language-objectivec\"><code class=\"language-objectivec\"><span class=\"token comment\" spellcheck=\"true\">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</span>\n<span class=\"token comment\" spellcheck=\"true\">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>\n<span class=\"token comment\" spellcheck=\"true\">// https://github.com/ChenYilong</span>\n<span class=\"token comment\" spellcheck=\"true\">// 摘自2011年版本的Apple API 官方文档 - Associative References </span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">char</span> overviewKey<span class=\"token punctuation\">;</span>\n\nNSArray <span class=\"token operator\">*</span>array <span class=\"token operator\">=</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSArray alloc<span class=\"token punctuation\">]</span> initWithObjects<span class=\"token punctuation\">:</span><span class=\"token string\">@\"One\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"Two\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"Three\"</span><span class=\"token punctuation\">,</span> nil<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// For the purposes of illustration, use initWithFormat: to ensure</span>\n<span class=\"token comment\" spellcheck=\"true\">// the string can be deallocated</span>\nNSString <span class=\"token operator\">*</span>overview <span class=\"token operator\">=</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>NSString alloc<span class=\"token punctuation\">]</span> initWithFormat<span class=\"token punctuation\">:</span><span class=\"token string\">@\"%@\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">@\"First three numbers\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">objc_setAssociatedObject</span> <span class=\"token punctuation\">(</span>\n    array<span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">&amp;</span>overviewKey<span class=\"token punctuation\">,</span>\n    overview<span class=\"token punctuation\">,</span>\n    OBJC_ASSOCIATION_RETAIN\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span>overview release<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// (1) overview valid</span>\n<span class=\"token punctuation\">[</span>array release<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// (2) overview invalid</span>\n</code></pre>\n<p>文档指出 </p>\n<blockquote>\n<p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p>\n</blockquote>\n<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>\n<p>既然会被销毁，那么具体在什么时间点？</p>\n<blockquote>\n<p>根据<a href=\"https://developer.apple.com/videos/wwdc/2011/#322-video\" target=\"_blank\" rel=\"external\"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>\n</blockquote>\n<p>对象的内存销毁时间表，分四个步骤：</p>\n<pre><code>// 对象的内存销毁时间表\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 \n\n 1. 调用 -release ：引用计数变为零\n     * 对象正在被销毁，生命周期即将结束.\n     * 不能再有新的 __weak 弱引用， 否则将指向 nil.\n     * 调用 [self dealloc] \n 2. 子类 调用 -dealloc\n     * 继承关系中最底层的子类 在调用 -dealloc\n     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）\n     * 继承关系中每一层的父类 都在调用 -dealloc\n 3. NSObject 调 -dealloc\n     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法\n 4. 调用 object_dispose()\n     * 为 C++ 的实例变量们（iVars）调用 destructors \n     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release \n     * 解除所有使用 runtime Associate方法关联的对象\n     * 解除所有 __weak 引用\n     * 调用 free()\n</code></pre><p>对象的内存销毁时间表：<a href=\"http://stackoverflow.com/a/10843510/3395008\" target=\"_blank\" rel=\"external\">参考链接</a>。</p>\n<h3 id=\"24-objc中的类方法和实例方法有什么本质区别和联系？\"><a href=\"#24-objc中的类方法和实例方法有什么本质区别和联系？\" class=\"headerlink\" title=\"24. objc中的类方法和实例方法有什么本质区别和联系？\"></a>24. objc中的类方法和实例方法有什么本质区别和联系？</h3><p>类方法：</p>\n<ol>\n<li>类方法是属于类对象的</li>\n<li>类方法只能通过类对象调用</li>\n<li>类方法中的self是类对象</li>\n<li>类方法可以调用其他的类方法</li>\n<li>类方法中不能访问成员变量</li>\n<li>类方法中不能直接调用对象方法</li>\n</ol>\n<p>实例方法：</p>\n<ol>\n<li>实例方法是属于实例对象的</li>\n<li>实例方法只能通过实例对象调用</li>\n<li>实例方法中的self是实例对象</li>\n<li>实例方法中可以访问成员变量</li>\n<li>实例方法中直接调用实例方法</li>\n<li>实例方法中也可以调用类方法(通过类名)</li>\n</ol>\n<h2 id=\"下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁\"><a href=\"#下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁\" class=\"headerlink\" title=\"下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博@iOS程序犭袁\"></a>下一篇文章将发布在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a></h2><p>@property部分主要参考<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2\" target=\"_blank\" rel=\"external\">Apple官方文档：Properties Encapsulate an Object’s Values</a><br>runtime部分主要参考<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\" target=\"_blank\" rel=\"external\">Apple官方文档：Declared Properties</a></p>\n<h3 id=\"25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><h3 id=\"26-runtime如何实现weak变量的自动置nil？\"><a href=\"#26-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"26. runtime如何实现weak变量的自动置nil？\"></a>26. runtime如何实现weak变量的自动置nil？</h3><h3 id=\"27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><h3 id=\"28-runloop和线程有什么关系？\"><a href=\"#28-runloop和线程有什么关系？\" class=\"headerlink\" title=\"28. runloop和线程有什么关系？\"></a>28. runloop和线程有什么关系？</h3><h3 id=\"29-runloop的mode作用是什么？\"><a href=\"#29-runloop的mode作用是什么？\" class=\"headerlink\" title=\"29. runloop的mode作用是什么？\"></a>29. runloop的mode作用是什么？</h3><h3 id=\"30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><h3 id=\"31-猜想runloop内部是如何实现的？\"><a href=\"#31-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"31. 猜想runloop内部是如何实现的？\"></a>31. 猜想runloop内部是如何实现的？</h3><h3 id=\"32-objc使用什么机制管理对象内存？\"><a href=\"#32-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"32. objc使用什么机制管理对象内存？\"></a>32. objc使用什么机制管理对象内存？</h3><h3 id=\"33-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#33-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"33. ARC通过什么方式帮助开发者管理内存？\"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><h3 id=\"34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><h3 id=\"35-BAD-ACCESS在什么情况下出现？\"><a href=\"#35-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"35. BAD_ACCESS在什么情况下出现？\"></a>35. <code>BAD_ACCESS</code>在什么情况下出现？</h3><h3 id=\"36-苹果是如何实现autoreleasepool的？\"><a href=\"#36-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"36. 苹果是如何实现autoreleasepool的？\"></a>36. 苹果是如何实现autoreleasepool的？</h3><h3 id=\"37-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#37-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"37. 使用block时什么情况会发生引用循环，如何解决？\"></a>37. 使用block时什么情况会发生引用循环，如何解决？</h3><h3 id=\"38-在block内如何修改block外部变量？\"><a href=\"#38-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"38. 在block内如何修改block外部变量？\"></a>38. 在block内如何修改block外部变量？</h3><h3 id=\"39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><h3 id=\"40-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#40-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"40. GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3><h3 id=\"41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><h3 id=\"42-dispatch-barrier-async的作用是什么？\"><a href=\"#42-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"42. dispatch_barrier_async的作用是什么？\"></a>42. <code>dispatch_barrier_async</code>的作用是什么？</h3><h3 id=\"43-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#43-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"43. 苹果为什么要废弃dispatch_get_current_queue？\"></a>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3><h3 id=\"44-以下代码运行结果如何？\"><a href=\"#44-以下代码运行结果如何？\" class=\"headerlink\" title=\"44. 以下代码运行结果如何？\"></a>44. 以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><h3 id=\"45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><h3 id=\"46-如何手动触发一个value的KVO\"><a href=\"#46-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"46. 如何手动触发一个value的KVO\"></a>46. 如何手动触发一个value的KVO</h3><h3 id=\"47-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\"><a href=\"#47-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\" class=\"headerlink\" title=\"47. 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\"></a>47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</h3><h3 id=\"48-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#48-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"48. KVC的keyPath中的集合运算符如何使用？\"></a>48. KVC的keyPath中的集合运算符如何使用？</h3><h3 id=\"49-KVC和KVO的keyPath一定是属性么？\"><a href=\"#49-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"49. KVC和KVO的keyPath一定是属性么？\"></a>49. KVC和KVO的keyPath一定是属性么？</h3><h3 id=\"50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><h3 id=\"51-apple用什么方式实现对一个对象的KVO？\"><a href=\"#51-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"51. apple用什么方式实现对一个对象的KVO？\"></a>51. apple用什么方式实现对一个对象的KVO？</h3><h3 id=\"52-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#52-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"52. IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><h3 id=\"53-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#53-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"53. IB中User Defined Runtime Attributes如何使用？\"></a>53. IB中User Defined Runtime Attributes如何使用？</h3><h3 id=\"54-如何调试BAD-ACCESS错误\"><a href=\"#54-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"54. 如何调试BAD_ACCESS错误\"></a>54. 如何调试<code>BAD_ACCESS</code>错误</h3><h3 id=\"55-lldb（gdb）常用的调试命令？\"><a href=\"#55-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"55. lldb（gdb）常用的调试命令？\"></a>55. lldb（gdb）常用的调试命令？</h3><hr>\n<p>Posted by <a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" target=\"_blank\" rel=\"external\">Creative Commons BY-NC-ND 3.0</a></p>\n","site":{"data":{"gallery":{"她":{"full_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","thumb_link":"http://os3okv9i4.bkt.clouddn.com/girlFriend.png","descr":""}}}},"excerpt":"","more":"<p><a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>\n<p>说明：面试题来源是<a href=\"http://weibo.com/u/1364395395\" target=\"_blank\" rel=\"external\">微博@我就叫Sunny怎么了</a>的这篇博文：<a href=\"http://blog.sunnyxx.com/2015/07/04/ios-interview/\" target=\"_blank\" rel=\"external\">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>\n<p>作者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>\n<p>答案为<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a>指正。</p>\n<hr>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><ol>\n<li><p><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-风格纠错题\" target=\"_blank\" rel=\"external\">风格纠错题</a> </p>\n<ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#优化部分\" target=\"_blank\" rel=\"external\">优化部分</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#硬伤部分\" target=\"_blank\" rel=\"external\">硬伤部分</a> </li>\n</ol>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2-什么情况使用-weak-关键字相比-assign-有什么不同\" target=\"_blank\" rel=\"external\">什么情况使用 weak 关键字，相比 assign 有什么不同？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字\" target=\"_blank\" rel=\"external\">怎么用 copy 关键字？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#4-这个写法会出什么问题-property-copy-nsmutablearray-array\" target=\"_blank\" rel=\"external\">这个写法会出什么问题： @property (copy) NSMutableArray *array;</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#5-如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter\" target=\"_blank\" rel=\"external\"> 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#6-property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的\" target=\"_blank\" rel=\"external\">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#7-protocol-和-category-中如何使用-property\" target=\"_blank\" rel=\"external\">@protocol 和 category 中如何使用 @property</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#8-runtime-如何实现-weak-属性\" target=\"_blank\" rel=\"external\"> runtime 如何实现 weak 属性</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#9-property中有哪些属性关键字-property-后面可以有哪些修饰符\" target=\"_blank\" rel=\"external\">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#10-weak属性需要在dealloc中置nil么\" target=\"_blank\" rel=\"external\"> weak属性需要在dealloc中置nil么？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#11-synthesize和dynamic分别有什么作用\" target=\"_blank\" rel=\"external\">@synthesize和@dynamic分别有什么作用？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#12-arc下不显式指定任何属性关键字时默认的关键字都有哪些\" target=\"_blank\" rel=\"external\">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题\" target=\"_blank\" rel=\"external\">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</a> <ol>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-对非集合类对象的copy操作\" target=\"_blank\" rel=\"external\">对非集合类对象的copy操作</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2集合类对象的copy与mutablecopy\" target=\"_blank\" rel=\"external\">集合类对象的copy与mutableCopy</a> </li>\n</ol>\n</li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么\" target=\"_blank\" rel=\"external\">@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景\" target=\"_blank\" rel=\"external\">在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#16-objc中向一个nil对象发送消息将会发生什么\" target=\"_blank\" rel=\"external\">objc中向一个nil对象发送消息将会发生什么？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#17-objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系\" target=\"_blank\" rel=\"external\">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#18-什么时候会报unrecognized-selector的异常\" target=\"_blank\" rel=\"external\">什么时候会报unrecognized selector的异常？</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#19-一个objc对象如何进行内存布局考虑有父类的情况\" target=\"_blank\" rel=\"external\">一个objc对象如何进行内存布局？（考虑有父类的情况）</a> </li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#20-一个objc对象的isa的指针指向什么有什么作用\" target=\"_blank\" rel=\"external\">一个objc对象的isa的指针指向什么？有什么作用？</a></li>\n<li><a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么\" target=\"_blank\" rel=\"external\">下面的代码输出什么？</a> </li>\n</ol>\n<pre><code class=\"objectivec\">    @implementation Son : Father\n    - (id)init\n    {\n        self = [super init];\n        if (self) {\n            NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));\n            NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));\n        }\n        return self;\n    }\n    @end\n</code></pre>\n<ol>\n<li>22–55题，请看下篇。</li>\n</ol>\n<h3 id=\"1-风格纠错题\"><a href=\"#1-风格纠错题\" class=\"headerlink\" title=\"1. 风格纠错题\"></a>1. 风格纠错题</h3><p><img src=\"http://i.imgur.com/O7Zev94.png\" alt=\"enter image description here\"><br>修改完的代码：</p>\n<p>修改方法有很多种，现给出一种做示例：</p>\n<pre><code class=\"objectivec\">// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject&lt;NSCopying&gt;\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n@end\n</code></pre>\n<p>下面对具体修改的地方，分两部分做下介绍：<strong>硬伤部分</strong> 和 <strong>优化部分</strong><br>。因为<strong>硬伤部分</strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong>优化部分</strong>。</p>\n<h4 id=\"优化部分\"><a href=\"#优化部分\" class=\"headerlink\" title=\"优化部分\"></a><strong>优化部分</strong></h4><ol>\n<li>enum 建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href=\"https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html\" target=\"_blank\" rel=\"external\">Adopting Modern Objective-C</a> 一文：</li>\n</ol>\n<pre><code class=\"objectivec\">//定义一个枚举\n    typedef NS_ENUM(NSInteger, CYLSex) {\n        CYLSexMan,\n        CYLSexWoman\n    };\n</code></pre>\n<p> （仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 <a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/issues/9\" target=\"_blank\" rel=\"external\">这里</a> 。）</p>\n<ol>\n<li><p>age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：</p>\n<pre><code class=\"objectivec\">int -&gt; NSInteger\nunsigned -&gt; NSUInteger\nfloat -&gt; CGFloat\n动画时间 -&gt; NSTimeInterval\n</code></pre>\n<p>同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。<br>这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href=\"http://blog.sunnyxx.com/2014/12/20/64-bit-tips/\" target=\"_blank\" rel=\"external\">《64-bit Tips》</a>。</p>\n</li>\n</ol>\n<ol>\n<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>\n<li>doLogIn方法不应写在该类中： <p><del>虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： <a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>\n</ol>\n<blockquote>\n<p>无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。</p>\n</blockquote>\n<p> （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： <code>-logIn</code> 对应的应当是注册并登录的一个 Button ，出现 <code>-logIn</code> 方法也可能是合理的。）</p>\n<ol>\n<li><p>doLogIn 方法命名不规范：添加了多余的动词前缀。<br>请牢记：</p>\n<blockquote>\n<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 <code>do</code>，<code>does</code> 这种多余的关键字，动词本身的暗示就足够了。</p>\n</blockquote>\n<p>应为 <code>-logIn</code> （注意： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆。  见<a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</p>\n</li>\n<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用 <code>with</code> 来连接两个参数: <code>withAge:</code> 应当换为<code>age:</code>，<code>age:</code> 已经足以清晰说明参数的作用，也不建议用 <code>andAge:</code> ：通常情况下，即使有类似 <code>withA:withB:</code> 的命名需求，也通常是使用<code>withA:andB:</code> 这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p>\n<pre><code class=\"objectivec\">//错误，不要使用&quot;and&quot;来连接参数\n- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;\n//错误，不要使用&quot;and&quot;来阐明有多个参数\n- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;\n//正确，使用&quot;and&quot;来表示两个相对独立的操作\n- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;\n</code></pre>\n</li>\n<li><p>由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？</em></strong>)</p>\n</li>\n<li><p>“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</p>\n<p>Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：</p>\n</li>\n</ol>\n<pre><code class=\"objectivec\">\n    // .m文件\n    // http://weibo.com/luohanchenyilong/\n    // https://github.com/ChenYilong\n    //\n\n    @implementation CYLUser\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age\n                             sex:(CYLSex)sex {\n        if(self = [super init]) {\n            _name = [name copy];\n            _age = age;\n            _sex = sex;\n        }\n        return self;\n    }\n\n    - (instancetype)initWithName:(NSString *)name\n                             age:(NSUInteger)age {\n        return [self initWithName:name age:age sex:nil];\n    }\n\n    @end\n</code></pre>\n<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>\n<p>  因为出题者没有给出 <code>.m</code> 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：</p>\n<pre><code class=\"objectivec\">\n\n    // .h文件\n    // http://weibo.com/luohanchenyilong/\n    // https://github.com/ChenYilong\n    // 第二种修改方法（基于第一种修改方法的基础上）\n\n    typedef NS_ENUM(NSInteger, CYLSex) {\n        CYLSexMan,\n        CYLSexWoman\n    };\n\n    @interface CYLUser : NSObject&lt;NSCopying&gt;\n\n    @property (nonatomic, readonly, copy) NSString *name;\n    @property (nonatomic, readonly, assign) NSUInteger age;\n    @property (nonatomic, readwrite, assign) CYLSex sex;\n\n    - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n    - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;\n    + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n    @end\n</code></pre>\n<p>  <code>.h</code> 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳–》 <a href=\"http://is.gd/OQ49zk\" target=\"_blank\" rel=\"external\"><strong><em>《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》</em></strong></a>。）</p>\n<ul>\n<li>按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。</li>\n<li>如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:<br>那么在设计对应 <code>@property</code> 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样</li>\n</ul>\n<pre><code class=\"objectivec\">        @property (nonatomic, readonly, copy) NSString *name;\n        @property (nonatomic, readonly, assign) NSUInteger age;\n        @property (nonatomic, readonly, assign) CYLSex sex;\n</code></pre>\n<pre><code>  由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。\n</code></pre><ol>\n<li><code>initUserModelWithUserName</code> 如果改为 <code>initWithName</code> 会更加简洁，而且足够清晰。</li>\n<li><code>UserModel</code> 如果改为 <code>User</code> 会更加简洁，而且足够清晰。</li>\n<li><code>UserSex</code>如果改为<code>Sex</code> 会更加简洁，而且足够清晰。</li>\n<li><p>第二个 <code>@property</code> 中 assign 和 nonatomic 调换位置。<br>推荐按照下面的格式来定义属性</p>\n<pre><code class=\"objectivec\">@property (nonatomic, readwrite, copy) NSString *name;\n</code></pre>\n<p>属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在<a href=\"https://github.com/oa414/objc-zen-book-cn#属性定义\" target=\"_blank\" rel=\"external\">《禅与Objective-C编程艺术 &gt;》</a>里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。</p>\n</li>\n</ol>\n<h4 id=\"硬伤部分\"><a href=\"#硬伤部分\" class=\"headerlink\" title=\"硬伤部分\"></a><strong><em>硬伤部分</em></strong></h4><ol>\n<li>在-和(void)之间应该有一个空格</li>\n<li>enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。</li>\n<li>enum 左括号前加一个空格，或者将左括号换到下一行</li>\n<li>enum 右括号后加一个空格</li>\n<li><code>UserModel :NSObject</code> 应为<code>UserModel : NSObject</code>，也就是<code>:</code>右侧少了一个空格。</li>\n<li><code>@interface</code> 与 <code>@property</code> 属性声明中间应当间隔一行。</li>\n<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中方法名与参数之间多了空格。而且 <code>-</code> 与 <code>(id)</code> 之间少了空格。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中方法名与参数之间多了空格：<code>(NSString*)name</code> 前多了空格。</li>\n<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中 <code>(NSString*)name</code>,应为 <code>(NSString *)name</code>，少了空格。 </li>\n<li><p><del>doLogIn方法中的 <code>LogIn</code> 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。<br>（勘误： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆的意思。见： <a href=\"http://grammarist.com/spelling/log-in-login/\" target=\"_blank\" rel=\"external\"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>\n\n</li>\n</ol>\n<h3 id=\"2-什么情况使用-weak-关键字，相比-assign-有什么不同？\"><a href=\"#2-什么情况使用-weak-关键字，相比-assign-有什么不同？\" class=\"headerlink\" title=\"2. 什么情况使用 weak 关键字，相比 assign 有什么不同？\"></a>2. 什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><p>什么情况使用 weak 关键字？</p>\n<ol>\n<li><p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</p>\n</li>\n<li><p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></p>\n</li>\n</ol>\n<p>不同点：</p>\n<ol>\n<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，<br>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。<br>而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或<br>NSlnteger 等)的简单赋值操作。</p>\n</li>\n<li><p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p>\n</li>\n</ol>\n<h3 id=\"3-怎么用-copy-关键字？\"><a href=\"#3-怎么用-copy-关键字？\" class=\"headerlink\" title=\"3. 怎么用 copy 关键字？\"></a>3. 怎么用 copy 关键字？</h3><p>用途：</p>\n<ol>\n<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>\n<li><p>block 也经常使用 copy 关键字，具体原因见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12\" target=\"_blank\" rel=\"external\">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</p>\n<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p>\n</li>\n</ol>\n<pre><code class=\"objectivec\"> @property (nonatomic, copy) NSString *userId;\n\n - (instancetype)initWithUserId:(NSString *)userId {\n    self = [super init];\n    if (!self) {\n        return nil;\n    }\n    _userId = [userId copy];\n    return self;\n }\n</code></pre>\n<p> <img src=\"http://i.imgur.com/VlVKl8L.png\" alt=\"enter image description here\"></p>\n<p>下面做下解释：<br> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>\n<blockquote>\n<p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<p>该问题在下文中也有论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong></p>\n<h3 id=\"4-这个写法会出什么问题：-property-copy-NSMutableArray-array\"><a href=\"#4-这个写法会出什么问题：-property-copy-NSMutableArray-array\" class=\"headerlink\" title=\"4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;\"></a>4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code></h3><p>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； </p>\n<p>第1条的相关原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>\n<p>比如下面的代码就会发生崩溃</p>\n<pre><code class=\"objectivec\">// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\n@property (nonatomic, copy) NSMutableArray *mutableArray;\n</code></pre>\n<pre><code class=\"objectivec\">// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 下面的代码就会发生崩溃\n\nNSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];\nself.mutableArray = array;\n[self.mutableArray removeObjectAtIndex:0];\n</code></pre>\n<p>接下来就会奔溃：</p>\n<pre><code class=\"objectivec\"> -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460\n</code></pre>\n<p>第2条原因，如下：</p>\n<blockquote>\n<p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p>\n</blockquote>\n<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>\n<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>\n<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>\n<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用<br> atomic 属性通常都不会有性能瓶颈。</p>\n<h3 id=\"5-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\"><a href=\"#5-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？\" class=\"headerlink\" title=\"5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？\"></a>5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><blockquote>\n<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p>\n</blockquote>\n<p>具体步骤：</p>\n<ol>\n<li>需声明该类遵从 NSCopying 协议</li>\n<li><p>实现 NSCopying 协议。该协议只有一个方法: </p>\n<pre><code class=\"objectivec\">- (id)copyWithZone:(NSZone *)zone;\n</code></pre>\n<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>\n</li>\n</ol>\n<p>以第一题的代码为例：</p>\n<pre><code class=\"objectivec\">    // .h文件\n    // http://weibo.com/luohanchenyilong/\n    // https://github.com/ChenYilong\n    // 修改完的代码\n\n    typedef NS_ENUM(NSInteger, CYLSex) {\n        CYLSexMan,\n        CYLSexWoman\n    };\n\n    @interface CYLUser : NSObject&lt;NSCopying&gt;\n\n    @property (nonatomic, readonly, copy) NSString *name;\n    @property (nonatomic, readonly, assign) NSUInteger age;\n    @property (nonatomic, readonly, assign) CYLSex sex;\n\n    - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n    + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n\n    @end\n</code></pre>\n<p>然后实现协议中规定的方法：</p>\n<pre><code class=\"objectivec\">- (id)copyWithZone:(NSZone *)zone {\n    CYLUser *copy = [[[self class] allocWithZone:zone] \n                     initWithName:_name\n                                   age:_age\n                                  sex:_sex];\n    return copy;\n}\n</code></pre>\n<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>\n<pre><code class=\"objectivec\">// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 以第一题《风格纠错题》里的代码为例\n\ntypedef NS_ENUM(NSInteger, CYLSex) {\n    CYLSexMan,\n    CYLSexWoman\n};\n\n@interface CYLUser : NSObject&lt;NSCopying&gt;\n\n@property (nonatomic, readonly, copy) NSString *name;\n@property (nonatomic, readonly, assign) NSUInteger age;\n@property (nonatomic, readonly, assign) CYLSex sex;\n\n- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;\n- (void)addFriend:(CYLUser *)user;\n- (void)removeFriend:(CYLUser *)user;\n\n@end\n</code></pre>\n<p>// .m文件</p>\n<pre><code class=\"objectivec\">// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n//\n\n@implementation CYLUser {\n    NSMutableSet *_friends;\n}\n\n- (void)setName:(NSString *)name {\n    _name = [name copy];\n}\n\n- (instancetype)initWithName:(NSString *)name\n                         age:(NSUInteger)age\n                         sex:(CYLSex)sex {\n    if(self = [super init]) {\n        _name = [name copy];\n        _age = age;\n        _sex = sex;\n        _friends = [[NSMutableSet alloc] init];\n    }\n    return self;\n}\n\n- (void)addFriend:(CYLUser *)user {\n    [_friends addObject:user];\n}\n\n- (void)removeFriend:(CYLUser *)user {\n    [_friends removeObject:user];\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n    CYLUser *copy = [[[self class] allocWithZone:zone]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy-&gt;_friends = [_friends mutableCopy];\n    return copy;\n}\n\n- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n\n@end\n</code></pre>\n<p>以上做法能满足基本的需求，但是也有缺陷：</p>\n<blockquote>\n<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>\n</blockquote>\n<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>\n<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>\n<pre><code class=\"objectivec\">- (id)deepCopy {\n    CYLUser *copy = [[[self class] alloc]\n                     initWithName:_name\n                     age:_age\n                     sex:_sex];\n    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends\n                                             copyItems:YES];\n    return copy;\n}\n</code></pre>\n<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>\n<p>如果抛开本例来回答的话，如下：</p>\n<pre><code class=\"objectivec\">- (void)setName:(NSString *)name {\n    //[_name release];\n    _name = [name copy];\n}\n</code></pre>\n<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>\n<pre><code class=\"objectivec\">- (void)setName:(NSString *)name {\n    if (_name != name) {\n        //[_name release];//MRC\n        _name = [name copy];\n    }\n}\n</code></pre>\n<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>\n<p><img src=\"http://i.imgur.com/UwV9oSn.jpeg\" alt=\"enter image description here\"></p>\n<p>克强总理这样评价你的代码风格：</p>\n<p><img src=\"http://i.imgur.com/N77Lkic.png\" alt=\"enter image description here\"></p>\n<p>我和总理的意见基本一致：</p>\n<blockquote>\n<p>老百姓 copy 一下，咋就这么难？</p>\n</blockquote>\n<p>你可能会说：</p>\n<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。<br>(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>\n<p>但是你有没有考虑过代价：</p>\n<blockquote>\n<p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p>\n</blockquote>\n<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>\n<pre><code class=\"objectivec\">[a setX:x1];\n[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？\n</code></pre>\n<p>或者</p>\n<pre><code class=\"objectivec\">[a setX:[a x]];   //队友咆哮道：你在干嘛？！！\n</code></pre>\n<blockquote>\n<p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href=\"http://vgable.com/blog/tag/autorelease/\" target=\"_blank\" rel=\"external\"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a><br>）</p>\n</blockquote>\n<p>什么情况会在 copy setter 里做 if 判断？<br>例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>\n<pre><code class=\"objectivec\">-(void)setSpeed:(int)_speed{\n    if(_speed &lt; 0) speed = 0;\n    if(_speed &gt; 300) speed = 300;\n    _speed = speed;\n}\n</code></pre>\n<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>\n<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>\n<pre><code class=\"objectivec\">    - (instancetype)initWithName:(NSString *)name \n                                 age:(NSUInteger)age \n                                 sex:(CYLSex)sex {\n         if(self = [super init]) {\n             _name = [name copy];\n             _age = age;\n             _sex = sex;\n             _friends = [[NSMutableSet alloc] init];\n         }\n         return self;\n    }\n</code></pre>\n<h3 id=\"6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\"><a href=\"#6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的\" class=\"headerlink\" title=\"6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的\"></a>6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><p><strong>@property 的本质是什么？</strong></p>\n<blockquote>\n<p>@property = ivar + getter + setter;</p>\n</blockquote>\n<p>下面解释下：</p>\n<blockquote>\n<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>\n</blockquote>\n<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>Objective-C 2.0</code> 的一部分。<br>而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。<br>正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>\n<blockquote>\n<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。<br>所以你也可以这么说：</p>\n<p>@property = getter + setter;</p>\n</blockquote>\n<p>例如下面这个类：</p>\n<pre><code class=\"objectivec\">@interface Person : NSObject\n@property NSString *firstName;\n@property NSString *lastName;\n@end\n</code></pre>\n<p>上述代码写出来的类与下面这种写法等效：</p>\n<pre><code class=\"objectivec\">@interface Person : NSObject\n- (NSString *)firstName;\n- (void)setFirstName:(NSString *)firstName;\n- (NSString *)lastName;\n- (void)setLastName:(NSString *)lastName;\n@end\n</code></pre>\n<p><strong>更新</strong>：</p>\n<p>property在runtime中是<code>objc_property_t</code>定义如下:</p>\n<pre><code class=\"objectivec\">typedef struct objc_property *objc_property_t;\n</code></pre>\n<p>而<code>objc_property</code>是一个结构体，包括name和attributes，定义如下：</p>\n<pre><code class=\"objectivec\">struct property_t {\n    const char *name;\n    const char *attributes;\n};\n</code></pre>\n<p>而attributes本质是<code>objc_property_attribute_t</code>，定义了property的一些属性，定义如下：</p>\n<pre><code class=\"objectivec\">/// Defines a property attribute\ntypedef struct {\n    const char *name;           /**&lt; The name of the attribute */\n    const char *value;          /**&lt; The value of the attribute (usually empty) */\n} objc_property_attribute_t;\n</code></pre>\n<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>\n<p>例如：我们定义一个string的property<code>@property (nonatomic, copy) NSString *string;</code>，通过 <code>property_getAttributes(property)</code>获取到attributes并打印出来之后的结果为<code>T@&quot;NSString&quot;,C,N,V_string</code></p>\n<p>其中T就代表类型，可参阅<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1\" target=\"_blank\" rel=\"external\">Type Encodings</a>，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p>\n<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>\n<blockquote>\n<p>“自动合成”( autosynthesis)</p>\n</blockquote>\n<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译<br>器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过<br> <code>@synthesize</code> 语法来指定实例变量的名字.</p>\n<pre><code class=\"objectivec\">@implementation Person\n@synthesize firstName = _myFirstName;\n@synthesize lastName = _myLastName;\n@end\n</code></pre>\n<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>\n<ol>\n<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>\n<li>setter 与 getter 方法对应的实现函数</li>\n<li><code>ivar_list</code> ：成员变量列表</li>\n<li><code>method_list</code> ：方法列表</li>\n<li><code>prop_list</code> ：属性列表</li>\n</ol>\n<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>\n<h3 id=\"7-protocol-和-category-中如何使用-property\"><a href=\"#7-protocol-和-category-中如何使用-property\" class=\"headerlink\" title=\"7. @protocol 和 category 中如何使用 @property\"></a>7. @protocol 和 category 中如何使用 @property</h3><ol>\n<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>\n<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p>\n<ol>\n<li><code>objc_setAssociatedObject</code></li>\n<li><code>objc_getAssociatedObject</code></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"8-runtime-如何实现-weak-属性\"><a href=\"#8-runtime-如何实现-weak-属性\" class=\"headerlink\" title=\"8. runtime 如何实现 weak 属性\"></a>8. runtime 如何实现 weak 属性</h3><p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>\n<blockquote>\n<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>\n</blockquote>\n<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>\n<blockquote>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n</blockquote>\n<p>（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>\n<p>先看下 runtime 里源码的实现：</p>\n<pre><code class=\"objectivec\">/**\n * The internal structure stored in the weak references table. \n * It maintains and stores\n * a hash set of weak references pointing to an object.\n * If out_of_line==0, the set is instead a small inline array.\n */\n#define WEAK_INLINE_COUNT 4\nstruct weak_entry_t {\n    DisguisedPtr&lt;objc_object&gt; referent;\n    union {\n        struct {\n            weak_referrer_t *referrers;\n            uintptr_t        out_of_line : 1;\n            uintptr_t        num_refs : PTR_MINUS_1;\n            uintptr_t        mask;\n            uintptr_t        max_hash_displacement;\n        };\n        struct {\n            // out_of_line=0 is LSB of one of these (don&#39;t care which)\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        };\n    };\n};\n\n/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */\nstruct weak_table_t {\n    weak_entry_t *weak_entries;\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\n</code></pre>\n<p>具体完整实现参照 <a href=\"https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h\" target=\"_blank\" rel=\"external\">objc/objc-weak.h</a> 。</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>\n<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>\n<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由 assign 修饰的，则：<br>在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。</p>\n<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<pre><code class=\"objectivec\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\n id obj1;\n objc_initWeak(&amp;obj1, obj);\n/*obj引用计数变为0，变量作用域结束*/\n objc_destroyWeak(&amp;obj1);\n</code></pre>\n<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>\n<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<pre><code class=\"objectivec\">obj1 = 0；\nobj_storeWeak(&amp;obj1, obj);\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>\n</blockquote>\n<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>\n<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>\n<p>前面的源代码与下列源代码相同。</p>\n<pre><code class=\"objectivec\">// 使用伪代码模拟：runtime如何实现weak属性\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nid obj1;\nobj1 = 0;\nobjc_storeWeak(&amp;obj1, obj);\n/* ... obj的引用计数变为0，被置nil ... */\nobjc_storeWeak(&amp;obj1, 0);\n</code></pre>\n<p><code>objc_storeWeak</code> 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。</p>\n<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>\n<blockquote>\n<p>如何让不使用weak修饰的@property，拥有weak的效果。</p>\n</blockquote>\n<p>我们从setter方法入手：</p>\n<p>（注意以下的 <code>cyl_runAtDealloc</code> 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> ）</p>\n<pre><code class=\"objectivec\">- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n</code></pre>\n<p>也就是有两个步骤：</p>\n<ol>\n<li>在setter方法中做如下设置：</li>\n</ol>\n<pre><code class=\"objectivec\">        objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);\n</code></pre>\n<ol>\n<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：</p>\n<pre><code class=\"objectivec\">//要销毁的目标对象\nid objectToBeDeallocated;\n//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。\nid objectWeWantToBeReleasedWhenThatHappens;\nobjc_setAssociatedObject(objectToBeDeallocted,\n                     someUniqueKey,\n                     objectWeWantToBeReleasedWhenThatHappens,\n                     OBJC_ASSOCIATION_RETAIN);\n</code></pre>\n</li>\n</ol>\n<p>知道了思路，我们就开始实现 <code>cyl_runAtDealloc</code> 方法，实现过程分两部分：</p>\n<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。</p>\n<p>// .h文件</p>\n<pre><code class=\"objectivec\">// .h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\ntypedef void (^voidBlock)(void);\n\n@interface CYLBlockExecutor : NSObject\n\n- (id)initWithBlock:(voidBlock)block;\n\n@end\n</code></pre>\n<p>// .m文件</p>\n<pre><code class=\"objectivec\">// .m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。\n\n#import &quot;CYLBlockExecutor.h&quot;\n\n@interface CYLBlockExecutor() {\n    voidBlock _block;\n}\n@implementation CYLBlockExecutor\n\n- (id)initWithBlock:(voidBlock)aBlock\n{\n    self = [super init];\n\n    if (self) {\n        _block = [aBlock copy];\n    }\n\n    return self;\n}\n\n- (void)dealloc\n{\n    _block ? _block() : nil;\n}\n\n@end\n</code></pre>\n<p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p>\n<pre><code class=\"objectivec\">// CYLNSObject+RunAtDealloc.h文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import &quot;CYLBlockExecutor.h&quot;\n\nconst void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;\n\n@interface NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block;\n\n@end\n\n\n// CYLNSObject+RunAtDealloc.m文件\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n// 利用runtime实现cyl_runAtDealloc方法\n\n#import &quot;CYLNSObject+RunAtDealloc.h&quot;\n#import &quot;CYLBlockExecutor.h&quot;\n\n@implementation NSObject (CYLRunAtDealloc)\n\n- (void)cyl_runAtDealloc:(voidBlock)block\n{\n    if (block) {\n        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];\n\n        objc_setAssociatedObject(self,\n                                 runAtDeallocBlockKey,\n                                 executor,\n                                 OBJC_ASSOCIATION_RETAIN);\n    }\n}\n\n@end\n</code></pre>\n<p>使用方法：<br>导入</p>\n<pre><code class=\"objectivec\">    #import &quot;CYLNSObject+RunAtDealloc.h&quot;\n</code></pre>\n<p>然后就可以使用了：</p>\n<pre><code class=\"objectivec\">NSObject *foo = [[NSObject alloc] init];\n\n[foo cyl_runAtDealloc:^{\n    NSLog(@&quot;正在释放foo!&quot;);\n}];\n</code></pre>\n<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> </p>\n<p>参考博文： <a href=\"http://stackoverflow.com/a/31560217/3395008\" target=\"_blank\" rel=\"external\"><strong><em>Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</em></strong></a></p>\n<h3 id=\"9-property中有哪些属性关键字？-property-后面可以有哪些修饰符？\"><a href=\"#9-property中有哪些属性关键字？-property-后面可以有哪些修饰符？\" class=\"headerlink\" title=\"9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？\"></a>9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3><p>属性可以拥有的特质分为四类:</p>\n<ol>\n<li><p>原子性— <code>nonatomic</code> 特质</p>\n<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>\n</li>\n<li><p>读/写权限—<code>readwrite(读写)</code>、<code>readonly (只读)</code></p>\n</li>\n<li>内存管理语义—<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>\n<li><p>方法名—<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></p>\n<p><code>getter=&lt;name&gt;</code>的样式：</p>\n</li>\n</ol>\n<pre><code class=\"objectivec\">        @property (nonatomic, getter=isOn) BOOL on;\n</code></pre>\n <p><del>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）<br></del></p>\n\n\n<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>\n<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>\n<p>这时你就可以使用下面的方式来避免编译器报错：</p>\n<pre><code class=\"objectivec\">@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;\n</code></pre>\n<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>\n<pre><code class=\"objectivec\">@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;\n- (NSString *)initBy __attribute__((objc_method_family(none)));\n</code></pre>\n<ol>\n<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>\n</ol>\n<p>注意：很多人会认为如果属性具备 nonatomic 特质，则不使用<br>“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：</p>\n<pre><code class=\"objectivec\">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t&amp; slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n{\n    bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);\n    bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n}\n</code></pre>\n<h3 id=\"10-weak属性需要在dealloc中置nil么？\"><a href=\"#10-weak属性需要在dealloc中置nil么？\" class=\"headerlink\" title=\"10. weak属性需要在dealloc中置nil么？\"></a>10. weak属性需要在dealloc中置nil么？</h3><p>不需要。</p>\n<blockquote>\n<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p>\n</blockquote>\n<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>\n<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>\n<p>我们模拟下 weak 的 setter 方法，应该如下：</p>\n<pre><code class=\"objectivec\">- (void)setObject:(NSObject *)object\n{\n    objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);\n    [object cyl_runAtDealloc:^{\n        _object = nil;\n    }];\n}\n</code></pre>\n<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： <a href=\"https://github.com/ChenYilong/CYLDeallocBlockExecutor\" target=\"_blank\" rel=\"external\">CYLDeallocBlockExecutor</a> </p>\n<p>也即:</p>\n<blockquote>\n<p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>\n</blockquote>\n<h3 id=\"11-synthesize和-dynamic分别有什么作用？\"><a href=\"#11-synthesize和-dynamic分别有什么作用？\" class=\"headerlink\" title=\"11. @synthesize和@dynamic分别有什么作用？\"></a>11. @synthesize和@dynamic分别有什么作用？</h3><ol>\n<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>\n<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>\n<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>\n</ol>\n<h3 id=\"12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"><a href=\"#12-ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\" class=\"headerlink\" title=\"12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？\"></a>12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><ol>\n<li><p>对应基本数据类型默认关键字是</p>\n<p>atomic,readwrite,assign</p>\n</li>\n<li><p>对于普通的 Objective-C 对象</p>\n<p>atomic,readwrite,strong</p>\n</li>\n</ol>\n<p>参考链接：</p>\n<ol>\n<li><p><a href=\"http://stackoverflow.com/a/15541801/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>Objective-C ARC: strong vs retain and weak vs assign</em></strong> </a></p>\n</li>\n<li><p><a href=\"http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html\" target=\"_blank\" rel=\"external\"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p>\n</li>\n</ol>\n<h3 id=\"13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"><a href=\"#13-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\" class=\"headerlink\" title=\"13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？\"></a>13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><ol>\n<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>\n<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>\n<p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>\n</li>\n</ol>\n<p>举例说明：</p>\n<p>定义一个以 strong 修饰的 array：</p>\n<pre><code class=\"objectivec\">@property (nonatomic ,readwrite, strong) NSArray *array;\n</code></pre>\n<p>然后进行下面的操作：</p>\n<pre><code class=\"objectivec\">    NSMutableArray *mutableArray = [[NSMutableArray alloc] init];\n    NSArray *array = @[ @1, @2, @3, @4 ];\n    self.array = mutableArray;\n    [mutableArray removeAllObjects];;\n    NSLog(@&quot;%@&quot;,self.array);\n\n    [mutableArray addObjectsFromArray:array];\n    self.array = [mutableArray copy];\n    [mutableArray removeAllObjects];;\n    NSLog(@&quot;%@&quot;,self.array);\n</code></pre>\n<p>打印结果如下所示：</p>\n<pre><code class=\"objectivec\">2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (\n)\n2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (\n    1,\n    2,\n    3,\n    4\n)\n</code></pre>\n<p>（详见仓库内附录的 Demo。）</p>\n<p>为了理解这种做法，首先要知道，两种情况：</p>\n<ol>\n<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>\n<li>对集合类对象的 copy 与 mutableCopy 操作。</li>\n</ol>\n<h4 id=\"1-对非集合类对象的copy操作：\"><a href=\"#1-对非集合类对象的copy操作：\" class=\"headerlink\" title=\"1. 对非集合类对象的copy操作：\"></a>1. 对非集合类对象的copy操作：</h4><p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>\n<ul>\n<li>[immutableObject copy] // 浅复制</li>\n<li>[immutableObject mutableCopy] //深复制</li>\n<li>[mutableObject copy] //深复制</li>\n<li>[mutableObject mutableCopy] //深复制</li>\n</ul>\n<p>比如以下代码：</p>\n<pre><code class=\"objectivec\">NSMutableString *string = [NSMutableString stringWithString:@&quot;origin&quot;];//copy\nNSString *stringCopy = [string copy];\n</code></pre>\n<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>\n<pre><code class=\"objectivec\">[string appendString:@&quot;origion!&quot;]\n</code></pre>\n<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。<br>  集合类对象以此类推。<br>所以，</p>\n<blockquote>\n<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>\n</blockquote>\n<h4 id=\"2、集合类对象的copy与mutableCopy\"><a href=\"#2、集合类对象的copy与mutableCopy\" class=\"headerlink\" title=\"2、集合类对象的copy与mutableCopy\"></a>2、集合类对象的copy与mutableCopy</h4><p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>\n<pre><code class=\"objectivec\">NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n</code></pre>\n<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>\n<pre><code class=\"objectivec\">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];\nNSArray *copyArray = [array copy];\nNSMutableArray *mCopyArray = [array mutableCopy];\n</code></pre>\n<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>\n<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>\n<pre><code class=\"objectivec\">[immutableObject copy] // 浅复制\n[immutableObject mutableCopy] //单层深复制\n[mutableObject copy] //单层深复制\n[mutableObject mutableCopy] //单层深复制\n</code></pre>\n<p>这个代码结论和非集合类的非常相似。</p>\n<p>参考链接：<a href=\"https://www.zybuluo.com/MicroCai/note/50592\" target=\"_blank\" rel=\"external\">iOS 集合的深复制与浅复制</a></p>\n<h3 id=\"14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\"><a href=\"#14-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？\" class=\"headerlink\" title=\"14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？\"></a>14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？</h3><p>在回答之前先说明下一个概念：</p>\n<blockquote>\n<p>实例变量 = 成员变量 ＝ ivar</p>\n</blockquote>\n<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>\n<p>正如<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6\" target=\"_blank\" rel=\"external\">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：<br><img src=\"http://i.imgur.com/D6d0zGJ.png\" alt=\"enter image description here\"></p>\n<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>\n<pre><code class=\"objectivec\">@interface CYLPerson : NSObject \n@property NSString *firstName; \n@property NSString *lastName; \n@end\n</code></pre>\n<p>在上例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>\n<pre><code class=\"objectivec\">@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end\n</code></pre>\n<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>\n<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>\n<ol>\n<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p>\n</li>\n<li><p>如果这个成员已经存在了就不再生成了.</p>\n</li>\n<li><p>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</p>\n<blockquote>\n<p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>\n</ol>\n<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？<br>不会。如下图：</p>\n<p><img src=\"http://i.imgur.com/t28ge4W.png\" alt=\"enter image description here\"></p>\n<h3 id=\"15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\"><a href=\"#15-在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？\" class=\"headerlink\" title=\"15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？\"></a>15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h3><p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>\n<ol>\n<li>同时重写了 setter 和 getter 时</li>\n<li>重写了只读属性的 getter 时</li>\n<li>使用了 @dynamic 时</li>\n<li>在 @protocol 中定义的所有属性</li>\n<li>在 category 中定义的所有属性</li>\n<li><p>重载的属性 </p>\n<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>\n</li>\n</ol>\n<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>\n<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>\n<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>\n<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>\n<pre><code class=\"objectivec\">@implementation CYLPerson \n@synthesize firstName = _myFirstName; \n@synthesize lastName = _myLastName; \n@end\n</code></pre>\n<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>\n<p>举例说明：应用场景：</p>\n<pre><code class=\"objectivec\">\n//\n// .m文件\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 打开第14行和第17行中任意一行，就可编译成功\n\n@import Foundation;\n\n@interface CYLObject : NSObject\n@property (nonatomic, copy) NSString *title;\n@end\n\n@implementation CYLObject {\n    //    NSString *_title;\n}\n\n//@synthesize title = _title;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _title = @&quot;微博@iOS程序犭袁&quot;;\n    }\n    return self;\n}\n\n- (NSString *)title {\n    return _title;\n}\n\n- (void)setTitle:(NSString *)title {\n    _title = [title copy];\n}\n\n@end\n</code></pre>\n<p>结果编译器报错：<br><img src=\"http://i.imgur.com/fAEGHIo.png\" alt=\"enter image description here\"></p>\n<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>\n<ol>\n<li>要么如第14行：手动创建 ivar</li>\n<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>\n</ol>\n<p>更多信息，请戳- 》<a href=\"http://stackoverflow.com/a/19821816/3395008\" target=\"_blank\" rel=\"external\"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>\n<h3 id=\"16-objc中向一个nil对象发送消息将会发生什么？\"><a href=\"#16-objc中向一个nil对象发送消息将会发生什么？\" class=\"headerlink\" title=\"16. objc中向一个nil对象发送消息将会发生什么？\"></a>16. objc中向一个nil对象发送消息将会发生什么？</h3><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>\n<ol>\n<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  </li>\n</ol>\n<pre><code class=\"objectivec\">Person * motherInlaw = [[aPerson spouse] mother];\n</code></pre>\n<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。</p>\n<ol>\n<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。</li>\n<li>如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。</li>\n<li>如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</li>\n</ol>\n<p>具体原因如下：</p>\n<blockquote>\n<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>\n</blockquote>\n<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>\n<pre><code class=\"objectivec\">// runtime.h（类在runtime中的定义）\n// http://weibo.com/luohanchenyilong/\n// https://github.com/ChenYilong\n\nstruct objc_class {\n  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object\n  #if !__OBJC2__\n  Class super_class OBJC2_UNAVAILABLE; // 父类\n  const char *name OBJC2_UNAVAILABLE; // 类名\n  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0\n  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识\n  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小\n  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表\n  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表\n  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。\n  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表\n  #endif\n  } OBJC2_UNAVAILABLE;\n</code></pre>\n<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。<br>那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>\n<h3 id=\"17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\"><a href=\"#17-objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？\" class=\"headerlink\" title=\"17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？\"></a>17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？</h3><p>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>\n<p>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>\n<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>\n<pre><code class=\"objectivec\">//\n//  main.m\n//  http://weibo.com/luohanchenyilong/\n//  https://github.com/ChenYilong\n//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.\n//\n\n\n#import &quot;CYLTest.h&quot;\n\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        CYLTest *test = [[CYLTest alloc] init];\n        [test performSelector:(@selector(iOSinit))];\n        return 0;\n    }\n}\n</code></pre>\n<p>在终端中输入</p>\n<pre><code class=\"objectivec\">clang -rewrite-objc main.m\n</code></pre>\n<p>就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>\n<p><img src=\"http://i.imgur.com/eAH5YWn.png\" alt=\"enter image description here\"></p>\n<p>我们可以看到大概是这样的：</p>\n<pre><code class=\"objectivec\">((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(&quot;foo&quot;));\n</code></pre>\n<p>也就是说：</p>\n<blockquote>\n<p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p>\n</blockquote>\n<h3 id=\"18-什么时候会报unrecognized-selector的异常？\"><a href=\"#18-什么时候会报unrecognized-selector的异常？\" class=\"headerlink\" title=\"18. 什么时候会报unrecognized selector的异常？\"></a>18. 什么时候会报unrecognized selector的异常？</h3><p>简单来说：</p>\n<blockquote>\n<p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，<br>可以通过“消息转发”进行解决。</p>\n</blockquote>\n<p>简单的流程如下，在上一题中也提到过：</p>\n<blockquote>\n<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>\n</blockquote>\n<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>\n<ol>\n<li><p>Method resolution</p>\n<p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>\n</li>\n<li><p>Fast forwarding</p>\n<p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。<br>只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。<br>这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>\n</li>\n<li><p>Normal forwarding</p>\n<p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>\n</li>\n</ol>\n<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>\n<h3 id=\"19-一个objc对象如何进行内存布局？（考虑有父类的情况）\"><a href=\"#19-一个objc对象如何进行内存布局？（考虑有父类的情况）\" class=\"headerlink\" title=\"19. 一个objc对象如何进行内存布局？（考虑有父类的情况）\"></a>19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</h3><ul>\n<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>\n<li>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</li>\n</ul>\n<ol>\n<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>\n<li>成员变量的列表,</li>\n<li><p>属性列表,</p>\n<p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>\n</li>\n</ol>\n<p>每个 Objective-C 对象都有相同的结构，如下图所示：</p>\n<p> <img src=\"http://i.imgur.com/7mJlUj1.png\" alt=\"enter image description here\"></p>\n<p>翻译过来就是</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Objective-C 对象的结构图</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> ISA指针</td>\n<td></td>\n</tr>\n<tr>\n<td> 根类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> 倒数第二层父类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> …</td>\n<td></td>\n</tr>\n<tr>\n<td> 父类的实例变量</td>\n<td></td>\n</tr>\n<tr>\n<td> 类的实例变量</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>根对象就是NSObject，它的superclass指针指向nil</p>\n</li>\n<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p>\n</li>\n</ul>\n<p>如图:<br><img src=\"http://i.imgur.com/w6tzFxz.png\" alt=\"enter image description here\"></p>\n<h3 id=\"20-一个objc对象的isa的指针指向什么？有什么作用？\"><a href=\"#20-一个objc对象的isa的指针指向什么？有什么作用？\" class=\"headerlink\" title=\"20. 一个objc对象的isa的指针指向什么？有什么作用？\"></a>20. 一个objc对象的isa的指针指向什么？有什么作用？</h3><p>指向他的类对象,从而可以找到对象上的方法</p>\n<h3 id=\"21-下面的代码输出什么？\"><a href=\"#21-下面的代码输出什么？\" class=\"headerlink\" title=\"21. 下面的代码输出什么？\"></a>21. 下面的代码输出什么？</h3><pre><code class=\"objectivec\">    @implementation Son : Father\n    - (id)init\n    {\n        self = [super init];\n        if (self) {\n            NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));\n            NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));\n        }\n        return self;\n    }\n    @end\n</code></pre>\n<p><strong>答案：</strong></p>\n<p>都输出 Son</p>\n<pre><code>NSStringFromClass([self class]) = Son\nNSStringFromClass([super class]) = Son\n</code></pre><p>这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。</p>\n<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>\n<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>\n<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>\n<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>\n<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>\n<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>\n<pre><code class=\"objectivec\">//\n//  ChenPerson.m\n//  \n//\n//  Created by https://github.com/ChenYilong on 15/8/30.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//\n\n#import &quot;ChenPerson.h&quot;\n\n@implementation ChenPerson\n\n@synthesize lastName = _lastName;\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([super class]));\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    //设置方法一：如果setter采用是这种方式，就可能引起崩溃\n//    if (![lastName isEqualToString:@&quot;陈&quot;])\n//    {\n//        [NSException raise:NSInvalidArgumentException format:@&quot;姓不是陈&quot;];\n//    }\n//    _lastName = lastName;\n\n    //设置方法二：如果setter采用是这种方式，就可能引起崩溃\n    _lastName = @&quot;陈&quot;;\n    NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;会调用这个方法,想一下为什么？&quot;);\n\n}\n\n@end\n</code></pre>\n<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>\n<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>\n<p>如果基类的代码是这样的：</p>\n<pre><code class=\"objectivec\">//\n//  Person.m\n//  nil对象调用点语法\n//\n//  Created by https://github.com/ChenYilong on 15/8/29.\n//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.\n//  \n\n#import &quot;Person.h&quot;\n\n@implementation Person\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.lastName = @&quot;&quot;;\n        //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));\n        //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, self.lastName);\n    }\n    return self;\n}\n\n- (void)setLastName:(NSString*)lastName\n{\n    NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;根本不会调用这个方法&quot;);\n    _lastName = @&quot;炎黄&quot;;\n}\n\n@end\n</code></pre>\n<p>那么打印结果将会是这样的：</p>\n<pre><code class=\"objectivec\"> 🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？\n 🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson\n 🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson\n</code></pre>\n<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo<em>21题</em>下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>\n<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>\n<pre><code class=\"objectivec\">    $ clang -rewrite-objc test.m\n</code></pre>\n<p>将这道题目中给出的代码被转化为:</p>\n<pre><code class=\"objectivec\">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));\n\n    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;)) }, sel_registerName(&quot;class&quot;))));\n</code></pre>\n<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>\n<pre><code class=\"objectivec\">    id objc_msgSend(id self, SEL op, ...)\n</code></pre>\n<p>我们把 self 做为第一个参数传递进去。</p>\n<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>\n<pre><code class=\"objectivec\">    id objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n</code></pre>\n<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>\n<pre><code class=\"objectivec\">struct objc_super {\n       __unsafe_unretained id receiver;\n       __unsafe_unretained Class super_class;\n};\n</code></pre>\n<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>\n<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>\n<p>objc Runtime开源代码对- (Class)class方法的实现:</p>\n<pre><code class=\"objectivec\">- (Class)class {\n    return object_getClass(self);\n}\n</code></pre>\n<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。<br>第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>\n<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>\n<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>\n<p>参考链接：<a href=\"http://weibo.com/junbbcom\" target=\"_blank\" rel=\"external\">微博@Chun_iOS</a>的博文<a href=\"http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1\" target=\"_blank\" rel=\"external\">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>\n<h3 id=\"22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"><a href=\"#22-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\" class=\"headerlink\" title=\"22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\"></a>22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h3><p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>\n<h3 id=\"23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"><a href=\"#23-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？\" class=\"headerlink\" title=\"23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？\"></a>23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h3><ul>\n<li>在ARC下不需要。</li>\n<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>\n</ul>\n<blockquote>\n<p>无论在MRC下还是ARC下均不需要。</p>\n</blockquote>\n<p><a href=\"https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html\" target=\"_blank\" rel=\"external\"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>\n<pre><code class=\"objectivec\">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 摘自2011年版本的Apple API 官方文档 - Associative References \n\nstatic char overviewKey;\n\nNSArray *array =\n    [[NSArray alloc] initWithObjects:@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;, nil];\n// For the purposes of illustration, use initWithFormat: to ensure\n// the string can be deallocated\nNSString *overview =\n    [[NSString alloc] initWithFormat:@&quot;%@&quot;, @&quot;First three numbers&quot;];\n\nobjc_setAssociatedObject (\n    array,\n    &amp;overviewKey,\n    overview,\n    OBJC_ASSOCIATION_RETAIN\n);\n\n[overview release];\n// (1) overview valid\n[array release];\n// (2) overview invalid\n</code></pre>\n<p>文档指出 </p>\n<blockquote>\n<p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p>\n</blockquote>\n<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>\n<p>既然会被销毁，那么具体在什么时间点？</p>\n<blockquote>\n<p>根据<a href=\"https://developer.apple.com/videos/wwdc/2011/#322-video\" target=\"_blank\" rel=\"external\"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>\n</blockquote>\n<p>对象的内存销毁时间表，分四个步骤：</p>\n<pre><code>// 对象的内存销毁时间表\n// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)\n// https://github.com/ChenYilong\n// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 \n\n 1. 调用 -release ：引用计数变为零\n     * 对象正在被销毁，生命周期即将结束.\n     * 不能再有新的 __weak 弱引用， 否则将指向 nil.\n     * 调用 [self dealloc] \n 2. 子类 调用 -dealloc\n     * 继承关系中最底层的子类 在调用 -dealloc\n     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）\n     * 继承关系中每一层的父类 都在调用 -dealloc\n 3. NSObject 调 -dealloc\n     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法\n 4. 调用 object_dispose()\n     * 为 C++ 的实例变量们（iVars）调用 destructors \n     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release \n     * 解除所有使用 runtime Associate方法关联的对象\n     * 解除所有 __weak 引用\n     * 调用 free()\n</code></pre><p>对象的内存销毁时间表：<a href=\"http://stackoverflow.com/a/10843510/3395008\" target=\"_blank\" rel=\"external\">参考链接</a>。</p>\n<h3 id=\"24-objc中的类方法和实例方法有什么本质区别和联系？\"><a href=\"#24-objc中的类方法和实例方法有什么本质区别和联系？\" class=\"headerlink\" title=\"24. objc中的类方法和实例方法有什么本质区别和联系？\"></a>24. objc中的类方法和实例方法有什么本质区别和联系？</h3><p>类方法：</p>\n<ol>\n<li>类方法是属于类对象的</li>\n<li>类方法只能通过类对象调用</li>\n<li>类方法中的self是类对象</li>\n<li>类方法可以调用其他的类方法</li>\n<li>类方法中不能访问成员变量</li>\n<li>类方法中不能直接调用对象方法</li>\n</ol>\n<p>实例方法：</p>\n<ol>\n<li>实例方法是属于实例对象的</li>\n<li>实例方法只能通过实例对象调用</li>\n<li>实例方法中的self是实例对象</li>\n<li>实例方法中可以访问成员变量</li>\n<li>实例方法中直接调用实例方法</li>\n<li>实例方法中也可以调用类方法(通过类名)</li>\n</ol>\n<h2 id=\"下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁\"><a href=\"#下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁\" class=\"headerlink\" title=\"下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博@iOS程序犭袁\"></a>下一篇文章将发布在<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions\" target=\"_blank\" rel=\"external\">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a></h2><p>@property部分主要参考<br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2\" target=\"_blank\" rel=\"external\">Apple官方文档：Properties Encapsulate an Object’s Values</a><br>runtime部分主要参考<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\" target=\"_blank\" rel=\"external\">Apple官方文档：Declared Properties</a></p>\n<h3 id=\"25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\"><a href=\"#25-objc-msgForward函数是做什么的，直接调用它将会发生什么？\" class=\"headerlink\" title=\"25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？\"></a>25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><h3 id=\"26-runtime如何实现weak变量的自动置nil？\"><a href=\"#26-runtime如何实现weak变量的自动置nil？\" class=\"headerlink\" title=\"26. runtime如何实现weak变量的自动置nil？\"></a>26. runtime如何实现weak变量的自动置nil？</h3><h3 id=\"27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"><a href=\"#27-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\" class=\"headerlink\" title=\"27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？\"></a>27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h3><h3 id=\"28-runloop和线程有什么关系？\"><a href=\"#28-runloop和线程有什么关系？\" class=\"headerlink\" title=\"28. runloop和线程有什么关系？\"></a>28. runloop和线程有什么关系？</h3><h3 id=\"29-runloop的mode作用是什么？\"><a href=\"#29-runloop的mode作用是什么？\" class=\"headerlink\" title=\"29. runloop的mode作用是什么？\"></a>29. runloop的mode作用是什么？</h3><h3 id=\"30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"><a href=\"#30-以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\" class=\"headerlink\" title=\"30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？\"></a>30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><h3 id=\"31-猜想runloop内部是如何实现的？\"><a href=\"#31-猜想runloop内部是如何实现的？\" class=\"headerlink\" title=\"31. 猜想runloop内部是如何实现的？\"></a>31. 猜想runloop内部是如何实现的？</h3><h3 id=\"32-objc使用什么机制管理对象内存？\"><a href=\"#32-objc使用什么机制管理对象内存？\" class=\"headerlink\" title=\"32. objc使用什么机制管理对象内存？\"></a>32. objc使用什么机制管理对象内存？</h3><h3 id=\"33-ARC通过什么方式帮助开发者管理内存？\"><a href=\"#33-ARC通过什么方式帮助开发者管理内存？\" class=\"headerlink\" title=\"33. ARC通过什么方式帮助开发者管理内存？\"></a>33. ARC通过什么方式帮助开发者管理内存？</h3><h3 id=\"34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"><a href=\"#34-不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\" class=\"headerlink\" title=\"34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）\"></a>34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</h3><h3 id=\"35-BAD-ACCESS在什么情况下出现？\"><a href=\"#35-BAD-ACCESS在什么情况下出现？\" class=\"headerlink\" title=\"35. BAD_ACCESS在什么情况下出现？\"></a>35. <code>BAD_ACCESS</code>在什么情况下出现？</h3><h3 id=\"36-苹果是如何实现autoreleasepool的？\"><a href=\"#36-苹果是如何实现autoreleasepool的？\" class=\"headerlink\" title=\"36. 苹果是如何实现autoreleasepool的？\"></a>36. 苹果是如何实现autoreleasepool的？</h3><h3 id=\"37-使用block时什么情况会发生引用循环，如何解决？\"><a href=\"#37-使用block时什么情况会发生引用循环，如何解决？\" class=\"headerlink\" title=\"37. 使用block时什么情况会发生引用循环，如何解决？\"></a>37. 使用block时什么情况会发生引用循环，如何解决？</h3><h3 id=\"38-在block内如何修改block外部变量？\"><a href=\"#38-在block内如何修改block外部变量？\" class=\"headerlink\" title=\"38. 在block内如何修改block外部变量？\"></a>38. 在block内如何修改block外部变量？</h3><h3 id=\"39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"><a href=\"#39-使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？\" class=\"headerlink\" title=\"39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？\"></a>39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h3><h3 id=\"40-GCD的队列（dispatch-queue-t）分哪两种类型？\"><a href=\"#40-GCD的队列（dispatch-queue-t）分哪两种类型？\" class=\"headerlink\" title=\"40. GCD的队列（dispatch_queue_t）分哪两种类型？\"></a>40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</h3><h3 id=\"41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"><a href=\"#41-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\" class=\"headerlink\" title=\"41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\"></a>41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h3><h3 id=\"42-dispatch-barrier-async的作用是什么？\"><a href=\"#42-dispatch-barrier-async的作用是什么？\" class=\"headerlink\" title=\"42. dispatch_barrier_async的作用是什么？\"></a>42. <code>dispatch_barrier_async</code>的作用是什么？</h3><h3 id=\"43-苹果为什么要废弃dispatch-get-current-queue？\"><a href=\"#43-苹果为什么要废弃dispatch-get-current-queue？\" class=\"headerlink\" title=\"43. 苹果为什么要废弃dispatch_get_current_queue？\"></a>43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</h3><h3 id=\"44-以下代码运行结果如何？\"><a href=\"#44-以下代码运行结果如何？\" class=\"headerlink\" title=\"44. 以下代码运行结果如何？\"></a>44. 以下代码运行结果如何？</h3><pre><code>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><h3 id=\"45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"><a href=\"#45-addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\" class=\"headerlink\" title=\"45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？\"></a>45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h3><h3 id=\"46-如何手动触发一个value的KVO\"><a href=\"#46-如何手动触发一个value的KVO\" class=\"headerlink\" title=\"46. 如何手动触发一个value的KVO\"></a>46. 如何手动触发一个value的KVO</h3><h3 id=\"47-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\"><a href=\"#47-若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？\" class=\"headerlink\" title=\"47. 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？\"></a>47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</h3><h3 id=\"48-KVC的keyPath中的集合运算符如何使用？\"><a href=\"#48-KVC的keyPath中的集合运算符如何使用？\" class=\"headerlink\" title=\"48. KVC的keyPath中的集合运算符如何使用？\"></a>48. KVC的keyPath中的集合运算符如何使用？</h3><h3 id=\"49-KVC和KVO的keyPath一定是属性么？\"><a href=\"#49-KVC和KVO的keyPath一定是属性么？\" class=\"headerlink\" title=\"49. KVC和KVO的keyPath一定是属性么？\"></a>49. KVC和KVO的keyPath一定是属性么？</h3><h3 id=\"50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"><a href=\"#50-如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\" class=\"headerlink\" title=\"50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？\"></a>50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h3><h3 id=\"51-apple用什么方式实现对一个对象的KVO？\"><a href=\"#51-apple用什么方式实现对一个对象的KVO？\" class=\"headerlink\" title=\"51. apple用什么方式实现对一个对象的KVO？\"></a>51. apple用什么方式实现对一个对象的KVO？</h3><h3 id=\"52-IBOutlet连出来的视图属性为什么可以被设置成weak\"><a href=\"#52-IBOutlet连出来的视图属性为什么可以被设置成weak\" class=\"headerlink\" title=\"52. IBOutlet连出来的视图属性为什么可以被设置成weak?\"></a>52. IBOutlet连出来的视图属性为什么可以被设置成weak?</h3><h3 id=\"53-IB中User-Defined-Runtime-Attributes如何使用？\"><a href=\"#53-IB中User-Defined-Runtime-Attributes如何使用？\" class=\"headerlink\" title=\"53. IB中User Defined Runtime Attributes如何使用？\"></a>53. IB中User Defined Runtime Attributes如何使用？</h3><h3 id=\"54-如何调试BAD-ACCESS错误\"><a href=\"#54-如何调试BAD-ACCESS错误\" class=\"headerlink\" title=\"54. 如何调试BAD_ACCESS错误\"></a>54. 如何调试<code>BAD_ACCESS</code>错误</h3><h3 id=\"55-lldb（gdb）常用的调试命令？\"><a href=\"#55-lldb（gdb）常用的调试命令？\" class=\"headerlink\" title=\"55. lldb（gdb）常用的调试命令？\"></a>55. lldb（gdb）常用的调试命令？</h3><hr>\n<p>Posted by <a href=\"http://weibo.com/luohanchenyilong/\" target=\"_blank\" rel=\"external\">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\" target=\"_blank\" rel=\"external\">Creative Commons BY-NC-ND 3.0</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj56u8tun0001znuzx49a9jur","category_id":"cj56u8tuw0004znuzv1sfz7gz","_id":"cj56u8tv9000aznuz137rzqhq"},{"post_id":"cj56u8tut0003znuz7hkt7h5s","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvh000fznuz9fn3ymfz"},{"post_id":"cj56u8tva000bznuzf5spa7lu","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvk000iznuztr9s6q8m"},{"post_id":"cj56u8tve000dznuzb0m8ahbd","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvm000kznuzhvujyl7p"},{"post_id":"cj56u8tv00005znuzka8vs9vb","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvo000nznuz72i1tpks"},{"post_id":"cj56u8tvg000eznuzvuikniw8","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvp000pznuzvvbwulwx"},{"post_id":"cj56u8tvj000hznuzrd8udjna","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvr000sznuzexrvtof4"},{"post_id":"cj56u8tv20006znuzyhh7r47w","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvt000uznuz3yz51zwv"},{"post_id":"cj56u8tvl000jznuza2e1nrsk","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvw000xznuz6zv5er4l"},{"post_id":"cj56u8tvn000mznuzfewxmqyz","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tvy000zznuzc44lkqib"},{"post_id":"cj56u8tv30007znuz8rhalhmi","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tw30012znuzazjc044z"},{"post_id":"cj56u8tvp000oznuzqnfmzfl3","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8tw50014znuzzffn7e1e"},{"post_id":"cj56u8tv70009znuzr0icl6ix","category_id":"cj56u8tvp000qznuz75tcg98z","_id":"cj56u8tw70017znuzwrkoo8kp"},{"post_id":"cj56u8tvx000yznuziznhx1em","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8tw80019znuzwivqq1c3"},{"post_id":"cj56u8tvq000rznuz9chc2rbx","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8twa001bznuzg2dpdcg8"},{"post_id":"cj56u8tw10010znuzrrqy1mv2","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8twc001eznuzx3x0zejl"},{"post_id":"cj56u8tw40013znuzfci7lmxr","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8twe001gznuz6sia2xei"},{"post_id":"cj56u8tvs000tznuzolbfg5dd","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8twf001iznuzgmhx16c2"},{"post_id":"cj56u8tw50015znuz05zt5p21","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8twh001kznuzgyqwljkb"},{"post_id":"cj56u8tvu000wznuz3a5t53al","category_id":"cj56u8tvu000vznuz4d0555wn","_id":"cj56u8twk001mznuzvxftlh79"},{"post_id":"cj56u8tw9001aznuz87k3csti","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8twn001oznuzynhrn2w7"},{"post_id":"cj56u8twc001dznuzdq85554r","category_id":"cj56u8tvp000qznuz75tcg98z","_id":"cj56u8two001qznuz776rj352"},{"post_id":"cj56u8twd001fznuz607fa37x","category_id":"cj56u8tvp000qznuz75tcg98z","_id":"cj56u8twp001rznuzxkqqvzm0"},{"post_id":"cj56u8tw70018znuzisdq0bjz","category_id":"cj56u8twb001cznuzv6j627we","_id":"cj56u8twp001tznuztjsue3l9"},{"post_id":"cj56u8twf001hznuzabzb6nui","category_id":"cj56u8tvp000qznuz75tcg98z","_id":"cj56u8twq001uznuztw93gl82"},{"post_id":"cj56u8twg001jznuzopgxhpl9","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8twq001vznuzy37fwiow"},{"post_id":"cj56u8twi001lznuzm5eldok4","category_id":"cj56u8twb001cznuzv6j627we","_id":"cj56u8twr001wznuzkeak0zzi"},{"post_id":"cj56u8twl001nznuz78y79i95","category_id":"cj56u8tv60008znuzqn82igzd","_id":"cj56u8twr001xznuzpz4fvjmo"},{"post_id":"cj56u8two001pznuzjjk18j15","category_id":"cj56u8twp001sznuzyy1vhqdv","_id":"cj56u8twr001yznuzoekiyi0z"},{"post_id":"cj56u8twu001zznuz9ibr687f","category_id":"cj56u8twp001sznuzyy1vhqdv","_id":"cj56u8twx0020znuzijim8t0v"}],"PostTag":[],"Tag":[]}}